#!/usr/bin/env python
# -*- coding: utf-8 -*-
"""
This experiment was created using PsychoPy3 Experiment Builder (v2023.2.3),
    on Mon Jun 24 08:28:40 2024
If you publish work using this script the most relevant publication is:

    Peirce J, Gray JR, Simpson S, MacAskill M, Höchenberger R, Sogo H, Kastman E, Lindeløv JK. (2019) 
        PsychoPy2: Experiments in behavior made easy Behav Res 51: 195. 
        https://doi.org/10.3758/s13428-018-01193-y

"""

# --- Import packages ---
from psychopy import locale_setup
from psychopy import prefs
from psychopy import plugins
plugins.activatePlugins()
from psychopy import sound, gui, visual, core, data, event, logging, clock, colors, layout
from psychopy.tools import environmenttools
from psychopy.constants import (NOT_STARTED, STARTED, PLAYING, PAUSED,
                                STOPPED, FINISHED, PRESSED, RELEASED, FOREVER, priority)

import numpy as np  # whole numpy lib is available, prepend 'np.'
from numpy import (sin, cos, tan, log, log10, pi, average,
                   sqrt, std, deg2rad, rad2deg, linspace, asarray)
from numpy.random import random, randint, normal, shuffle, choice as randchoice
import os  # handy system and path functions
import sys  # to get file system encoding

import psychopy.iohub as io
from psychopy.hardware import keyboard

# --- Setup global variables (available in all functions) ---
# Ensure that relative paths start from the same directory as this script
_thisDir = os.path.dirname(os.path.abspath(__file__))
# Store info about the experiment session
psychopyVersion = '2023.2.3'
expName = 'thisExp'  # from the Builder filename that created this script
expInfo = {
    'participant': '',
    'session': '001',
    'date': data.getDateStr(),  # add a simple timestamp
    'expName': expName,
    'psychopyVersion': psychopyVersion,
}


def showExpInfoDlg(expInfo):
    """
    Show participant info dialog.
    Parameters
    ==========
    expInfo : dict
        Information about this experiment, created by the `setupExpInfo` function.
    
    Returns
    ==========
    dict
        Information about this experiment.
    """
    # temporarily remove keys which the dialog doesn't need to show
    poppedKeys = {
        'date': expInfo.pop('date', data.getDateStr()),
        'expName': expInfo.pop('expName', expName),
        'psychopyVersion': expInfo.pop('psychopyVersion', psychopyVersion),
    }
    # show participant info dialog
    dlg = gui.DlgFromDict(dictionary=expInfo, sortKeys=False, title=expName)
    if dlg.OK == False:
        core.quit()  # user pressed cancel
    # restore hidden keys
    expInfo.update(poppedKeys)
    # return expInfo
    return expInfo


def setupData(expInfo, dataDir=None):
    """
    Make an ExperimentHandler to handle trials and saving.
    
    Parameters
    ==========
    expInfo : dict
        Information about this experiment, created by the `setupExpInfo` function.
    dataDir : Path, str or None
        Folder to save the data to, leave as None to create a folder in the current directory.    
    Returns
    ==========
    psychopy.data.ExperimentHandler
        Handler object for this experiment, contains the data to save and information about 
        where to save it to.
    """
    
    # data file name stem = absolute path + name; later add .psyexp, .csv, .log, etc
    if dataDir is None:
        dataDir = _thisDir
    filename = u'data/%s_%s_%s' % (expInfo['participant'], expName, expInfo['date'])
    # make sure filename is relative to dataDir
    if os.path.isabs(filename):
        dataDir = os.path.commonprefix([dataDir, filename])
        filename = os.path.relpath(filename, dataDir)
    
    # an ExperimentHandler isn't essential but helps with data saving
    thisExp = data.ExperimentHandler(
        name=expName, version='',
        extraInfo=expInfo, runtimeInfo=None,
        originPath='/Users/pbs44/Documents_local/learn_to_plan_study/task/thisExp.py',
        savePickle=True, saveWideText=True,
        dataFileName=dataDir + os.sep + filename, sortColumns='time'
    )
    thisExp.setPriority('thisRow.t', priority.CRITICAL)
    thisExp.setPriority('expName', priority.LOW)
    # return experiment handler
    return thisExp


def setupLogging(filename):
    """
    Setup a log file and tell it what level to log at.
    
    Parameters
    ==========
    filename : str or pathlib.Path
        Filename to save log file and data files as, doesn't need an extension.
    
    Returns
    ==========
    psychopy.logging.LogFile
        Text stream to receive inputs from the logging system.
    """
    # this outputs to the screen, not a file
    logging.console.setLevel(logging.DEBUG)
    # save a log file for detail verbose info
    logFile = logging.LogFile(filename+'.log', level=logging.DEBUG)
    
    return logFile


def setupWindow(expInfo=None, win=None):
    """
    Setup the Window
    
    Parameters
    ==========
    expInfo : dict
        Information about this experiment, created by the `setupExpInfo` function.
    win : psychopy.visual.Window
        Window to setup - leave as None to create a new window.
    
    Returns
    ==========
    psychopy.visual.Window
        Window in which to run this experiment.
    """
    if win is None:
        # if not given a window to setup, make one
        win = visual.Window(
            size=[1512, 982], fullscr=True, screen=0,
            winType='pyglet', allowStencil=False,
            monitor='testMonitor', color=[0,0,0], colorSpace='rgb',
            backgroundImage='', backgroundFit='none',
            blendMode='avg', useFBO=True,
            units=None
        )
        if expInfo is not None:
            # store frame rate of monitor if we can measure it
            expInfo['frameRate'] = win.getActualFrameRate()
    else:
        # if we have a window, just set the attributes which are safe to set
        win.color = [0,0,0]
        win.colorSpace = 'rgb'
        win.backgroundImage = ''
        win.backgroundFit = 'none'
        win.units = None
    win.mouseVisible = False
    win.hideMessage()
    return win


def setupInputs(expInfo, thisExp, win):
    """
    Setup whatever inputs are available (mouse, keyboard, eyetracker, etc.)
    
    Parameters
    ==========
    expInfo : dict
        Information about this experiment, created by the `setupExpInfo` function.
    thisExp : psychopy.data.ExperimentHandler
        Handler object for this experiment, contains the data to save and information about 
        where to save it to.
    win : psychopy.visual.Window
        Window in which to run this experiment.
    Returns
    ==========
    dict
        Dictionary of input devices by name.
    """
    # --- Setup input devices ---
    inputs = {}
    ioConfig = {}
    
    # Setup iohub keyboard
    ioConfig['Keyboard'] = dict(use_keymap='psychopy')
    
    ioSession = '1'
    if 'session' in expInfo:
        ioSession = str(expInfo['session'])
    ioServer = io.launchHubServer(window=win, **ioConfig)
    eyetracker = None
    
    # create a default keyboard (e.g. to check for escape)
    defaultKeyboard = keyboard.Keyboard(backend='iohub')
    # return inputs dict
    return {
        'ioServer': ioServer,
        'defaultKeyboard': defaultKeyboard,
        'eyetracker': eyetracker,
    }

def pauseExperiment(thisExp, inputs=None, win=None, timers=[], playbackComponents=[]):
    """
    Pause this experiment, preventing the flow from advancing to the next routine until resumed.
    
    Parameters
    ==========
    thisExp : psychopy.data.ExperimentHandler
        Handler object for this experiment, contains the data to save and information about 
        where to save it to.
    inputs : dict
        Dictionary of input devices by name.
    win : psychopy.visual.Window
        Window for this experiment.
    timers : list, tuple
        List of timers to reset once pausing is finished.
    playbackComponents : list, tuple
        List of any components with a `pause` method which need to be paused.
    """
    # if we are not paused, do nothing
    if thisExp.status != PAUSED:
        return
    
    # pause any playback components
    for comp in playbackComponents:
        comp.pause()
    # prevent components from auto-drawing
    win.stashAutoDraw()
    # run a while loop while we wait to unpause
    while thisExp.status == PAUSED:
        # make sure we have a keyboard
        if inputs is None:
            inputs = {
                'defaultKeyboard': keyboard.Keyboard(backend='ioHub')
            }
        # check for quit (typically the Esc key)
        if inputs['defaultKeyboard'].getKeys(keyList=['escape']):
            endExperiment(thisExp, win=win, inputs=inputs)
        # flip the screen
        win.flip()
    # if stop was requested while paused, quit
    if thisExp.status == FINISHED:
        endExperiment(thisExp, inputs=inputs, win=win)
    # resume any playback components
    for comp in playbackComponents:
        comp.play()
    # restore auto-drawn components
    win.retrieveAutoDraw()
    # reset any timers
    for timer in timers:
        timer.reset()


def run(expInfo, thisExp, win, inputs, globalClock=None, thisSession=None):
    """
    Run the experiment flow.
    
    Parameters
    ==========
    expInfo : dict
        Information about this experiment, created by the `setupExpInfo` function.
    thisExp : psychopy.data.ExperimentHandler
        Handler object for this experiment, contains the data to save and information about 
        where to save it to.
    psychopy.visual.Window
        Window in which to run this experiment.
    inputs : dict
        Dictionary of input devices by name.
    globalClock : psychopy.core.clock.Clock or None
        Clock to get global time from - supply None to make a new one.
    thisSession : psychopy.session.Session or None
        Handle of the Session object this experiment is being run from, if any.
    """
    # mark experiment as started
    thisExp.status = STARTED
    # make sure variables created by exec are available globally
    exec = environmenttools.setExecEnvironment(globals())
    # get device handles from dict of input devices
    ioServer = inputs['ioServer']
    defaultKeyboard = inputs['defaultKeyboard']
    eyetracker = inputs['eyetracker']
    # make sure we're running in the directory for this experiment
    os.chdir(_thisDir)
    # get filename from ExperimentHandler for convenience
    filename = thisExp.dataFileName
    frameTolerance = 0.001  # how close to onset before 'same' frame
    endExpNow = False  # flag for 'escape' or other condition => quit the exp
    # get frame duration from frame rate in expInfo
    if 'frameRate' in expInfo and expInfo['frameRate'] is not None:
        frameDur = 1.0 / round(expInfo['frameRate'])
    else:
        frameDur = 1.0 / 60.0  # could not measure, so guess
    
    # Start Code - component code to be run after the window creation
    
    # --- Initialize components for Routine "consent" ---
    image_11 = visual.ImageStim(
        win=win,
        name='image_11', 
        image='default.png', mask=None, anchor='center',
        ori=0.0, pos=(0, 0.05), size=(0.65, 0.75),
        color=[1,1,1], colorSpace='rgb', opacity=None,
        flipHoriz=False, flipVert=False,
        texRes=128.0, interpolate=True, depth=0.0)
    consent1_next = keyboard.Keyboard()
    text_89 = visual.TextStim(win=win, name='text_89',
        text='Click SPACE to Continue',
        font='Open Sans',
        pos=(0, -0.4), height=0.03, wrapWidth=None, ori=0.0, 
        color='black', colorSpace='rgb', opacity=None, 
        languageStyle='LTR',
        depth=-2.0);
    
    # --- Initialize components for Routine "consent2" ---
    image_13 = visual.ImageStim(
        win=win,
        name='image_13', 
        image='default.png', mask=None, anchor='center',
        ori=0.0, pos=(0, 0.1), size=(0.65, 0.5),
        color=[1,1,1], colorSpace='rgb', opacity=None,
        flipHoriz=False, flipVert=False,
        texRes=128.0, interpolate=True, depth=0.0)
    consent1_next_2 = keyboard.Keyboard()
    text_90 = visual.TextStim(win=win, name='text_90',
        text='I certify that I have read the informed consent and received the information to contact the investigators if necessary.\n\nClick ‘y’ for YES\nClick ’n’ for NO, and you will EXIT the study',
        font='Open Sans',
        pos=(0, -0.35), height=0.03, wrapWidth=None, ori=0.0, 
        color='black', colorSpace='rgb', opacity=None, 
        languageStyle='LTR',
        depth=-2.0);
    
    # --- Initialize components for Routine "questionnaire_start" ---
    text_33 = visual.TextStim(win=win, name='text_33',
        text='First you’re going to answer a few questions about how much you worry. ',
        font='Open Sans',
        pos=(0, 0), height=0.05, wrapWidth=None, ori=0.0, 
        color='black', colorSpace='rgb', opacity=None, 
        languageStyle='LTR',
        depth=0.0);
    
    # --- Initialize components for Routine "PSWQ1" ---
    text_36 = visual.TextStim(win=win, name='text_36',
        text='Rate each of the following statements on a scale of 1 (“not at all typical of me”) to 5 (“very typical of me”). Please do not leave any items blank.',
        font='Open Sans',
        pos=(0, 0.28), height=0.045, wrapWidth=None, ori=0.0, 
        color='black', colorSpace='rgb', opacity=None, 
        languageStyle='LTR',
        depth=0.0);
    text_56 = visual.TextStim(win=win, name='text_56',
        text='If I do not have enough time to do everything, I do not worry about it.',
        font='Open Sans',
        pos=(0, 0), height=0.045, wrapWidth=None, ori=0.0, 
        color='black', colorSpace='rgb', opacity=None, 
        languageStyle='LTR',
        depth=-1.0);
    text_57 = visual.TextStim(win=win, name='text_57',
        text='1=Not at all typical - 2 - 3 - 4 - 5=Very typical',
        font='Open Sans',
        pos=(0, -0.2), height=0.045, wrapWidth=None, ori=0.0, 
        color='black', colorSpace='rgb', opacity=None, 
        languageStyle='LTR',
        depth=-2.0);
    key_resp_3 = keyboard.Keyboard()
    
    # --- Initialize components for Routine "PSWQ2" ---
    text_58 = visual.TextStim(win=win, name='text_58',
        text='Rate each of the following statements on a scale of 1 (“not at all typical of me”) to 5 (“very typical of me”). Please do not leave any items blank.',
        font='Open Sans',
        pos=(0, 0.28), height=0.045, wrapWidth=None, ori=0.0, 
        color='black', colorSpace='rgb', opacity=None, 
        languageStyle='LTR',
        depth=0.0);
    text_59 = visual.TextStim(win=win, name='text_59',
        text='My worries overwhelm me.',
        font='Open Sans',
        pos=(0, 0), height=0.045, wrapWidth=None, ori=0.0, 
        color='black', colorSpace='rgb', opacity=None, 
        languageStyle='LTR',
        depth=-1.0);
    text_60 = visual.TextStim(win=win, name='text_60',
        text='1=Not at all typical - 2 - 3 - 4 - 5=Very typical',
        font='Open Sans',
        pos=(0, -0.2), height=0.045, wrapWidth=None, ori=0.0, 
        color='black', colorSpace='rgb', opacity=None, 
        languageStyle='LTR',
        depth=-2.0);
    key_resp_13 = keyboard.Keyboard()
    
    # --- Initialize components for Routine "PSWQ3" ---
    text_61 = visual.TextStim(win=win, name='text_61',
        text='Rate each of the following statements on a scale of 1 (“not at all typical of me”) to 5 (“very typical of me”). Please do not leave any items blank.',
        font='Open Sans',
        pos=(0, 0.28), height=0.045, wrapWidth=None, ori=0.0, 
        color='black', colorSpace='rgb', opacity=None, 
        languageStyle='LTR',
        depth=0.0);
    text_62 = visual.TextStim(win=win, name='text_62',
        text='I do not tend to worry about things.',
        font='Open Sans',
        pos=(0, 0), height=0.045, wrapWidth=None, ori=0.0, 
        color='black', colorSpace='rgb', opacity=None, 
        languageStyle='LTR',
        depth=-1.0);
    text_63 = visual.TextStim(win=win, name='text_63',
        text='1=Not at all typical - 2 - 3 - 4 - 5=Very typical',
        font='Open Sans',
        pos=(0, -0.2), height=0.045, wrapWidth=None, ori=0.0, 
        color='black', colorSpace='rgb', opacity=None, 
        languageStyle='LTR',
        depth=-2.0);
    key_resp_14 = keyboard.Keyboard()
    
    # --- Initialize components for Routine "PSWQ4" ---
    text_64 = visual.TextStim(win=win, name='text_64',
        text='Rate each of the following statements on a scale of 1 (“not at all typical of me”) to 5 (“very typical of me”). Please do not leave any items blank.',
        font='Open Sans',
        pos=(0, 0.28), height=0.045, wrapWidth=None, ori=0.0, 
        color='black', colorSpace='rgb', opacity=None, 
        languageStyle='LTR',
        depth=0.0);
    text_65 = visual.TextStim(win=win, name='text_65',
        text='Many situations make me worry.',
        font='Open Sans',
        pos=(0, 0), height=0.045, wrapWidth=None, ori=0.0, 
        color='black', colorSpace='rgb', opacity=None, 
        languageStyle='LTR',
        depth=-1.0);
    text_66 = visual.TextStim(win=win, name='text_66',
        text='1=Not at all typical - 2 - 3 - 4 - 5=Very typical',
        font='Open Sans',
        pos=(0, -0.2), height=0.045, wrapWidth=None, ori=0.0, 
        color='black', colorSpace='rgb', opacity=None, 
        languageStyle='LTR',
        depth=-2.0);
    key_resp_15 = keyboard.Keyboard()
    
    # --- Initialize components for Routine "PSWQ5" ---
    text_67 = visual.TextStim(win=win, name='text_67',
        text='Rate each of the following statements on a scale of 1 (“not at all typical of me”) to 5 (“very typical of me”). Please do not leave any items blank.',
        font='Open Sans',
        pos=(0, 0.28), height=0.045, wrapWidth=None, ori=0.0, 
        color='black', colorSpace='rgb', opacity=None, 
        languageStyle='LTR',
        depth=0.0);
    text_68 = visual.TextStim(win=win, name='text_68',
        text='I know I should not worry about things, but I just cannot help it.',
        font='Open Sans',
        pos=(0, 0), height=0.045, wrapWidth=None, ori=0.0, 
        color='black', colorSpace='rgb', opacity=None, 
        languageStyle='LTR',
        depth=-1.0);
    text_69 = visual.TextStim(win=win, name='text_69',
        text='1=Not at all typical - 2 - 3 - 4 - 5=Very typical',
        font='Open Sans',
        pos=(0, -0.2), height=0.045, wrapWidth=None, ori=0.0, 
        color='black', colorSpace='rgb', opacity=None, 
        languageStyle='LTR',
        depth=-2.0);
    key_resp_16 = keyboard.Keyboard()
    
    # --- Initialize components for Routine "PSWQ6" ---
    text_76 = visual.TextStim(win=win, name='text_76',
        text='Rate each of the following statements on a scale of 1 (“not at all typical of me”) to 5 (“very typical of me”). Please do not leave any items blank.',
        font='Open Sans',
        pos=(0, 0.28), height=0.045, wrapWidth=None, ori=0.0, 
        color='black', colorSpace='rgb', opacity=None, 
        languageStyle='LTR',
        depth=0.0);
    text_77 = visual.TextStim(win=win, name='text_77',
        text='When I am under pressure I worry a lot.',
        font='Open Sans',
        pos=(0, 0), height=0.045, wrapWidth=None, ori=0.0, 
        color='black', colorSpace='rgb', opacity=None, 
        languageStyle='LTR',
        depth=-1.0);
    text_78 = visual.TextStim(win=win, name='text_78',
        text='1=Not at all typical - 2 - 3 - 4 - 5=Very typical',
        font='Open Sans',
        pos=(0, -0.2), height=0.045, wrapWidth=None, ori=0.0, 
        color='black', colorSpace='rgb', opacity=None, 
        languageStyle='LTR',
        depth=-2.0);
    key_resp_25 = keyboard.Keyboard()
    
    # --- Initialize components for Routine "PSWQ7" ---
    text_79 = visual.TextStim(win=win, name='text_79',
        text='Rate each of the following statements on a scale of 1 (“not at all typical of me”) to 5 (“very typical of me”). Please do not leave any items blank.',
        font='Open Sans',
        pos=(0, 0.28), height=0.045, wrapWidth=None, ori=0.0, 
        color='black', colorSpace='rgb', opacity=None, 
        languageStyle='LTR',
        depth=0.0);
    text_80 = visual.TextStim(win=win, name='text_80',
        text='I am always worrying about something.',
        font='Open Sans',
        pos=(0, 0), height=0.045, wrapWidth=None, ori=0.0, 
        color='black', colorSpace='rgb', opacity=None, 
        languageStyle='LTR',
        depth=-1.0);
    text_81 = visual.TextStim(win=win, name='text_81',
        text='1=Not at all typical - 2 - 3 - 4 - 5=Very typical',
        font='Open Sans',
        pos=(0, -0.2), height=0.045, wrapWidth=None, ori=0.0, 
        color='black', colorSpace='rgb', opacity=None, 
        languageStyle='LTR',
        depth=-2.0);
    key_resp_26 = keyboard.Keyboard()
    
    # --- Initialize components for Routine "PSWQ8" ---
    text_82 = visual.TextStim(win=win, name='text_82',
        text='Rate each of the following statements on a scale of 1 (“not at all typical of me”) to 5 (“very typical of me”). Please do not leave any items blank.',
        font='Open Sans',
        pos=(0, 0.28), height=0.045, wrapWidth=None, ori=0.0, 
        color='black', colorSpace='rgb', opacity=None, 
        languageStyle='LTR',
        depth=0.0);
    text_83 = visual.TextStim(win=win, name='text_83',
        text='I find it easy to dismiss worrisome thoughts.',
        font='Open Sans',
        pos=(0, 0), height=0.045, wrapWidth=None, ori=0.0, 
        color='black', colorSpace='rgb', opacity=None, 
        languageStyle='LTR',
        depth=-1.0);
    text_84 = visual.TextStim(win=win, name='text_84',
        text='1=Not at all typical - 2 - 3 - 4 - 5=Very typical',
        font='Open Sans',
        pos=(0, -0.2), height=0.045, wrapWidth=None, ori=0.0, 
        color='black', colorSpace='rgb', opacity=None, 
        languageStyle='LTR',
        depth=-2.0);
    key_resp_27 = keyboard.Keyboard()
    
    # --- Initialize components for Routine "PSWQ9" ---
    text_85 = visual.TextStim(win=win, name='text_85',
        text='Rate each of the following statements on a scale of 1 (“not at all typical of me”) to 5 (“very typical of me”). Please do not leave any items blank.',
        font='Open Sans',
        pos=(0, 0.28), height=0.045, wrapWidth=None, ori=0.0, 
        color='black', colorSpace='rgb', opacity=None, 
        languageStyle='LTR',
        depth=0.0);
    text_86 = visual.TextStim(win=win, name='text_86',
        text='As soon as I finish one task, I start to worry about everything else I have to do.',
        font='Open Sans',
        pos=(0, 0), height=0.045, wrapWidth=None, ori=0.0, 
        color='black', colorSpace='rgb', opacity=None, 
        languageStyle='LTR',
        depth=-1.0);
    text_87 = visual.TextStim(win=win, name='text_87',
        text='1=Not at all typical - 2 - 3 - 4 - 5=Very typical',
        font='Open Sans',
        pos=(0, -0.2), height=0.045, wrapWidth=None, ori=0.0, 
        color='black', colorSpace='rgb', opacity=None, 
        languageStyle='LTR',
        depth=-2.0);
    key_resp_28 = keyboard.Keyboard()
    
    # --- Initialize components for Routine "PSWQ10" ---
    text_88 = visual.TextStim(win=win, name='text_88',
        text='Rate each of the following statements on a scale of 1 (“not at all typical of me”) to 5 (“very typical of me”). Please do not leave any items blank.',
        font='Open Sans',
        pos=(0, 0.28), height=0.045, wrapWidth=None, ori=0.0, 
        color='black', colorSpace='rgb', opacity=None, 
        languageStyle='LTR',
        depth=0.0);
    text_91 = visual.TextStim(win=win, name='text_91',
        text='I never worry about anything.',
        font='Open Sans',
        pos=(0, 0), height=0.045, wrapWidth=None, ori=0.0, 
        color='black', colorSpace='rgb', opacity=None, 
        languageStyle='LTR',
        depth=-1.0);
    text_92 = visual.TextStim(win=win, name='text_92',
        text='1=Not at all typical - 2 - 3 - 4 - 5=Very typical',
        font='Open Sans',
        pos=(0, -0.2), height=0.045, wrapWidth=None, ori=0.0, 
        color='black', colorSpace='rgb', opacity=None, 
        languageStyle='LTR',
        depth=-2.0);
    key_resp_29 = keyboard.Keyboard()
    
    # --- Initialize components for Routine "PSWQ11" ---
    text_93 = visual.TextStim(win=win, name='text_93',
        text='Rate each of the following statements on a scale of 1 (“not at all typical of me”) to 5 (“very typical of me”). Please do not leave any items blank.',
        font='Open Sans',
        pos=(0, 0.28), height=0.045, wrapWidth=None, ori=0.0, 
        color='black', colorSpace='rgb', opacity=None, 
        languageStyle='LTR',
        depth=0.0);
    text_94 = visual.TextStim(win=win, name='text_94',
        text='When there is nothing more I can do about a concern, I do not worry about it any more.',
        font='Open Sans',
        pos=(0, 0), height=0.045, wrapWidth=None, ori=0.0, 
        color='black', colorSpace='rgb', opacity=None, 
        languageStyle='LTR',
        depth=-1.0);
    text_95 = visual.TextStim(win=win, name='text_95',
        text='1=Not at all typical - 2 - 3 - 4 - 5=Very typical',
        font='Open Sans',
        pos=(0, -0.2), height=0.045, wrapWidth=None, ori=0.0, 
        color='black', colorSpace='rgb', opacity=None, 
        languageStyle='LTR',
        depth=-2.0);
    key_resp_30 = keyboard.Keyboard()
    
    # --- Initialize components for Routine "PSWQ12" ---
    text_96 = visual.TextStim(win=win, name='text_96',
        text='Rate each of the following statements on a scale of 1 (“not at all typical of me”) to 5 (“very typical of me”). Please do not leave any items blank.',
        font='Open Sans',
        pos=(0, 0.28), height=0.045, wrapWidth=None, ori=0.0, 
        color='black', colorSpace='rgb', opacity=None, 
        languageStyle='LTR',
        depth=0.0);
    text_97 = visual.TextStim(win=win, name='text_97',
        text='I have been a worrier all my life.',
        font='Open Sans',
        pos=(0, 0), height=0.045, wrapWidth=None, ori=0.0, 
        color='black', colorSpace='rgb', opacity=None, 
        languageStyle='LTR',
        depth=-1.0);
    text_98 = visual.TextStim(win=win, name='text_98',
        text='1=Not at all typical - 2 - 3 - 4 - 5=Very typical',
        font='Open Sans',
        pos=(0, -0.2), height=0.045, wrapWidth=None, ori=0.0, 
        color='black', colorSpace='rgb', opacity=None, 
        languageStyle='LTR',
        depth=-2.0);
    key_resp_31 = keyboard.Keyboard()
    
    # --- Initialize components for Routine "PSWQ13" ---
    text_99 = visual.TextStim(win=win, name='text_99',
        text='Rate each of the following statements on a scale of 1 (“not at all typical of me”) to 5 (“very typical of me”). Please do not leave any items blank.',
        font='Open Sans',
        pos=(0, 0.28), height=0.045, wrapWidth=None, ori=0.0, 
        color='black', colorSpace='rgb', opacity=None, 
        languageStyle='LTR',
        depth=0.0);
    text_100 = visual.TextStim(win=win, name='text_100',
        text='I notice that I have been worrying about things.',
        font='Open Sans',
        pos=(0, 0), height=0.045, wrapWidth=None, ori=0.0, 
        color='black', colorSpace='rgb', opacity=None, 
        languageStyle='LTR',
        depth=-1.0);
    text_101 = visual.TextStim(win=win, name='text_101',
        text='1=Not at all typical - 2 - 3 - 4 - 5=Very typical',
        font='Open Sans',
        pos=(0, -0.2), height=0.045, wrapWidth=None, ori=0.0, 
        color='black', colorSpace='rgb', opacity=None, 
        languageStyle='LTR',
        depth=-2.0);
    key_resp_32 = keyboard.Keyboard()
    
    # --- Initialize components for Routine "PSWQ14" ---
    text_102 = visual.TextStim(win=win, name='text_102',
        text='Rate each of the following statements on a scale of 1 (“not at all typical of me”) to 5 (“very typical of me”). Please do not leave any items blank.',
        font='Open Sans',
        pos=(0, 0.28), height=0.045, wrapWidth=None, ori=0.0, 
        color='black', colorSpace='rgb', opacity=None, 
        languageStyle='LTR',
        depth=0.0);
    text_103 = visual.TextStim(win=win, name='text_103',
        text='Once I start worrying, I cannot stop.',
        font='Open Sans',
        pos=(0, 0), height=0.045, wrapWidth=None, ori=0.0, 
        color='black', colorSpace='rgb', opacity=None, 
        languageStyle='LTR',
        depth=-1.0);
    text_104 = visual.TextStim(win=win, name='text_104',
        text='1=Not at all typical - 2 - 3 - 4 - 5=Very typical',
        font='Open Sans',
        pos=(0, -0.2), height=0.045, wrapWidth=None, ori=0.0, 
        color='black', colorSpace='rgb', opacity=None, 
        languageStyle='LTR',
        depth=-2.0);
    key_resp_33 = keyboard.Keyboard()
    
    # --- Initialize components for Routine "PSWQ15" ---
    text_105 = visual.TextStim(win=win, name='text_105',
        text='Rate each of the following statements on a scale of 1 (“not at all typical of me”) to 5 (“very typical of me”). Please do not leave any items blank.',
        font='Open Sans',
        pos=(0, 0.28), height=0.045, wrapWidth=None, ori=0.0, 
        color='black', colorSpace='rgb', opacity=None, 
        languageStyle='LTR',
        depth=0.0);
    text_106 = visual.TextStim(win=win, name='text_106',
        text='I worry all the time.',
        font='Open Sans',
        pos=(0, 0), height=0.045, wrapWidth=None, ori=0.0, 
        color='black', colorSpace='rgb', opacity=None, 
        languageStyle='LTR',
        depth=-1.0);
    text_107 = visual.TextStim(win=win, name='text_107',
        text='1=Not at all typical - 2 - 3 - 4 - 5=Very typical',
        font='Open Sans',
        pos=(0, -0.2), height=0.045, wrapWidth=None, ori=0.0, 
        color='black', colorSpace='rgb', opacity=None, 
        languageStyle='LTR',
        depth=-2.0);
    key_resp_34 = keyboard.Keyboard()
    
    # --- Initialize components for Routine "PSWQ16" ---
    text_108 = visual.TextStim(win=win, name='text_108',
        text='Rate each of the following statements on a scale of 1 (“not at all typical of me”) to 5 (“very typical of me”). Please do not leave any items blank.',
        font='Open Sans',
        pos=(0, 0.28), height=0.045, wrapWidth=None, ori=0.0, 
        color='black', colorSpace='rgb', opacity=None, 
        languageStyle='LTR',
        depth=0.0);
    text_109 = visual.TextStim(win=win, name='text_109',
        text='I have been a worrier all my life.',
        font='Open Sans',
        pos=(0, 0), height=0.045, wrapWidth=None, ori=0.0, 
        color='black', colorSpace='rgb', opacity=None, 
        languageStyle='LTR',
        depth=-1.0);
    text_110 = visual.TextStim(win=win, name='text_110',
        text='1=Not at all typical - 2 - 3 - 4 - 5=Very typical',
        font='Open Sans',
        pos=(0, -0.2), height=0.045, wrapWidth=None, ori=0.0, 
        color='black', colorSpace='rgb', opacity=None, 
        languageStyle='LTR',
        depth=-2.0);
    key_resp_35 = keyboard.Keyboard()
    
    # --- Initialize components for Routine "q2_instructions" ---
    text_155 = visual.TextStim(win=win, name='text_155',
        text="Now you’re going to answer a few questions about how much you've been feeling. ",
        font='Open Sans',
        pos=(0, 0), height=0.05, wrapWidth=None, ori=0.0, 
        color='black', colorSpace='rgb', opacity=None, 
        languageStyle='LTR',
        depth=0.0);
    
    # --- Initialize components for Routine "AM1" ---
    text_156 = visual.TextStim(win=win, name='text_156',
        text='How much has this happened to you in past two weeks? 1=Not at all, 3=Sometimes, 5=All the time',
        font='Open Sans',
        pos=(0, 0.28), height=0.045, wrapWidth=None, ori=0.0, 
        color='black', colorSpace='rgb', opacity=None, 
        languageStyle='LTR',
        depth=0.0);
    text_157 = visual.TextStim(win=win, name='text_157',
        text='Feel happier or more cheerful than usual.',
        font='Open Sans',
        pos=(0, 0), height=0.045, wrapWidth=None, ori=0.0, 
        color='black', colorSpace='rgb', opacity=None, 
        languageStyle='LTR',
        depth=-1.0);
    text_158 = visual.TextStim(win=win, name='text_158',
        text='1=Not at all - 2 - 3 - 4 - 5=All the time',
        font='Open Sans',
        pos=(0, -0.2), height=0.045, wrapWidth=None, ori=0.0, 
        color='black', colorSpace='rgb', opacity=None, 
        languageStyle='LTR',
        depth=-2.0);
    key_resp_41 = keyboard.Keyboard()
    
    # --- Initialize components for Routine "AM2" ---
    text_159 = visual.TextStim(win=win, name='text_159',
        text='How much has this happened to you in past two weeks? 1=Not at all, 3=Sometimes, 5=All the time',
        font='Open Sans',
        pos=(0, 0.28), height=0.045, wrapWidth=None, ori=0.0, 
        color='black', colorSpace='rgb', opacity=None, 
        languageStyle='LTR',
        depth=0.0);
    text_160 = visual.TextStim(win=win, name='text_160',
        text='Feel more self-confident than usual.',
        font='Open Sans',
        pos=(0, 0), height=0.045, wrapWidth=None, ori=0.0, 
        color='black', colorSpace='rgb', opacity=None, 
        languageStyle='LTR',
        depth=-1.0);
    text_161 = visual.TextStim(win=win, name='text_161',
        text='1=Not at all - 2 - 3 - 4 - 5=All the time',
        font='Open Sans',
        pos=(0, -0.2), height=0.045, wrapWidth=None, ori=0.0, 
        color='black', colorSpace='rgb', opacity=None, 
        languageStyle='LTR',
        depth=-2.0);
    key_resp_42 = keyboard.Keyboard()
    
    # --- Initialize components for Routine "AM3" ---
    text_162 = visual.TextStim(win=win, name='text_162',
        text='How much has this happened to you in past two weeks? 1=Not at all, 3=Sometimes, 5=All the time',
        font='Open Sans',
        pos=(0, 0.28), height=0.045, wrapWidth=None, ori=0.0, 
        color='black', colorSpace='rgb', opacity=None, 
        languageStyle='LTR',
        depth=0.0);
    text_163 = visual.TextStim(win=win, name='text_163',
        text='Need LESS Sleep than usual.',
        font='Open Sans',
        pos=(0, 0), height=0.045, wrapWidth=None, ori=0.0, 
        color='black', colorSpace='rgb', opacity=None, 
        languageStyle='LTR',
        depth=-1.0);
    text_164 = visual.TextStim(win=win, name='text_164',
        text='1=Not at all - 2 - 3 - 4 - 5=All the time',
        font='Open Sans',
        pos=(0, -0.2), height=0.045, wrapWidth=None, ori=0.0, 
        color='black', colorSpace='rgb', opacity=None, 
        languageStyle='LTR',
        depth=-2.0);
    key_resp_43 = keyboard.Keyboard()
    
    # --- Initialize components for Routine "AM4" ---
    text_165 = visual.TextStim(win=win, name='text_165',
        text='How much has this happened to you in past two weeks? 1=Not at all, 3=Sometimes, 5=All the time',
        font='Open Sans',
        pos=(0, 0.28), height=0.045, wrapWidth=None, ori=0.0, 
        color='black', colorSpace='rgb', opacity=None, 
        languageStyle='LTR',
        depth=0.0);
    text_166 = visual.TextStim(win=win, name='text_166',
        text='I talk more than usual.',
        font='Open Sans',
        pos=(0, 0), height=0.045, wrapWidth=None, ori=0.0, 
        color='black', colorSpace='rgb', opacity=None, 
        languageStyle='LTR',
        depth=-1.0);
    text_167 = visual.TextStim(win=win, name='text_167',
        text='1=Not at all - 2 - 3 - 4 - 5=All the time',
        font='Open Sans',
        pos=(0, -0.2), height=0.045, wrapWidth=None, ori=0.0, 
        color='black', colorSpace='rgb', opacity=None, 
        languageStyle='LTR',
        depth=-2.0);
    key_resp_44 = keyboard.Keyboard()
    
    # --- Initialize components for Routine "AM5" ---
    text_168 = visual.TextStim(win=win, name='text_168',
        text='How much has this happened to you in past two weeks? 1=Not at all, 3=Sometimes, 5=All the time',
        font='Open Sans',
        pos=(0, 0.28), height=0.045, wrapWidth=None, ori=0.0, 
        color='black', colorSpace='rgb', opacity=None, 
        languageStyle='LTR',
        depth=0.0);
    text_169 = visual.TextStim(win=win, name='text_169',
        text='I talk more than usual.',
        font='Open Sans',
        pos=(0, 0), height=0.045, wrapWidth=None, ori=0.0, 
        color='black', colorSpace='rgb', opacity=None, 
        languageStyle='LTR',
        depth=-1.0);
    text_170 = visual.TextStim(win=win, name='text_170',
        text='1=Not at all - 2 - 3 - 4 - 5=All the time',
        font='Open Sans',
        pos=(0, -0.2), height=0.045, wrapWidth=None, ori=0.0, 
        color='black', colorSpace='rgb', opacity=None, 
        languageStyle='LTR',
        depth=-2.0);
    key_resp_45 = keyboard.Keyboard()
    
    # --- Initialize components for Routine "q3_instructions" ---
    text_171 = visual.TextStim(win=win, name='text_171',
        text="Answer Yes (with 'y' key) or No (with 'n') key to the following questions",
        font='Open Sans',
        pos=(0, 0), height=0.05, wrapWidth=None, ori=0.0, 
        color='black', colorSpace='rgb', opacity=None, 
        languageStyle='LTR',
        depth=0.0);
    
    # --- Initialize components for Routine "SPQ1" ---
    text_173 = visual.TextStim(win=win, name='text_173',
        text='Have you ever had the sense that some person or force is around you, even though you\ncannot see anyone?',
        font='Open Sans',
        pos=(0, 0), height=0.045, wrapWidth=None, ori=0.0, 
        color='black', colorSpace='rgb', opacity=None, 
        languageStyle='LTR',
        depth=0.0);
    text_174 = visual.TextStim(win=win, name='text_174',
        text='y=YES        n=NO',
        font='Open Sans',
        pos=(0, -0.3), height=0.045, wrapWidth=None, ori=0.0, 
        color='black', colorSpace='rgb', opacity=None, 
        languageStyle='LTR',
        depth=-1.0);
    key_resp_46 = keyboard.Keyboard()
    
    # --- Initialize components for Routine "SPQ2" ---
    text_175 = visual.TextStim(win=win, name='text_175',
        text='Are you sometimes sure that other people can tell what you are thinking?',
        font='Open Sans',
        pos=(0, 0), height=0.045, wrapWidth=None, ori=0.0, 
        color='black', colorSpace='rgb', opacity=None, 
        languageStyle='LTR',
        depth=0.0);
    text_176 = visual.TextStim(win=win, name='text_176',
        text='y=YES        n=NO',
        font='Open Sans',
        pos=(0, -0.3), height=0.045, wrapWidth=None, ori=0.0, 
        color='black', colorSpace='rgb', opacity=None, 
        languageStyle='LTR',
        depth=-1.0);
    key_resp_47 = keyboard.Keyboard()
    
    # --- Initialize components for Routine "SPQ3" ---
    text_177 = visual.TextStim(win=win, name='text_177',
        text='Have you ever noticed a common event or object that seemed to be a special sign for\nyou?',
        font='Open Sans',
        pos=(0, 0), height=0.045, wrapWidth=None, ori=0.0, 
        color='black', colorSpace='rgb', opacity=None, 
        languageStyle='LTR',
        depth=0.0);
    text_178 = visual.TextStim(win=win, name='text_178',
        text='y=YES        n=NO',
        font='Open Sans',
        pos=(0, -0.3), height=0.045, wrapWidth=None, ori=0.0, 
        color='black', colorSpace='rgb', opacity=None, 
        languageStyle='LTR',
        depth=-1.0);
    key_resp_48 = keyboard.Keyboard()
    
    # --- Initialize components for Routine "SPQ4" ---
    text_179 = visual.TextStim(win=win, name='text_179',
        text='Do you often pick up hidden threats or put-downs from what people say or do?',
        font='Open Sans',
        pos=(0, 0), height=0.045, wrapWidth=None, ori=0.0, 
        color='black', colorSpace='rgb', opacity=None, 
        languageStyle='LTR',
        depth=0.0);
    text_180 = visual.TextStim(win=win, name='text_180',
        text='y=YES        n=NO',
        font='Open Sans',
        pos=(0, -0.3), height=0.045, wrapWidth=None, ori=0.0, 
        color='black', colorSpace='rgb', opacity=None, 
        languageStyle='LTR',
        depth=-1.0);
    key_resp_49 = keyboard.Keyboard()
    
    # --- Initialize components for Routine "SPQ5" ---
    text_181 = visual.TextStim(win=win, name='text_181',
        text='Do you often pick up hidden threats or put-downs from what people say or do?',
        font='Open Sans',
        pos=(0, 0), height=0.045, wrapWidth=None, ori=0.0, 
        color='black', colorSpace='rgb', opacity=None, 
        languageStyle='LTR',
        depth=0.0);
    text_182 = visual.TextStim(win=win, name='text_182',
        text='y=YES        n=NO',
        font='Open Sans',
        pos=(0, -0.3), height=0.045, wrapWidth=None, ori=0.0, 
        color='black', colorSpace='rgb', opacity=None, 
        languageStyle='LTR',
        depth=-1.0);
    key_resp_50 = keyboard.Keyboard()
    
    # --- Initialize components for Routine "SPQ6" ---
    text_183 = visual.TextStim(win=win, name='text_183',
        text='Have you had experiences with astrology, seeing the future, UFOs, ESP, or a sixth\nsense?',
        font='Open Sans',
        pos=(0, 0), height=0.045, wrapWidth=None, ori=0.0, 
        color='black', colorSpace='rgb', opacity=None, 
        languageStyle='LTR',
        depth=0.0);
    text_184 = visual.TextStim(win=win, name='text_184',
        text='y=YES        n=NO',
        font='Open Sans',
        pos=(0, -0.3), height=0.045, wrapWidth=None, ori=0.0, 
        color='black', colorSpace='rgb', opacity=None, 
        languageStyle='LTR',
        depth=-1.0);
    key_resp_51 = keyboard.Keyboard()
    
    # --- Initialize components for Routine "SPQ7" ---
    text_185 = visual.TextStim(win=win, name='text_185',
        text='Do you ever suddenly feel distracted by distant sounds that you are not normally aware\nof?',
        font='Open Sans',
        pos=(0, 0), height=0.045, wrapWidth=None, ori=0.0, 
        color='black', colorSpace='rgb', opacity=None, 
        languageStyle='LTR',
        depth=0.0);
    text_186 = visual.TextStim(win=win, name='text_186',
        text='y=YES        n=NO',
        font='Open Sans',
        pos=(0, -0.3), height=0.045, wrapWidth=None, ori=0.0, 
        color='black', colorSpace='rgb', opacity=None, 
        languageStyle='LTR',
        depth=-1.0);
    key_resp_52 = keyboard.Keyboard()
    
    # --- Initialize components for Routine "SPQ8" ---
    text_187 = visual.TextStim(win=win, name='text_187',
        text='Do you often have to keep an eye out to stop people from taking advantage of you?',
        font='Open Sans',
        pos=(0, 0), height=0.045, wrapWidth=None, ori=0.0, 
        color='black', colorSpace='rgb', opacity=None, 
        languageStyle='LTR',
        depth=0.0);
    text_188 = visual.TextStim(win=win, name='text_188',
        text='y=YES        n=NO',
        font='Open Sans',
        pos=(0, -0.3), height=0.045, wrapWidth=None, ori=0.0, 
        color='black', colorSpace='rgb', opacity=None, 
        languageStyle='LTR',
        depth=-1.0);
    key_resp_53 = keyboard.Keyboard()
    
    # --- Initialize components for Routine "SPQ9" ---
    text_189 = visual.TextStim(win=win, name='text_189',
        text='People sometimes find me aloof and distant.',
        font='Open Sans',
        pos=(0, 0), height=0.045, wrapWidth=None, ori=0.0, 
        color='black', colorSpace='rgb', opacity=None, 
        languageStyle='LTR',
        depth=0.0);
    text_190 = visual.TextStim(win=win, name='text_190',
        text='y=YES        n=NO',
        font='Open Sans',
        pos=(0, -0.3), height=0.045, wrapWidth=None, ori=0.0, 
        color='black', colorSpace='rgb', opacity=None, 
        languageStyle='LTR',
        depth=-1.0);
    key_resp_54 = keyboard.Keyboard()
    
    # --- Initialize components for Routine "SPQ10" ---
    text_191 = visual.TextStim(win=win, name='text_191',
        text='1 feel I have to be on my guard even with friends.',
        font='Open Sans',
        pos=(0, 0), height=0.045, wrapWidth=None, ori=0.0, 
        color='black', colorSpace='rgb', opacity=None, 
        languageStyle='LTR',
        depth=0.0);
    text_192 = visual.TextStim(win=win, name='text_192',
        text='y=YES        n=NO',
        font='Open Sans',
        pos=(0, -0.3), height=0.045, wrapWidth=None, ori=0.0, 
        color='black', colorSpace='rgb', opacity=None, 
        languageStyle='LTR',
        depth=-1.0);
    key_resp_55 = keyboard.Keyboard()
    
    # --- Initialize components for Routine "SQP11" ---
    text_193 = visual.TextStim(win=win, name='text_193',
        text='I feel very uncomfortable in social situations involving unfamiliar people.',
        font='Open Sans',
        pos=(0, 0), height=0.045, wrapWidth=None, ori=0.0, 
        color='black', colorSpace='rgb', opacity=None, 
        languageStyle='LTR',
        depth=0.0);
    text_194 = visual.TextStim(win=win, name='text_194',
        text='y=YES        n=NO',
        font='Open Sans',
        pos=(0, -0.3), height=0.045, wrapWidth=None, ori=0.0, 
        color='black', colorSpace='rgb', opacity=None, 
        languageStyle='LTR',
        depth=-1.0);
    key_resp_56 = keyboard.Keyboard()
    
    # --- Initialize components for Routine "SPQ12" ---
    text_195 = visual.TextStim(win=win, name='text_195',
        text='Have you found that it is best not to let other people know too much about you?',
        font='Open Sans',
        pos=(0, 0), height=0.045, wrapWidth=None, ori=0.0, 
        color='black', colorSpace='rgb', opacity=None, 
        languageStyle='LTR',
        depth=0.0);
    text_196 = visual.TextStim(win=win, name='text_196',
        text='y=YES        n=NO',
        font='Open Sans',
        pos=(0, -0.3), height=0.045, wrapWidth=None, ori=0.0, 
        color='black', colorSpace='rgb', opacity=None, 
        languageStyle='LTR',
        depth=-1.0);
    key_resp_57 = keyboard.Keyboard()
    
    # --- Initialize components for Routine "SPQ13" ---
    text_197 = visual.TextStim(win=win, name='text_197',
        text='I tend to keep in the background on social occasions.',
        font='Open Sans',
        pos=(0, 0), height=0.045, wrapWidth=None, ori=0.0, 
        color='black', colorSpace='rgb', opacity=None, 
        languageStyle='LTR',
        depth=0.0);
    text_198 = visual.TextStim(win=win, name='text_198',
        text='y=YES        n=NO',
        font='Open Sans',
        pos=(0, -0.3), height=0.045, wrapWidth=None, ori=0.0, 
        color='black', colorSpace='rgb', opacity=None, 
        languageStyle='LTR',
        depth=-1.0);
    key_resp_58 = keyboard.Keyboard()
    
    # --- Initialize components for Routine "SPQ14" ---
    text_199 = visual.TextStim(win=win, name='text_199',
        text='Do you feel that you are unable to get "close" to people?',
        font='Open Sans',
        pos=(0, 0), height=0.045, wrapWidth=None, ori=0.0, 
        color='black', colorSpace='rgb', opacity=None, 
        languageStyle='LTR',
        depth=0.0);
    text_200 = visual.TextStim(win=win, name='text_200',
        text='y=YES        n=NO',
        font='Open Sans',
        pos=(0, -0.3), height=0.045, wrapWidth=None, ori=0.0, 
        color='black', colorSpace='rgb', opacity=None, 
        languageStyle='LTR',
        depth=-1.0);
    key_resp_59 = keyboard.Keyboard()
    
    # --- Initialize components for Routine "SPQ15" ---
    text_201 = visual.TextStim(win=win, name='text_201',
        text='I feel very uneasy talking to people I do not know well.',
        font='Open Sans',
        pos=(0, 0), height=0.045, wrapWidth=None, ori=0.0, 
        color='black', colorSpace='rgb', opacity=None, 
        languageStyle='LTR',
        depth=0.0);
    text_202 = visual.TextStim(win=win, name='text_202',
        text='y=YES        n=NO',
        font='Open Sans',
        pos=(0, -0.3), height=0.045, wrapWidth=None, ori=0.0, 
        color='black', colorSpace='rgb', opacity=None, 
        languageStyle='LTR',
        depth=-1.0);
    key_resp_60 = keyboard.Keyboard()
    
    # --- Initialize components for Routine "SPQ16" ---
    text_203 = visual.TextStim(win=win, name='text_203',
        text='I tend to keep my feelings to myself.',
        font='Open Sans',
        pos=(0, 0), height=0.045, wrapWidth=None, ori=0.0, 
        color='black', colorSpace='rgb', opacity=None, 
        languageStyle='LTR',
        depth=0.0);
    text_204 = visual.TextStim(win=win, name='text_204',
        text='y=YES        n=NO',
        font='Open Sans',
        pos=(0, -0.3), height=0.045, wrapWidth=None, ori=0.0, 
        color='black', colorSpace='rgb', opacity=None, 
        languageStyle='LTR',
        depth=-1.0);
    key_resp_61 = keyboard.Keyboard()
    
    # --- Initialize components for Routine "SPQ17" ---
    text_205 = visual.TextStim(win=win, name='text_205',
        text='People sometimes comment on my unusual mannerisms and habits.',
        font='Open Sans',
        pos=(0, 0), height=0.045, wrapWidth=None, ori=0.0, 
        color='black', colorSpace='rgb', opacity=None, 
        languageStyle='LTR',
        depth=0.0);
    text_206 = visual.TextStim(win=win, name='text_206',
        text='y=YES        n=NO',
        font='Open Sans',
        pos=(0, -0.3), height=0.045, wrapWidth=None, ori=0.0, 
        color='black', colorSpace='rgb', opacity=None, 
        languageStyle='LTR',
        depth=-1.0);
    key_resp_62 = keyboard.Keyboard()
    
    # --- Initialize components for Routine "SPQ18" ---
    text_207 = visual.TextStim(win=win, name='text_207',
        text='Some people think that I am a very bizarre person.',
        font='Open Sans',
        pos=(0, 0), height=0.045, wrapWidth=None, ori=0.0, 
        color='black', colorSpace='rgb', opacity=None, 
        languageStyle='LTR',
        depth=0.0);
    text_208 = visual.TextStim(win=win, name='text_208',
        text='y=YES        n=NO',
        font='Open Sans',
        pos=(0, -0.3), height=0.045, wrapWidth=None, ori=0.0, 
        color='black', colorSpace='rgb', opacity=None, 
        languageStyle='LTR',
        depth=-1.0);
    key_resp_63 = keyboard.Keyboard()
    
    # --- Initialize components for Routine "SPQ19" ---
    text_209 = visual.TextStim(win=win, name='text_209',
        text='Some people find me a bit vague and elusive during a conversation.',
        font='Open Sans',
        pos=(0, 0), height=0.045, wrapWidth=None, ori=0.0, 
        color='black', colorSpace='rgb', opacity=None, 
        languageStyle='LTR',
        depth=0.0);
    text_210 = visual.TextStim(win=win, name='text_210',
        text='y=YES        n=NO',
        font='Open Sans',
        pos=(0, -0.3), height=0.045, wrapWidth=None, ori=0.0, 
        color='black', colorSpace='rgb', opacity=None, 
        languageStyle='LTR',
        depth=-1.0);
    key_resp_64 = keyboard.Keyboard()
    
    # --- Initialize components for Routine "SPQ20" ---
    text_211 = visual.TextStim(win=win, name='text_211',
        text='I sometimes use words in unusual ways.',
        font='Open Sans',
        pos=(0, 0), height=0.045, wrapWidth=None, ori=0.0, 
        color='black', colorSpace='rgb', opacity=None, 
        languageStyle='LTR',
        depth=0.0);
    text_212 = visual.TextStim(win=win, name='text_212',
        text='y=YES        n=NO',
        font='Open Sans',
        pos=(0, -0.3), height=0.045, wrapWidth=None, ori=0.0, 
        color='black', colorSpace='rgb', opacity=None, 
        languageStyle='LTR',
        depth=-1.0);
    key_resp_65 = keyboard.Keyboard()
    
    # --- Initialize components for Routine "SPQ21" ---
    text_213 = visual.TextStim(win=win, name='text_213',
        text='1 am an odd, unusual person.',
        font='Open Sans',
        pos=(0, 0), height=0.045, wrapWidth=None, ori=0.0, 
        color='black', colorSpace='rgb', opacity=None, 
        languageStyle='LTR',
        depth=0.0);
    text_214 = visual.TextStim(win=win, name='text_214',
        text='y=YES        n=NO',
        font='Open Sans',
        pos=(0, -0.3), height=0.045, wrapWidth=None, ori=0.0, 
        color='black', colorSpace='rgb', opacity=None, 
        languageStyle='LTR',
        depth=-1.0);
    key_resp_66 = keyboard.Keyboard()
    
    # --- Initialize components for Routine "SPQ22" ---
    text_215 = visual.TextStim(win=win, name='text_215',
        text='I find it hard to communicate clearly what I want to say to people.',
        font='Open Sans',
        pos=(0, 0), height=0.045, wrapWidth=None, ori=0.0, 
        color='black', colorSpace='rgb', opacity=None, 
        languageStyle='LTR',
        depth=0.0);
    text_216 = visual.TextStim(win=win, name='text_216',
        text='y=YES        n=NO',
        font='Open Sans',
        pos=(0, -0.3), height=0.045, wrapWidth=None, ori=0.0, 
        color='black', colorSpace='rgb', opacity=None, 
        languageStyle='LTR',
        depth=-1.0);
    key_resp_67 = keyboard.Keyboard()
    
    # --- Initialize components for Routine "q4_instructions" ---
    text_172 = visual.TextStim(win=win, name='text_172',
        text='Now you will rate how much you feel several emotions at this moment',
        font='Open Sans',
        pos=(0, 0), height=0.05, wrapWidth=None, ori=0.0, 
        color='black', colorSpace='rgb', opacity=None, 
        languageStyle='LTR',
        depth=0.0);
    
    # --- Initialize components for Routine "SS1" ---
    text_217 = visual.TextStim(win=win, name='text_217',
        text='How much do you feel this emotion now?',
        font='Open Sans',
        pos=(0, 0.28), height=0.045, wrapWidth=None, ori=0.0, 
        color='black', colorSpace='rgb', opacity=None, 
        languageStyle='LTR',
        depth=0.0);
    text_218 = visual.TextStim(win=win, name='text_218',
        text='Dissatisfied',
        font='Open Sans',
        pos=(0, 0), height=0.045, wrapWidth=None, ori=0.0, 
        color='black', colorSpace='rgb', opacity=None, 
        languageStyle='LTR',
        depth=-1.0);
    text_219 = visual.TextStim(win=win, name='text_219',
        text='1=Not at all - 2 - 3 - 4 - 5=Extremely',
        font='Open Sans',
        pos=(0, -0.2), height=0.045, wrapWidth=None, ori=0.0, 
        color='black', colorSpace='rgb', opacity=None, 
        languageStyle='LTR',
        depth=-2.0);
    key_resp_68 = keyboard.Keyboard()
    
    # --- Initialize components for Routine "SS2" ---
    text_220 = visual.TextStim(win=win, name='text_220',
        text='How much do you feel this emotion now?',
        font='Open Sans',
        pos=(0, 0.28), height=0.045, wrapWidth=None, ori=0.0, 
        color='black', colorSpace='rgb', opacity=None, 
        languageStyle='LTR',
        depth=0.0);
    text_221 = visual.TextStim(win=win, name='text_221',
        text='Alert',
        font='Open Sans',
        pos=(0, 0), height=0.045, wrapWidth=None, ori=0.0, 
        color='black', colorSpace='rgb', opacity=None, 
        languageStyle='LTR',
        depth=-1.0);
    text_222 = visual.TextStim(win=win, name='text_222',
        text='1=Not at all - 2 - 3 - 4 - 5=Extremely',
        font='Open Sans',
        pos=(0, -0.2), height=0.045, wrapWidth=None, ori=0.0, 
        color='black', colorSpace='rgb', opacity=None, 
        languageStyle='LTR',
        depth=-2.0);
    key_resp_69 = keyboard.Keyboard()
    
    # --- Initialize components for Routine "SS3" ---
    text_223 = visual.TextStim(win=win, name='text_223',
        text='How much do you feel this emotion now?',
        font='Open Sans',
        pos=(0, 0.28), height=0.045, wrapWidth=None, ori=0.0, 
        color='black', colorSpace='rgb', opacity=None, 
        languageStyle='LTR',
        depth=0.0);
    text_224 = visual.TextStim(win=win, name='text_224',
        text='Depressed',
        font='Open Sans',
        pos=(0, 0), height=0.045, wrapWidth=None, ori=0.0, 
        color='black', colorSpace='rgb', opacity=None, 
        languageStyle='LTR',
        depth=-1.0);
    text_225 = visual.TextStim(win=win, name='text_225',
        text='1=Not at all - 2 - 3 - 4 - 5=Extremely',
        font='Open Sans',
        pos=(0, -0.2), height=0.045, wrapWidth=None, ori=0.0, 
        color='black', colorSpace='rgb', opacity=None, 
        languageStyle='LTR',
        depth=-2.0);
    key_resp_70 = keyboard.Keyboard()
    
    # --- Initialize components for Routine "SS4" ---
    text_226 = visual.TextStim(win=win, name='text_226',
        text='How much do you feel this emotion now?',
        font='Open Sans',
        pos=(0, 0.28), height=0.045, wrapWidth=None, ori=0.0, 
        color='black', colorSpace='rgb', opacity=None, 
        languageStyle='LTR',
        depth=0.0);
    text_227 = visual.TextStim(win=win, name='text_227',
        text='Sad',
        font='Open Sans',
        pos=(0, 0), height=0.045, wrapWidth=None, ori=0.0, 
        color='black', colorSpace='rgb', opacity=None, 
        languageStyle='LTR',
        depth=-1.0);
    text_228 = visual.TextStim(win=win, name='text_228',
        text='1=Not at all - 2 - 3 - 4 - 5=Extremely',
        font='Open Sans',
        pos=(0, -0.2), height=0.045, wrapWidth=None, ori=0.0, 
        color='black', colorSpace='rgb', opacity=None, 
        languageStyle='LTR',
        depth=-2.0);
    key_resp_71 = keyboard.Keyboard()
    
    # --- Initialize components for Routine "SS5" ---
    text_229 = visual.TextStim(win=win, name='text_229',
        text='How much do you feel this emotion now?',
        font='Open Sans',
        pos=(0, 0.28), height=0.045, wrapWidth=None, ori=0.0, 
        color='black', colorSpace='rgb', opacity=None, 
        languageStyle='LTR',
        depth=0.0);
    text_230 = visual.TextStim(win=win, name='text_230',
        text='Active',
        font='Open Sans',
        pos=(0, 0), height=0.045, wrapWidth=None, ori=0.0, 
        color='black', colorSpace='rgb', opacity=None, 
        languageStyle='LTR',
        depth=-1.0);
    text_231 = visual.TextStim(win=win, name='text_231',
        text='1=Not at all - 2 - 3 - 4 - 5=Extremely',
        font='Open Sans',
        pos=(0, -0.2), height=0.045, wrapWidth=None, ori=0.0, 
        color='black', colorSpace='rgb', opacity=None, 
        languageStyle='LTR',
        depth=-2.0);
    key_resp_72 = keyboard.Keyboard()
    
    # --- Initialize components for Routine "SS6" ---
    text_232 = visual.TextStim(win=win, name='text_232',
        text='How much do you feel this emotion now?',
        font='Open Sans',
        pos=(0, 0.28), height=0.045, wrapWidth=None, ori=0.0, 
        color='black', colorSpace='rgb', opacity=None, 
        languageStyle='LTR',
        depth=0.0);
    text_233 = visual.TextStim(win=win, name='text_233',
        text='Impatient',
        font='Open Sans',
        pos=(0, 0), height=0.045, wrapWidth=None, ori=0.0, 
        color='black', colorSpace='rgb', opacity=None, 
        languageStyle='LTR',
        depth=-1.0);
    text_234 = visual.TextStim(win=win, name='text_234',
        text='1=Not at all - 2 - 3 - 4 - 5=Extremely',
        font='Open Sans',
        pos=(0, -0.2), height=0.045, wrapWidth=None, ori=0.0, 
        color='black', colorSpace='rgb', opacity=None, 
        languageStyle='LTR',
        depth=-2.0);
    key_resp_73 = keyboard.Keyboard()
    
    # --- Initialize components for Routine "SS7" ---
    text_235 = visual.TextStim(win=win, name='text_235',
        text='How much do you feel this emotion now?',
        font='Open Sans',
        pos=(0, 0.28), height=0.045, wrapWidth=None, ori=0.0, 
        color='black', colorSpace='rgb', opacity=None, 
        languageStyle='LTR',
        depth=0.0);
    text_236 = visual.TextStim(win=win, name='text_236',
        text='Annoyed',
        font='Open Sans',
        pos=(0, 0), height=0.045, wrapWidth=None, ori=0.0, 
        color='black', colorSpace='rgb', opacity=None, 
        languageStyle='LTR',
        depth=-1.0);
    text_237 = visual.TextStim(win=win, name='text_237',
        text='1=Not at all - 2 - 3 - 4 - 5=Extremely',
        font='Open Sans',
        pos=(0, -0.2), height=0.045, wrapWidth=None, ori=0.0, 
        color='black', colorSpace='rgb', opacity=None, 
        languageStyle='LTR',
        depth=-2.0);
    key_resp_74 = keyboard.Keyboard()
    
    # --- Initialize components for Routine "SS8" ---
    text_238 = visual.TextStim(win=win, name='text_238',
        text='How much do you feel this emotion now?',
        font='Open Sans',
        pos=(0, 0.28), height=0.045, wrapWidth=None, ori=0.0, 
        color='black', colorSpace='rgb', opacity=None, 
        languageStyle='LTR',
        depth=0.0);
    text_239 = visual.TextStim(win=win, name='text_239',
        text='Angry',
        font='Open Sans',
        pos=(0, 0), height=0.045, wrapWidth=None, ori=0.0, 
        color='black', colorSpace='rgb', opacity=None, 
        languageStyle='LTR',
        depth=-1.0);
    text_240 = visual.TextStim(win=win, name='text_240',
        text='1=Not at all - 2 - 3 - 4 - 5=Extremely',
        font='Open Sans',
        pos=(0, -0.2), height=0.045, wrapWidth=None, ori=0.0, 
        color='black', colorSpace='rgb', opacity=None, 
        languageStyle='LTR',
        depth=-2.0);
    key_resp_75 = keyboard.Keyboard()
    
    # --- Initialize components for Routine "SS9" ---
    text_241 = visual.TextStim(win=win, name='text_241',
        text='How much do you feel this emotion now?',
        font='Open Sans',
        pos=(0, 0.28), height=0.045, wrapWidth=None, ori=0.0, 
        color='black', colorSpace='rgb', opacity=None, 
        languageStyle='LTR',
        depth=0.0);
    text_242 = visual.TextStim(win=win, name='text_242',
        text='Irritated',
        font='Open Sans',
        pos=(0, 0), height=0.045, wrapWidth=None, ori=0.0, 
        color='black', colorSpace='rgb', opacity=None, 
        languageStyle='LTR',
        depth=-1.0);
    text_243 = visual.TextStim(win=win, name='text_243',
        text='1=Not at all - 2 - 3 - 4 - 5=Extremely',
        font='Open Sans',
        pos=(0, -0.2), height=0.045, wrapWidth=None, ori=0.0, 
        color='black', colorSpace='rgb', opacity=None, 
        languageStyle='LTR',
        depth=-2.0);
    key_resp_76 = keyboard.Keyboard()
    
    # --- Initialize components for Routine "SS10" ---
    text_244 = visual.TextStim(win=win, name='text_244',
        text='How much do you feel this emotion now?',
        font='Open Sans',
        pos=(0, 0.28), height=0.045, wrapWidth=None, ori=0.0, 
        color='black', colorSpace='rgb', opacity=None, 
        languageStyle='LTR',
        depth=0.0);
    text_245 = visual.TextStim(win=win, name='text_245',
        text='Grouchy',
        font='Open Sans',
        pos=(0, 0), height=0.045, wrapWidth=None, ori=0.0, 
        color='black', colorSpace='rgb', opacity=None, 
        languageStyle='LTR',
        depth=-1.0);
    text_246 = visual.TextStim(win=win, name='text_246',
        text='1=Not at all - 2 - 3 - 4 - 5=Extremely',
        font='Open Sans',
        pos=(0, -0.2), height=0.045, wrapWidth=None, ori=0.0, 
        color='black', colorSpace='rgb', opacity=None, 
        languageStyle='LTR',
        depth=-2.0);
    key_resp_77 = keyboard.Keyboard()
    
    # --- Initialize components for Routine "instructions" ---
    # Run 'Begin Experiment' code from code_2
    incorrect_actions = 0
    
    cogmap={'baby_left':'backpack',
    'baby_right':'bowtie',
    'toothbrush_left':'car',
    'toothbrush_right':'backpack',
    'backpack_left':'lamp',
    'backpack_right':'zebra',
    'car_left':'cat',
    'car_right':'lamp',
    'bowtie_left':'knight',
    'bowtie_right':'lamp'
    }
    
    cogmap_replanning={'baby_left':'car',
    'baby_right':'backpack',
    'toothbrush_left':'bowtie',
    'toothbrush_right':'backpack',
    'hourglass_left':'bending',
    'hourglass_right':'zebra',
    'backpack_left':'lamp',
    'backpack_right':'hourglass',
    'lamp_left':'zebra',
    'lamp_right':'knight',
    'cat_left':'zebra',
    'cat_right':'hammer',
    'car_left':'cat',
    'car_right':'lamp',
    'bowtie_left':'lamp',
    'bowtie_right':'lamp'
    }
    
    current_image='images/baby.png'
    current_image2='images/backpack.png'
    current_image3='images/lamp.png'
    current_image4='images/zebra.png'
    alternative_image='images/car.png'
    instruction_test = visual.TextStim(win=win, name='instruction_test',
        text='The beginning of the task will involve learning associations between images. You will be told to click left or right at a starting image. You will then see which picture you see next. Your goal is to learn how to get from one picture to the next depending on which direction you go — left or right.\n\nIf you fail to click the correct button 5 times, you will be exited from the game and not win any money. Also, be sure NOT TO CLICK ESC on your keyboard, as that will also exit you from the game. \n\nLAST, if you do not get a high enough score on a simple memory test by the end of training, you are at risk of losing half of your money. So pay attention on memory quizzes!\n\nPress SPACE to continue',
        font='Open Sans',
        pos=(0, 0), height=0.042, wrapWidth=None, ori=0.0, 
        color='black', colorSpace='rgb', opacity=None, 
        languageStyle='LTR',
        depth=-1.0);
    end_instructions = keyboard.Keyboard()
    
    # --- Initialize components for Routine "second_instructions" ---
    key_resp_2 = keyboard.Keyboard()
    text_22 = visual.TextStim(win=win, name='text_22',
        text='Your goal is to learn which new picture you will arrive at after selecting a picture by clicking LEFT or RIGHT on your keyboard.\n\nNOTE: There will be a SECOND phase after this first phase, where you can use what you learned to win even more money!\n\nPress SPACE to continue',
        font='Open Sans',
        pos=(0, 0), height=0.04, wrapWidth=None, ori=0.0, 
        color='black', colorSpace='rgb', opacity=None, 
        languageStyle='LTR',
        depth=-1.0);
    
    # --- Initialize components for Routine "third_instructions" ---
    responseleft = keyboard.Keyboard()
    text_23 = visual.TextStim(win=win, name='text_23',
        text='Remember, your goal is to remember which images come after you choose and the action, LEFT or RIGHT at a starting image. For example, choosing LEFT at a picture of an APPLE may take you to a different image than choosing RIGHT.\n\nTo show you what this looks like, you will do a practice round. You will be tested to see if you remember which images come after the starting image. Good luck! \n\nPress SPACE to continue',
        font='Open Sans',
        pos=(0, 0.0), height=0.04, wrapWidth=None, ori=0.0, 
        color='black', colorSpace='rgb', opacity=None, 
        languageStyle='LTR',
        depth=-1.0);
    
    # --- Initialize components for Routine "instructions4" ---
    text_153 = visual.TextStim(win=win, name='text_153',
        text='If you fail to get 100% on the questions that make sure you understand the ways to get from one picture to the next picture, THE GAME WILL EXIT and you will receive only partial credit for time spent.\n\npay attention during learning so you can win more money! ',
        font='Open Sans',
        pos=(0, 0), height=0.06, wrapWidth=None, ori=0.0, 
        color='black', colorSpace='rgb', opacity=None, 
        languageStyle='LTR',
        depth=0.0);
    
    # --- Initialize components for Routine "practice1" ---
    image_22 = visual.ImageStim(
        win=win,
        name='image_22', 
        image='default.png', mask=None, anchor='center',
        ori=0.0, pos=(0, 0), size=(0.5, 0.5),
        color=[1,1,1], colorSpace='rgb', opacity=None,
        flipHoriz=False, flipVert=False,
        texRes=128.0, interpolate=True, depth=0.0)
    key_resp_10 = keyboard.Keyboard()
    text_40 = visual.TextStim(win=win, name='text_40',
        text='Press left',
        font='Open Sans',
        pos=(0, -0.35), height=0.05, wrapWidth=None, ori=0.0, 
        color='black', colorSpace='rgb', opacity=None, 
        languageStyle='LTR',
        depth=-2.0);
    
    # --- Initialize components for Routine "practice1_result" ---
    image_20 = visual.ImageStim(
        win=win,
        name='image_20', 
        image='default.png', mask=None, anchor='center',
        ori=0.0, pos=(0, 0), size=(0.5, 0.5),
        color=[1,1,1], colorSpace='rgb', opacity=None,
        flipHoriz=False, flipVert=False,
        texRes=128.0, interpolate=True, depth=0.0)
    
    # --- Initialize components for Routine "next_trial" ---
    next_trial_text = visual.TextStim(win=win, name='next_trial_text',
        text='next trial…',
        font='Open Sans',
        pos=(0, 0), height=0.05, wrapWidth=None, ori=0.0, 
        color='black', colorSpace='rgb', opacity=None, 
        languageStyle='LTR',
        depth=0.0);
    
    # --- Initialize components for Routine "practice1_quiz" ---
    basket_2 = visual.ImageStim(
        win=win,
        name='basket_2', 
        image='basket.png', mask=None, anchor='center',
        ori=0.0, pos=(-0.6, -0.05), size=(0.25, 0.25),
        color=[1,1,1], colorSpace='rgb', opacity=None,
        flipHoriz=False, flipVert=False,
        texRes=128.0, interpolate=True, depth=0.0)
    fireworks_2 = visual.ImageStim(
        win=win,
        name='fireworks_2', 
        image='fireworks.png', mask=None, anchor='center',
        ori=0.0, pos=(0, -0.05), size=(0.25, 0.25),
        color=[1,1,1], colorSpace='rgb', opacity=None,
        flipHoriz=False, flipVert=False,
        texRes=128.0, interpolate=True, depth=-1.0)
    tree_2 = visual.ImageStim(
        win=win,
        name='tree_2', 
        image='default.png', mask=None, anchor='center',
        ori=0.0, pos=(0.6, -0.05), size=(0.25, 0.25),
        color=[1,1,1], colorSpace='rgb', opacity=None,
        flipHoriz=False, flipVert=False,
        texRes=128.0, interpolate=True, depth=-2.0)
    text_24 = visual.TextStim(win=win, name='text_24',
        text='A',
        font='Open Sans',
        pos=(-0.6, -0.25), height=0.1, wrapWidth=None, ori=0.0, 
        color='black', colorSpace='rgb', opacity=None, 
        languageStyle='LTR',
        depth=-3.0);
    text_25 = visual.TextStim(win=win, name='text_25',
        text='G',
        font='Open Sans',
        pos=(0, -0.25), height=0.1, wrapWidth=None, ori=0.0, 
        color='black', colorSpace='rgb', opacity=None, 
        languageStyle='LTR',
        depth=-4.0);
    text_27 = visual.TextStim(win=win, name='text_27',
        text='L',
        font='Open Sans',
        pos=(0.6, -0.25), height=0.1, wrapWidth=None, ori=0.0, 
        color='black', colorSpace='rgb', opacity=None, 
        languageStyle='LTR',
        depth=-5.0);
    practice_answer = keyboard.Keyboard()
    text_26 = visual.TextStim(win=win, name='text_26',
        text='Which image below did you see after clicking LEFT at the apple image?',
        font='Open Sans',
        pos=(0, 0.2), height=0.05, wrapWidth=None, ori=0.0, 
        color='black', colorSpace='rgb', opacity=None, 
        languageStyle='LTR',
        depth=-8.0);
    
    # --- Initialize components for Routine "practice1_quizfeedback" ---
    text_30 = visual.TextStim(win=win, name='text_30',
        text='',
        font='Open Sans',
        pos=(0, 0), height=0.05, wrapWidth=None, ori=0.0, 
        color='black', colorSpace='rgb', opacity=None, 
        languageStyle='LTR',
        depth=-1.0);
    
    # --- Initialize components for Routine "memory_quiz_instructions" ---
    text_75 = visual.TextStim(win=win, name='text_75',
        text='During your learning about how to get from one picture to another, you will be tested on your learning.\n\nEvery so often (30 trials) you will be asked to use what you’ve learned to try to reach an image where money is hiding. Each of these questions has a correct answer, and we will reward you at the end of the study based on how well you did on these questions. \n\nSpecifically, we will pick a total of 5 rounds at random from these rounds where you can earn reward to determine how much money you win\n\nPress SPACE to continue',
        font='Open Sans',
        pos=(0, 0), height=0.05, wrapWidth=None, ori=0.0, 
        color='black', colorSpace='rgb', opacity=None, 
        languageStyle='LTR',
        depth=0.0);
    key_resp_23 = keyboard.Keyboard()
    
    # --- Initialize components for Routine "quiz1_i" ---
    text_43 = visual.TextStim(win=win, name='text_43',
        text='Instructions Quiz\n\n1. What is the goal of the picture game?\n\na.to learn the type of picture\n\nb.to learn the meaning of pictures\n\nc.to learn which pictures come after taking actions (left or right) certain pictures\n\nd.to learn how actions you take at a picture give you rewards or punishments',
        font='Open Sans',
        pos=(0, 0), height=0.038, wrapWidth=None, ori=0.0, 
        color='black', colorSpace='rgb', opacity=None, 
        languageStyle='LTR',
        depth=0.0);
    key_resp_17 = keyboard.Keyboard()
    
    # --- Initialize components for Routine "quiz2_i" ---
    text_70 = visual.TextStim(win=win, name='text_70',
        text='Instructions Quiz\n\n2. Will you be quizzed during a learning phase about how to get to certain images?\n\na. no\n\nb. yes, every trial you will be quizzed\n\nc. yes, every so oftern (30 trials) you will be quizzed\n\nd. yes, but only at the end of training',
        font='Open Sans',
        pos=(0, 0), height=0.038, wrapWidth=None, ori=0.0, 
        color='black', colorSpace='rgb', opacity=None, 
        languageStyle='LTR',
        depth=0.0);
    key_resp_18 = keyboard.Keyboard()
    
    # --- Initialize components for Routine "quiz3" ---
    text_71 = visual.TextStim(win=win, name='text_71',
        text='Instructions Quiz\n\n3. What happens during the memory quiz?\n\na.you must recall how the pictures look\n\nb. you must REMEMBER the action that will take you a starting image to an upcoming image. 5 of these questions picked at random by the computer will add money to your total\n\nc. you must recall images you most likely DO NOT see after taking an action at a starting image\n\nd. FORGET the action that will take you a starting image to an upcoming image. ',
        font='Open Sans',
        pos=(0, 0), height=0.038, wrapWidth=None, ori=0.0, 
        color='black', colorSpace='rgb', opacity=None, 
        languageStyle='LTR',
        depth=0.0);
    key_resp_19 = keyboard.Keyboard()
    
    # --- Initialize components for Routine "quiz4" ---
    text_72 = visual.TextStim(win=win, name='text_72',
        text='Instructions Quiz\n\n4. After learning you will:\n\na. Be done with the task\n\nb. Use what you learned to plan how to get to certain images\n\nc. Asked to paint an image of what you learned\n\nd. answer many questions about how much you liked the game',
        font='Open Sans',
        pos=(0, 0), height=0.038, wrapWidth=None, ori=0.0, 
        color='black', colorSpace='rgb', opacity=None, 
        languageStyle='LTR',
        depth=0.0);
    key_resp_20 = keyboard.Keyboard()
    
    # --- Initialize components for Routine "quiz_feedback" ---
    result_q_instr = visual.TextStim(win=win, name='result_q_instr',
        text='',
        font='Open Sans',
        pos=(0, 0), height=0.06, wrapWidth=None, ori=0.0, 
        color='black', colorSpace='rgb', opacity=None, 
        languageStyle='LTR',
        depth=0.0);
    
    # --- Initialize components for Routine "start_learning" ---
    text_31 = visual.TextStim(win=win, name='text_31',
        text='Press SPACE to start learning!',
        font='Open Sans',
        pos=(0, 0), height=0.04, wrapWidth=None, ori=0.0, 
        color='black', colorSpace='rgb', opacity=None, 
        languageStyle='LTR',
        depth=0.0);
    key_resp_7 = keyboard.Keyboard()
    
    # --- Initialize components for Routine "learn1" ---
    key_resp = keyboard.Keyboard()
    image_1 = visual.ImageStim(
        win=win,
        name='image_1', 
        image='default.png', mask=None, anchor='center',
        ori=0.0, pos=(0, 0), size=(0.5, 0.5),
        color=[1,1,1], colorSpace='rgb', opacity=None,
        flipHoriz=False, flipVert=False,
        texRes=128.0, interpolate=True, depth=-1.0)
    text = visual.TextStim(win=win, name='text',
        text='',
        font='Open Sans',
        pos=(0, -0.35), height=0.05, wrapWidth=None, ori=0.0, 
        color='black', colorSpace='rgb', opacity=None, 
        languageStyle='LTR',
        depth=-2.0);
    
    # --- Initialize components for Routine "check_incorrect1" ---
    text_incorrect_2 = visual.TextStim(win=win, name='text_incorrect_2',
        text='',
        font='Open Sans',
        pos=(0, 0), height=0.05, wrapWidth=None, ori=0.0, 
        color='black', colorSpace='rgb', opacity=None, 
        languageStyle='LTR',
        depth=-1.0);
    
    # --- Initialize components for Routine "learn2" ---
    image_2 = visual.ImageStim(
        win=win,
        name='image_2', 
        image='default.png', mask=None, anchor='center',
        ori=0.0, pos=(0, 0), size=(0.5,0.5),
        color=[1,1,1], colorSpace='rgb', opacity=None,
        flipHoriz=False, flipVert=False,
        texRes=128.0, interpolate=True, depth=0.0)
    
    # --- Initialize components for Routine "next_trial" ---
    next_trial_text = visual.TextStim(win=win, name='next_trial_text',
        text='next trial…',
        font='Open Sans',
        pos=(0, 0), height=0.05, wrapWidth=None, ori=0.0, 
        color='black', colorSpace='rgb', opacity=None, 
        languageStyle='LTR',
        depth=0.0);
    
    # --- Initialize components for Routine "counter_quizzes_round" ---
    
    # --- Initialize components for Routine "between" ---
    text_2 = visual.TextStim(win=win, name='text_2',
        text='Time for a memory quiz based on what you learned',
        font='Open Sans',
        pos=(0, 0), height=0.05, wrapWidth=None, ori=0.0, 
        color='black', colorSpace='rgb', opacity=None, 
        languageStyle='LTR',
        depth=0.0);
    
    # --- Initialize components for Routine "quiz" ---
    target_quiz1 = visual.ImageStim(
        win=win,
        name='target_quiz1', 
        image='default.png', mask=None, anchor='center',
        ori=0.0, pos=(0,.15), size=(0.4,0.4),
        color=[1,1,1], colorSpace='rgb', opacity=None,
        flipHoriz=False, flipVert=False,
        texRes=128.0, interpolate=True, depth=0.0)
    question_quiz1 = visual.TextStim(win=win, name='question_quiz1',
        text='',
        font='Open Sans',
        pos=(0, 0.4), height=0.05, wrapWidth=None, ori=0.0, 
        color='black', colorSpace='rgb', opacity=None, 
        languageStyle='LTR',
        depth=-1.0);
    answer_quiz1 = keyboard.Keyboard()
    answer1 = visual.ImageStim(
        win=win,
        name='answer1', 
        image='default.png', mask=None, anchor='center',
        ori=0.0, pos=(-0.45, -.20), size=(0.2, 0.2),
        color=[1,1,1], colorSpace='rgb', opacity=None,
        flipHoriz=False, flipVert=False,
        texRes=128.0, interpolate=True, depth=-3.0)
    answer2 = visual.ImageStim(
        win=win,
        name='answer2', 
        image='default.png', mask=None, anchor='center',
        ori=0.0, pos=(-0.15, -.20), size=(0.2, 0.2),
        color=[1,1,1], colorSpace='rgb', opacity=None,
        flipHoriz=False, flipVert=False,
        texRes=128.0, interpolate=True, depth=-4.0)
    answer3 = visual.ImageStim(
        win=win,
        name='answer3', 
        image='default.png', mask=None, anchor='center',
        ori=0.0, pos=(0.15, -.20), size=(0.2, 0.2),
        color=[1,1,1], colorSpace='rgb', opacity=None,
        flipHoriz=False, flipVert=False,
        texRes=128.0, interpolate=True, depth=-5.0)
    answer4 = visual.ImageStim(
        win=win,
        name='answer4', 
        image='default.png', mask=None, anchor='center',
        ori=0.0, pos=(0.45, -0.20), size=(0.2, 0.2),
        color=[1,1,1], colorSpace='rgb', opacity=None,
        flipHoriz=False, flipVert=False,
        texRes=128.0, interpolate=True, depth=-6.0)
    a1 = visual.TextStim(win=win, name='a1',
        text='1',
        font='Open Sans',
        pos=(-0.45, -0.35), height=0.05, wrapWidth=None, ori=0.0, 
        color='black', colorSpace='rgb', opacity=None, 
        languageStyle='LTR',
        depth=-7.0);
    a2 = visual.TextStim(win=win, name='a2',
        text='2',
        font='Open Sans',
        pos=(-.15, -0.35), height=0.05, wrapWidth=None, ori=0.0, 
        color='black', colorSpace='rgb', opacity=None, 
        languageStyle='LTR',
        depth=-8.0);
    a3 = visual.TextStim(win=win, name='a3',
        text='3',
        font='Open Sans',
        pos=(.15, -0.35), height=0.05, wrapWidth=None, ori=0.0, 
        color='black', colorSpace='rgb', opacity=None, 
        languageStyle='LTR',
        depth=-9.0);
    a4 = visual.TextStim(win=win, name='a4',
        text='4',
        font='Open Sans',
        pos=(0.45, -0.35), height=0.05, wrapWidth=None, ori=0.0, 
        color='black', colorSpace='rgb', opacity=None, 
        languageStyle='LTR',
        depth=-10.0);
    
    # --- Initialize components for Routine "quiz_feedback" ---
    result_q_instr = visual.TextStim(win=win, name='result_q_instr',
        text='',
        font='Open Sans',
        pos=(0, 0), height=0.06, wrapWidth=None, ori=0.0, 
        color='black', colorSpace='rgb', opacity=None, 
        languageStyle='LTR',
        depth=0.0);
    
    # --- Initialize components for Routine "back_to_learn" ---
    text_8 = visual.TextStim(win=win, name='text_8',
        text='Take a break for 5 seconds before the next round of learning',
        font='Open Sans',
        pos=(0, 0), height=0.05, wrapWidth=None, ori=0.0, 
        color='black', colorSpace='rgb', opacity=None, 
        languageStyle='LTR',
        depth=0.0);
    
    # --- Initialize components for Routine "learn1" ---
    key_resp = keyboard.Keyboard()
    image_1 = visual.ImageStim(
        win=win,
        name='image_1', 
        image='default.png', mask=None, anchor='center',
        ori=0.0, pos=(0, 0), size=(0.5, 0.5),
        color=[1,1,1], colorSpace='rgb', opacity=None,
        flipHoriz=False, flipVert=False,
        texRes=128.0, interpolate=True, depth=-1.0)
    text = visual.TextStim(win=win, name='text',
        text='',
        font='Open Sans',
        pos=(0, -0.35), height=0.05, wrapWidth=None, ori=0.0, 
        color='black', colorSpace='rgb', opacity=None, 
        languageStyle='LTR',
        depth=-2.0);
    
    # --- Initialize components for Routine "check_incorrect" ---
    text_incorrect = visual.TextStim(win=win, name='text_incorrect',
        text='',
        font='Open Sans',
        pos=(0, 0), height=0.5, wrapWidth=None, ori=0.0, 
        color='black', colorSpace='rgb', opacity=None, 
        languageStyle='LTR',
        depth=-1.0);
    
    # --- Initialize components for Routine "learn2" ---
    image_2 = visual.ImageStim(
        win=win,
        name='image_2', 
        image='default.png', mask=None, anchor='center',
        ori=0.0, pos=(0, 0), size=(0.5,0.5),
        color=[1,1,1], colorSpace='rgb', opacity=None,
        flipHoriz=False, flipVert=False,
        texRes=128.0, interpolate=True, depth=0.0)
    
    # --- Initialize components for Routine "next_trial" ---
    next_trial_text = visual.TextStim(win=win, name='next_trial_text',
        text='next trial…',
        font='Open Sans',
        pos=(0, 0), height=0.05, wrapWidth=None, ori=0.0, 
        color='black', colorSpace='rgb', opacity=None, 
        languageStyle='LTR',
        depth=0.0);
    
    # --- Initialize components for Routine "between" ---
    text_2 = visual.TextStim(win=win, name='text_2',
        text='Time for a memory quiz based on what you learned',
        font='Open Sans',
        pos=(0, 0), height=0.05, wrapWidth=None, ori=0.0, 
        color='black', colorSpace='rgb', opacity=None, 
        languageStyle='LTR',
        depth=0.0);
    
    # --- Initialize components for Routine "quiz2" ---
    target_quiz1_2 = visual.ImageStim(
        win=win,
        name='target_quiz1_2', 
        image='default.png', mask=None, anchor='center',
        ori=0.0, pos=(0,.15), size=(0.4,0.4),
        color=[1,1,1], colorSpace='rgb', opacity=None,
        flipHoriz=False, flipVert=False,
        texRes=128.0, interpolate=True, depth=0.0)
    question_quiz1_2 = visual.TextStim(win=win, name='question_quiz1_2',
        text='',
        font='Open Sans',
        pos=(0, 0.4), height=0.05, wrapWidth=None, ori=0.0, 
        color='black', colorSpace='rgb', opacity=None, 
        languageStyle='LTR',
        depth=-1.0);
    answer_quiz1_2 = keyboard.Keyboard()
    answer1_2 = visual.ImageStim(
        win=win,
        name='answer1_2', 
        image='default.png', mask=None, anchor='center',
        ori=0.0, pos=(-0.45, -.20), size=(0.2, 0.2),
        color=[1,1,1], colorSpace='rgb', opacity=None,
        flipHoriz=False, flipVert=False,
        texRes=128.0, interpolate=True, depth=-3.0)
    answer2_2 = visual.ImageStim(
        win=win,
        name='answer2_2', 
        image='default.png', mask=None, anchor='center',
        ori=0.0, pos=(-0.15, -.20), size=(0.2, 0.2),
        color=[1,1,1], colorSpace='rgb', opacity=None,
        flipHoriz=False, flipVert=False,
        texRes=128.0, interpolate=True, depth=-4.0)
    answer3_2 = visual.ImageStim(
        win=win,
        name='answer3_2', 
        image='default.png', mask=None, anchor='center',
        ori=0.0, pos=(0.15, -.20), size=(0.2, 0.2),
        color=[1,1,1], colorSpace='rgb', opacity=None,
        flipHoriz=False, flipVert=False,
        texRes=128.0, interpolate=True, depth=-5.0)
    answer4_2 = visual.ImageStim(
        win=win,
        name='answer4_2', 
        image='default.png', mask=None, anchor='center',
        ori=0.0, pos=(0.45, -0.20), size=(0.2, 0.2),
        color=[1,1,1], colorSpace='rgb', opacity=None,
        flipHoriz=False, flipVert=False,
        texRes=128.0, interpolate=True, depth=-6.0)
    a1_2 = visual.TextStim(win=win, name='a1_2',
        text='1',
        font='Open Sans',
        pos=(-0.45, -0.35), height=0.05, wrapWidth=None, ori=0.0, 
        color='black', colorSpace='rgb', opacity=None, 
        languageStyle='LTR',
        depth=-7.0);
    a2_2 = visual.TextStim(win=win, name='a2_2',
        text='2',
        font='Open Sans',
        pos=(-.15, -0.35), height=0.05, wrapWidth=None, ori=0.0, 
        color='black', colorSpace='rgb', opacity=None, 
        languageStyle='LTR',
        depth=-8.0);
    a3_2 = visual.TextStim(win=win, name='a3_2',
        text='3',
        font='Open Sans',
        pos=(.15, -0.35), height=0.05, wrapWidth=None, ori=0.0, 
        color='black', colorSpace='rgb', opacity=None, 
        languageStyle='LTR',
        depth=-9.0);
    a4_2 = visual.TextStim(win=win, name='a4_2',
        text='4',
        font='Open Sans',
        pos=(0.45, -0.35), height=0.05, wrapWidth=None, ori=0.0, 
        color='black', colorSpace='rgb', opacity=None, 
        languageStyle='LTR',
        depth=-10.0);
    
    # --- Initialize components for Routine "quiz_feedback" ---
    result_q_instr = visual.TextStim(win=win, name='result_q_instr',
        text='',
        font='Open Sans',
        pos=(0, 0), height=0.06, wrapWidth=None, ori=0.0, 
        color='black', colorSpace='rgb', opacity=None, 
        languageStyle='LTR',
        depth=0.0);
    
    # --- Initialize components for Routine "planning_paths" ---
    text_149 = visual.TextStim(win=win, name='text_149',
        text='Plan how to get from either the BABY or TOOTHBRUSH to new images. \n\nPlan how to get from one image to the next image. \n\nREMEMBER: Nothing has changed since you initially learned about how to navigate between pictures at the beginning of the task.',
        font='Open Sans',
        pos=(0, 0.2), height=0.05, wrapWidth=None, ori=0.0, 
        color='black', colorSpace='rgb', opacity=None, 
        languageStyle='LTR',
        depth=0.0);
    key_resp_40 = keyboard.Keyboard()
    text_49 = visual.TextStim(win=win, name='text_49',
        text='Press space to begin',
        font='Open Sans',
        pos=(0, -0.25), height=0.045, wrapWidth=None, ori=0.0, 
        color='black', colorSpace='rgb', opacity=None, 
        languageStyle='LTR',
        depth=-3.0);
    
    # --- Initialize components for Routine "forgetting_paths1" ---
    question_quiz1_3 = visual.TextStim(win=win, name='question_quiz1_3',
        text='Plan the 2 actions in your head how to get from the left image to the right image. You have two minutes to plan.',
        font='Open Sans',
        pos=(0, 0.3), height=0.05, wrapWidth=None, ori=0.0, 
        color='black', colorSpace='rgb', opacity=None, 
        languageStyle='LTR',
        depth=0.0);
    answer_quiz1_3 = keyboard.Keyboard()
    answer1_3 = visual.ImageStim(
        win=win,
        name='answer1_3', 
        image='default.png', mask=None, anchor='center',
        ori=0.0, pos=(-0.40, 0), size=(0.2, 0.2),
        color=[1,1,1], colorSpace='rgb', opacity=None,
        flipHoriz=False, flipVert=False,
        texRes=128.0, interpolate=True, depth=-2.0)
    answer2_3 = visual.ImageStim(
        win=win,
        name='answer2_3', 
        image='default.png', mask=None, anchor='center',
        ori=0.0, pos=(0, 0), size=(0.2, 0.2),
        color=[1,1,1], colorSpace='rgb', opacity=None,
        flipHoriz=False, flipVert=False,
        texRes=128.0, interpolate=True, depth=-3.0)
    answer3_3 = visual.ImageStim(
        win=win,
        name='answer3_3', 
        image='default.png', mask=None, anchor='center',
        ori=0.0, pos=(0.40, 0), size=(0.2, 0.2),
        color=[1,1,1], colorSpace='rgb', opacity=None,
        flipHoriz=False, flipVert=False,
        texRes=128.0, interpolate=True, depth=-4.0)
    a1_3 = visual.TextStim(win=win, name='a1_3',
        text='>',
        font='Open Sans',
        pos=(-0.20, 0), height=0.1, wrapWidth=None, ori=0.0, 
        color='black', colorSpace='rgb', opacity=None, 
        languageStyle='LTR',
        depth=-5.0);
    a2_3 = visual.TextStim(win=win, name='a2_3',
        text='>',
        font='Open Sans',
        pos=(0.20, 0), height=0.1, wrapWidth=None, ori=0.0, 
        color='black', colorSpace='rgb', opacity=None, 
        languageStyle='LTR',
        depth=-6.0);
    text_146 = visual.TextStim(win=win, name='text_146',
        text='Click the two actions (a sequence of LEFT and RIGHT) on the keyboard that will get you from the image on the far left to the image on the far right.',
        font='Open Sans',
        pos=(0, -0.28), height=0.055, wrapWidth=None, ori=0.0, 
        color='black', colorSpace='rgb', opacity=None, 
        languageStyle='LTR',
        depth=-7.0);
    
    # --- Initialize components for Routine "planningpathstraining2" ---
    question_quiz1_5 = visual.TextStim(win=win, name='question_quiz1_5',
        text='Plan the 2 actions in your head how to get from the left image to the right image. You have two minutes to plan.',
        font='Open Sans',
        pos=(0, 0.3), height=0.05, wrapWidth=None, ori=0.0, 
        color='black', colorSpace='rgb', opacity=None, 
        languageStyle='LTR',
        depth=0.0);
    answer_quiz1_5 = keyboard.Keyboard()
    answer1_5 = visual.ImageStim(
        win=win,
        name='answer1_5', 
        image='default.png', mask=None, anchor='center',
        ori=0.0, pos=(-0.40, 0), size=(0.2, 0.2),
        color=[1,1,1], colorSpace='rgb', opacity=None,
        flipHoriz=False, flipVert=False,
        texRes=128.0, interpolate=True, depth=-2.0)
    answer2_5 = visual.ImageStim(
        win=win,
        name='answer2_5', 
        image='default.png', mask=None, anchor='center',
        ori=0.0, pos=(0, 0), size=(0.2, 0.2),
        color=[1,1,1], colorSpace='rgb', opacity=None,
        flipHoriz=False, flipVert=False,
        texRes=128.0, interpolate=True, depth=-3.0)
    answer3_5 = visual.ImageStim(
        win=win,
        name='answer3_5', 
        image='default.png', mask=None, anchor='center',
        ori=0.0, pos=(0.40, 0), size=(0.2, 0.2),
        color=[1,1,1], colorSpace='rgb', opacity=None,
        flipHoriz=False, flipVert=False,
        texRes=128.0, interpolate=True, depth=-4.0)
    a1_5 = visual.TextStim(win=win, name='a1_5',
        text='>',
        font='Open Sans',
        pos=(-0.20, 0), height=0.1, wrapWidth=None, ori=0.0, 
        color='black', colorSpace='rgb', opacity=None, 
        languageStyle='LTR',
        depth=-5.0);
    a2_5 = visual.TextStim(win=win, name='a2_5',
        text='>',
        font='Open Sans',
        pos=(0.20, 0), height=0.1, wrapWidth=None, ori=0.0, 
        color='black', colorSpace='rgb', opacity=None, 
        languageStyle='LTR',
        depth=-6.0);
    text_152 = visual.TextStim(win=win, name='text_152',
        text='Click the two actions (a sequence of LEFT and RIGHT) on the keyboard that will get you from the image on the far left to the image on the far right.',
        font='Open Sans',
        pos=(0, -0.28), height=0.055, wrapWidth=None, ori=0.0, 
        color='black', colorSpace='rgb', opacity=None, 
        languageStyle='LTR',
        depth=-8.0);
    
    # --- Initialize components for Routine "correct_forget_paths" ---
    next_trial_text_2 = visual.TextStim(win=win, name='next_trial_text_2',
        text='',
        font='Open Sans',
        pos=(0, 0), height=0.05, wrapWidth=None, ori=0.0, 
        color='black', colorSpace='rgb', opacity=None, 
        languageStyle='LTR',
        depth=0.0);
    text_151 = visual.TextStim(win=win, name='text_151',
        text='',
        font='Open Sans',
        pos=(0, -0.25), height=0.1, wrapWidth=None, ori=0.0, 
        color='black', colorSpace='rgb', opacity=None, 
        languageStyle='LTR',
        depth=-1.0);
    
    # --- Initialize components for Routine "total_score_planning" ---
    next_trial_text_3 = visual.TextStim(win=win, name='next_trial_text_3',
        text='',
        font='Open Sans',
        pos=(0, -0.2), height=0.05, wrapWidth=None, ori=0.0, 
        color='black', colorSpace='rgb', opacity=None, 
        languageStyle='LTR',
        depth=-1.0);
    text_150 = visual.TextStim(win=win, name='text_150',
        text='Percent correct:',
        font='Open Sans',
        pos=(0, 0.05), height=0.06, wrapWidth=None, ori=0.0, 
        color='black', colorSpace='rgb', opacity=None, 
        languageStyle='LTR',
        depth=-2.0);
    
    # --- Initialize components for Routine "break_routine" ---
    text_9 = visual.TextStim(win=win, name='text_9',
        text='Next stage: Planning phase!',
        font='Open Sans',
        pos=(0, 0), height=0.05, wrapWidth=None, ori=0.0, 
        color='black', colorSpace='rgb', opacity=None, 
        languageStyle='LTR',
        depth=0.0);
    
    # --- Initialize components for Routine "instructions_reward" ---
    instructions_rewardstage = visual.TextStim(win=win, name='instructions_rewardstage',
        text='Now it’s time to use what you learned to get rewards. You will play a series of trials that each have 3 decisions. Each decision, you will be shown a long-term BIG reward that you can get to at the 3rd decision. You can plan how to get there based off of what you learned.\n\nThe first choice will always involve choosing whether you start at the picture of the BABY or the picture of the TOOTHBRUSH. After that, you will click either LEFT or RIGHT to try to get to new pictures. \n\nIMPORTANT: You will always have the option to click SPACE to win 100 points. By choosing this option, the computer will take take you to a new image by choosing left or right for you. For example, on the first trial, if you click SPACE, the computer will randomly select either BABY or TOOTHBRUSH for you.',
        font='Open Sans',
        pos=(0, 0), height=0.032, wrapWidth=None, ori=0.0, 
        color='black', colorSpace='rgb', opacity=None, 
        languageStyle='LTR',
        depth=0.0);
    key_resp_11 = keyboard.Keyboard()
    text_46 = visual.TextStim(win=win, name='text_46',
        text='Press SPACE to continue ',
        font='Open Sans',
        pos=(0, -0.32), height=0.045, wrapWidth=None, ori=0.0, 
        color='black', colorSpace='rgb', opacity=None, 
        languageStyle='LTR',
        depth=-2.0);
    
    # --- Initialize components for Routine "instructions_planning_2" ---
    text_50 = visual.TextStim(win=win, name='text_50',
        text='VERY RARELY, the computer will take you to a location you didn’t want to go.\n\nTry your best to get the most points possible! You can win the most points both by collecting immediate rewards by clicking SPACE and by reaching and winning the long-term goals.\n\nYou will always see your WINNING TOTAL on each screen and your goal is to win the most points to win th most money!\n\nPress SPACE to continue',
        font='Open Sans',
        pos=(0, 0), height=0.04, wrapWidth=None, ori=0.0, 
        color='black', colorSpace='rgb', opacity=None, 
        languageStyle='LTR',
        depth=0.0);
    key_resp_9 = keyboard.Keyboard()
    # Run 'Begin Experiment' code from code_20
    
    
    directions_dict={'baby_left':'images/backpack.png',
    'baby_right':'images/bowtie.png',
    'toothbrush_left':'images/car.png',
    'toothbrush_right':'images/backpack.png',
    'hourglass_right':'images/hammer.png',
    'hourglass_left':'images/knight.png',
    'backpack_left':'images/lamp.png',
    'backpack_right':'images/hourglass.png',
    'lamp_left':'images/hammer.png',
    'lamp_right':'images/bending.png',
    'cat_left':'images/hammer.png',
    'cat_right':'images/zebra.png',
    'car_left':'images/cat.png',
    'car_right':'images/lamp.png',
    'bowtie_left':'images/lamp.png',
    'bowtie_right':'images/lamp.png'}
    
    
    
    incorrect_actions=0
    action='left.png'
    
    
    
    correct_quiz='p'
    percent_correct=''
    text_correct=''
    
    
    
    # --- Initialize components for Routine "instructions_example_trial" ---
    text_13 = visual.TextStim(win=win, name='text_13',
        text='EXAMPLE TRIAL: You are now at the image below. Choose left or right based off of what you learned to get the most points in images listed below!',
        font='Open Sans',
        pos=(0, 0.35), height=0.04, wrapWidth=None, ori=0.0, 
        color='black', colorSpace='rgb', opacity=None, 
        languageStyle='LTR',
        depth=-1.0);
    R1_5 = visual.ImageStim(
        win=win,
        name='R1_5', 
        image='images/knight.png', mask=None, anchor='center',
        ori=0.0, pos=(-0.15,-0.1), size=(0.15, 0.15),
        color=[1,1,1], colorSpace='rgb', opacity=None,
        flipHoriz=False, flipVert=False,
        texRes=128.0, interpolate=True, depth=-2.0)
    R2_5 = visual.ImageStim(
        win=win,
        name='R2_5', 
        image='images/computer.png', mask=None, anchor='center',
        ori=0.0, pos=(0.15, -0.1), size=(0.15, 0.15),
        color=[1,1,1], colorSpace='rgb', opacity=None,
        flipHoriz=False, flipVert=False,
        texRes=128.0, interpolate=True, depth=-3.0)
    rew1_5 = visual.TextStim(win=win, name='rew1_5',
        text='',
        font='Open Sans',
        pos=(-0.15, -0.22), height=0.05, wrapWidth=None, ori=0.0, 
        color='green', colorSpace='rgb', opacity=None, 
        languageStyle='LTR',
        depth=-4.0);
    rew2_5 = visual.TextStim(win=win, name='rew2_5',
        text='',
        font='Open Sans',
        pos=(0.15, -0.25), height=0.05, wrapWidth=None, ori=0.0, 
        color='green', colorSpace='rgb', opacity=None, 
        languageStyle='LTR',
        depth=-5.0);
    text_21 = visual.TextStim(win=win, name='text_21',
        text='Choose LEFT or RIGHT to try to win points!',
        font='Open Sans',
        pos=(0, -0.38), height=0.025, wrapWidth=None, ori=0.0, 
        color='black', colorSpace='rgb', opacity=None, 
        languageStyle='LTR',
        depth=-6.0);
    plan2_response_2 = keyboard.Keyboard()
    current_image_decision2_2 = visual.ImageStim(
        win=win,
        name='current_image_decision2_2', 
        image='images/baby.png', mask=None, anchor='center',
        ori=0.0, pos=(0, 0.17), size=(0.2, 0.2),
        color=[1,1,1], colorSpace='rgb', opacity=None,
        flipHoriz=False, flipVert=False,
        texRes=128.0, interpolate=True, depth=-8.0)
    
    # --- Initialize components for Routine "long_term_reward_instructions" ---
    instructions_rewardstage_2 = visual.TextStim(win=win, name='instructions_rewardstage_2',
        text='Each planning trial has 3 decisions. You have the chance to win 400 points if you successfully make it to that destination at the 3rd decision. It is always presented on the bottom RIGHT of the 3 decisions, and will NEVER CHANGE across the 3 decisions.\n\nBy contrast, on the bottom LEFT, you can choose to have the computer select which state to go to next, and win 100 points instantly! You will see your total score.\n\nIMPORTANT: MANY TIMES YOU CAN WIN BOTH THE IMMEDIATE REWARD AND THE LONG TERM REWARD!\n',
        font='Open Sans',
        pos=(0, 0), height=0.032, wrapWidth=None, ori=0.0, 
        color='black', colorSpace='rgb', opacity=None, 
        languageStyle='LTR',
        depth=0.0);
    key_resp_12 = keyboard.Keyboard()
    text_45 = visual.TextStim(win=win, name='text_45',
        text='press SPACE to continue',
        font='Open Sans',
        pos=(0, -0.32), height=0.05, wrapWidth=None, ori=0.0, 
        color='black', colorSpace='rgb', opacity=None, 
        languageStyle='LTR',
        depth=-2.0);
    
    # --- Initialize components for Routine "quiz_planning_1" ---
    text_47 = visual.TextStim(win=win, name='text_47',
        text='Planning Quiz\n\n1. What is always the first decision out of the 3 decisions for EVERY planning trial?\n\na. between CAT and TOOTHBRUSH\n\nb. between CAR and TOOTHBRUSH\n\nc. between BABY and TOOTHBRUSH\n\nd. You start at a different point each planning trial',
        font='Open Sans',
        pos=(0, 0), height=0.038, wrapWidth=None, ori=0.0, 
        color='black', colorSpace='rgb', opacity=None, 
        languageStyle='LTR',
        depth=0.0);
    key_resp_21 = keyboard.Keyboard()
    
    # --- Initialize components for Routine "quiz_planning_2" ---
    text_73 = visual.TextStim(win=win, name='text_73',
        text='Instructions Quiz\n\n2. What is the long term reward depicted on bottom right?\n\na. It is a reward you can obtain every decision out of the 3 decisions.\n\nb. It is a big reward you can get only at the 3rd decision. Its location will not change across all 3 decisions to allow you to plan how to get there!\n\nc. It is always a reward that you can ONLY get by AVOIDING going for short-term rewards.\n\nd. It is your total amount of winnings in the game.',
        font='Open Sans',
        pos=(0, 0), height=0.038, wrapWidth=None, ori=0.0, 
        color='black', colorSpace='rgb', opacity=None, 
        languageStyle='LTR',
        depth=0.0);
    key_resp_22 = keyboard.Keyboard()
    
    # --- Initialize components for Routine "quiz_planning_3" ---
    text_74 = visual.TextStim(win=win, name='text_74',
        text='Planning Quiz\n\n3. What happens when you press SPACE ?\n\na. It is the reward you get from memory quizzes during learning\n\nb. You instantly get 100 points but the computer randomly selects LEFT or RIGHT for you, so you don’t know the image you’ll end up at next.\n\nc. It gives you 60 points but PREVENTS you from getting the LONG-term reward. \n\nd. It is the rewards you already got during what you previously learned.',
        font='Open Sans',
        pos=(0, 0), height=0.038, wrapWidth=None, ori=0.0, 
        color='black', colorSpace='rgb', opacity=None, 
        languageStyle='LTR',
        depth=0.0);
    key_resp_24 = keyboard.Keyboard()
    
    # --- Initialize components for Routine "quiz_feedback" ---
    result_q_instr = visual.TextStim(win=win, name='result_q_instr',
        text='',
        font='Open Sans',
        pos=(0, 0), height=0.06, wrapWidth=None, ori=0.0, 
        color='black', colorSpace='rgb', opacity=None, 
        languageStyle='LTR',
        depth=0.0);
    
    # --- Initialize components for Routine "see_planning_trials" ---
    text_48 = visual.TextStim(win=win, name='text_48',
        text='Now you will see how planning trials look in the real game. These trials will not include the same images you just learned about. However, the same things you learn now in practice will apply to the real planning phase. \n\nPress SPACE to continue.',
        font='Open Sans',
        pos=(0, 0), height=0.05, wrapWidth=None, ori=0.0, 
        color='black', colorSpace='rgb', opacity=None, 
        languageStyle='LTR',
        depth=0.0);
    key_resp_8 = keyboard.Keyboard()
    
    # --- Initialize components for Routine "instructions_planning_new" ---
    text_32 = visual.TextStim(win=win, name='text_32',
        text='EXAMPLE Decision 1: Choose SPACE and the computer randomly selects which state you get to.',
        font='Open Sans',
        pos=(0, 0.35), height=0.04, wrapWidth=None, ori=0.0, 
        color='black', colorSpace='rgb', opacity=None, 
        languageStyle='LTR',
        depth=-1.0);
    R1_6 = visual.ImageStim(
        win=win,
        name='R1_6', 
        image='images/computer.png', mask=None, anchor='center',
        ori=0.0, pos=(-0.15,-0.1), size=(0.15, 0.15),
        color=[1,1,1], colorSpace='rgb', opacity=None,
        flipHoriz=False, flipVert=False,
        texRes=128.0, interpolate=True, depth=-2.0)
    R2_6 = visual.ImageStim(
        win=win,
        name='R2_6', 
        image='images/knight.png', mask=None, anchor='center',
        ori=0.0, pos=(0.15, -0.1), size=(0.15, 0.15),
        color=[1,1,1], colorSpace='rgb', opacity=None,
        flipHoriz=False, flipVert=False,
        texRes=128.0, interpolate=True, depth=-3.0)
    rew1_6 = visual.TextStim(win=win, name='rew1_6',
        text='',
        font='Open Sans',
        pos=(-0.15, -0.22), height=0.05, wrapWidth=None, ori=0.0, 
        color='green', colorSpace='rgb', opacity=None, 
        languageStyle='LTR',
        depth=-4.0);
    rew2_6 = visual.TextStim(win=win, name='rew2_6',
        text='',
        font='Open Sans',
        pos=(0.15, -0.22), height=0.05, wrapWidth=None, ori=0.0, 
        color='green', colorSpace='rgb', opacity=None, 
        languageStyle='LTR',
        depth=-5.0);
    plan2_response_3 = keyboard.Keyboard()
    text_34 = visual.TextStim(win=win, name='text_34',
        text='Long-Term Reward',
        font='Open Sans',
        pos=(0.20, -0.32), height=0.04, wrapWidth=None, ori=0.0, 
        color='black', colorSpace='rgb', opacity=None, 
        languageStyle='LTR',
        depth=-7.0);
    text_41 = visual.TextStim(win=win, name='text_41',
        text='Computer Chooses',
        font='Open Sans',
        pos=(-0.20, -0.32), height=0.04, wrapWidth=None, ori=0.0, 
        color='black', colorSpace='rgb', opacity=None, 
        languageStyle='LTR',
        depth=-8.0);
    text_114 = visual.TextStim(win=win, name='text_114',
        text='',
        font='Open Sans',
        pos=(0.1, -0.41), height=0.04, wrapWidth=None, ori=0.0, 
        color='red', colorSpace='rgb', opacity=None, 
        languageStyle='LTR',
        depth=-9.0);
    text_128 = visual.TextStim(win=win, name='text_128',
        text='Total=',
        font='Open Sans',
        pos=(-0.10, -0.41), height=0.04, wrapWidth=None, ori=0.0, 
        color='red', colorSpace='rgb', opacity=None, 
        languageStyle='LTR',
        depth=-10.0);
    
    # --- Initialize components for Routine "planning_2_instructions" ---
    text_52 = visual.TextStim(win=win, name='text_52',
        text='The COMPUTER chose LEFT and now you’re at the PLANET. \nDecision 2: Choose the computer again by clicking SPACE. ',
        font='Open Sans',
        pos=(0, 0.38), height=0.04, wrapWidth=None, ori=0.0, 
        color='black', colorSpace='rgb', opacity=None, 
        languageStyle='LTR',
        depth=-1.0);
    R1_9 = visual.ImageStim(
        win=win,
        name='R1_9', 
        image='images/computer.png', mask=None, anchor='center',
        ori=0.0, pos=(-0.15,-0.1), size=(0.15, 0.15),
        color=[1,1,1], colorSpace='rgb', opacity=None,
        flipHoriz=False, flipVert=False,
        texRes=128.0, interpolate=True, depth=-2.0)
    R2_9 = visual.ImageStim(
        win=win,
        name='R2_9', 
        image='images/knight.png', mask=None, anchor='center',
        ori=0.0, pos=(0.15, -0.1), size=(0.15, 0.15),
        color=[1,1,1], colorSpace='rgb', opacity=None,
        flipHoriz=False, flipVert=False,
        texRes=128.0, interpolate=True, depth=-3.0)
    rew1_9 = visual.TextStim(win=win, name='rew1_9',
        text='',
        font='Open Sans',
        pos=(-0.15, -0.22), height=0.05, wrapWidth=None, ori=0.0, 
        color='green', colorSpace='rgb', opacity=None, 
        languageStyle='LTR',
        depth=-4.0);
    rew2_9 = visual.TextStim(win=win, name='rew2_9',
        text='',
        font='Open Sans',
        pos=(0.15, -0.22), height=0.05, wrapWidth=None, ori=0.0, 
        color='green', colorSpace='rgb', opacity=None, 
        languageStyle='LTR',
        depth=-5.0);
    text_53 = visual.TextStim(win=win, name='text_53',
        text='Choose LEFT or RIGHT',
        font='Open Sans',
        pos=(0.15, -0.30), height=0.025, wrapWidth=None, ori=0.0, 
        color='black', colorSpace='rgb', opacity=None, 
        languageStyle='LTR',
        depth=-6.0);
    plan2_response_6 = keyboard.Keyboard()
    current_image_decision2_5 = visual.ImageStim(
        win=win,
        name='current_image_decision2_5', 
        image='planet.png', mask=None, anchor='center',
        ori=0.0, pos=(0, 0.17), size=(0.2, 0.2),
        color=[1,1,1], colorSpace='rgb', opacity=None,
        flipHoriz=False, flipVert=False,
        texRes=128.0, interpolate=True, depth=-8.0)
    text_115 = visual.TextStim(win=win, name='text_115',
        text='',
        font='Open Sans',
        pos=(0.1, -0.41), height=0.04, wrapWidth=None, ori=0.0, 
        color='red', colorSpace='rgb', opacity=None, 
        languageStyle='LTR',
        depth=-9.0);
    text_129 = visual.TextStim(win=win, name='text_129',
        text='Total=',
        font='Open Sans',
        pos=(-0.15, -0.41), height=0.04, wrapWidth=None, ori=0.0, 
        color='red', colorSpace='rgb', opacity=None, 
        languageStyle='LTR',
        depth=-10.0);
    
    # --- Initialize components for Routine "instructions_planning_new3" ---
    text_136 = visual.TextStim(win=win, name='text_136',
        text='Decision 3: You are at the BASKET. Choose right to get the BIG REWARD at the KNIGHT. ',
        font='Open Sans',
        pos=(0, 0.35), height=0.04, wrapWidth=None, ori=0.0, 
        color='black', colorSpace='rgb', opacity=None, 
        languageStyle='LTR',
        depth=-1.0);
    R1_11 = visual.ImageStim(
        win=win,
        name='R1_11', 
        image='images/computer.png', mask=None, anchor='center',
        ori=0.0, pos=(-0.15,-0.1), size=(0.10, 0.10),
        color=[1,1,1], colorSpace='rgb', opacity=None,
        flipHoriz=False, flipVert=False,
        texRes=128.0, interpolate=True, depth=-2.0)
    R2_11 = visual.ImageStim(
        win=win,
        name='R2_11', 
        image='images/knight.png', mask=None, anchor='center',
        ori=0.0, pos=(0.15, -0.1), size=(0.10, 0.10),
        color=[1,1,1], colorSpace='rgb', opacity=None,
        flipHoriz=False, flipVert=False,
        texRes=128.0, interpolate=True, depth=-3.0)
    rew1_11 = visual.TextStim(win=win, name='rew1_11',
        text='',
        font='Open Sans',
        pos=(-0.15, -0.22), height=0.05, wrapWidth=None, ori=0.0, 
        color='green', colorSpace='rgb', opacity=None, 
        languageStyle='LTR',
        depth=-4.0);
    rew2_11 = visual.TextStim(win=win, name='rew2_11',
        text='',
        font='Open Sans',
        pos=(0.15, -0.22), height=0.05, wrapWidth=None, ori=0.0, 
        color='green', colorSpace='rgb', opacity=None, 
        languageStyle='LTR',
        depth=-5.0);
    plan2_response_5 = keyboard.Keyboard()
    current_image_decision2_6 = visual.ImageStim(
        win=win,
        name='current_image_decision2_6', 
        image='basket.png', mask=None, anchor='center',
        ori=0.0, pos=(0, 0.17), size=(0.15, 0.15),
        color=[1,1,1], colorSpace='rgb', opacity=None,
        flipHoriz=False, flipVert=False,
        texRes=128.0, interpolate=True, depth=-7.0)
    text_137 = visual.TextStim(win=win, name='text_137',
        text='Long-Term Reward',
        font='Open Sans',
        pos=(0.20, -0.32), height=0.04, wrapWidth=None, ori=0.0, 
        color='black', colorSpace='rgb', opacity=None, 
        languageStyle='LTR',
        depth=-8.0);
    text_138 = visual.TextStim(win=win, name='text_138',
        text='Short-Term Reward',
        font='Open Sans',
        pos=(-0.20, -0.32), height=0.04, wrapWidth=None, ori=0.0, 
        color='black', colorSpace='rgb', opacity=None, 
        languageStyle='LTR',
        depth=-9.0);
    text_139 = visual.TextStim(win=win, name='text_139',
        text='',
        font='Open Sans',
        pos=(0.1, -0.41), height=0.04, wrapWidth=None, ori=0.0, 
        color='red', colorSpace='rgb', opacity=None, 
        languageStyle='LTR',
        depth=-10.0);
    text_140 = visual.TextStim(win=win, name='text_140',
        text='Total=',
        font='Open Sans',
        pos=(-0.15, -0.41), height=0.04, wrapWidth=None, ori=0.0, 
        color='red', colorSpace='rgb', opacity=None, 
        languageStyle='LTR',
        depth=-11.0);
    
    # --- Initialize components for Routine "practice_planning_outcomes" ---
    image_6 = visual.ImageStim(
        win=win,
        name='image_6', 
        image='images/knight.png', mask=None, anchor='center',
        ori=0.0, pos=(0, 0), size=(0.5, 0.5),
        color=[1,1,1], colorSpace='rgb', opacity=None,
        flipHoriz=False, flipVert=False,
        texRes=128.0, interpolate=True, depth=-1.0)
    text_141 = visual.TextStim(win=win, name='text_141',
        text='You arrived here! ',
        font='Open Sans',
        pos=(0, 0.35), height=0.05, wrapWidth=None, ori=0.0, 
        color='black', colorSpace='rgb', opacity=None, 
        languageStyle='LTR',
        depth=-2.0);
    text_142 = visual.TextStim(win=win, name='text_142',
        text='',
        font='Open Sans',
        pos=(0, -0.41), height=0.04, wrapWidth=None, ori=0.0, 
        color='red', colorSpace='rgb', opacity=None, 
        languageStyle='LTR',
        depth=-3.0);
    text_143 = visual.TextStim(win=win, name='text_143',
        text='Total=',
        font='Open Sans',
        pos=(-0.12, -0.41), height=0.04, wrapWidth=None, ori=0.0, 
        color='red', colorSpace='rgb', opacity=None, 
        languageStyle='LTR',
        depth=-4.0);
    
    # --- Initialize components for Routine "immediate_rewar_lesson" ---
    text_148 = visual.TextStim(win=win, name='text_148',
        text='NOTICE: You were able to avoid planning twice by clicking SPACE to win 200 more points and STILL arrive at the long-term goal of KNIGHT. In the upcoming planning phase, use what you know about how to get to long term goals to determine when it is best to choose yourself or let the COMPUTER choose for you to win more points. Press SPACE to continue.',
        font='Open Sans',
        pos=(0, 0), height=0.05, wrapWidth=None, ori=0.0, 
        color='black', colorSpace='rgb', opacity=None, 
        languageStyle='LTR',
        depth=0.0);
    key_resp_39 = keyboard.Keyboard()
    
    # --- Initialize components for Routine "lesson_practice" ---
    text_144 = visual.TextStim(win=win, name='text_144',
        text='If you do well in upcoming planning trials, you can WIN even more bonus MONEY!\n\nIMPORTANT: when you press SPACE to have the computer choose for you, it will always take you to a new image the way you learned about in the learning phase. After this random choice, you will then be able to try to reach the long term goal image from where the random choice led you to.\n\nPress SPACE to continue',
        font='Open Sans',
        pos=(0, 0), height=0.045, wrapWidth=None, ori=0.0, 
        color='black', colorSpace='rgb', opacity=None, 
        languageStyle='LTR',
        depth=0.0);
    key_resp_37 = keyboard.Keyboard()
    
    # --- Initialize components for Routine "lesson_practice_2" ---
    text_145 = visual.TextStim(win=win, name='text_145',
        text='IMPORTANT: Each big long-term image you can plan to reach has a different amount of ROUTES to get there. For example, one long-term image may have only one route, while another may have many! Use this to choose well and win the most points you can! \n\n\nPress SPACE to continue',
        font='Open Sans',
        pos=(0, 0), height=0.045, wrapWidth=None, ori=0.0, 
        color='black', colorSpace='rgb', opacity=None, 
        languageStyle='LTR',
        depth=0.0);
    key_resp_38 = keyboard.Keyboard()
    
    # --- Initialize components for Routine "start_real_planning" ---
    text_42 = visual.TextStim(win=win, name='text_42',
        text='Starting the actual planning phase. \n\nREMEMBER: You have UNLIMITED time to plan. Try to figure out when it makes sense press SPACE and have the computer choose for you in a way that still makes sure you can get to the BIG REWARD. \n\npress SPACE to start and good luck!',
        font='Open Sans',
        pos=(0, 0), height=0.05, wrapWidth=None, ori=0.0, 
        color='black', colorSpace='rgb', opacity=None, 
        languageStyle='LTR',
        depth=0.0);
    key_resp_6 = keyboard.Keyboard()
    
    # --- Initialize components for Routine "plan1_info_2" ---
    text_5 = visual.TextStim(win=win, name='text_5',
        text='Choose LEFT for BABY or RIGHT for TOOTHBRUSH or SPACE. Make this choice by considering how to get the most points at the images shown below.',
        font='Open Sans',
        pos=(0, 0.35), height=0.03, wrapWidth=None, ori=0.0, 
        color='black', colorSpace='rgb', opacity=None, 
        languageStyle='LTR',
        depth=-1.0);
    R1 = visual.ImageStim(
        win=win,
        name='R1', 
        image='images/computer.png', mask=None, anchor='center',
        ori=0.0, pos=(-0.15,-0.12), size=(0.15, 0.15),
        color=[1,1,1], colorSpace='rgb', opacity=None,
        flipHoriz=False, flipVert=False,
        texRes=128.0, interpolate=True, depth=-2.0)
    R2 = visual.ImageStim(
        win=win,
        name='R2', 
        image='default.png', mask=None, anchor='center',
        ori=0.0, pos=(0.15, -.12), size=(0.15, 0.15),
        color=[1,1,1], colorSpace='rgb', opacity=None,
        flipHoriz=False, flipVert=False,
        texRes=128.0, interpolate=True, depth=-3.0)
    rew1 = visual.TextStim(win=win, name='rew1',
        text='SPACE for 100',
        font='Open Sans',
        pos=(-0.15, -0.27), height=0.05, wrapWidth=None, ori=0.0, 
        color='green', colorSpace='rgb', opacity=None, 
        languageStyle='LTR',
        depth=-4.0);
    rew2 = visual.TextStim(win=win, name='rew2',
        text='',
        font='Open Sans',
        pos=(0.15, -0.27), height=0.05, wrapWidth=None, ori=0.0, 
        color='green', colorSpace='rgb', opacity=None, 
        languageStyle='LTR',
        depth=-5.0);
    text_6 = visual.TextStim(win=win, name='text_6',
        text='Left or Right',
        font='Open Sans',
        pos=(0.15, -0.32), height=0.025, wrapWidth=None, ori=0.0, 
        color='black', colorSpace='rgb', opacity=None, 
        languageStyle='LTR',
        depth=-6.0);
    plan1_response = keyboard.Keyboard()
    babyleft = visual.ImageStim(
        win=win,
        name='babyleft', 
        image='images/baby.png', mask=None, anchor='center',
        ori=0.0, pos=(-0.2, 0.2), size=(0.15, 0.15),
        color=[1,1,1], colorSpace='rgb', opacity=None,
        flipHoriz=False, flipVert=False,
        texRes=128.0, interpolate=True, depth=-8.0)
    toothbrushright = visual.ImageStim(
        win=win,
        name='toothbrushright', 
        image='images/toothbrush.png', mask=None, anchor='center',
        ori=0.0, pos=(0.2, 0.2), size=(0.15, 0.15),
        color=[1,1,1], colorSpace='rgb', opacity=None,
        flipHoriz=False, flipVert=False,
        texRes=128.0, interpolate=True, depth=-9.0)
    text_117 = visual.TextStim(win=win, name='text_117',
        text='',
        font='Open Sans',
        pos=(0, -0.41), height=0.04, wrapWidth=None, ori=0.0, 
        color='red', colorSpace='rgb', opacity=None, 
        languageStyle='LTR',
        depth=-10.0);
    text_120 = visual.TextStim(win=win, name='text_120',
        text='Total=',
        font='Open Sans',
        pos=(-0.1, -0.41), height=0.04, wrapWidth=None, ori=0.0, 
        color='red', colorSpace='rgb', opacity=None, 
        languageStyle='LTR',
        depth=-11.0);
    
    # --- Initialize components for Routine "plan2_info" ---
    text_7 = visual.TextStim(win=win, name='text_7',
        text='You are now at the image below. Choose left or right or SPACE based off of what you learned to get the most points in images listed below!',
        font='Open Sans',
        pos=(0, 0.4), height=0.04, wrapWidth=None, ori=0.0, 
        color='black', colorSpace='rgb', opacity=None, 
        languageStyle='LTR',
        depth=-1.0);
    R1_2 = visual.ImageStim(
        win=win,
        name='R1_2', 
        image='default.png', mask=None, anchor='center',
        ori=0.0, pos=(-0.15,-0.1), size=(0.15, 0.15),
        color=[1,1,1], colorSpace='rgb', opacity=None,
        flipHoriz=False, flipVert=False,
        texRes=128.0, interpolate=True, depth=-2.0)
    R2_2 = visual.ImageStim(
        win=win,
        name='R2_2', 
        image='default.png', mask=None, anchor='center',
        ori=0.0, pos=(0.15, -0.1), size=(0.15, 0.15),
        color=[1,1,1], colorSpace='rgb', opacity=None,
        flipHoriz=False, flipVert=False,
        texRes=128.0, interpolate=True, depth=-3.0)
    rew1_2 = visual.TextStim(win=win, name='rew1_2',
        text='SPACE for 100',
        font='Open Sans',
        pos=(-0.15, -0.22), height=0.05, wrapWidth=None, ori=0.0, 
        color='green', colorSpace='rgb', opacity=None, 
        languageStyle='LTR',
        depth=-4.0);
    rew2_2 = visual.TextStim(win=win, name='rew2_2',
        text='',
        font='Open Sans',
        pos=(0.15, -0.22), height=0.05, wrapWidth=None, ori=0.0, 
        color='green', colorSpace='rgb', opacity=None, 
        languageStyle='LTR',
        depth=-5.0);
    text_10 = visual.TextStim(win=win, name='text_10',
        text='Left or Right',
        font='Open Sans',
        pos=(0.15, -0.32), height=0.025, wrapWidth=None, ori=0.0, 
        color='black', colorSpace='rgb', opacity=None, 
        languageStyle='LTR',
        depth=-6.0);
    plan2_response = keyboard.Keyboard()
    current_image_decision2 = visual.ImageStim(
        win=win,
        name='current_image_decision2', 
        image='default.png', mask=None, anchor='center',
        ori=0.0, pos=(0, 0.17), size=(0.2, 0.2),
        color=[1,1,1], colorSpace='rgb', opacity=None,
        flipHoriz=False, flipVert=False,
        texRes=128.0, interpolate=True, depth=-8.0)
    text_118 = visual.TextStim(win=win, name='text_118',
        text='',
        font='Open Sans',
        pos=(0, -0.41), height=0.04, wrapWidth=None, ori=0.0, 
        color='red', colorSpace='rgb', opacity=None, 
        languageStyle='LTR',
        depth=-9.0);
    text_121 = visual.TextStim(win=win, name='text_121',
        text='Total=',
        font='Open Sans',
        pos=(-0.1, -0.41), height=0.04, wrapWidth=None, ori=0.0, 
        color='red', colorSpace='rgb', opacity=None, 
        languageStyle='LTR',
        depth=-10.0);
    
    # --- Initialize components for Routine "plan3_info" ---
    text_14 = visual.TextStim(win=win, name='text_14',
        text='You are now at the image below. Choose left or right or SPACE based off of what you learned to get the most points in images listed below!',
        font='Open Sans',
        pos=(0, 0.4), height=0.04, wrapWidth=None, ori=0.0, 
        color='black', colorSpace='rgb', opacity=None, 
        languageStyle='LTR',
        depth=-1.0);
    R1_3 = visual.ImageStim(
        win=win,
        name='R1_3', 
        image='images/computer.png', mask=None, anchor='center',
        ori=0.0, pos=(-0.15,-0.1), size=(0.15, 0.15),
        color=[1,1,1], colorSpace='rgb', opacity=None,
        flipHoriz=False, flipVert=False,
        texRes=128.0, interpolate=True, depth=-2.0)
    R2_3 = visual.ImageStim(
        win=win,
        name='R2_3', 
        image='default.png', mask=None, anchor='center',
        ori=0.0, pos=(0.15, -0.1), size=(0.15, 0.15),
        color=[1,1,1], colorSpace='rgb', opacity=None,
        flipHoriz=False, flipVert=False,
        texRes=128.0, interpolate=True, depth=-3.0)
    rew1_3 = visual.TextStim(win=win, name='rew1_3',
        text='SPACE for 100',
        font='Open Sans',
        pos=(-0.15, -0.22), height=0.05, wrapWidth=None, ori=0.0, 
        color='green', colorSpace='rgb', opacity=None, 
        languageStyle='LTR',
        depth=-4.0);
    rew2_3 = visual.TextStim(win=win, name='rew2_3',
        text='',
        font='Open Sans',
        pos=(0.15, -0.22), height=0.05, wrapWidth=None, ori=0.0, 
        color='green', colorSpace='rgb', opacity=None, 
        languageStyle='LTR',
        depth=-5.0);
    text_15 = visual.TextStim(win=win, name='text_15',
        text='Left or Right',
        font='Open Sans',
        pos=(0.15, -0.32), height=0.025, wrapWidth=None, ori=0.0, 
        color='black', colorSpace='rgb', opacity=None, 
        languageStyle='LTR',
        depth=-6.0);
    plan3_response = keyboard.Keyboard()
    current_image_decision3 = visual.ImageStim(
        win=win,
        name='current_image_decision3', 
        image='default.png', mask=None, anchor='center',
        ori=0.0, pos=(0, 0.17), size=(0.2, 0.2),
        color=[1,1,1], colorSpace='rgb', opacity=None,
        flipHoriz=False, flipVert=False,
        texRes=128.0, interpolate=True, depth=-8.0)
    text_122 = visual.TextStim(win=win, name='text_122',
        text='',
        font='Open Sans',
        pos=(0, -0.41), height=0.04, wrapWidth=None, ori=0.0, 
        color='red', colorSpace='rgb', opacity=None, 
        languageStyle='LTR',
        depth=-9.0);
    text_123 = visual.TextStim(win=win, name='text_123',
        text='Total=',
        font='Open Sans',
        pos=(-0.1, -0.41), height=0.04, wrapWidth=None, ori=0.0, 
        color='red', colorSpace='rgb', opacity=None, 
        languageStyle='LTR',
        depth=-10.0);
    
    # --- Initialize components for Routine "planning4" ---
    image_4 = visual.ImageStim(
        win=win,
        name='image_4', 
        image='default.png', mask=None, anchor='center',
        ori=0.0, pos=(0, 0), size=(0.5, 0.5),
        color=[1,1,1], colorSpace='rgb', opacity=None,
        flipHoriz=False, flipVert=False,
        texRes=128.0, interpolate=True, depth=-1.0)
    text_19 = visual.TextStim(win=win, name='text_19',
        text='You arrived here! ',
        font='Open Sans',
        pos=(0, 0.35), height=0.05, wrapWidth=None, ori=0.0, 
        color='black', colorSpace='rgb', opacity=None, 
        languageStyle='LTR',
        depth=-2.0);
    text_119 = visual.TextStim(win=win, name='text_119',
        text='',
        font='Open Sans',
        pos=(0, -0.41), height=0.04, wrapWidth=None, ori=0.0, 
        color='red', colorSpace='rgb', opacity=None, 
        languageStyle='LTR',
        depth=-3.0);
    text_131 = visual.TextStim(win=win, name='text_131',
        text='Total=',
        font='Open Sans',
        pos=(-0.12, -0.41), height=0.04, wrapWidth=None, ori=0.0, 
        color='red', colorSpace='rgb', opacity=None, 
        languageStyle='LTR',
        depth=-4.0);
    
    # --- Initialize components for Routine "next_trial" ---
    next_trial_text = visual.TextStim(win=win, name='next_trial_text',
        text='next trial…',
        font='Open Sans',
        pos=(0, 0), height=0.05, wrapWidth=None, ori=0.0, 
        color='black', colorSpace='rgb', opacity=None, 
        languageStyle='LTR',
        depth=0.0);
    
    # --- Initialize components for Routine "planning_paths" ---
    text_149 = visual.TextStim(win=win, name='text_149',
        text='Plan how to get from either the BABY or TOOTHBRUSH to new images. \n\nPlan how to get from one image to the next image. \n\nREMEMBER: Nothing has changed since you initially learned about how to navigate between pictures at the beginning of the task.',
        font='Open Sans',
        pos=(0, 0.2), height=0.05, wrapWidth=None, ori=0.0, 
        color='black', colorSpace='rgb', opacity=None, 
        languageStyle='LTR',
        depth=0.0);
    key_resp_40 = keyboard.Keyboard()
    text_49 = visual.TextStim(win=win, name='text_49',
        text='Press space to begin',
        font='Open Sans',
        pos=(0, -0.25), height=0.045, wrapWidth=None, ori=0.0, 
        color='black', colorSpace='rgb', opacity=None, 
        languageStyle='LTR',
        depth=-3.0);
    
    # --- Initialize components for Routine "forgetting_paths1" ---
    question_quiz1_3 = visual.TextStim(win=win, name='question_quiz1_3',
        text='Plan the 2 actions in your head how to get from the left image to the right image. You have two minutes to plan.',
        font='Open Sans',
        pos=(0, 0.3), height=0.05, wrapWidth=None, ori=0.0, 
        color='black', colorSpace='rgb', opacity=None, 
        languageStyle='LTR',
        depth=0.0);
    answer_quiz1_3 = keyboard.Keyboard()
    answer1_3 = visual.ImageStim(
        win=win,
        name='answer1_3', 
        image='default.png', mask=None, anchor='center',
        ori=0.0, pos=(-0.40, 0), size=(0.2, 0.2),
        color=[1,1,1], colorSpace='rgb', opacity=None,
        flipHoriz=False, flipVert=False,
        texRes=128.0, interpolate=True, depth=-2.0)
    answer2_3 = visual.ImageStim(
        win=win,
        name='answer2_3', 
        image='default.png', mask=None, anchor='center',
        ori=0.0, pos=(0, 0), size=(0.2, 0.2),
        color=[1,1,1], colorSpace='rgb', opacity=None,
        flipHoriz=False, flipVert=False,
        texRes=128.0, interpolate=True, depth=-3.0)
    answer3_3 = visual.ImageStim(
        win=win,
        name='answer3_3', 
        image='default.png', mask=None, anchor='center',
        ori=0.0, pos=(0.40, 0), size=(0.2, 0.2),
        color=[1,1,1], colorSpace='rgb', opacity=None,
        flipHoriz=False, flipVert=False,
        texRes=128.0, interpolate=True, depth=-4.0)
    a1_3 = visual.TextStim(win=win, name='a1_3',
        text='>',
        font='Open Sans',
        pos=(-0.20, 0), height=0.1, wrapWidth=None, ori=0.0, 
        color='black', colorSpace='rgb', opacity=None, 
        languageStyle='LTR',
        depth=-5.0);
    a2_3 = visual.TextStim(win=win, name='a2_3',
        text='>',
        font='Open Sans',
        pos=(0.20, 0), height=0.1, wrapWidth=None, ori=0.0, 
        color='black', colorSpace='rgb', opacity=None, 
        languageStyle='LTR',
        depth=-6.0);
    text_146 = visual.TextStim(win=win, name='text_146',
        text='Click the two actions (a sequence of LEFT and RIGHT) on the keyboard that will get you from the image on the far left to the image on the far right.',
        font='Open Sans',
        pos=(0, -0.28), height=0.055, wrapWidth=None, ori=0.0, 
        color='black', colorSpace='rgb', opacity=None, 
        languageStyle='LTR',
        depth=-7.0);
    
    # --- Initialize components for Routine "planningpathstraining2" ---
    question_quiz1_5 = visual.TextStim(win=win, name='question_quiz1_5',
        text='Plan the 2 actions in your head how to get from the left image to the right image. You have two minutes to plan.',
        font='Open Sans',
        pos=(0, 0.3), height=0.05, wrapWidth=None, ori=0.0, 
        color='black', colorSpace='rgb', opacity=None, 
        languageStyle='LTR',
        depth=0.0);
    answer_quiz1_5 = keyboard.Keyboard()
    answer1_5 = visual.ImageStim(
        win=win,
        name='answer1_5', 
        image='default.png', mask=None, anchor='center',
        ori=0.0, pos=(-0.40, 0), size=(0.2, 0.2),
        color=[1,1,1], colorSpace='rgb', opacity=None,
        flipHoriz=False, flipVert=False,
        texRes=128.0, interpolate=True, depth=-2.0)
    answer2_5 = visual.ImageStim(
        win=win,
        name='answer2_5', 
        image='default.png', mask=None, anchor='center',
        ori=0.0, pos=(0, 0), size=(0.2, 0.2),
        color=[1,1,1], colorSpace='rgb', opacity=None,
        flipHoriz=False, flipVert=False,
        texRes=128.0, interpolate=True, depth=-3.0)
    answer3_5 = visual.ImageStim(
        win=win,
        name='answer3_5', 
        image='default.png', mask=None, anchor='center',
        ori=0.0, pos=(0.40, 0), size=(0.2, 0.2),
        color=[1,1,1], colorSpace='rgb', opacity=None,
        flipHoriz=False, flipVert=False,
        texRes=128.0, interpolate=True, depth=-4.0)
    a1_5 = visual.TextStim(win=win, name='a1_5',
        text='>',
        font='Open Sans',
        pos=(-0.20, 0), height=0.1, wrapWidth=None, ori=0.0, 
        color='black', colorSpace='rgb', opacity=None, 
        languageStyle='LTR',
        depth=-5.0);
    a2_5 = visual.TextStim(win=win, name='a2_5',
        text='>',
        font='Open Sans',
        pos=(0.20, 0), height=0.1, wrapWidth=None, ori=0.0, 
        color='black', colorSpace='rgb', opacity=None, 
        languageStyle='LTR',
        depth=-6.0);
    text_152 = visual.TextStim(win=win, name='text_152',
        text='Click the two actions (a sequence of LEFT and RIGHT) on the keyboard that will get you from the image on the far left to the image on the far right.',
        font='Open Sans',
        pos=(0, -0.28), height=0.055, wrapWidth=None, ori=0.0, 
        color='black', colorSpace='rgb', opacity=None, 
        languageStyle='LTR',
        depth=-8.0);
    
    # --- Initialize components for Routine "correct_forget_paths" ---
    next_trial_text_2 = visual.TextStim(win=win, name='next_trial_text_2',
        text='',
        font='Open Sans',
        pos=(0, 0), height=0.05, wrapWidth=None, ori=0.0, 
        color='black', colorSpace='rgb', opacity=None, 
        languageStyle='LTR',
        depth=0.0);
    text_151 = visual.TextStim(win=win, name='text_151',
        text='',
        font='Open Sans',
        pos=(0, -0.25), height=0.1, wrapWidth=None, ori=0.0, 
        color='black', colorSpace='rgb', opacity=None, 
        languageStyle='LTR',
        depth=-1.0);
    
    # --- Initialize components for Routine "total_score_planning" ---
    next_trial_text_3 = visual.TextStim(win=win, name='next_trial_text_3',
        text='',
        font='Open Sans',
        pos=(0, -0.2), height=0.05, wrapWidth=None, ori=0.0, 
        color='black', colorSpace='rgb', opacity=None, 
        languageStyle='LTR',
        depth=-1.0);
    text_150 = visual.TextStim(win=win, name='text_150',
        text='Percent correct:',
        font='Open Sans',
        pos=(0, 0.05), height=0.06, wrapWidth=None, ori=0.0, 
        color='black', colorSpace='rgb', opacity=None, 
        languageStyle='LTR',
        depth=-2.0);
    
    # --- Initialize components for Routine "end" ---
    text_20 = visual.TextStim(win=win, name='text_20',
        text='Thanks for your participation! you will have your Prolific credit and bonuses updated in the next couple of weeks.',
        font='Open Sans',
        pos=(0, 0), height=0.04, wrapWidth=None, ori=0.0, 
        color='black', colorSpace='rgb', opacity=None, 
        languageStyle='LTR',
        depth=0.0);
    
    # create some handy timers
    if globalClock is None:
        globalClock = core.Clock()  # to track the time since experiment started
    if ioServer is not None:
        ioServer.syncClock(globalClock)
    logging.setDefaultClock(globalClock)
    routineTimer = core.Clock()  # to track time remaining of each (possibly non-slip) routine
    win.flip()  # flip window to reset last flip timer
    # store the exact time the global clock started
    expInfo['expStart'] = data.getDateStr(format='%Y-%m-%d %Hh%M.%S.%f %z', fractionalSecondDigits=6)
    
    # --- Prepare to start Routine "consent" ---
    continueRoutine = True
    # update component parameters for each repeat
    thisExp.addData('consent.started', globalClock.getTime())
    image_11.setImage('consent1.png')
    consent1_next.keys = []
    consent1_next.rt = []
    _consent1_next_allKeys = []
    # keep track of which components have finished
    consentComponents = [image_11, consent1_next, text_89]
    for thisComponent in consentComponents:
        thisComponent.tStart = None
        thisComponent.tStop = None
        thisComponent.tStartRefresh = None
        thisComponent.tStopRefresh = None
        if hasattr(thisComponent, 'status'):
            thisComponent.status = NOT_STARTED
    # reset timers
    t = 0
    _timeToFirstFrame = win.getFutureFlipTime(clock="now")
    frameN = -1
    
    # --- Run Routine "consent" ---
    routineForceEnded = not continueRoutine
    while continueRoutine:
        # get current time
        t = routineTimer.getTime()
        tThisFlip = win.getFutureFlipTime(clock=routineTimer)
        tThisFlipGlobal = win.getFutureFlipTime(clock=None)
        frameN = frameN + 1  # number of completed frames (so 0 is the first frame)
        # update/draw components on each frame
        
        # *image_11* updates
        
        # if image_11 is starting this frame...
        if image_11.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
            # keep track of start time/frame for later
            image_11.frameNStart = frameN  # exact frame index
            image_11.tStart = t  # local t and not account for scr refresh
            image_11.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(image_11, 'tStartRefresh')  # time at next scr refresh
            # add timestamp to datafile
            thisExp.timestampOnFlip(win, 'image_11.started')
            # update status
            image_11.status = STARTED
            image_11.setAutoDraw(True)
        
        # if image_11 is active this frame...
        if image_11.status == STARTED:
            # update params
            pass
        
        # *consent1_next* updates
        waitOnFlip = False
        
        # if consent1_next is starting this frame...
        if consent1_next.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
            # keep track of start time/frame for later
            consent1_next.frameNStart = frameN  # exact frame index
            consent1_next.tStart = t  # local t and not account for scr refresh
            consent1_next.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(consent1_next, 'tStartRefresh')  # time at next scr refresh
            # add timestamp to datafile
            thisExp.timestampOnFlip(win, 'consent1_next.started')
            # update status
            consent1_next.status = STARTED
            # keyboard checking is just starting
            waitOnFlip = True
            win.callOnFlip(consent1_next.clock.reset)  # t=0 on next screen flip
            win.callOnFlip(consent1_next.clearEvents, eventType='keyboard')  # clear events on next screen flip
        if consent1_next.status == STARTED and not waitOnFlip:
            theseKeys = consent1_next.getKeys(keyList=['space'], ignoreKeys=["escape"], waitRelease=False)
            _consent1_next_allKeys.extend(theseKeys)
            if len(_consent1_next_allKeys):
                consent1_next.keys = _consent1_next_allKeys[-1].name  # just the last key pressed
                consent1_next.rt = _consent1_next_allKeys[-1].rt
                consent1_next.duration = _consent1_next_allKeys[-1].duration
                # a response ends the routine
                continueRoutine = False
        
        # *text_89* updates
        
        # if text_89 is starting this frame...
        if text_89.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
            # keep track of start time/frame for later
            text_89.frameNStart = frameN  # exact frame index
            text_89.tStart = t  # local t and not account for scr refresh
            text_89.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(text_89, 'tStartRefresh')  # time at next scr refresh
            # add timestamp to datafile
            thisExp.timestampOnFlip(win, 'text_89.started')
            # update status
            text_89.status = STARTED
            text_89.setAutoDraw(True)
        
        # if text_89 is active this frame...
        if text_89.status == STARTED:
            # update params
            pass
        
        # check for quit (typically the Esc key)
        if defaultKeyboard.getKeys(keyList=["escape"]):
            thisExp.status = FINISHED
        if thisExp.status == FINISHED or endExpNow:
            endExperiment(thisExp, inputs=inputs, win=win)
            return
        
        # check if all components have finished
        if not continueRoutine:  # a component has requested a forced-end of Routine
            routineForceEnded = True
            break
        continueRoutine = False  # will revert to True if at least one component still running
        for thisComponent in consentComponents:
            if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:
                continueRoutine = True
                break  # at least one component has not yet finished
        
        # refresh the screen
        if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen
            win.flip()
    
    # --- Ending Routine "consent" ---
    for thisComponent in consentComponents:
        if hasattr(thisComponent, "setAutoDraw"):
            thisComponent.setAutoDraw(False)
    thisExp.addData('consent.stopped', globalClock.getTime())
    # check responses
    if consent1_next.keys in ['', [], None]:  # No response was made
        consent1_next.keys = None
    thisExp.addData('consent1_next.keys',consent1_next.keys)
    if consent1_next.keys != None:  # we had a response
        thisExp.addData('consent1_next.rt', consent1_next.rt)
        thisExp.addData('consent1_next.duration', consent1_next.duration)
    thisExp.nextEntry()
    # the Routine "consent" was not non-slip safe, so reset the non-slip timer
    routineTimer.reset()
    
    # --- Prepare to start Routine "consent2" ---
    continueRoutine = True
    # update component parameters for each repeat
    thisExp.addData('consent2.started', globalClock.getTime())
    image_13.setImage('consent2.png')
    consent1_next_2.keys = []
    consent1_next_2.rt = []
    _consent1_next_2_allKeys = []
    # keep track of which components have finished
    consent2Components = [image_13, consent1_next_2, text_90]
    for thisComponent in consent2Components:
        thisComponent.tStart = None
        thisComponent.tStop = None
        thisComponent.tStartRefresh = None
        thisComponent.tStopRefresh = None
        if hasattr(thisComponent, 'status'):
            thisComponent.status = NOT_STARTED
    # reset timers
    t = 0
    _timeToFirstFrame = win.getFutureFlipTime(clock="now")
    frameN = -1
    
    # --- Run Routine "consent2" ---
    routineForceEnded = not continueRoutine
    while continueRoutine:
        # get current time
        t = routineTimer.getTime()
        tThisFlip = win.getFutureFlipTime(clock=routineTimer)
        tThisFlipGlobal = win.getFutureFlipTime(clock=None)
        frameN = frameN + 1  # number of completed frames (so 0 is the first frame)
        # update/draw components on each frame
        
        # *image_13* updates
        
        # if image_13 is starting this frame...
        if image_13.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
            # keep track of start time/frame for later
            image_13.frameNStart = frameN  # exact frame index
            image_13.tStart = t  # local t and not account for scr refresh
            image_13.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(image_13, 'tStartRefresh')  # time at next scr refresh
            # add timestamp to datafile
            thisExp.timestampOnFlip(win, 'image_13.started')
            # update status
            image_13.status = STARTED
            image_13.setAutoDraw(True)
        
        # if image_13 is active this frame...
        if image_13.status == STARTED:
            # update params
            pass
        
        # *consent1_next_2* updates
        waitOnFlip = False
        
        # if consent1_next_2 is starting this frame...
        if consent1_next_2.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
            # keep track of start time/frame for later
            consent1_next_2.frameNStart = frameN  # exact frame index
            consent1_next_2.tStart = t  # local t and not account for scr refresh
            consent1_next_2.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(consent1_next_2, 'tStartRefresh')  # time at next scr refresh
            # add timestamp to datafile
            thisExp.timestampOnFlip(win, 'consent1_next_2.started')
            # update status
            consent1_next_2.status = STARTED
            # keyboard checking is just starting
            waitOnFlip = True
            win.callOnFlip(consent1_next_2.clock.reset)  # t=0 on next screen flip
            win.callOnFlip(consent1_next_2.clearEvents, eventType='keyboard')  # clear events on next screen flip
        if consent1_next_2.status == STARTED and not waitOnFlip:
            theseKeys = consent1_next_2.getKeys(keyList=['y','n'], ignoreKeys=["escape"], waitRelease=False)
            _consent1_next_2_allKeys.extend(theseKeys)
            if len(_consent1_next_2_allKeys):
                consent1_next_2.keys = _consent1_next_2_allKeys[-1].name  # just the last key pressed
                consent1_next_2.rt = _consent1_next_2_allKeys[-1].rt
                consent1_next_2.duration = _consent1_next_2_allKeys[-1].duration
                # a response ends the routine
                continueRoutine = False
        
        # *text_90* updates
        
        # if text_90 is starting this frame...
        if text_90.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
            # keep track of start time/frame for later
            text_90.frameNStart = frameN  # exact frame index
            text_90.tStart = t  # local t and not account for scr refresh
            text_90.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(text_90, 'tStartRefresh')  # time at next scr refresh
            # add timestamp to datafile
            thisExp.timestampOnFlip(win, 'text_90.started')
            # update status
            text_90.status = STARTED
            text_90.setAutoDraw(True)
        
        # if text_90 is active this frame...
        if text_90.status == STARTED:
            # update params
            pass
        
        # check for quit (typically the Esc key)
        if defaultKeyboard.getKeys(keyList=["escape"]):
            thisExp.status = FINISHED
        if thisExp.status == FINISHED or endExpNow:
            endExperiment(thisExp, inputs=inputs, win=win)
            return
        
        # check if all components have finished
        if not continueRoutine:  # a component has requested a forced-end of Routine
            routineForceEnded = True
            break
        continueRoutine = False  # will revert to True if at least one component still running
        for thisComponent in consent2Components:
            if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:
                continueRoutine = True
                break  # at least one component has not yet finished
        
        # refresh the screen
        if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen
            win.flip()
    
    # --- Ending Routine "consent2" ---
    for thisComponent in consent2Components:
        if hasattr(thisComponent, "setAutoDraw"):
            thisComponent.setAutoDraw(False)
    thisExp.addData('consent2.stopped', globalClock.getTime())
    # check responses
    if consent1_next_2.keys in ['', [], None]:  # No response was made
        consent1_next_2.keys = None
    thisExp.addData('consent1_next_2.keys',consent1_next_2.keys)
    if consent1_next_2.keys != None:  # we had a response
        thisExp.addData('consent1_next_2.rt', consent1_next_2.rt)
        thisExp.addData('consent1_next_2.duration', consent1_next_2.duration)
    thisExp.nextEntry()
    # Run 'End Routine' code from code_19
    if consent1_next_2.keys=='n':
        psychoJS.quit()
    # the Routine "consent2" was not non-slip safe, so reset the non-slip timer
    routineTimer.reset()
    
    # --- Prepare to start Routine "questionnaire_start" ---
    continueRoutine = True
    # update component parameters for each repeat
    thisExp.addData('questionnaire_start.started', globalClock.getTime())
    # keep track of which components have finished
    questionnaire_startComponents = [text_33]
    for thisComponent in questionnaire_startComponents:
        thisComponent.tStart = None
        thisComponent.tStop = None
        thisComponent.tStartRefresh = None
        thisComponent.tStopRefresh = None
        if hasattr(thisComponent, 'status'):
            thisComponent.status = NOT_STARTED
    # reset timers
    t = 0
    _timeToFirstFrame = win.getFutureFlipTime(clock="now")
    frameN = -1
    
    # --- Run Routine "questionnaire_start" ---
    routineForceEnded = not continueRoutine
    while continueRoutine and routineTimer.getTime() < 5.0:
        # get current time
        t = routineTimer.getTime()
        tThisFlip = win.getFutureFlipTime(clock=routineTimer)
        tThisFlipGlobal = win.getFutureFlipTime(clock=None)
        frameN = frameN + 1  # number of completed frames (so 0 is the first frame)
        # update/draw components on each frame
        
        # *text_33* updates
        
        # if text_33 is starting this frame...
        if text_33.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
            # keep track of start time/frame for later
            text_33.frameNStart = frameN  # exact frame index
            text_33.tStart = t  # local t and not account for scr refresh
            text_33.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(text_33, 'tStartRefresh')  # time at next scr refresh
            # add timestamp to datafile
            thisExp.timestampOnFlip(win, 'text_33.started')
            # update status
            text_33.status = STARTED
            text_33.setAutoDraw(True)
        
        # if text_33 is active this frame...
        if text_33.status == STARTED:
            # update params
            pass
        
        # if text_33 is stopping this frame...
        if text_33.status == STARTED:
            # is it time to stop? (based on global clock, using actual start)
            if tThisFlipGlobal > text_33.tStartRefresh + 5.0-frameTolerance:
                # keep track of stop time/frame for later
                text_33.tStop = t  # not accounting for scr refresh
                text_33.frameNStop = frameN  # exact frame index
                # add timestamp to datafile
                thisExp.timestampOnFlip(win, 'text_33.stopped')
                # update status
                text_33.status = FINISHED
                text_33.setAutoDraw(False)
        
        # check for quit (typically the Esc key)
        if defaultKeyboard.getKeys(keyList=["escape"]):
            thisExp.status = FINISHED
        if thisExp.status == FINISHED or endExpNow:
            endExperiment(thisExp, inputs=inputs, win=win)
            return
        
        # check if all components have finished
        if not continueRoutine:  # a component has requested a forced-end of Routine
            routineForceEnded = True
            break
        continueRoutine = False  # will revert to True if at least one component still running
        for thisComponent in questionnaire_startComponents:
            if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:
                continueRoutine = True
                break  # at least one component has not yet finished
        
        # refresh the screen
        if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen
            win.flip()
    
    # --- Ending Routine "questionnaire_start" ---
    for thisComponent in questionnaire_startComponents:
        if hasattr(thisComponent, "setAutoDraw"):
            thisComponent.setAutoDraw(False)
    thisExp.addData('questionnaire_start.stopped', globalClock.getTime())
    # using non-slip timing so subtract the expected duration of this Routine (unless ended on request)
    if routineForceEnded:
        routineTimer.reset()
    else:
        routineTimer.addTime(-5.000000)
    
    # --- Prepare to start Routine "PSWQ1" ---
    continueRoutine = True
    # update component parameters for each repeat
    thisExp.addData('PSWQ1.started', globalClock.getTime())
    key_resp_3.keys = []
    key_resp_3.rt = []
    _key_resp_3_allKeys = []
    # keep track of which components have finished
    PSWQ1Components = [text_36, text_56, text_57, key_resp_3]
    for thisComponent in PSWQ1Components:
        thisComponent.tStart = None
        thisComponent.tStop = None
        thisComponent.tStartRefresh = None
        thisComponent.tStopRefresh = None
        if hasattr(thisComponent, 'status'):
            thisComponent.status = NOT_STARTED
    # reset timers
    t = 0
    _timeToFirstFrame = win.getFutureFlipTime(clock="now")
    frameN = -1
    
    # --- Run Routine "PSWQ1" ---
    routineForceEnded = not continueRoutine
    while continueRoutine:
        # get current time
        t = routineTimer.getTime()
        tThisFlip = win.getFutureFlipTime(clock=routineTimer)
        tThisFlipGlobal = win.getFutureFlipTime(clock=None)
        frameN = frameN + 1  # number of completed frames (so 0 is the first frame)
        # update/draw components on each frame
        
        # *text_36* updates
        
        # if text_36 is starting this frame...
        if text_36.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
            # keep track of start time/frame for later
            text_36.frameNStart = frameN  # exact frame index
            text_36.tStart = t  # local t and not account for scr refresh
            text_36.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(text_36, 'tStartRefresh')  # time at next scr refresh
            # add timestamp to datafile
            thisExp.timestampOnFlip(win, 'text_36.started')
            # update status
            text_36.status = STARTED
            text_36.setAutoDraw(True)
        
        # if text_36 is active this frame...
        if text_36.status == STARTED:
            # update params
            pass
        
        # *text_56* updates
        
        # if text_56 is starting this frame...
        if text_56.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
            # keep track of start time/frame for later
            text_56.frameNStart = frameN  # exact frame index
            text_56.tStart = t  # local t and not account for scr refresh
            text_56.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(text_56, 'tStartRefresh')  # time at next scr refresh
            # add timestamp to datafile
            thisExp.timestampOnFlip(win, 'text_56.started')
            # update status
            text_56.status = STARTED
            text_56.setAutoDraw(True)
        
        # if text_56 is active this frame...
        if text_56.status == STARTED:
            # update params
            pass
        
        # *text_57* updates
        
        # if text_57 is starting this frame...
        if text_57.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
            # keep track of start time/frame for later
            text_57.frameNStart = frameN  # exact frame index
            text_57.tStart = t  # local t and not account for scr refresh
            text_57.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(text_57, 'tStartRefresh')  # time at next scr refresh
            # add timestamp to datafile
            thisExp.timestampOnFlip(win, 'text_57.started')
            # update status
            text_57.status = STARTED
            text_57.setAutoDraw(True)
        
        # if text_57 is active this frame...
        if text_57.status == STARTED:
            # update params
            pass
        
        # *key_resp_3* updates
        waitOnFlip = False
        
        # if key_resp_3 is starting this frame...
        if key_resp_3.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
            # keep track of start time/frame for later
            key_resp_3.frameNStart = frameN  # exact frame index
            key_resp_3.tStart = t  # local t and not account for scr refresh
            key_resp_3.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(key_resp_3, 'tStartRefresh')  # time at next scr refresh
            # add timestamp to datafile
            thisExp.timestampOnFlip(win, 'key_resp_3.started')
            # update status
            key_resp_3.status = STARTED
            # keyboard checking is just starting
            waitOnFlip = True
            win.callOnFlip(key_resp_3.clock.reset)  # t=0 on next screen flip
            win.callOnFlip(key_resp_3.clearEvents, eventType='keyboard')  # clear events on next screen flip
        if key_resp_3.status == STARTED and not waitOnFlip:
            theseKeys = key_resp_3.getKeys(keyList=[1,2,3,4,5,'1','2','3','4','5'], ignoreKeys=["escape"], waitRelease=False)
            _key_resp_3_allKeys.extend(theseKeys)
            if len(_key_resp_3_allKeys):
                key_resp_3.keys = _key_resp_3_allKeys[-1].name  # just the last key pressed
                key_resp_3.rt = _key_resp_3_allKeys[-1].rt
                key_resp_3.duration = _key_resp_3_allKeys[-1].duration
                # a response ends the routine
                continueRoutine = False
        
        # check for quit (typically the Esc key)
        if defaultKeyboard.getKeys(keyList=["escape"]):
            thisExp.status = FINISHED
        if thisExp.status == FINISHED or endExpNow:
            endExperiment(thisExp, inputs=inputs, win=win)
            return
        
        # check if all components have finished
        if not continueRoutine:  # a component has requested a forced-end of Routine
            routineForceEnded = True
            break
        continueRoutine = False  # will revert to True if at least one component still running
        for thisComponent in PSWQ1Components:
            if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:
                continueRoutine = True
                break  # at least one component has not yet finished
        
        # refresh the screen
        if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen
            win.flip()
    
    # --- Ending Routine "PSWQ1" ---
    for thisComponent in PSWQ1Components:
        if hasattr(thisComponent, "setAutoDraw"):
            thisComponent.setAutoDraw(False)
    thisExp.addData('PSWQ1.stopped', globalClock.getTime())
    # check responses
    if key_resp_3.keys in ['', [], None]:  # No response was made
        key_resp_3.keys = None
    thisExp.addData('key_resp_3.keys',key_resp_3.keys)
    if key_resp_3.keys != None:  # we had a response
        thisExp.addData('key_resp_3.rt', key_resp_3.rt)
        thisExp.addData('key_resp_3.duration', key_resp_3.duration)
    thisExp.nextEntry()
    # the Routine "PSWQ1" was not non-slip safe, so reset the non-slip timer
    routineTimer.reset()
    
    # --- Prepare to start Routine "PSWQ2" ---
    continueRoutine = True
    # update component parameters for each repeat
    thisExp.addData('PSWQ2.started', globalClock.getTime())
    key_resp_13.keys = []
    key_resp_13.rt = []
    _key_resp_13_allKeys = []
    # keep track of which components have finished
    PSWQ2Components = [text_58, text_59, text_60, key_resp_13]
    for thisComponent in PSWQ2Components:
        thisComponent.tStart = None
        thisComponent.tStop = None
        thisComponent.tStartRefresh = None
        thisComponent.tStopRefresh = None
        if hasattr(thisComponent, 'status'):
            thisComponent.status = NOT_STARTED
    # reset timers
    t = 0
    _timeToFirstFrame = win.getFutureFlipTime(clock="now")
    frameN = -1
    
    # --- Run Routine "PSWQ2" ---
    routineForceEnded = not continueRoutine
    while continueRoutine:
        # get current time
        t = routineTimer.getTime()
        tThisFlip = win.getFutureFlipTime(clock=routineTimer)
        tThisFlipGlobal = win.getFutureFlipTime(clock=None)
        frameN = frameN + 1  # number of completed frames (so 0 is the first frame)
        # update/draw components on each frame
        
        # *text_58* updates
        
        # if text_58 is starting this frame...
        if text_58.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
            # keep track of start time/frame for later
            text_58.frameNStart = frameN  # exact frame index
            text_58.tStart = t  # local t and not account for scr refresh
            text_58.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(text_58, 'tStartRefresh')  # time at next scr refresh
            # add timestamp to datafile
            thisExp.timestampOnFlip(win, 'text_58.started')
            # update status
            text_58.status = STARTED
            text_58.setAutoDraw(True)
        
        # if text_58 is active this frame...
        if text_58.status == STARTED:
            # update params
            pass
        
        # *text_59* updates
        
        # if text_59 is starting this frame...
        if text_59.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
            # keep track of start time/frame for later
            text_59.frameNStart = frameN  # exact frame index
            text_59.tStart = t  # local t and not account for scr refresh
            text_59.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(text_59, 'tStartRefresh')  # time at next scr refresh
            # add timestamp to datafile
            thisExp.timestampOnFlip(win, 'text_59.started')
            # update status
            text_59.status = STARTED
            text_59.setAutoDraw(True)
        
        # if text_59 is active this frame...
        if text_59.status == STARTED:
            # update params
            pass
        
        # *text_60* updates
        
        # if text_60 is starting this frame...
        if text_60.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
            # keep track of start time/frame for later
            text_60.frameNStart = frameN  # exact frame index
            text_60.tStart = t  # local t and not account for scr refresh
            text_60.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(text_60, 'tStartRefresh')  # time at next scr refresh
            # add timestamp to datafile
            thisExp.timestampOnFlip(win, 'text_60.started')
            # update status
            text_60.status = STARTED
            text_60.setAutoDraw(True)
        
        # if text_60 is active this frame...
        if text_60.status == STARTED:
            # update params
            pass
        
        # *key_resp_13* updates
        waitOnFlip = False
        
        # if key_resp_13 is starting this frame...
        if key_resp_13.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
            # keep track of start time/frame for later
            key_resp_13.frameNStart = frameN  # exact frame index
            key_resp_13.tStart = t  # local t and not account for scr refresh
            key_resp_13.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(key_resp_13, 'tStartRefresh')  # time at next scr refresh
            # add timestamp to datafile
            thisExp.timestampOnFlip(win, 'key_resp_13.started')
            # update status
            key_resp_13.status = STARTED
            # keyboard checking is just starting
            waitOnFlip = True
            win.callOnFlip(key_resp_13.clock.reset)  # t=0 on next screen flip
            win.callOnFlip(key_resp_13.clearEvents, eventType='keyboard')  # clear events on next screen flip
        if key_resp_13.status == STARTED and not waitOnFlip:
            theseKeys = key_resp_13.getKeys(keyList=[1,2,3,4,5,'1','2','3','4','5'], ignoreKeys=["escape"], waitRelease=False)
            _key_resp_13_allKeys.extend(theseKeys)
            if len(_key_resp_13_allKeys):
                key_resp_13.keys = _key_resp_13_allKeys[-1].name  # just the last key pressed
                key_resp_13.rt = _key_resp_13_allKeys[-1].rt
                key_resp_13.duration = _key_resp_13_allKeys[-1].duration
                # a response ends the routine
                continueRoutine = False
        
        # check for quit (typically the Esc key)
        if defaultKeyboard.getKeys(keyList=["escape"]):
            thisExp.status = FINISHED
        if thisExp.status == FINISHED or endExpNow:
            endExperiment(thisExp, inputs=inputs, win=win)
            return
        
        # check if all components have finished
        if not continueRoutine:  # a component has requested a forced-end of Routine
            routineForceEnded = True
            break
        continueRoutine = False  # will revert to True if at least one component still running
        for thisComponent in PSWQ2Components:
            if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:
                continueRoutine = True
                break  # at least one component has not yet finished
        
        # refresh the screen
        if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen
            win.flip()
    
    # --- Ending Routine "PSWQ2" ---
    for thisComponent in PSWQ2Components:
        if hasattr(thisComponent, "setAutoDraw"):
            thisComponent.setAutoDraw(False)
    thisExp.addData('PSWQ2.stopped', globalClock.getTime())
    # check responses
    if key_resp_13.keys in ['', [], None]:  # No response was made
        key_resp_13.keys = None
    thisExp.addData('key_resp_13.keys',key_resp_13.keys)
    if key_resp_13.keys != None:  # we had a response
        thisExp.addData('key_resp_13.rt', key_resp_13.rt)
        thisExp.addData('key_resp_13.duration', key_resp_13.duration)
    thisExp.nextEntry()
    # the Routine "PSWQ2" was not non-slip safe, so reset the non-slip timer
    routineTimer.reset()
    
    # --- Prepare to start Routine "PSWQ3" ---
    continueRoutine = True
    # update component parameters for each repeat
    thisExp.addData('PSWQ3.started', globalClock.getTime())
    key_resp_14.keys = []
    key_resp_14.rt = []
    _key_resp_14_allKeys = []
    # keep track of which components have finished
    PSWQ3Components = [text_61, text_62, text_63, key_resp_14]
    for thisComponent in PSWQ3Components:
        thisComponent.tStart = None
        thisComponent.tStop = None
        thisComponent.tStartRefresh = None
        thisComponent.tStopRefresh = None
        if hasattr(thisComponent, 'status'):
            thisComponent.status = NOT_STARTED
    # reset timers
    t = 0
    _timeToFirstFrame = win.getFutureFlipTime(clock="now")
    frameN = -1
    
    # --- Run Routine "PSWQ3" ---
    routineForceEnded = not continueRoutine
    while continueRoutine:
        # get current time
        t = routineTimer.getTime()
        tThisFlip = win.getFutureFlipTime(clock=routineTimer)
        tThisFlipGlobal = win.getFutureFlipTime(clock=None)
        frameN = frameN + 1  # number of completed frames (so 0 is the first frame)
        # update/draw components on each frame
        
        # *text_61* updates
        
        # if text_61 is starting this frame...
        if text_61.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
            # keep track of start time/frame for later
            text_61.frameNStart = frameN  # exact frame index
            text_61.tStart = t  # local t and not account for scr refresh
            text_61.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(text_61, 'tStartRefresh')  # time at next scr refresh
            # add timestamp to datafile
            thisExp.timestampOnFlip(win, 'text_61.started')
            # update status
            text_61.status = STARTED
            text_61.setAutoDraw(True)
        
        # if text_61 is active this frame...
        if text_61.status == STARTED:
            # update params
            pass
        
        # *text_62* updates
        
        # if text_62 is starting this frame...
        if text_62.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
            # keep track of start time/frame for later
            text_62.frameNStart = frameN  # exact frame index
            text_62.tStart = t  # local t and not account for scr refresh
            text_62.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(text_62, 'tStartRefresh')  # time at next scr refresh
            # add timestamp to datafile
            thisExp.timestampOnFlip(win, 'text_62.started')
            # update status
            text_62.status = STARTED
            text_62.setAutoDraw(True)
        
        # if text_62 is active this frame...
        if text_62.status == STARTED:
            # update params
            pass
        
        # *text_63* updates
        
        # if text_63 is starting this frame...
        if text_63.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
            # keep track of start time/frame for later
            text_63.frameNStart = frameN  # exact frame index
            text_63.tStart = t  # local t and not account for scr refresh
            text_63.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(text_63, 'tStartRefresh')  # time at next scr refresh
            # add timestamp to datafile
            thisExp.timestampOnFlip(win, 'text_63.started')
            # update status
            text_63.status = STARTED
            text_63.setAutoDraw(True)
        
        # if text_63 is active this frame...
        if text_63.status == STARTED:
            # update params
            pass
        
        # *key_resp_14* updates
        waitOnFlip = False
        
        # if key_resp_14 is starting this frame...
        if key_resp_14.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
            # keep track of start time/frame for later
            key_resp_14.frameNStart = frameN  # exact frame index
            key_resp_14.tStart = t  # local t and not account for scr refresh
            key_resp_14.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(key_resp_14, 'tStartRefresh')  # time at next scr refresh
            # add timestamp to datafile
            thisExp.timestampOnFlip(win, 'key_resp_14.started')
            # update status
            key_resp_14.status = STARTED
            # keyboard checking is just starting
            waitOnFlip = True
            win.callOnFlip(key_resp_14.clock.reset)  # t=0 on next screen flip
            win.callOnFlip(key_resp_14.clearEvents, eventType='keyboard')  # clear events on next screen flip
        if key_resp_14.status == STARTED and not waitOnFlip:
            theseKeys = key_resp_14.getKeys(keyList=[1,2,3,4,5,'1','2','3','4','5'], ignoreKeys=["escape"], waitRelease=False)
            _key_resp_14_allKeys.extend(theseKeys)
            if len(_key_resp_14_allKeys):
                key_resp_14.keys = _key_resp_14_allKeys[-1].name  # just the last key pressed
                key_resp_14.rt = _key_resp_14_allKeys[-1].rt
                key_resp_14.duration = _key_resp_14_allKeys[-1].duration
                # a response ends the routine
                continueRoutine = False
        
        # check for quit (typically the Esc key)
        if defaultKeyboard.getKeys(keyList=["escape"]):
            thisExp.status = FINISHED
        if thisExp.status == FINISHED or endExpNow:
            endExperiment(thisExp, inputs=inputs, win=win)
            return
        
        # check if all components have finished
        if not continueRoutine:  # a component has requested a forced-end of Routine
            routineForceEnded = True
            break
        continueRoutine = False  # will revert to True if at least one component still running
        for thisComponent in PSWQ3Components:
            if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:
                continueRoutine = True
                break  # at least one component has not yet finished
        
        # refresh the screen
        if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen
            win.flip()
    
    # --- Ending Routine "PSWQ3" ---
    for thisComponent in PSWQ3Components:
        if hasattr(thisComponent, "setAutoDraw"):
            thisComponent.setAutoDraw(False)
    thisExp.addData('PSWQ3.stopped', globalClock.getTime())
    # check responses
    if key_resp_14.keys in ['', [], None]:  # No response was made
        key_resp_14.keys = None
    thisExp.addData('key_resp_14.keys',key_resp_14.keys)
    if key_resp_14.keys != None:  # we had a response
        thisExp.addData('key_resp_14.rt', key_resp_14.rt)
        thisExp.addData('key_resp_14.duration', key_resp_14.duration)
    thisExp.nextEntry()
    # the Routine "PSWQ3" was not non-slip safe, so reset the non-slip timer
    routineTimer.reset()
    
    # --- Prepare to start Routine "PSWQ4" ---
    continueRoutine = True
    # update component parameters for each repeat
    thisExp.addData('PSWQ4.started', globalClock.getTime())
    key_resp_15.keys = []
    key_resp_15.rt = []
    _key_resp_15_allKeys = []
    # keep track of which components have finished
    PSWQ4Components = [text_64, text_65, text_66, key_resp_15]
    for thisComponent in PSWQ4Components:
        thisComponent.tStart = None
        thisComponent.tStop = None
        thisComponent.tStartRefresh = None
        thisComponent.tStopRefresh = None
        if hasattr(thisComponent, 'status'):
            thisComponent.status = NOT_STARTED
    # reset timers
    t = 0
    _timeToFirstFrame = win.getFutureFlipTime(clock="now")
    frameN = -1
    
    # --- Run Routine "PSWQ4" ---
    routineForceEnded = not continueRoutine
    while continueRoutine:
        # get current time
        t = routineTimer.getTime()
        tThisFlip = win.getFutureFlipTime(clock=routineTimer)
        tThisFlipGlobal = win.getFutureFlipTime(clock=None)
        frameN = frameN + 1  # number of completed frames (so 0 is the first frame)
        # update/draw components on each frame
        
        # *text_64* updates
        
        # if text_64 is starting this frame...
        if text_64.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
            # keep track of start time/frame for later
            text_64.frameNStart = frameN  # exact frame index
            text_64.tStart = t  # local t and not account for scr refresh
            text_64.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(text_64, 'tStartRefresh')  # time at next scr refresh
            # add timestamp to datafile
            thisExp.timestampOnFlip(win, 'text_64.started')
            # update status
            text_64.status = STARTED
            text_64.setAutoDraw(True)
        
        # if text_64 is active this frame...
        if text_64.status == STARTED:
            # update params
            pass
        
        # *text_65* updates
        
        # if text_65 is starting this frame...
        if text_65.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
            # keep track of start time/frame for later
            text_65.frameNStart = frameN  # exact frame index
            text_65.tStart = t  # local t and not account for scr refresh
            text_65.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(text_65, 'tStartRefresh')  # time at next scr refresh
            # add timestamp to datafile
            thisExp.timestampOnFlip(win, 'text_65.started')
            # update status
            text_65.status = STARTED
            text_65.setAutoDraw(True)
        
        # if text_65 is active this frame...
        if text_65.status == STARTED:
            # update params
            pass
        
        # *text_66* updates
        
        # if text_66 is starting this frame...
        if text_66.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
            # keep track of start time/frame for later
            text_66.frameNStart = frameN  # exact frame index
            text_66.tStart = t  # local t and not account for scr refresh
            text_66.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(text_66, 'tStartRefresh')  # time at next scr refresh
            # add timestamp to datafile
            thisExp.timestampOnFlip(win, 'text_66.started')
            # update status
            text_66.status = STARTED
            text_66.setAutoDraw(True)
        
        # if text_66 is active this frame...
        if text_66.status == STARTED:
            # update params
            pass
        
        # *key_resp_15* updates
        waitOnFlip = False
        
        # if key_resp_15 is starting this frame...
        if key_resp_15.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
            # keep track of start time/frame for later
            key_resp_15.frameNStart = frameN  # exact frame index
            key_resp_15.tStart = t  # local t and not account for scr refresh
            key_resp_15.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(key_resp_15, 'tStartRefresh')  # time at next scr refresh
            # add timestamp to datafile
            thisExp.timestampOnFlip(win, 'key_resp_15.started')
            # update status
            key_resp_15.status = STARTED
            # keyboard checking is just starting
            waitOnFlip = True
            win.callOnFlip(key_resp_15.clock.reset)  # t=0 on next screen flip
            win.callOnFlip(key_resp_15.clearEvents, eventType='keyboard')  # clear events on next screen flip
        if key_resp_15.status == STARTED and not waitOnFlip:
            theseKeys = key_resp_15.getKeys(keyList=[1,2,3,4,5,'1','2','3','4','5'], ignoreKeys=["escape"], waitRelease=False)
            _key_resp_15_allKeys.extend(theseKeys)
            if len(_key_resp_15_allKeys):
                key_resp_15.keys = _key_resp_15_allKeys[-1].name  # just the last key pressed
                key_resp_15.rt = _key_resp_15_allKeys[-1].rt
                key_resp_15.duration = _key_resp_15_allKeys[-1].duration
                # a response ends the routine
                continueRoutine = False
        
        # check for quit (typically the Esc key)
        if defaultKeyboard.getKeys(keyList=["escape"]):
            thisExp.status = FINISHED
        if thisExp.status == FINISHED or endExpNow:
            endExperiment(thisExp, inputs=inputs, win=win)
            return
        
        # check if all components have finished
        if not continueRoutine:  # a component has requested a forced-end of Routine
            routineForceEnded = True
            break
        continueRoutine = False  # will revert to True if at least one component still running
        for thisComponent in PSWQ4Components:
            if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:
                continueRoutine = True
                break  # at least one component has not yet finished
        
        # refresh the screen
        if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen
            win.flip()
    
    # --- Ending Routine "PSWQ4" ---
    for thisComponent in PSWQ4Components:
        if hasattr(thisComponent, "setAutoDraw"):
            thisComponent.setAutoDraw(False)
    thisExp.addData('PSWQ4.stopped', globalClock.getTime())
    # check responses
    if key_resp_15.keys in ['', [], None]:  # No response was made
        key_resp_15.keys = None
    thisExp.addData('key_resp_15.keys',key_resp_15.keys)
    if key_resp_15.keys != None:  # we had a response
        thisExp.addData('key_resp_15.rt', key_resp_15.rt)
        thisExp.addData('key_resp_15.duration', key_resp_15.duration)
    thisExp.nextEntry()
    # the Routine "PSWQ4" was not non-slip safe, so reset the non-slip timer
    routineTimer.reset()
    
    # --- Prepare to start Routine "PSWQ5" ---
    continueRoutine = True
    # update component parameters for each repeat
    thisExp.addData('PSWQ5.started', globalClock.getTime())
    key_resp_16.keys = []
    key_resp_16.rt = []
    _key_resp_16_allKeys = []
    # keep track of which components have finished
    PSWQ5Components = [text_67, text_68, text_69, key_resp_16]
    for thisComponent in PSWQ5Components:
        thisComponent.tStart = None
        thisComponent.tStop = None
        thisComponent.tStartRefresh = None
        thisComponent.tStopRefresh = None
        if hasattr(thisComponent, 'status'):
            thisComponent.status = NOT_STARTED
    # reset timers
    t = 0
    _timeToFirstFrame = win.getFutureFlipTime(clock="now")
    frameN = -1
    
    # --- Run Routine "PSWQ5" ---
    routineForceEnded = not continueRoutine
    while continueRoutine:
        # get current time
        t = routineTimer.getTime()
        tThisFlip = win.getFutureFlipTime(clock=routineTimer)
        tThisFlipGlobal = win.getFutureFlipTime(clock=None)
        frameN = frameN + 1  # number of completed frames (so 0 is the first frame)
        # update/draw components on each frame
        
        # *text_67* updates
        
        # if text_67 is starting this frame...
        if text_67.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
            # keep track of start time/frame for later
            text_67.frameNStart = frameN  # exact frame index
            text_67.tStart = t  # local t and not account for scr refresh
            text_67.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(text_67, 'tStartRefresh')  # time at next scr refresh
            # add timestamp to datafile
            thisExp.timestampOnFlip(win, 'text_67.started')
            # update status
            text_67.status = STARTED
            text_67.setAutoDraw(True)
        
        # if text_67 is active this frame...
        if text_67.status == STARTED:
            # update params
            pass
        
        # *text_68* updates
        
        # if text_68 is starting this frame...
        if text_68.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
            # keep track of start time/frame for later
            text_68.frameNStart = frameN  # exact frame index
            text_68.tStart = t  # local t and not account for scr refresh
            text_68.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(text_68, 'tStartRefresh')  # time at next scr refresh
            # add timestamp to datafile
            thisExp.timestampOnFlip(win, 'text_68.started')
            # update status
            text_68.status = STARTED
            text_68.setAutoDraw(True)
        
        # if text_68 is active this frame...
        if text_68.status == STARTED:
            # update params
            pass
        
        # *text_69* updates
        
        # if text_69 is starting this frame...
        if text_69.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
            # keep track of start time/frame for later
            text_69.frameNStart = frameN  # exact frame index
            text_69.tStart = t  # local t and not account for scr refresh
            text_69.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(text_69, 'tStartRefresh')  # time at next scr refresh
            # add timestamp to datafile
            thisExp.timestampOnFlip(win, 'text_69.started')
            # update status
            text_69.status = STARTED
            text_69.setAutoDraw(True)
        
        # if text_69 is active this frame...
        if text_69.status == STARTED:
            # update params
            pass
        
        # *key_resp_16* updates
        waitOnFlip = False
        
        # if key_resp_16 is starting this frame...
        if key_resp_16.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
            # keep track of start time/frame for later
            key_resp_16.frameNStart = frameN  # exact frame index
            key_resp_16.tStart = t  # local t and not account for scr refresh
            key_resp_16.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(key_resp_16, 'tStartRefresh')  # time at next scr refresh
            # add timestamp to datafile
            thisExp.timestampOnFlip(win, 'key_resp_16.started')
            # update status
            key_resp_16.status = STARTED
            # keyboard checking is just starting
            waitOnFlip = True
            win.callOnFlip(key_resp_16.clock.reset)  # t=0 on next screen flip
            win.callOnFlip(key_resp_16.clearEvents, eventType='keyboard')  # clear events on next screen flip
        if key_resp_16.status == STARTED and not waitOnFlip:
            theseKeys = key_resp_16.getKeys(keyList=[1,2,3,4,5,'1','2','3','4','5'], ignoreKeys=["escape"], waitRelease=False)
            _key_resp_16_allKeys.extend(theseKeys)
            if len(_key_resp_16_allKeys):
                key_resp_16.keys = _key_resp_16_allKeys[-1].name  # just the last key pressed
                key_resp_16.rt = _key_resp_16_allKeys[-1].rt
                key_resp_16.duration = _key_resp_16_allKeys[-1].duration
                # a response ends the routine
                continueRoutine = False
        
        # check for quit (typically the Esc key)
        if defaultKeyboard.getKeys(keyList=["escape"]):
            thisExp.status = FINISHED
        if thisExp.status == FINISHED or endExpNow:
            endExperiment(thisExp, inputs=inputs, win=win)
            return
        
        # check if all components have finished
        if not continueRoutine:  # a component has requested a forced-end of Routine
            routineForceEnded = True
            break
        continueRoutine = False  # will revert to True if at least one component still running
        for thisComponent in PSWQ5Components:
            if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:
                continueRoutine = True
                break  # at least one component has not yet finished
        
        # refresh the screen
        if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen
            win.flip()
    
    # --- Ending Routine "PSWQ5" ---
    for thisComponent in PSWQ5Components:
        if hasattr(thisComponent, "setAutoDraw"):
            thisComponent.setAutoDraw(False)
    thisExp.addData('PSWQ5.stopped', globalClock.getTime())
    # check responses
    if key_resp_16.keys in ['', [], None]:  # No response was made
        key_resp_16.keys = None
    thisExp.addData('key_resp_16.keys',key_resp_16.keys)
    if key_resp_16.keys != None:  # we had a response
        thisExp.addData('key_resp_16.rt', key_resp_16.rt)
        thisExp.addData('key_resp_16.duration', key_resp_16.duration)
    thisExp.nextEntry()
    # the Routine "PSWQ5" was not non-slip safe, so reset the non-slip timer
    routineTimer.reset()
    
    # --- Prepare to start Routine "PSWQ6" ---
    continueRoutine = True
    # update component parameters for each repeat
    thisExp.addData('PSWQ6.started', globalClock.getTime())
    key_resp_25.keys = []
    key_resp_25.rt = []
    _key_resp_25_allKeys = []
    # keep track of which components have finished
    PSWQ6Components = [text_76, text_77, text_78, key_resp_25]
    for thisComponent in PSWQ6Components:
        thisComponent.tStart = None
        thisComponent.tStop = None
        thisComponent.tStartRefresh = None
        thisComponent.tStopRefresh = None
        if hasattr(thisComponent, 'status'):
            thisComponent.status = NOT_STARTED
    # reset timers
    t = 0
    _timeToFirstFrame = win.getFutureFlipTime(clock="now")
    frameN = -1
    
    # --- Run Routine "PSWQ6" ---
    routineForceEnded = not continueRoutine
    while continueRoutine:
        # get current time
        t = routineTimer.getTime()
        tThisFlip = win.getFutureFlipTime(clock=routineTimer)
        tThisFlipGlobal = win.getFutureFlipTime(clock=None)
        frameN = frameN + 1  # number of completed frames (so 0 is the first frame)
        # update/draw components on each frame
        
        # *text_76* updates
        
        # if text_76 is starting this frame...
        if text_76.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
            # keep track of start time/frame for later
            text_76.frameNStart = frameN  # exact frame index
            text_76.tStart = t  # local t and not account for scr refresh
            text_76.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(text_76, 'tStartRefresh')  # time at next scr refresh
            # add timestamp to datafile
            thisExp.timestampOnFlip(win, 'text_76.started')
            # update status
            text_76.status = STARTED
            text_76.setAutoDraw(True)
        
        # if text_76 is active this frame...
        if text_76.status == STARTED:
            # update params
            pass
        
        # *text_77* updates
        
        # if text_77 is starting this frame...
        if text_77.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
            # keep track of start time/frame for later
            text_77.frameNStart = frameN  # exact frame index
            text_77.tStart = t  # local t and not account for scr refresh
            text_77.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(text_77, 'tStartRefresh')  # time at next scr refresh
            # add timestamp to datafile
            thisExp.timestampOnFlip(win, 'text_77.started')
            # update status
            text_77.status = STARTED
            text_77.setAutoDraw(True)
        
        # if text_77 is active this frame...
        if text_77.status == STARTED:
            # update params
            pass
        
        # *text_78* updates
        
        # if text_78 is starting this frame...
        if text_78.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
            # keep track of start time/frame for later
            text_78.frameNStart = frameN  # exact frame index
            text_78.tStart = t  # local t and not account for scr refresh
            text_78.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(text_78, 'tStartRefresh')  # time at next scr refresh
            # add timestamp to datafile
            thisExp.timestampOnFlip(win, 'text_78.started')
            # update status
            text_78.status = STARTED
            text_78.setAutoDraw(True)
        
        # if text_78 is active this frame...
        if text_78.status == STARTED:
            # update params
            pass
        
        # *key_resp_25* updates
        waitOnFlip = False
        
        # if key_resp_25 is starting this frame...
        if key_resp_25.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
            # keep track of start time/frame for later
            key_resp_25.frameNStart = frameN  # exact frame index
            key_resp_25.tStart = t  # local t and not account for scr refresh
            key_resp_25.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(key_resp_25, 'tStartRefresh')  # time at next scr refresh
            # add timestamp to datafile
            thisExp.timestampOnFlip(win, 'key_resp_25.started')
            # update status
            key_resp_25.status = STARTED
            # keyboard checking is just starting
            waitOnFlip = True
            win.callOnFlip(key_resp_25.clock.reset)  # t=0 on next screen flip
            win.callOnFlip(key_resp_25.clearEvents, eventType='keyboard')  # clear events on next screen flip
        if key_resp_25.status == STARTED and not waitOnFlip:
            theseKeys = key_resp_25.getKeys(keyList=[1,2,3,4,5,'1','2','3','4','5'], ignoreKeys=["escape"], waitRelease=False)
            _key_resp_25_allKeys.extend(theseKeys)
            if len(_key_resp_25_allKeys):
                key_resp_25.keys = _key_resp_25_allKeys[-1].name  # just the last key pressed
                key_resp_25.rt = _key_resp_25_allKeys[-1].rt
                key_resp_25.duration = _key_resp_25_allKeys[-1].duration
                # a response ends the routine
                continueRoutine = False
        
        # check for quit (typically the Esc key)
        if defaultKeyboard.getKeys(keyList=["escape"]):
            thisExp.status = FINISHED
        if thisExp.status == FINISHED or endExpNow:
            endExperiment(thisExp, inputs=inputs, win=win)
            return
        
        # check if all components have finished
        if not continueRoutine:  # a component has requested a forced-end of Routine
            routineForceEnded = True
            break
        continueRoutine = False  # will revert to True if at least one component still running
        for thisComponent in PSWQ6Components:
            if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:
                continueRoutine = True
                break  # at least one component has not yet finished
        
        # refresh the screen
        if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen
            win.flip()
    
    # --- Ending Routine "PSWQ6" ---
    for thisComponent in PSWQ6Components:
        if hasattr(thisComponent, "setAutoDraw"):
            thisComponent.setAutoDraw(False)
    thisExp.addData('PSWQ6.stopped', globalClock.getTime())
    # check responses
    if key_resp_25.keys in ['', [], None]:  # No response was made
        key_resp_25.keys = None
    thisExp.addData('key_resp_25.keys',key_resp_25.keys)
    if key_resp_25.keys != None:  # we had a response
        thisExp.addData('key_resp_25.rt', key_resp_25.rt)
        thisExp.addData('key_resp_25.duration', key_resp_25.duration)
    thisExp.nextEntry()
    # the Routine "PSWQ6" was not non-slip safe, so reset the non-slip timer
    routineTimer.reset()
    
    # --- Prepare to start Routine "PSWQ7" ---
    continueRoutine = True
    # update component parameters for each repeat
    thisExp.addData('PSWQ7.started', globalClock.getTime())
    key_resp_26.keys = []
    key_resp_26.rt = []
    _key_resp_26_allKeys = []
    # keep track of which components have finished
    PSWQ7Components = [text_79, text_80, text_81, key_resp_26]
    for thisComponent in PSWQ7Components:
        thisComponent.tStart = None
        thisComponent.tStop = None
        thisComponent.tStartRefresh = None
        thisComponent.tStopRefresh = None
        if hasattr(thisComponent, 'status'):
            thisComponent.status = NOT_STARTED
    # reset timers
    t = 0
    _timeToFirstFrame = win.getFutureFlipTime(clock="now")
    frameN = -1
    
    # --- Run Routine "PSWQ7" ---
    routineForceEnded = not continueRoutine
    while continueRoutine:
        # get current time
        t = routineTimer.getTime()
        tThisFlip = win.getFutureFlipTime(clock=routineTimer)
        tThisFlipGlobal = win.getFutureFlipTime(clock=None)
        frameN = frameN + 1  # number of completed frames (so 0 is the first frame)
        # update/draw components on each frame
        
        # *text_79* updates
        
        # if text_79 is starting this frame...
        if text_79.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
            # keep track of start time/frame for later
            text_79.frameNStart = frameN  # exact frame index
            text_79.tStart = t  # local t and not account for scr refresh
            text_79.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(text_79, 'tStartRefresh')  # time at next scr refresh
            # add timestamp to datafile
            thisExp.timestampOnFlip(win, 'text_79.started')
            # update status
            text_79.status = STARTED
            text_79.setAutoDraw(True)
        
        # if text_79 is active this frame...
        if text_79.status == STARTED:
            # update params
            pass
        
        # *text_80* updates
        
        # if text_80 is starting this frame...
        if text_80.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
            # keep track of start time/frame for later
            text_80.frameNStart = frameN  # exact frame index
            text_80.tStart = t  # local t and not account for scr refresh
            text_80.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(text_80, 'tStartRefresh')  # time at next scr refresh
            # add timestamp to datafile
            thisExp.timestampOnFlip(win, 'text_80.started')
            # update status
            text_80.status = STARTED
            text_80.setAutoDraw(True)
        
        # if text_80 is active this frame...
        if text_80.status == STARTED:
            # update params
            pass
        
        # *text_81* updates
        
        # if text_81 is starting this frame...
        if text_81.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
            # keep track of start time/frame for later
            text_81.frameNStart = frameN  # exact frame index
            text_81.tStart = t  # local t and not account for scr refresh
            text_81.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(text_81, 'tStartRefresh')  # time at next scr refresh
            # add timestamp to datafile
            thisExp.timestampOnFlip(win, 'text_81.started')
            # update status
            text_81.status = STARTED
            text_81.setAutoDraw(True)
        
        # if text_81 is active this frame...
        if text_81.status == STARTED:
            # update params
            pass
        
        # *key_resp_26* updates
        waitOnFlip = False
        
        # if key_resp_26 is starting this frame...
        if key_resp_26.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
            # keep track of start time/frame for later
            key_resp_26.frameNStart = frameN  # exact frame index
            key_resp_26.tStart = t  # local t and not account for scr refresh
            key_resp_26.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(key_resp_26, 'tStartRefresh')  # time at next scr refresh
            # add timestamp to datafile
            thisExp.timestampOnFlip(win, 'key_resp_26.started')
            # update status
            key_resp_26.status = STARTED
            # keyboard checking is just starting
            waitOnFlip = True
            win.callOnFlip(key_resp_26.clock.reset)  # t=0 on next screen flip
            win.callOnFlip(key_resp_26.clearEvents, eventType='keyboard')  # clear events on next screen flip
        if key_resp_26.status == STARTED and not waitOnFlip:
            theseKeys = key_resp_26.getKeys(keyList=[1,2,3,4,5,'1','2','3','4','5'], ignoreKeys=["escape"], waitRelease=False)
            _key_resp_26_allKeys.extend(theseKeys)
            if len(_key_resp_26_allKeys):
                key_resp_26.keys = _key_resp_26_allKeys[-1].name  # just the last key pressed
                key_resp_26.rt = _key_resp_26_allKeys[-1].rt
                key_resp_26.duration = _key_resp_26_allKeys[-1].duration
                # a response ends the routine
                continueRoutine = False
        
        # check for quit (typically the Esc key)
        if defaultKeyboard.getKeys(keyList=["escape"]):
            thisExp.status = FINISHED
        if thisExp.status == FINISHED or endExpNow:
            endExperiment(thisExp, inputs=inputs, win=win)
            return
        
        # check if all components have finished
        if not continueRoutine:  # a component has requested a forced-end of Routine
            routineForceEnded = True
            break
        continueRoutine = False  # will revert to True if at least one component still running
        for thisComponent in PSWQ7Components:
            if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:
                continueRoutine = True
                break  # at least one component has not yet finished
        
        # refresh the screen
        if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen
            win.flip()
    
    # --- Ending Routine "PSWQ7" ---
    for thisComponent in PSWQ7Components:
        if hasattr(thisComponent, "setAutoDraw"):
            thisComponent.setAutoDraw(False)
    thisExp.addData('PSWQ7.stopped', globalClock.getTime())
    # check responses
    if key_resp_26.keys in ['', [], None]:  # No response was made
        key_resp_26.keys = None
    thisExp.addData('key_resp_26.keys',key_resp_26.keys)
    if key_resp_26.keys != None:  # we had a response
        thisExp.addData('key_resp_26.rt', key_resp_26.rt)
        thisExp.addData('key_resp_26.duration', key_resp_26.duration)
    thisExp.nextEntry()
    # the Routine "PSWQ7" was not non-slip safe, so reset the non-slip timer
    routineTimer.reset()
    
    # --- Prepare to start Routine "PSWQ8" ---
    continueRoutine = True
    # update component parameters for each repeat
    thisExp.addData('PSWQ8.started', globalClock.getTime())
    key_resp_27.keys = []
    key_resp_27.rt = []
    _key_resp_27_allKeys = []
    # keep track of which components have finished
    PSWQ8Components = [text_82, text_83, text_84, key_resp_27]
    for thisComponent in PSWQ8Components:
        thisComponent.tStart = None
        thisComponent.tStop = None
        thisComponent.tStartRefresh = None
        thisComponent.tStopRefresh = None
        if hasattr(thisComponent, 'status'):
            thisComponent.status = NOT_STARTED
    # reset timers
    t = 0
    _timeToFirstFrame = win.getFutureFlipTime(clock="now")
    frameN = -1
    
    # --- Run Routine "PSWQ8" ---
    routineForceEnded = not continueRoutine
    while continueRoutine:
        # get current time
        t = routineTimer.getTime()
        tThisFlip = win.getFutureFlipTime(clock=routineTimer)
        tThisFlipGlobal = win.getFutureFlipTime(clock=None)
        frameN = frameN + 1  # number of completed frames (so 0 is the first frame)
        # update/draw components on each frame
        
        # *text_82* updates
        
        # if text_82 is starting this frame...
        if text_82.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
            # keep track of start time/frame for later
            text_82.frameNStart = frameN  # exact frame index
            text_82.tStart = t  # local t and not account for scr refresh
            text_82.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(text_82, 'tStartRefresh')  # time at next scr refresh
            # add timestamp to datafile
            thisExp.timestampOnFlip(win, 'text_82.started')
            # update status
            text_82.status = STARTED
            text_82.setAutoDraw(True)
        
        # if text_82 is active this frame...
        if text_82.status == STARTED:
            # update params
            pass
        
        # *text_83* updates
        
        # if text_83 is starting this frame...
        if text_83.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
            # keep track of start time/frame for later
            text_83.frameNStart = frameN  # exact frame index
            text_83.tStart = t  # local t and not account for scr refresh
            text_83.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(text_83, 'tStartRefresh')  # time at next scr refresh
            # add timestamp to datafile
            thisExp.timestampOnFlip(win, 'text_83.started')
            # update status
            text_83.status = STARTED
            text_83.setAutoDraw(True)
        
        # if text_83 is active this frame...
        if text_83.status == STARTED:
            # update params
            pass
        
        # *text_84* updates
        
        # if text_84 is starting this frame...
        if text_84.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
            # keep track of start time/frame for later
            text_84.frameNStart = frameN  # exact frame index
            text_84.tStart = t  # local t and not account for scr refresh
            text_84.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(text_84, 'tStartRefresh')  # time at next scr refresh
            # add timestamp to datafile
            thisExp.timestampOnFlip(win, 'text_84.started')
            # update status
            text_84.status = STARTED
            text_84.setAutoDraw(True)
        
        # if text_84 is active this frame...
        if text_84.status == STARTED:
            # update params
            pass
        
        # *key_resp_27* updates
        waitOnFlip = False
        
        # if key_resp_27 is starting this frame...
        if key_resp_27.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
            # keep track of start time/frame for later
            key_resp_27.frameNStart = frameN  # exact frame index
            key_resp_27.tStart = t  # local t and not account for scr refresh
            key_resp_27.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(key_resp_27, 'tStartRefresh')  # time at next scr refresh
            # add timestamp to datafile
            thisExp.timestampOnFlip(win, 'key_resp_27.started')
            # update status
            key_resp_27.status = STARTED
            # keyboard checking is just starting
            waitOnFlip = True
            win.callOnFlip(key_resp_27.clock.reset)  # t=0 on next screen flip
            win.callOnFlip(key_resp_27.clearEvents, eventType='keyboard')  # clear events on next screen flip
        if key_resp_27.status == STARTED and not waitOnFlip:
            theseKeys = key_resp_27.getKeys(keyList=[1,2,3,4,5,'1','2','3','4','5'], ignoreKeys=["escape"], waitRelease=False)
            _key_resp_27_allKeys.extend(theseKeys)
            if len(_key_resp_27_allKeys):
                key_resp_27.keys = _key_resp_27_allKeys[-1].name  # just the last key pressed
                key_resp_27.rt = _key_resp_27_allKeys[-1].rt
                key_resp_27.duration = _key_resp_27_allKeys[-1].duration
                # a response ends the routine
                continueRoutine = False
        
        # check for quit (typically the Esc key)
        if defaultKeyboard.getKeys(keyList=["escape"]):
            thisExp.status = FINISHED
        if thisExp.status == FINISHED or endExpNow:
            endExperiment(thisExp, inputs=inputs, win=win)
            return
        
        # check if all components have finished
        if not continueRoutine:  # a component has requested a forced-end of Routine
            routineForceEnded = True
            break
        continueRoutine = False  # will revert to True if at least one component still running
        for thisComponent in PSWQ8Components:
            if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:
                continueRoutine = True
                break  # at least one component has not yet finished
        
        # refresh the screen
        if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen
            win.flip()
    
    # --- Ending Routine "PSWQ8" ---
    for thisComponent in PSWQ8Components:
        if hasattr(thisComponent, "setAutoDraw"):
            thisComponent.setAutoDraw(False)
    thisExp.addData('PSWQ8.stopped', globalClock.getTime())
    # check responses
    if key_resp_27.keys in ['', [], None]:  # No response was made
        key_resp_27.keys = None
    thisExp.addData('key_resp_27.keys',key_resp_27.keys)
    if key_resp_27.keys != None:  # we had a response
        thisExp.addData('key_resp_27.rt', key_resp_27.rt)
        thisExp.addData('key_resp_27.duration', key_resp_27.duration)
    thisExp.nextEntry()
    # the Routine "PSWQ8" was not non-slip safe, so reset the non-slip timer
    routineTimer.reset()
    
    # --- Prepare to start Routine "PSWQ9" ---
    continueRoutine = True
    # update component parameters for each repeat
    thisExp.addData('PSWQ9.started', globalClock.getTime())
    key_resp_28.keys = []
    key_resp_28.rt = []
    _key_resp_28_allKeys = []
    # keep track of which components have finished
    PSWQ9Components = [text_85, text_86, text_87, key_resp_28]
    for thisComponent in PSWQ9Components:
        thisComponent.tStart = None
        thisComponent.tStop = None
        thisComponent.tStartRefresh = None
        thisComponent.tStopRefresh = None
        if hasattr(thisComponent, 'status'):
            thisComponent.status = NOT_STARTED
    # reset timers
    t = 0
    _timeToFirstFrame = win.getFutureFlipTime(clock="now")
    frameN = -1
    
    # --- Run Routine "PSWQ9" ---
    routineForceEnded = not continueRoutine
    while continueRoutine:
        # get current time
        t = routineTimer.getTime()
        tThisFlip = win.getFutureFlipTime(clock=routineTimer)
        tThisFlipGlobal = win.getFutureFlipTime(clock=None)
        frameN = frameN + 1  # number of completed frames (so 0 is the first frame)
        # update/draw components on each frame
        
        # *text_85* updates
        
        # if text_85 is starting this frame...
        if text_85.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
            # keep track of start time/frame for later
            text_85.frameNStart = frameN  # exact frame index
            text_85.tStart = t  # local t and not account for scr refresh
            text_85.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(text_85, 'tStartRefresh')  # time at next scr refresh
            # add timestamp to datafile
            thisExp.timestampOnFlip(win, 'text_85.started')
            # update status
            text_85.status = STARTED
            text_85.setAutoDraw(True)
        
        # if text_85 is active this frame...
        if text_85.status == STARTED:
            # update params
            pass
        
        # *text_86* updates
        
        # if text_86 is starting this frame...
        if text_86.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
            # keep track of start time/frame for later
            text_86.frameNStart = frameN  # exact frame index
            text_86.tStart = t  # local t and not account for scr refresh
            text_86.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(text_86, 'tStartRefresh')  # time at next scr refresh
            # add timestamp to datafile
            thisExp.timestampOnFlip(win, 'text_86.started')
            # update status
            text_86.status = STARTED
            text_86.setAutoDraw(True)
        
        # if text_86 is active this frame...
        if text_86.status == STARTED:
            # update params
            pass
        
        # *text_87* updates
        
        # if text_87 is starting this frame...
        if text_87.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
            # keep track of start time/frame for later
            text_87.frameNStart = frameN  # exact frame index
            text_87.tStart = t  # local t and not account for scr refresh
            text_87.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(text_87, 'tStartRefresh')  # time at next scr refresh
            # add timestamp to datafile
            thisExp.timestampOnFlip(win, 'text_87.started')
            # update status
            text_87.status = STARTED
            text_87.setAutoDraw(True)
        
        # if text_87 is active this frame...
        if text_87.status == STARTED:
            # update params
            pass
        
        # *key_resp_28* updates
        waitOnFlip = False
        
        # if key_resp_28 is starting this frame...
        if key_resp_28.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
            # keep track of start time/frame for later
            key_resp_28.frameNStart = frameN  # exact frame index
            key_resp_28.tStart = t  # local t and not account for scr refresh
            key_resp_28.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(key_resp_28, 'tStartRefresh')  # time at next scr refresh
            # add timestamp to datafile
            thisExp.timestampOnFlip(win, 'key_resp_28.started')
            # update status
            key_resp_28.status = STARTED
            # keyboard checking is just starting
            waitOnFlip = True
            win.callOnFlip(key_resp_28.clock.reset)  # t=0 on next screen flip
            win.callOnFlip(key_resp_28.clearEvents, eventType='keyboard')  # clear events on next screen flip
        if key_resp_28.status == STARTED and not waitOnFlip:
            theseKeys = key_resp_28.getKeys(keyList=[1,2,3,4,5,'1','2','3','4','5'], ignoreKeys=["escape"], waitRelease=False)
            _key_resp_28_allKeys.extend(theseKeys)
            if len(_key_resp_28_allKeys):
                key_resp_28.keys = _key_resp_28_allKeys[-1].name  # just the last key pressed
                key_resp_28.rt = _key_resp_28_allKeys[-1].rt
                key_resp_28.duration = _key_resp_28_allKeys[-1].duration
                # a response ends the routine
                continueRoutine = False
        
        # check for quit (typically the Esc key)
        if defaultKeyboard.getKeys(keyList=["escape"]):
            thisExp.status = FINISHED
        if thisExp.status == FINISHED or endExpNow:
            endExperiment(thisExp, inputs=inputs, win=win)
            return
        
        # check if all components have finished
        if not continueRoutine:  # a component has requested a forced-end of Routine
            routineForceEnded = True
            break
        continueRoutine = False  # will revert to True if at least one component still running
        for thisComponent in PSWQ9Components:
            if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:
                continueRoutine = True
                break  # at least one component has not yet finished
        
        # refresh the screen
        if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen
            win.flip()
    
    # --- Ending Routine "PSWQ9" ---
    for thisComponent in PSWQ9Components:
        if hasattr(thisComponent, "setAutoDraw"):
            thisComponent.setAutoDraw(False)
    thisExp.addData('PSWQ9.stopped', globalClock.getTime())
    # check responses
    if key_resp_28.keys in ['', [], None]:  # No response was made
        key_resp_28.keys = None
    thisExp.addData('key_resp_28.keys',key_resp_28.keys)
    if key_resp_28.keys != None:  # we had a response
        thisExp.addData('key_resp_28.rt', key_resp_28.rt)
        thisExp.addData('key_resp_28.duration', key_resp_28.duration)
    thisExp.nextEntry()
    # the Routine "PSWQ9" was not non-slip safe, so reset the non-slip timer
    routineTimer.reset()
    
    # --- Prepare to start Routine "PSWQ10" ---
    continueRoutine = True
    # update component parameters for each repeat
    thisExp.addData('PSWQ10.started', globalClock.getTime())
    key_resp_29.keys = []
    key_resp_29.rt = []
    _key_resp_29_allKeys = []
    # keep track of which components have finished
    PSWQ10Components = [text_88, text_91, text_92, key_resp_29]
    for thisComponent in PSWQ10Components:
        thisComponent.tStart = None
        thisComponent.tStop = None
        thisComponent.tStartRefresh = None
        thisComponent.tStopRefresh = None
        if hasattr(thisComponent, 'status'):
            thisComponent.status = NOT_STARTED
    # reset timers
    t = 0
    _timeToFirstFrame = win.getFutureFlipTime(clock="now")
    frameN = -1
    
    # --- Run Routine "PSWQ10" ---
    routineForceEnded = not continueRoutine
    while continueRoutine:
        # get current time
        t = routineTimer.getTime()
        tThisFlip = win.getFutureFlipTime(clock=routineTimer)
        tThisFlipGlobal = win.getFutureFlipTime(clock=None)
        frameN = frameN + 1  # number of completed frames (so 0 is the first frame)
        # update/draw components on each frame
        
        # *text_88* updates
        
        # if text_88 is starting this frame...
        if text_88.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
            # keep track of start time/frame for later
            text_88.frameNStart = frameN  # exact frame index
            text_88.tStart = t  # local t and not account for scr refresh
            text_88.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(text_88, 'tStartRefresh')  # time at next scr refresh
            # add timestamp to datafile
            thisExp.timestampOnFlip(win, 'text_88.started')
            # update status
            text_88.status = STARTED
            text_88.setAutoDraw(True)
        
        # if text_88 is active this frame...
        if text_88.status == STARTED:
            # update params
            pass
        
        # *text_91* updates
        
        # if text_91 is starting this frame...
        if text_91.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
            # keep track of start time/frame for later
            text_91.frameNStart = frameN  # exact frame index
            text_91.tStart = t  # local t and not account for scr refresh
            text_91.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(text_91, 'tStartRefresh')  # time at next scr refresh
            # add timestamp to datafile
            thisExp.timestampOnFlip(win, 'text_91.started')
            # update status
            text_91.status = STARTED
            text_91.setAutoDraw(True)
        
        # if text_91 is active this frame...
        if text_91.status == STARTED:
            # update params
            pass
        
        # *text_92* updates
        
        # if text_92 is starting this frame...
        if text_92.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
            # keep track of start time/frame for later
            text_92.frameNStart = frameN  # exact frame index
            text_92.tStart = t  # local t and not account for scr refresh
            text_92.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(text_92, 'tStartRefresh')  # time at next scr refresh
            # add timestamp to datafile
            thisExp.timestampOnFlip(win, 'text_92.started')
            # update status
            text_92.status = STARTED
            text_92.setAutoDraw(True)
        
        # if text_92 is active this frame...
        if text_92.status == STARTED:
            # update params
            pass
        
        # *key_resp_29* updates
        waitOnFlip = False
        
        # if key_resp_29 is starting this frame...
        if key_resp_29.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
            # keep track of start time/frame for later
            key_resp_29.frameNStart = frameN  # exact frame index
            key_resp_29.tStart = t  # local t and not account for scr refresh
            key_resp_29.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(key_resp_29, 'tStartRefresh')  # time at next scr refresh
            # add timestamp to datafile
            thisExp.timestampOnFlip(win, 'key_resp_29.started')
            # update status
            key_resp_29.status = STARTED
            # keyboard checking is just starting
            waitOnFlip = True
            win.callOnFlip(key_resp_29.clock.reset)  # t=0 on next screen flip
            win.callOnFlip(key_resp_29.clearEvents, eventType='keyboard')  # clear events on next screen flip
        if key_resp_29.status == STARTED and not waitOnFlip:
            theseKeys = key_resp_29.getKeys(keyList=[1,2,3,4,5,'1','2','3','4','5'], ignoreKeys=["escape"], waitRelease=False)
            _key_resp_29_allKeys.extend(theseKeys)
            if len(_key_resp_29_allKeys):
                key_resp_29.keys = _key_resp_29_allKeys[-1].name  # just the last key pressed
                key_resp_29.rt = _key_resp_29_allKeys[-1].rt
                key_resp_29.duration = _key_resp_29_allKeys[-1].duration
                # a response ends the routine
                continueRoutine = False
        
        # check for quit (typically the Esc key)
        if defaultKeyboard.getKeys(keyList=["escape"]):
            thisExp.status = FINISHED
        if thisExp.status == FINISHED or endExpNow:
            endExperiment(thisExp, inputs=inputs, win=win)
            return
        
        # check if all components have finished
        if not continueRoutine:  # a component has requested a forced-end of Routine
            routineForceEnded = True
            break
        continueRoutine = False  # will revert to True if at least one component still running
        for thisComponent in PSWQ10Components:
            if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:
                continueRoutine = True
                break  # at least one component has not yet finished
        
        # refresh the screen
        if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen
            win.flip()
    
    # --- Ending Routine "PSWQ10" ---
    for thisComponent in PSWQ10Components:
        if hasattr(thisComponent, "setAutoDraw"):
            thisComponent.setAutoDraw(False)
    thisExp.addData('PSWQ10.stopped', globalClock.getTime())
    # check responses
    if key_resp_29.keys in ['', [], None]:  # No response was made
        key_resp_29.keys = None
    thisExp.addData('key_resp_29.keys',key_resp_29.keys)
    if key_resp_29.keys != None:  # we had a response
        thisExp.addData('key_resp_29.rt', key_resp_29.rt)
        thisExp.addData('key_resp_29.duration', key_resp_29.duration)
    thisExp.nextEntry()
    # the Routine "PSWQ10" was not non-slip safe, so reset the non-slip timer
    routineTimer.reset()
    
    # --- Prepare to start Routine "PSWQ11" ---
    continueRoutine = True
    # update component parameters for each repeat
    thisExp.addData('PSWQ11.started', globalClock.getTime())
    key_resp_30.keys = []
    key_resp_30.rt = []
    _key_resp_30_allKeys = []
    # keep track of which components have finished
    PSWQ11Components = [text_93, text_94, text_95, key_resp_30]
    for thisComponent in PSWQ11Components:
        thisComponent.tStart = None
        thisComponent.tStop = None
        thisComponent.tStartRefresh = None
        thisComponent.tStopRefresh = None
        if hasattr(thisComponent, 'status'):
            thisComponent.status = NOT_STARTED
    # reset timers
    t = 0
    _timeToFirstFrame = win.getFutureFlipTime(clock="now")
    frameN = -1
    
    # --- Run Routine "PSWQ11" ---
    routineForceEnded = not continueRoutine
    while continueRoutine:
        # get current time
        t = routineTimer.getTime()
        tThisFlip = win.getFutureFlipTime(clock=routineTimer)
        tThisFlipGlobal = win.getFutureFlipTime(clock=None)
        frameN = frameN + 1  # number of completed frames (so 0 is the first frame)
        # update/draw components on each frame
        
        # *text_93* updates
        
        # if text_93 is starting this frame...
        if text_93.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
            # keep track of start time/frame for later
            text_93.frameNStart = frameN  # exact frame index
            text_93.tStart = t  # local t and not account for scr refresh
            text_93.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(text_93, 'tStartRefresh')  # time at next scr refresh
            # add timestamp to datafile
            thisExp.timestampOnFlip(win, 'text_93.started')
            # update status
            text_93.status = STARTED
            text_93.setAutoDraw(True)
        
        # if text_93 is active this frame...
        if text_93.status == STARTED:
            # update params
            pass
        
        # *text_94* updates
        
        # if text_94 is starting this frame...
        if text_94.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
            # keep track of start time/frame for later
            text_94.frameNStart = frameN  # exact frame index
            text_94.tStart = t  # local t and not account for scr refresh
            text_94.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(text_94, 'tStartRefresh')  # time at next scr refresh
            # add timestamp to datafile
            thisExp.timestampOnFlip(win, 'text_94.started')
            # update status
            text_94.status = STARTED
            text_94.setAutoDraw(True)
        
        # if text_94 is active this frame...
        if text_94.status == STARTED:
            # update params
            pass
        
        # *text_95* updates
        
        # if text_95 is starting this frame...
        if text_95.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
            # keep track of start time/frame for later
            text_95.frameNStart = frameN  # exact frame index
            text_95.tStart = t  # local t and not account for scr refresh
            text_95.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(text_95, 'tStartRefresh')  # time at next scr refresh
            # add timestamp to datafile
            thisExp.timestampOnFlip(win, 'text_95.started')
            # update status
            text_95.status = STARTED
            text_95.setAutoDraw(True)
        
        # if text_95 is active this frame...
        if text_95.status == STARTED:
            # update params
            pass
        
        # *key_resp_30* updates
        waitOnFlip = False
        
        # if key_resp_30 is starting this frame...
        if key_resp_30.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
            # keep track of start time/frame for later
            key_resp_30.frameNStart = frameN  # exact frame index
            key_resp_30.tStart = t  # local t and not account for scr refresh
            key_resp_30.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(key_resp_30, 'tStartRefresh')  # time at next scr refresh
            # add timestamp to datafile
            thisExp.timestampOnFlip(win, 'key_resp_30.started')
            # update status
            key_resp_30.status = STARTED
            # keyboard checking is just starting
            waitOnFlip = True
            win.callOnFlip(key_resp_30.clock.reset)  # t=0 on next screen flip
            win.callOnFlip(key_resp_30.clearEvents, eventType='keyboard')  # clear events on next screen flip
        if key_resp_30.status == STARTED and not waitOnFlip:
            theseKeys = key_resp_30.getKeys(keyList=[1,2,3,4,5,'1','2','3','4','5'], ignoreKeys=["escape"], waitRelease=False)
            _key_resp_30_allKeys.extend(theseKeys)
            if len(_key_resp_30_allKeys):
                key_resp_30.keys = _key_resp_30_allKeys[-1].name  # just the last key pressed
                key_resp_30.rt = _key_resp_30_allKeys[-1].rt
                key_resp_30.duration = _key_resp_30_allKeys[-1].duration
                # a response ends the routine
                continueRoutine = False
        
        # check for quit (typically the Esc key)
        if defaultKeyboard.getKeys(keyList=["escape"]):
            thisExp.status = FINISHED
        if thisExp.status == FINISHED or endExpNow:
            endExperiment(thisExp, inputs=inputs, win=win)
            return
        
        # check if all components have finished
        if not continueRoutine:  # a component has requested a forced-end of Routine
            routineForceEnded = True
            break
        continueRoutine = False  # will revert to True if at least one component still running
        for thisComponent in PSWQ11Components:
            if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:
                continueRoutine = True
                break  # at least one component has not yet finished
        
        # refresh the screen
        if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen
            win.flip()
    
    # --- Ending Routine "PSWQ11" ---
    for thisComponent in PSWQ11Components:
        if hasattr(thisComponent, "setAutoDraw"):
            thisComponent.setAutoDraw(False)
    thisExp.addData('PSWQ11.stopped', globalClock.getTime())
    # check responses
    if key_resp_30.keys in ['', [], None]:  # No response was made
        key_resp_30.keys = None
    thisExp.addData('key_resp_30.keys',key_resp_30.keys)
    if key_resp_30.keys != None:  # we had a response
        thisExp.addData('key_resp_30.rt', key_resp_30.rt)
        thisExp.addData('key_resp_30.duration', key_resp_30.duration)
    thisExp.nextEntry()
    # the Routine "PSWQ11" was not non-slip safe, so reset the non-slip timer
    routineTimer.reset()
    
    # --- Prepare to start Routine "PSWQ12" ---
    continueRoutine = True
    # update component parameters for each repeat
    thisExp.addData('PSWQ12.started', globalClock.getTime())
    key_resp_31.keys = []
    key_resp_31.rt = []
    _key_resp_31_allKeys = []
    # keep track of which components have finished
    PSWQ12Components = [text_96, text_97, text_98, key_resp_31]
    for thisComponent in PSWQ12Components:
        thisComponent.tStart = None
        thisComponent.tStop = None
        thisComponent.tStartRefresh = None
        thisComponent.tStopRefresh = None
        if hasattr(thisComponent, 'status'):
            thisComponent.status = NOT_STARTED
    # reset timers
    t = 0
    _timeToFirstFrame = win.getFutureFlipTime(clock="now")
    frameN = -1
    
    # --- Run Routine "PSWQ12" ---
    routineForceEnded = not continueRoutine
    while continueRoutine:
        # get current time
        t = routineTimer.getTime()
        tThisFlip = win.getFutureFlipTime(clock=routineTimer)
        tThisFlipGlobal = win.getFutureFlipTime(clock=None)
        frameN = frameN + 1  # number of completed frames (so 0 is the first frame)
        # update/draw components on each frame
        
        # *text_96* updates
        
        # if text_96 is starting this frame...
        if text_96.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
            # keep track of start time/frame for later
            text_96.frameNStart = frameN  # exact frame index
            text_96.tStart = t  # local t and not account for scr refresh
            text_96.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(text_96, 'tStartRefresh')  # time at next scr refresh
            # add timestamp to datafile
            thisExp.timestampOnFlip(win, 'text_96.started')
            # update status
            text_96.status = STARTED
            text_96.setAutoDraw(True)
        
        # if text_96 is active this frame...
        if text_96.status == STARTED:
            # update params
            pass
        
        # *text_97* updates
        
        # if text_97 is starting this frame...
        if text_97.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
            # keep track of start time/frame for later
            text_97.frameNStart = frameN  # exact frame index
            text_97.tStart = t  # local t and not account for scr refresh
            text_97.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(text_97, 'tStartRefresh')  # time at next scr refresh
            # add timestamp to datafile
            thisExp.timestampOnFlip(win, 'text_97.started')
            # update status
            text_97.status = STARTED
            text_97.setAutoDraw(True)
        
        # if text_97 is active this frame...
        if text_97.status == STARTED:
            # update params
            pass
        
        # *text_98* updates
        
        # if text_98 is starting this frame...
        if text_98.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
            # keep track of start time/frame for later
            text_98.frameNStart = frameN  # exact frame index
            text_98.tStart = t  # local t and not account for scr refresh
            text_98.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(text_98, 'tStartRefresh')  # time at next scr refresh
            # add timestamp to datafile
            thisExp.timestampOnFlip(win, 'text_98.started')
            # update status
            text_98.status = STARTED
            text_98.setAutoDraw(True)
        
        # if text_98 is active this frame...
        if text_98.status == STARTED:
            # update params
            pass
        
        # *key_resp_31* updates
        waitOnFlip = False
        
        # if key_resp_31 is starting this frame...
        if key_resp_31.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
            # keep track of start time/frame for later
            key_resp_31.frameNStart = frameN  # exact frame index
            key_resp_31.tStart = t  # local t and not account for scr refresh
            key_resp_31.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(key_resp_31, 'tStartRefresh')  # time at next scr refresh
            # add timestamp to datafile
            thisExp.timestampOnFlip(win, 'key_resp_31.started')
            # update status
            key_resp_31.status = STARTED
            # keyboard checking is just starting
            waitOnFlip = True
            win.callOnFlip(key_resp_31.clock.reset)  # t=0 on next screen flip
            win.callOnFlip(key_resp_31.clearEvents, eventType='keyboard')  # clear events on next screen flip
        if key_resp_31.status == STARTED and not waitOnFlip:
            theseKeys = key_resp_31.getKeys(keyList=[1,2,3,4,5,'1','2','3','4','5'], ignoreKeys=["escape"], waitRelease=False)
            _key_resp_31_allKeys.extend(theseKeys)
            if len(_key_resp_31_allKeys):
                key_resp_31.keys = _key_resp_31_allKeys[-1].name  # just the last key pressed
                key_resp_31.rt = _key_resp_31_allKeys[-1].rt
                key_resp_31.duration = _key_resp_31_allKeys[-1].duration
                # a response ends the routine
                continueRoutine = False
        
        # check for quit (typically the Esc key)
        if defaultKeyboard.getKeys(keyList=["escape"]):
            thisExp.status = FINISHED
        if thisExp.status == FINISHED or endExpNow:
            endExperiment(thisExp, inputs=inputs, win=win)
            return
        
        # check if all components have finished
        if not continueRoutine:  # a component has requested a forced-end of Routine
            routineForceEnded = True
            break
        continueRoutine = False  # will revert to True if at least one component still running
        for thisComponent in PSWQ12Components:
            if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:
                continueRoutine = True
                break  # at least one component has not yet finished
        
        # refresh the screen
        if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen
            win.flip()
    
    # --- Ending Routine "PSWQ12" ---
    for thisComponent in PSWQ12Components:
        if hasattr(thisComponent, "setAutoDraw"):
            thisComponent.setAutoDraw(False)
    thisExp.addData('PSWQ12.stopped', globalClock.getTime())
    # check responses
    if key_resp_31.keys in ['', [], None]:  # No response was made
        key_resp_31.keys = None
    thisExp.addData('key_resp_31.keys',key_resp_31.keys)
    if key_resp_31.keys != None:  # we had a response
        thisExp.addData('key_resp_31.rt', key_resp_31.rt)
        thisExp.addData('key_resp_31.duration', key_resp_31.duration)
    thisExp.nextEntry()
    # the Routine "PSWQ12" was not non-slip safe, so reset the non-slip timer
    routineTimer.reset()
    
    # --- Prepare to start Routine "PSWQ13" ---
    continueRoutine = True
    # update component parameters for each repeat
    thisExp.addData('PSWQ13.started', globalClock.getTime())
    key_resp_32.keys = []
    key_resp_32.rt = []
    _key_resp_32_allKeys = []
    # keep track of which components have finished
    PSWQ13Components = [text_99, text_100, text_101, key_resp_32]
    for thisComponent in PSWQ13Components:
        thisComponent.tStart = None
        thisComponent.tStop = None
        thisComponent.tStartRefresh = None
        thisComponent.tStopRefresh = None
        if hasattr(thisComponent, 'status'):
            thisComponent.status = NOT_STARTED
    # reset timers
    t = 0
    _timeToFirstFrame = win.getFutureFlipTime(clock="now")
    frameN = -1
    
    # --- Run Routine "PSWQ13" ---
    routineForceEnded = not continueRoutine
    while continueRoutine:
        # get current time
        t = routineTimer.getTime()
        tThisFlip = win.getFutureFlipTime(clock=routineTimer)
        tThisFlipGlobal = win.getFutureFlipTime(clock=None)
        frameN = frameN + 1  # number of completed frames (so 0 is the first frame)
        # update/draw components on each frame
        
        # *text_99* updates
        
        # if text_99 is starting this frame...
        if text_99.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
            # keep track of start time/frame for later
            text_99.frameNStart = frameN  # exact frame index
            text_99.tStart = t  # local t and not account for scr refresh
            text_99.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(text_99, 'tStartRefresh')  # time at next scr refresh
            # add timestamp to datafile
            thisExp.timestampOnFlip(win, 'text_99.started')
            # update status
            text_99.status = STARTED
            text_99.setAutoDraw(True)
        
        # if text_99 is active this frame...
        if text_99.status == STARTED:
            # update params
            pass
        
        # *text_100* updates
        
        # if text_100 is starting this frame...
        if text_100.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
            # keep track of start time/frame for later
            text_100.frameNStart = frameN  # exact frame index
            text_100.tStart = t  # local t and not account for scr refresh
            text_100.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(text_100, 'tStartRefresh')  # time at next scr refresh
            # add timestamp to datafile
            thisExp.timestampOnFlip(win, 'text_100.started')
            # update status
            text_100.status = STARTED
            text_100.setAutoDraw(True)
        
        # if text_100 is active this frame...
        if text_100.status == STARTED:
            # update params
            pass
        
        # *text_101* updates
        
        # if text_101 is starting this frame...
        if text_101.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
            # keep track of start time/frame for later
            text_101.frameNStart = frameN  # exact frame index
            text_101.tStart = t  # local t and not account for scr refresh
            text_101.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(text_101, 'tStartRefresh')  # time at next scr refresh
            # add timestamp to datafile
            thisExp.timestampOnFlip(win, 'text_101.started')
            # update status
            text_101.status = STARTED
            text_101.setAutoDraw(True)
        
        # if text_101 is active this frame...
        if text_101.status == STARTED:
            # update params
            pass
        
        # *key_resp_32* updates
        waitOnFlip = False
        
        # if key_resp_32 is starting this frame...
        if key_resp_32.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
            # keep track of start time/frame for later
            key_resp_32.frameNStart = frameN  # exact frame index
            key_resp_32.tStart = t  # local t and not account for scr refresh
            key_resp_32.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(key_resp_32, 'tStartRefresh')  # time at next scr refresh
            # add timestamp to datafile
            thisExp.timestampOnFlip(win, 'key_resp_32.started')
            # update status
            key_resp_32.status = STARTED
            # keyboard checking is just starting
            waitOnFlip = True
            win.callOnFlip(key_resp_32.clock.reset)  # t=0 on next screen flip
            win.callOnFlip(key_resp_32.clearEvents, eventType='keyboard')  # clear events on next screen flip
        if key_resp_32.status == STARTED and not waitOnFlip:
            theseKeys = key_resp_32.getKeys(keyList=[1,2,3,4,5,'1','2','3','4','5'], ignoreKeys=["escape"], waitRelease=False)
            _key_resp_32_allKeys.extend(theseKeys)
            if len(_key_resp_32_allKeys):
                key_resp_32.keys = _key_resp_32_allKeys[-1].name  # just the last key pressed
                key_resp_32.rt = _key_resp_32_allKeys[-1].rt
                key_resp_32.duration = _key_resp_32_allKeys[-1].duration
                # a response ends the routine
                continueRoutine = False
        
        # check for quit (typically the Esc key)
        if defaultKeyboard.getKeys(keyList=["escape"]):
            thisExp.status = FINISHED
        if thisExp.status == FINISHED or endExpNow:
            endExperiment(thisExp, inputs=inputs, win=win)
            return
        
        # check if all components have finished
        if not continueRoutine:  # a component has requested a forced-end of Routine
            routineForceEnded = True
            break
        continueRoutine = False  # will revert to True if at least one component still running
        for thisComponent in PSWQ13Components:
            if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:
                continueRoutine = True
                break  # at least one component has not yet finished
        
        # refresh the screen
        if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen
            win.flip()
    
    # --- Ending Routine "PSWQ13" ---
    for thisComponent in PSWQ13Components:
        if hasattr(thisComponent, "setAutoDraw"):
            thisComponent.setAutoDraw(False)
    thisExp.addData('PSWQ13.stopped', globalClock.getTime())
    # check responses
    if key_resp_32.keys in ['', [], None]:  # No response was made
        key_resp_32.keys = None
    thisExp.addData('key_resp_32.keys',key_resp_32.keys)
    if key_resp_32.keys != None:  # we had a response
        thisExp.addData('key_resp_32.rt', key_resp_32.rt)
        thisExp.addData('key_resp_32.duration', key_resp_32.duration)
    thisExp.nextEntry()
    # the Routine "PSWQ13" was not non-slip safe, so reset the non-slip timer
    routineTimer.reset()
    
    # --- Prepare to start Routine "PSWQ14" ---
    continueRoutine = True
    # update component parameters for each repeat
    thisExp.addData('PSWQ14.started', globalClock.getTime())
    key_resp_33.keys = []
    key_resp_33.rt = []
    _key_resp_33_allKeys = []
    # keep track of which components have finished
    PSWQ14Components = [text_102, text_103, text_104, key_resp_33]
    for thisComponent in PSWQ14Components:
        thisComponent.tStart = None
        thisComponent.tStop = None
        thisComponent.tStartRefresh = None
        thisComponent.tStopRefresh = None
        if hasattr(thisComponent, 'status'):
            thisComponent.status = NOT_STARTED
    # reset timers
    t = 0
    _timeToFirstFrame = win.getFutureFlipTime(clock="now")
    frameN = -1
    
    # --- Run Routine "PSWQ14" ---
    routineForceEnded = not continueRoutine
    while continueRoutine:
        # get current time
        t = routineTimer.getTime()
        tThisFlip = win.getFutureFlipTime(clock=routineTimer)
        tThisFlipGlobal = win.getFutureFlipTime(clock=None)
        frameN = frameN + 1  # number of completed frames (so 0 is the first frame)
        # update/draw components on each frame
        
        # *text_102* updates
        
        # if text_102 is starting this frame...
        if text_102.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
            # keep track of start time/frame for later
            text_102.frameNStart = frameN  # exact frame index
            text_102.tStart = t  # local t and not account for scr refresh
            text_102.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(text_102, 'tStartRefresh')  # time at next scr refresh
            # add timestamp to datafile
            thisExp.timestampOnFlip(win, 'text_102.started')
            # update status
            text_102.status = STARTED
            text_102.setAutoDraw(True)
        
        # if text_102 is active this frame...
        if text_102.status == STARTED:
            # update params
            pass
        
        # *text_103* updates
        
        # if text_103 is starting this frame...
        if text_103.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
            # keep track of start time/frame for later
            text_103.frameNStart = frameN  # exact frame index
            text_103.tStart = t  # local t and not account for scr refresh
            text_103.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(text_103, 'tStartRefresh')  # time at next scr refresh
            # add timestamp to datafile
            thisExp.timestampOnFlip(win, 'text_103.started')
            # update status
            text_103.status = STARTED
            text_103.setAutoDraw(True)
        
        # if text_103 is active this frame...
        if text_103.status == STARTED:
            # update params
            pass
        
        # *text_104* updates
        
        # if text_104 is starting this frame...
        if text_104.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
            # keep track of start time/frame for later
            text_104.frameNStart = frameN  # exact frame index
            text_104.tStart = t  # local t and not account for scr refresh
            text_104.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(text_104, 'tStartRefresh')  # time at next scr refresh
            # add timestamp to datafile
            thisExp.timestampOnFlip(win, 'text_104.started')
            # update status
            text_104.status = STARTED
            text_104.setAutoDraw(True)
        
        # if text_104 is active this frame...
        if text_104.status == STARTED:
            # update params
            pass
        
        # *key_resp_33* updates
        waitOnFlip = False
        
        # if key_resp_33 is starting this frame...
        if key_resp_33.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
            # keep track of start time/frame for later
            key_resp_33.frameNStart = frameN  # exact frame index
            key_resp_33.tStart = t  # local t and not account for scr refresh
            key_resp_33.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(key_resp_33, 'tStartRefresh')  # time at next scr refresh
            # add timestamp to datafile
            thisExp.timestampOnFlip(win, 'key_resp_33.started')
            # update status
            key_resp_33.status = STARTED
            # keyboard checking is just starting
            waitOnFlip = True
            win.callOnFlip(key_resp_33.clock.reset)  # t=0 on next screen flip
            win.callOnFlip(key_resp_33.clearEvents, eventType='keyboard')  # clear events on next screen flip
        if key_resp_33.status == STARTED and not waitOnFlip:
            theseKeys = key_resp_33.getKeys(keyList=[1,2,3,4,5,'1','2','3','4','5'], ignoreKeys=["escape"], waitRelease=False)
            _key_resp_33_allKeys.extend(theseKeys)
            if len(_key_resp_33_allKeys):
                key_resp_33.keys = _key_resp_33_allKeys[-1].name  # just the last key pressed
                key_resp_33.rt = _key_resp_33_allKeys[-1].rt
                key_resp_33.duration = _key_resp_33_allKeys[-1].duration
                # a response ends the routine
                continueRoutine = False
        
        # check for quit (typically the Esc key)
        if defaultKeyboard.getKeys(keyList=["escape"]):
            thisExp.status = FINISHED
        if thisExp.status == FINISHED or endExpNow:
            endExperiment(thisExp, inputs=inputs, win=win)
            return
        
        # check if all components have finished
        if not continueRoutine:  # a component has requested a forced-end of Routine
            routineForceEnded = True
            break
        continueRoutine = False  # will revert to True if at least one component still running
        for thisComponent in PSWQ14Components:
            if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:
                continueRoutine = True
                break  # at least one component has not yet finished
        
        # refresh the screen
        if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen
            win.flip()
    
    # --- Ending Routine "PSWQ14" ---
    for thisComponent in PSWQ14Components:
        if hasattr(thisComponent, "setAutoDraw"):
            thisComponent.setAutoDraw(False)
    thisExp.addData('PSWQ14.stopped', globalClock.getTime())
    # check responses
    if key_resp_33.keys in ['', [], None]:  # No response was made
        key_resp_33.keys = None
    thisExp.addData('key_resp_33.keys',key_resp_33.keys)
    if key_resp_33.keys != None:  # we had a response
        thisExp.addData('key_resp_33.rt', key_resp_33.rt)
        thisExp.addData('key_resp_33.duration', key_resp_33.duration)
    thisExp.nextEntry()
    # the Routine "PSWQ14" was not non-slip safe, so reset the non-slip timer
    routineTimer.reset()
    
    # --- Prepare to start Routine "PSWQ15" ---
    continueRoutine = True
    # update component parameters for each repeat
    thisExp.addData('PSWQ15.started', globalClock.getTime())
    key_resp_34.keys = []
    key_resp_34.rt = []
    _key_resp_34_allKeys = []
    # keep track of which components have finished
    PSWQ15Components = [text_105, text_106, text_107, key_resp_34]
    for thisComponent in PSWQ15Components:
        thisComponent.tStart = None
        thisComponent.tStop = None
        thisComponent.tStartRefresh = None
        thisComponent.tStopRefresh = None
        if hasattr(thisComponent, 'status'):
            thisComponent.status = NOT_STARTED
    # reset timers
    t = 0
    _timeToFirstFrame = win.getFutureFlipTime(clock="now")
    frameN = -1
    
    # --- Run Routine "PSWQ15" ---
    routineForceEnded = not continueRoutine
    while continueRoutine:
        # get current time
        t = routineTimer.getTime()
        tThisFlip = win.getFutureFlipTime(clock=routineTimer)
        tThisFlipGlobal = win.getFutureFlipTime(clock=None)
        frameN = frameN + 1  # number of completed frames (so 0 is the first frame)
        # update/draw components on each frame
        
        # *text_105* updates
        
        # if text_105 is starting this frame...
        if text_105.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
            # keep track of start time/frame for later
            text_105.frameNStart = frameN  # exact frame index
            text_105.tStart = t  # local t and not account for scr refresh
            text_105.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(text_105, 'tStartRefresh')  # time at next scr refresh
            # add timestamp to datafile
            thisExp.timestampOnFlip(win, 'text_105.started')
            # update status
            text_105.status = STARTED
            text_105.setAutoDraw(True)
        
        # if text_105 is active this frame...
        if text_105.status == STARTED:
            # update params
            pass
        
        # *text_106* updates
        
        # if text_106 is starting this frame...
        if text_106.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
            # keep track of start time/frame for later
            text_106.frameNStart = frameN  # exact frame index
            text_106.tStart = t  # local t and not account for scr refresh
            text_106.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(text_106, 'tStartRefresh')  # time at next scr refresh
            # add timestamp to datafile
            thisExp.timestampOnFlip(win, 'text_106.started')
            # update status
            text_106.status = STARTED
            text_106.setAutoDraw(True)
        
        # if text_106 is active this frame...
        if text_106.status == STARTED:
            # update params
            pass
        
        # *text_107* updates
        
        # if text_107 is starting this frame...
        if text_107.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
            # keep track of start time/frame for later
            text_107.frameNStart = frameN  # exact frame index
            text_107.tStart = t  # local t and not account for scr refresh
            text_107.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(text_107, 'tStartRefresh')  # time at next scr refresh
            # add timestamp to datafile
            thisExp.timestampOnFlip(win, 'text_107.started')
            # update status
            text_107.status = STARTED
            text_107.setAutoDraw(True)
        
        # if text_107 is active this frame...
        if text_107.status == STARTED:
            # update params
            pass
        
        # *key_resp_34* updates
        waitOnFlip = False
        
        # if key_resp_34 is starting this frame...
        if key_resp_34.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
            # keep track of start time/frame for later
            key_resp_34.frameNStart = frameN  # exact frame index
            key_resp_34.tStart = t  # local t and not account for scr refresh
            key_resp_34.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(key_resp_34, 'tStartRefresh')  # time at next scr refresh
            # add timestamp to datafile
            thisExp.timestampOnFlip(win, 'key_resp_34.started')
            # update status
            key_resp_34.status = STARTED
            # keyboard checking is just starting
            waitOnFlip = True
            win.callOnFlip(key_resp_34.clock.reset)  # t=0 on next screen flip
            win.callOnFlip(key_resp_34.clearEvents, eventType='keyboard')  # clear events on next screen flip
        if key_resp_34.status == STARTED and not waitOnFlip:
            theseKeys = key_resp_34.getKeys(keyList=[1,2,3,4,5,'1','2','3','4','5'], ignoreKeys=["escape"], waitRelease=False)
            _key_resp_34_allKeys.extend(theseKeys)
            if len(_key_resp_34_allKeys):
                key_resp_34.keys = _key_resp_34_allKeys[-1].name  # just the last key pressed
                key_resp_34.rt = _key_resp_34_allKeys[-1].rt
                key_resp_34.duration = _key_resp_34_allKeys[-1].duration
                # a response ends the routine
                continueRoutine = False
        
        # check for quit (typically the Esc key)
        if defaultKeyboard.getKeys(keyList=["escape"]):
            thisExp.status = FINISHED
        if thisExp.status == FINISHED or endExpNow:
            endExperiment(thisExp, inputs=inputs, win=win)
            return
        
        # check if all components have finished
        if not continueRoutine:  # a component has requested a forced-end of Routine
            routineForceEnded = True
            break
        continueRoutine = False  # will revert to True if at least one component still running
        for thisComponent in PSWQ15Components:
            if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:
                continueRoutine = True
                break  # at least one component has not yet finished
        
        # refresh the screen
        if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen
            win.flip()
    
    # --- Ending Routine "PSWQ15" ---
    for thisComponent in PSWQ15Components:
        if hasattr(thisComponent, "setAutoDraw"):
            thisComponent.setAutoDraw(False)
    thisExp.addData('PSWQ15.stopped', globalClock.getTime())
    # check responses
    if key_resp_34.keys in ['', [], None]:  # No response was made
        key_resp_34.keys = None
    thisExp.addData('key_resp_34.keys',key_resp_34.keys)
    if key_resp_34.keys != None:  # we had a response
        thisExp.addData('key_resp_34.rt', key_resp_34.rt)
        thisExp.addData('key_resp_34.duration', key_resp_34.duration)
    thisExp.nextEntry()
    # the Routine "PSWQ15" was not non-slip safe, so reset the non-slip timer
    routineTimer.reset()
    
    # --- Prepare to start Routine "PSWQ16" ---
    continueRoutine = True
    # update component parameters for each repeat
    thisExp.addData('PSWQ16.started', globalClock.getTime())
    key_resp_35.keys = []
    key_resp_35.rt = []
    _key_resp_35_allKeys = []
    # keep track of which components have finished
    PSWQ16Components = [text_108, text_109, text_110, key_resp_35]
    for thisComponent in PSWQ16Components:
        thisComponent.tStart = None
        thisComponent.tStop = None
        thisComponent.tStartRefresh = None
        thisComponent.tStopRefresh = None
        if hasattr(thisComponent, 'status'):
            thisComponent.status = NOT_STARTED
    # reset timers
    t = 0
    _timeToFirstFrame = win.getFutureFlipTime(clock="now")
    frameN = -1
    
    # --- Run Routine "PSWQ16" ---
    routineForceEnded = not continueRoutine
    while continueRoutine:
        # get current time
        t = routineTimer.getTime()
        tThisFlip = win.getFutureFlipTime(clock=routineTimer)
        tThisFlipGlobal = win.getFutureFlipTime(clock=None)
        frameN = frameN + 1  # number of completed frames (so 0 is the first frame)
        # update/draw components on each frame
        
        # *text_108* updates
        
        # if text_108 is starting this frame...
        if text_108.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
            # keep track of start time/frame for later
            text_108.frameNStart = frameN  # exact frame index
            text_108.tStart = t  # local t and not account for scr refresh
            text_108.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(text_108, 'tStartRefresh')  # time at next scr refresh
            # add timestamp to datafile
            thisExp.timestampOnFlip(win, 'text_108.started')
            # update status
            text_108.status = STARTED
            text_108.setAutoDraw(True)
        
        # if text_108 is active this frame...
        if text_108.status == STARTED:
            # update params
            pass
        
        # *text_109* updates
        
        # if text_109 is starting this frame...
        if text_109.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
            # keep track of start time/frame for later
            text_109.frameNStart = frameN  # exact frame index
            text_109.tStart = t  # local t and not account for scr refresh
            text_109.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(text_109, 'tStartRefresh')  # time at next scr refresh
            # add timestamp to datafile
            thisExp.timestampOnFlip(win, 'text_109.started')
            # update status
            text_109.status = STARTED
            text_109.setAutoDraw(True)
        
        # if text_109 is active this frame...
        if text_109.status == STARTED:
            # update params
            pass
        
        # *text_110* updates
        
        # if text_110 is starting this frame...
        if text_110.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
            # keep track of start time/frame for later
            text_110.frameNStart = frameN  # exact frame index
            text_110.tStart = t  # local t and not account for scr refresh
            text_110.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(text_110, 'tStartRefresh')  # time at next scr refresh
            # add timestamp to datafile
            thisExp.timestampOnFlip(win, 'text_110.started')
            # update status
            text_110.status = STARTED
            text_110.setAutoDraw(True)
        
        # if text_110 is active this frame...
        if text_110.status == STARTED:
            # update params
            pass
        
        # *key_resp_35* updates
        waitOnFlip = False
        
        # if key_resp_35 is starting this frame...
        if key_resp_35.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
            # keep track of start time/frame for later
            key_resp_35.frameNStart = frameN  # exact frame index
            key_resp_35.tStart = t  # local t and not account for scr refresh
            key_resp_35.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(key_resp_35, 'tStartRefresh')  # time at next scr refresh
            # add timestamp to datafile
            thisExp.timestampOnFlip(win, 'key_resp_35.started')
            # update status
            key_resp_35.status = STARTED
            # keyboard checking is just starting
            waitOnFlip = True
            win.callOnFlip(key_resp_35.clock.reset)  # t=0 on next screen flip
            win.callOnFlip(key_resp_35.clearEvents, eventType='keyboard')  # clear events on next screen flip
        if key_resp_35.status == STARTED and not waitOnFlip:
            theseKeys = key_resp_35.getKeys(keyList=[1,2,3,4,5,'1','2','3','4','5'], ignoreKeys=["escape"], waitRelease=False)
            _key_resp_35_allKeys.extend(theseKeys)
            if len(_key_resp_35_allKeys):
                key_resp_35.keys = _key_resp_35_allKeys[-1].name  # just the last key pressed
                key_resp_35.rt = _key_resp_35_allKeys[-1].rt
                key_resp_35.duration = _key_resp_35_allKeys[-1].duration
                # a response ends the routine
                continueRoutine = False
        
        # check for quit (typically the Esc key)
        if defaultKeyboard.getKeys(keyList=["escape"]):
            thisExp.status = FINISHED
        if thisExp.status == FINISHED or endExpNow:
            endExperiment(thisExp, inputs=inputs, win=win)
            return
        
        # check if all components have finished
        if not continueRoutine:  # a component has requested a forced-end of Routine
            routineForceEnded = True
            break
        continueRoutine = False  # will revert to True if at least one component still running
        for thisComponent in PSWQ16Components:
            if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:
                continueRoutine = True
                break  # at least one component has not yet finished
        
        # refresh the screen
        if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen
            win.flip()
    
    # --- Ending Routine "PSWQ16" ---
    for thisComponent in PSWQ16Components:
        if hasattr(thisComponent, "setAutoDraw"):
            thisComponent.setAutoDraw(False)
    thisExp.addData('PSWQ16.stopped', globalClock.getTime())
    # check responses
    if key_resp_35.keys in ['', [], None]:  # No response was made
        key_resp_35.keys = None
    thisExp.addData('key_resp_35.keys',key_resp_35.keys)
    if key_resp_35.keys != None:  # we had a response
        thisExp.addData('key_resp_35.rt', key_resp_35.rt)
        thisExp.addData('key_resp_35.duration', key_resp_35.duration)
    thisExp.nextEntry()
    # the Routine "PSWQ16" was not non-slip safe, so reset the non-slip timer
    routineTimer.reset()
    
    # --- Prepare to start Routine "q2_instructions" ---
    continueRoutine = True
    # update component parameters for each repeat
    thisExp.addData('q2_instructions.started', globalClock.getTime())
    # keep track of which components have finished
    q2_instructionsComponents = [text_155]
    for thisComponent in q2_instructionsComponents:
        thisComponent.tStart = None
        thisComponent.tStop = None
        thisComponent.tStartRefresh = None
        thisComponent.tStopRefresh = None
        if hasattr(thisComponent, 'status'):
            thisComponent.status = NOT_STARTED
    # reset timers
    t = 0
    _timeToFirstFrame = win.getFutureFlipTime(clock="now")
    frameN = -1
    
    # --- Run Routine "q2_instructions" ---
    routineForceEnded = not continueRoutine
    while continueRoutine and routineTimer.getTime() < 5.0:
        # get current time
        t = routineTimer.getTime()
        tThisFlip = win.getFutureFlipTime(clock=routineTimer)
        tThisFlipGlobal = win.getFutureFlipTime(clock=None)
        frameN = frameN + 1  # number of completed frames (so 0 is the first frame)
        # update/draw components on each frame
        
        # *text_155* updates
        
        # if text_155 is starting this frame...
        if text_155.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
            # keep track of start time/frame for later
            text_155.frameNStart = frameN  # exact frame index
            text_155.tStart = t  # local t and not account for scr refresh
            text_155.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(text_155, 'tStartRefresh')  # time at next scr refresh
            # add timestamp to datafile
            thisExp.timestampOnFlip(win, 'text_155.started')
            # update status
            text_155.status = STARTED
            text_155.setAutoDraw(True)
        
        # if text_155 is active this frame...
        if text_155.status == STARTED:
            # update params
            pass
        
        # if text_155 is stopping this frame...
        if text_155.status == STARTED:
            # is it time to stop? (based on global clock, using actual start)
            if tThisFlipGlobal > text_155.tStartRefresh + 5.0-frameTolerance:
                # keep track of stop time/frame for later
                text_155.tStop = t  # not accounting for scr refresh
                text_155.frameNStop = frameN  # exact frame index
                # add timestamp to datafile
                thisExp.timestampOnFlip(win, 'text_155.stopped')
                # update status
                text_155.status = FINISHED
                text_155.setAutoDraw(False)
        
        # check for quit (typically the Esc key)
        if defaultKeyboard.getKeys(keyList=["escape"]):
            thisExp.status = FINISHED
        if thisExp.status == FINISHED or endExpNow:
            endExperiment(thisExp, inputs=inputs, win=win)
            return
        
        # check if all components have finished
        if not continueRoutine:  # a component has requested a forced-end of Routine
            routineForceEnded = True
            break
        continueRoutine = False  # will revert to True if at least one component still running
        for thisComponent in q2_instructionsComponents:
            if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:
                continueRoutine = True
                break  # at least one component has not yet finished
        
        # refresh the screen
        if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen
            win.flip()
    
    # --- Ending Routine "q2_instructions" ---
    for thisComponent in q2_instructionsComponents:
        if hasattr(thisComponent, "setAutoDraw"):
            thisComponent.setAutoDraw(False)
    thisExp.addData('q2_instructions.stopped', globalClock.getTime())
    # using non-slip timing so subtract the expected duration of this Routine (unless ended on request)
    if routineForceEnded:
        routineTimer.reset()
    else:
        routineTimer.addTime(-5.000000)
    
    # --- Prepare to start Routine "AM1" ---
    continueRoutine = True
    # update component parameters for each repeat
    thisExp.addData('AM1.started', globalClock.getTime())
    key_resp_41.keys = []
    key_resp_41.rt = []
    _key_resp_41_allKeys = []
    # keep track of which components have finished
    AM1Components = [text_156, text_157, text_158, key_resp_41]
    for thisComponent in AM1Components:
        thisComponent.tStart = None
        thisComponent.tStop = None
        thisComponent.tStartRefresh = None
        thisComponent.tStopRefresh = None
        if hasattr(thisComponent, 'status'):
            thisComponent.status = NOT_STARTED
    # reset timers
    t = 0
    _timeToFirstFrame = win.getFutureFlipTime(clock="now")
    frameN = -1
    
    # --- Run Routine "AM1" ---
    routineForceEnded = not continueRoutine
    while continueRoutine:
        # get current time
        t = routineTimer.getTime()
        tThisFlip = win.getFutureFlipTime(clock=routineTimer)
        tThisFlipGlobal = win.getFutureFlipTime(clock=None)
        frameN = frameN + 1  # number of completed frames (so 0 is the first frame)
        # update/draw components on each frame
        
        # *text_156* updates
        
        # if text_156 is starting this frame...
        if text_156.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
            # keep track of start time/frame for later
            text_156.frameNStart = frameN  # exact frame index
            text_156.tStart = t  # local t and not account for scr refresh
            text_156.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(text_156, 'tStartRefresh')  # time at next scr refresh
            # add timestamp to datafile
            thisExp.timestampOnFlip(win, 'text_156.started')
            # update status
            text_156.status = STARTED
            text_156.setAutoDraw(True)
        
        # if text_156 is active this frame...
        if text_156.status == STARTED:
            # update params
            pass
        
        # *text_157* updates
        
        # if text_157 is starting this frame...
        if text_157.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
            # keep track of start time/frame for later
            text_157.frameNStart = frameN  # exact frame index
            text_157.tStart = t  # local t and not account for scr refresh
            text_157.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(text_157, 'tStartRefresh')  # time at next scr refresh
            # add timestamp to datafile
            thisExp.timestampOnFlip(win, 'text_157.started')
            # update status
            text_157.status = STARTED
            text_157.setAutoDraw(True)
        
        # if text_157 is active this frame...
        if text_157.status == STARTED:
            # update params
            pass
        
        # *text_158* updates
        
        # if text_158 is starting this frame...
        if text_158.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
            # keep track of start time/frame for later
            text_158.frameNStart = frameN  # exact frame index
            text_158.tStart = t  # local t and not account for scr refresh
            text_158.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(text_158, 'tStartRefresh')  # time at next scr refresh
            # add timestamp to datafile
            thisExp.timestampOnFlip(win, 'text_158.started')
            # update status
            text_158.status = STARTED
            text_158.setAutoDraw(True)
        
        # if text_158 is active this frame...
        if text_158.status == STARTED:
            # update params
            pass
        
        # *key_resp_41* updates
        waitOnFlip = False
        
        # if key_resp_41 is starting this frame...
        if key_resp_41.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
            # keep track of start time/frame for later
            key_resp_41.frameNStart = frameN  # exact frame index
            key_resp_41.tStart = t  # local t and not account for scr refresh
            key_resp_41.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(key_resp_41, 'tStartRefresh')  # time at next scr refresh
            # add timestamp to datafile
            thisExp.timestampOnFlip(win, 'key_resp_41.started')
            # update status
            key_resp_41.status = STARTED
            # keyboard checking is just starting
            waitOnFlip = True
            win.callOnFlip(key_resp_41.clock.reset)  # t=0 on next screen flip
            win.callOnFlip(key_resp_41.clearEvents, eventType='keyboard')  # clear events on next screen flip
        if key_resp_41.status == STARTED and not waitOnFlip:
            theseKeys = key_resp_41.getKeys(keyList=[1,2,3,4,5,'1','2','3','4','5'], ignoreKeys=["escape"], waitRelease=False)
            _key_resp_41_allKeys.extend(theseKeys)
            if len(_key_resp_41_allKeys):
                key_resp_41.keys = _key_resp_41_allKeys[-1].name  # just the last key pressed
                key_resp_41.rt = _key_resp_41_allKeys[-1].rt
                key_resp_41.duration = _key_resp_41_allKeys[-1].duration
                # a response ends the routine
                continueRoutine = False
        
        # check for quit (typically the Esc key)
        if defaultKeyboard.getKeys(keyList=["escape"]):
            thisExp.status = FINISHED
        if thisExp.status == FINISHED or endExpNow:
            endExperiment(thisExp, inputs=inputs, win=win)
            return
        
        # check if all components have finished
        if not continueRoutine:  # a component has requested a forced-end of Routine
            routineForceEnded = True
            break
        continueRoutine = False  # will revert to True if at least one component still running
        for thisComponent in AM1Components:
            if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:
                continueRoutine = True
                break  # at least one component has not yet finished
        
        # refresh the screen
        if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen
            win.flip()
    
    # --- Ending Routine "AM1" ---
    for thisComponent in AM1Components:
        if hasattr(thisComponent, "setAutoDraw"):
            thisComponent.setAutoDraw(False)
    thisExp.addData('AM1.stopped', globalClock.getTime())
    # check responses
    if key_resp_41.keys in ['', [], None]:  # No response was made
        key_resp_41.keys = None
    thisExp.addData('key_resp_41.keys',key_resp_41.keys)
    if key_resp_41.keys != None:  # we had a response
        thisExp.addData('key_resp_41.rt', key_resp_41.rt)
        thisExp.addData('key_resp_41.duration', key_resp_41.duration)
    thisExp.nextEntry()
    # the Routine "AM1" was not non-slip safe, so reset the non-slip timer
    routineTimer.reset()
    
    # --- Prepare to start Routine "AM2" ---
    continueRoutine = True
    # update component parameters for each repeat
    thisExp.addData('AM2.started', globalClock.getTime())
    key_resp_42.keys = []
    key_resp_42.rt = []
    _key_resp_42_allKeys = []
    # keep track of which components have finished
    AM2Components = [text_159, text_160, text_161, key_resp_42]
    for thisComponent in AM2Components:
        thisComponent.tStart = None
        thisComponent.tStop = None
        thisComponent.tStartRefresh = None
        thisComponent.tStopRefresh = None
        if hasattr(thisComponent, 'status'):
            thisComponent.status = NOT_STARTED
    # reset timers
    t = 0
    _timeToFirstFrame = win.getFutureFlipTime(clock="now")
    frameN = -1
    
    # --- Run Routine "AM2" ---
    routineForceEnded = not continueRoutine
    while continueRoutine:
        # get current time
        t = routineTimer.getTime()
        tThisFlip = win.getFutureFlipTime(clock=routineTimer)
        tThisFlipGlobal = win.getFutureFlipTime(clock=None)
        frameN = frameN + 1  # number of completed frames (so 0 is the first frame)
        # update/draw components on each frame
        
        # *text_159* updates
        
        # if text_159 is starting this frame...
        if text_159.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
            # keep track of start time/frame for later
            text_159.frameNStart = frameN  # exact frame index
            text_159.tStart = t  # local t and not account for scr refresh
            text_159.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(text_159, 'tStartRefresh')  # time at next scr refresh
            # add timestamp to datafile
            thisExp.timestampOnFlip(win, 'text_159.started')
            # update status
            text_159.status = STARTED
            text_159.setAutoDraw(True)
        
        # if text_159 is active this frame...
        if text_159.status == STARTED:
            # update params
            pass
        
        # *text_160* updates
        
        # if text_160 is starting this frame...
        if text_160.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
            # keep track of start time/frame for later
            text_160.frameNStart = frameN  # exact frame index
            text_160.tStart = t  # local t and not account for scr refresh
            text_160.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(text_160, 'tStartRefresh')  # time at next scr refresh
            # add timestamp to datafile
            thisExp.timestampOnFlip(win, 'text_160.started')
            # update status
            text_160.status = STARTED
            text_160.setAutoDraw(True)
        
        # if text_160 is active this frame...
        if text_160.status == STARTED:
            # update params
            pass
        
        # *text_161* updates
        
        # if text_161 is starting this frame...
        if text_161.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
            # keep track of start time/frame for later
            text_161.frameNStart = frameN  # exact frame index
            text_161.tStart = t  # local t and not account for scr refresh
            text_161.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(text_161, 'tStartRefresh')  # time at next scr refresh
            # add timestamp to datafile
            thisExp.timestampOnFlip(win, 'text_161.started')
            # update status
            text_161.status = STARTED
            text_161.setAutoDraw(True)
        
        # if text_161 is active this frame...
        if text_161.status == STARTED:
            # update params
            pass
        
        # *key_resp_42* updates
        waitOnFlip = False
        
        # if key_resp_42 is starting this frame...
        if key_resp_42.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
            # keep track of start time/frame for later
            key_resp_42.frameNStart = frameN  # exact frame index
            key_resp_42.tStart = t  # local t and not account for scr refresh
            key_resp_42.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(key_resp_42, 'tStartRefresh')  # time at next scr refresh
            # add timestamp to datafile
            thisExp.timestampOnFlip(win, 'key_resp_42.started')
            # update status
            key_resp_42.status = STARTED
            # keyboard checking is just starting
            waitOnFlip = True
            win.callOnFlip(key_resp_42.clock.reset)  # t=0 on next screen flip
            win.callOnFlip(key_resp_42.clearEvents, eventType='keyboard')  # clear events on next screen flip
        if key_resp_42.status == STARTED and not waitOnFlip:
            theseKeys = key_resp_42.getKeys(keyList=[1,2,3,4,5,'1','2','3','4','5'], ignoreKeys=["escape"], waitRelease=False)
            _key_resp_42_allKeys.extend(theseKeys)
            if len(_key_resp_42_allKeys):
                key_resp_42.keys = _key_resp_42_allKeys[-1].name  # just the last key pressed
                key_resp_42.rt = _key_resp_42_allKeys[-1].rt
                key_resp_42.duration = _key_resp_42_allKeys[-1].duration
                # a response ends the routine
                continueRoutine = False
        
        # check for quit (typically the Esc key)
        if defaultKeyboard.getKeys(keyList=["escape"]):
            thisExp.status = FINISHED
        if thisExp.status == FINISHED or endExpNow:
            endExperiment(thisExp, inputs=inputs, win=win)
            return
        
        # check if all components have finished
        if not continueRoutine:  # a component has requested a forced-end of Routine
            routineForceEnded = True
            break
        continueRoutine = False  # will revert to True if at least one component still running
        for thisComponent in AM2Components:
            if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:
                continueRoutine = True
                break  # at least one component has not yet finished
        
        # refresh the screen
        if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen
            win.flip()
    
    # --- Ending Routine "AM2" ---
    for thisComponent in AM2Components:
        if hasattr(thisComponent, "setAutoDraw"):
            thisComponent.setAutoDraw(False)
    thisExp.addData('AM2.stopped', globalClock.getTime())
    # check responses
    if key_resp_42.keys in ['', [], None]:  # No response was made
        key_resp_42.keys = None
    thisExp.addData('key_resp_42.keys',key_resp_42.keys)
    if key_resp_42.keys != None:  # we had a response
        thisExp.addData('key_resp_42.rt', key_resp_42.rt)
        thisExp.addData('key_resp_42.duration', key_resp_42.duration)
    thisExp.nextEntry()
    # the Routine "AM2" was not non-slip safe, so reset the non-slip timer
    routineTimer.reset()
    
    # --- Prepare to start Routine "AM3" ---
    continueRoutine = True
    # update component parameters for each repeat
    thisExp.addData('AM3.started', globalClock.getTime())
    key_resp_43.keys = []
    key_resp_43.rt = []
    _key_resp_43_allKeys = []
    # keep track of which components have finished
    AM3Components = [text_162, text_163, text_164, key_resp_43]
    for thisComponent in AM3Components:
        thisComponent.tStart = None
        thisComponent.tStop = None
        thisComponent.tStartRefresh = None
        thisComponent.tStopRefresh = None
        if hasattr(thisComponent, 'status'):
            thisComponent.status = NOT_STARTED
    # reset timers
    t = 0
    _timeToFirstFrame = win.getFutureFlipTime(clock="now")
    frameN = -1
    
    # --- Run Routine "AM3" ---
    routineForceEnded = not continueRoutine
    while continueRoutine:
        # get current time
        t = routineTimer.getTime()
        tThisFlip = win.getFutureFlipTime(clock=routineTimer)
        tThisFlipGlobal = win.getFutureFlipTime(clock=None)
        frameN = frameN + 1  # number of completed frames (so 0 is the first frame)
        # update/draw components on each frame
        
        # *text_162* updates
        
        # if text_162 is starting this frame...
        if text_162.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
            # keep track of start time/frame for later
            text_162.frameNStart = frameN  # exact frame index
            text_162.tStart = t  # local t and not account for scr refresh
            text_162.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(text_162, 'tStartRefresh')  # time at next scr refresh
            # add timestamp to datafile
            thisExp.timestampOnFlip(win, 'text_162.started')
            # update status
            text_162.status = STARTED
            text_162.setAutoDraw(True)
        
        # if text_162 is active this frame...
        if text_162.status == STARTED:
            # update params
            pass
        
        # *text_163* updates
        
        # if text_163 is starting this frame...
        if text_163.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
            # keep track of start time/frame for later
            text_163.frameNStart = frameN  # exact frame index
            text_163.tStart = t  # local t and not account for scr refresh
            text_163.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(text_163, 'tStartRefresh')  # time at next scr refresh
            # add timestamp to datafile
            thisExp.timestampOnFlip(win, 'text_163.started')
            # update status
            text_163.status = STARTED
            text_163.setAutoDraw(True)
        
        # if text_163 is active this frame...
        if text_163.status == STARTED:
            # update params
            pass
        
        # *text_164* updates
        
        # if text_164 is starting this frame...
        if text_164.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
            # keep track of start time/frame for later
            text_164.frameNStart = frameN  # exact frame index
            text_164.tStart = t  # local t and not account for scr refresh
            text_164.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(text_164, 'tStartRefresh')  # time at next scr refresh
            # add timestamp to datafile
            thisExp.timestampOnFlip(win, 'text_164.started')
            # update status
            text_164.status = STARTED
            text_164.setAutoDraw(True)
        
        # if text_164 is active this frame...
        if text_164.status == STARTED:
            # update params
            pass
        
        # *key_resp_43* updates
        waitOnFlip = False
        
        # if key_resp_43 is starting this frame...
        if key_resp_43.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
            # keep track of start time/frame for later
            key_resp_43.frameNStart = frameN  # exact frame index
            key_resp_43.tStart = t  # local t and not account for scr refresh
            key_resp_43.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(key_resp_43, 'tStartRefresh')  # time at next scr refresh
            # add timestamp to datafile
            thisExp.timestampOnFlip(win, 'key_resp_43.started')
            # update status
            key_resp_43.status = STARTED
            # keyboard checking is just starting
            waitOnFlip = True
            win.callOnFlip(key_resp_43.clock.reset)  # t=0 on next screen flip
            win.callOnFlip(key_resp_43.clearEvents, eventType='keyboard')  # clear events on next screen flip
        if key_resp_43.status == STARTED and not waitOnFlip:
            theseKeys = key_resp_43.getKeys(keyList=[1,2,3,4,5,'1','2','3','4','5'], ignoreKeys=["escape"], waitRelease=False)
            _key_resp_43_allKeys.extend(theseKeys)
            if len(_key_resp_43_allKeys):
                key_resp_43.keys = _key_resp_43_allKeys[-1].name  # just the last key pressed
                key_resp_43.rt = _key_resp_43_allKeys[-1].rt
                key_resp_43.duration = _key_resp_43_allKeys[-1].duration
                # a response ends the routine
                continueRoutine = False
        
        # check for quit (typically the Esc key)
        if defaultKeyboard.getKeys(keyList=["escape"]):
            thisExp.status = FINISHED
        if thisExp.status == FINISHED or endExpNow:
            endExperiment(thisExp, inputs=inputs, win=win)
            return
        
        # check if all components have finished
        if not continueRoutine:  # a component has requested a forced-end of Routine
            routineForceEnded = True
            break
        continueRoutine = False  # will revert to True if at least one component still running
        for thisComponent in AM3Components:
            if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:
                continueRoutine = True
                break  # at least one component has not yet finished
        
        # refresh the screen
        if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen
            win.flip()
    
    # --- Ending Routine "AM3" ---
    for thisComponent in AM3Components:
        if hasattr(thisComponent, "setAutoDraw"):
            thisComponent.setAutoDraw(False)
    thisExp.addData('AM3.stopped', globalClock.getTime())
    # check responses
    if key_resp_43.keys in ['', [], None]:  # No response was made
        key_resp_43.keys = None
    thisExp.addData('key_resp_43.keys',key_resp_43.keys)
    if key_resp_43.keys != None:  # we had a response
        thisExp.addData('key_resp_43.rt', key_resp_43.rt)
        thisExp.addData('key_resp_43.duration', key_resp_43.duration)
    thisExp.nextEntry()
    # the Routine "AM3" was not non-slip safe, so reset the non-slip timer
    routineTimer.reset()
    
    # --- Prepare to start Routine "AM4" ---
    continueRoutine = True
    # update component parameters for each repeat
    thisExp.addData('AM4.started', globalClock.getTime())
    key_resp_44.keys = []
    key_resp_44.rt = []
    _key_resp_44_allKeys = []
    # keep track of which components have finished
    AM4Components = [text_165, text_166, text_167, key_resp_44]
    for thisComponent in AM4Components:
        thisComponent.tStart = None
        thisComponent.tStop = None
        thisComponent.tStartRefresh = None
        thisComponent.tStopRefresh = None
        if hasattr(thisComponent, 'status'):
            thisComponent.status = NOT_STARTED
    # reset timers
    t = 0
    _timeToFirstFrame = win.getFutureFlipTime(clock="now")
    frameN = -1
    
    # --- Run Routine "AM4" ---
    routineForceEnded = not continueRoutine
    while continueRoutine:
        # get current time
        t = routineTimer.getTime()
        tThisFlip = win.getFutureFlipTime(clock=routineTimer)
        tThisFlipGlobal = win.getFutureFlipTime(clock=None)
        frameN = frameN + 1  # number of completed frames (so 0 is the first frame)
        # update/draw components on each frame
        
        # *text_165* updates
        
        # if text_165 is starting this frame...
        if text_165.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
            # keep track of start time/frame for later
            text_165.frameNStart = frameN  # exact frame index
            text_165.tStart = t  # local t and not account for scr refresh
            text_165.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(text_165, 'tStartRefresh')  # time at next scr refresh
            # add timestamp to datafile
            thisExp.timestampOnFlip(win, 'text_165.started')
            # update status
            text_165.status = STARTED
            text_165.setAutoDraw(True)
        
        # if text_165 is active this frame...
        if text_165.status == STARTED:
            # update params
            pass
        
        # *text_166* updates
        
        # if text_166 is starting this frame...
        if text_166.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
            # keep track of start time/frame for later
            text_166.frameNStart = frameN  # exact frame index
            text_166.tStart = t  # local t and not account for scr refresh
            text_166.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(text_166, 'tStartRefresh')  # time at next scr refresh
            # add timestamp to datafile
            thisExp.timestampOnFlip(win, 'text_166.started')
            # update status
            text_166.status = STARTED
            text_166.setAutoDraw(True)
        
        # if text_166 is active this frame...
        if text_166.status == STARTED:
            # update params
            pass
        
        # *text_167* updates
        
        # if text_167 is starting this frame...
        if text_167.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
            # keep track of start time/frame for later
            text_167.frameNStart = frameN  # exact frame index
            text_167.tStart = t  # local t and not account for scr refresh
            text_167.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(text_167, 'tStartRefresh')  # time at next scr refresh
            # add timestamp to datafile
            thisExp.timestampOnFlip(win, 'text_167.started')
            # update status
            text_167.status = STARTED
            text_167.setAutoDraw(True)
        
        # if text_167 is active this frame...
        if text_167.status == STARTED:
            # update params
            pass
        
        # *key_resp_44* updates
        waitOnFlip = False
        
        # if key_resp_44 is starting this frame...
        if key_resp_44.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
            # keep track of start time/frame for later
            key_resp_44.frameNStart = frameN  # exact frame index
            key_resp_44.tStart = t  # local t and not account for scr refresh
            key_resp_44.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(key_resp_44, 'tStartRefresh')  # time at next scr refresh
            # add timestamp to datafile
            thisExp.timestampOnFlip(win, 'key_resp_44.started')
            # update status
            key_resp_44.status = STARTED
            # keyboard checking is just starting
            waitOnFlip = True
            win.callOnFlip(key_resp_44.clock.reset)  # t=0 on next screen flip
            win.callOnFlip(key_resp_44.clearEvents, eventType='keyboard')  # clear events on next screen flip
        if key_resp_44.status == STARTED and not waitOnFlip:
            theseKeys = key_resp_44.getKeys(keyList=[1,2,3,4,5,'1','2','3','4','5'], ignoreKeys=["escape"], waitRelease=False)
            _key_resp_44_allKeys.extend(theseKeys)
            if len(_key_resp_44_allKeys):
                key_resp_44.keys = _key_resp_44_allKeys[-1].name  # just the last key pressed
                key_resp_44.rt = _key_resp_44_allKeys[-1].rt
                key_resp_44.duration = _key_resp_44_allKeys[-1].duration
                # a response ends the routine
                continueRoutine = False
        
        # check for quit (typically the Esc key)
        if defaultKeyboard.getKeys(keyList=["escape"]):
            thisExp.status = FINISHED
        if thisExp.status == FINISHED or endExpNow:
            endExperiment(thisExp, inputs=inputs, win=win)
            return
        
        # check if all components have finished
        if not continueRoutine:  # a component has requested a forced-end of Routine
            routineForceEnded = True
            break
        continueRoutine = False  # will revert to True if at least one component still running
        for thisComponent in AM4Components:
            if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:
                continueRoutine = True
                break  # at least one component has not yet finished
        
        # refresh the screen
        if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen
            win.flip()
    
    # --- Ending Routine "AM4" ---
    for thisComponent in AM4Components:
        if hasattr(thisComponent, "setAutoDraw"):
            thisComponent.setAutoDraw(False)
    thisExp.addData('AM4.stopped', globalClock.getTime())
    # check responses
    if key_resp_44.keys in ['', [], None]:  # No response was made
        key_resp_44.keys = None
    thisExp.addData('key_resp_44.keys',key_resp_44.keys)
    if key_resp_44.keys != None:  # we had a response
        thisExp.addData('key_resp_44.rt', key_resp_44.rt)
        thisExp.addData('key_resp_44.duration', key_resp_44.duration)
    thisExp.nextEntry()
    # the Routine "AM4" was not non-slip safe, so reset the non-slip timer
    routineTimer.reset()
    
    # --- Prepare to start Routine "AM5" ---
    continueRoutine = True
    # update component parameters for each repeat
    thisExp.addData('AM5.started', globalClock.getTime())
    key_resp_45.keys = []
    key_resp_45.rt = []
    _key_resp_45_allKeys = []
    # keep track of which components have finished
    AM5Components = [text_168, text_169, text_170, key_resp_45]
    for thisComponent in AM5Components:
        thisComponent.tStart = None
        thisComponent.tStop = None
        thisComponent.tStartRefresh = None
        thisComponent.tStopRefresh = None
        if hasattr(thisComponent, 'status'):
            thisComponent.status = NOT_STARTED
    # reset timers
    t = 0
    _timeToFirstFrame = win.getFutureFlipTime(clock="now")
    frameN = -1
    
    # --- Run Routine "AM5" ---
    routineForceEnded = not continueRoutine
    while continueRoutine:
        # get current time
        t = routineTimer.getTime()
        tThisFlip = win.getFutureFlipTime(clock=routineTimer)
        tThisFlipGlobal = win.getFutureFlipTime(clock=None)
        frameN = frameN + 1  # number of completed frames (so 0 is the first frame)
        # update/draw components on each frame
        
        # *text_168* updates
        
        # if text_168 is starting this frame...
        if text_168.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
            # keep track of start time/frame for later
            text_168.frameNStart = frameN  # exact frame index
            text_168.tStart = t  # local t and not account for scr refresh
            text_168.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(text_168, 'tStartRefresh')  # time at next scr refresh
            # add timestamp to datafile
            thisExp.timestampOnFlip(win, 'text_168.started')
            # update status
            text_168.status = STARTED
            text_168.setAutoDraw(True)
        
        # if text_168 is active this frame...
        if text_168.status == STARTED:
            # update params
            pass
        
        # *text_169* updates
        
        # if text_169 is starting this frame...
        if text_169.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
            # keep track of start time/frame for later
            text_169.frameNStart = frameN  # exact frame index
            text_169.tStart = t  # local t and not account for scr refresh
            text_169.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(text_169, 'tStartRefresh')  # time at next scr refresh
            # add timestamp to datafile
            thisExp.timestampOnFlip(win, 'text_169.started')
            # update status
            text_169.status = STARTED
            text_169.setAutoDraw(True)
        
        # if text_169 is active this frame...
        if text_169.status == STARTED:
            # update params
            pass
        
        # *text_170* updates
        
        # if text_170 is starting this frame...
        if text_170.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
            # keep track of start time/frame for later
            text_170.frameNStart = frameN  # exact frame index
            text_170.tStart = t  # local t and not account for scr refresh
            text_170.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(text_170, 'tStartRefresh')  # time at next scr refresh
            # add timestamp to datafile
            thisExp.timestampOnFlip(win, 'text_170.started')
            # update status
            text_170.status = STARTED
            text_170.setAutoDraw(True)
        
        # if text_170 is active this frame...
        if text_170.status == STARTED:
            # update params
            pass
        
        # *key_resp_45* updates
        waitOnFlip = False
        
        # if key_resp_45 is starting this frame...
        if key_resp_45.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
            # keep track of start time/frame for later
            key_resp_45.frameNStart = frameN  # exact frame index
            key_resp_45.tStart = t  # local t and not account for scr refresh
            key_resp_45.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(key_resp_45, 'tStartRefresh')  # time at next scr refresh
            # add timestamp to datafile
            thisExp.timestampOnFlip(win, 'key_resp_45.started')
            # update status
            key_resp_45.status = STARTED
            # keyboard checking is just starting
            waitOnFlip = True
            win.callOnFlip(key_resp_45.clock.reset)  # t=0 on next screen flip
            win.callOnFlip(key_resp_45.clearEvents, eventType='keyboard')  # clear events on next screen flip
        if key_resp_45.status == STARTED and not waitOnFlip:
            theseKeys = key_resp_45.getKeys(keyList=[1,2,3,4,5,'1','2','3','4','5'], ignoreKeys=["escape"], waitRelease=False)
            _key_resp_45_allKeys.extend(theseKeys)
            if len(_key_resp_45_allKeys):
                key_resp_45.keys = _key_resp_45_allKeys[-1].name  # just the last key pressed
                key_resp_45.rt = _key_resp_45_allKeys[-1].rt
                key_resp_45.duration = _key_resp_45_allKeys[-1].duration
                # a response ends the routine
                continueRoutine = False
        
        # check for quit (typically the Esc key)
        if defaultKeyboard.getKeys(keyList=["escape"]):
            thisExp.status = FINISHED
        if thisExp.status == FINISHED or endExpNow:
            endExperiment(thisExp, inputs=inputs, win=win)
            return
        
        # check if all components have finished
        if not continueRoutine:  # a component has requested a forced-end of Routine
            routineForceEnded = True
            break
        continueRoutine = False  # will revert to True if at least one component still running
        for thisComponent in AM5Components:
            if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:
                continueRoutine = True
                break  # at least one component has not yet finished
        
        # refresh the screen
        if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen
            win.flip()
    
    # --- Ending Routine "AM5" ---
    for thisComponent in AM5Components:
        if hasattr(thisComponent, "setAutoDraw"):
            thisComponent.setAutoDraw(False)
    thisExp.addData('AM5.stopped', globalClock.getTime())
    # check responses
    if key_resp_45.keys in ['', [], None]:  # No response was made
        key_resp_45.keys = None
    thisExp.addData('key_resp_45.keys',key_resp_45.keys)
    if key_resp_45.keys != None:  # we had a response
        thisExp.addData('key_resp_45.rt', key_resp_45.rt)
        thisExp.addData('key_resp_45.duration', key_resp_45.duration)
    thisExp.nextEntry()
    # the Routine "AM5" was not non-slip safe, so reset the non-slip timer
    routineTimer.reset()
    
    # --- Prepare to start Routine "q3_instructions" ---
    continueRoutine = True
    # update component parameters for each repeat
    thisExp.addData('q3_instructions.started', globalClock.getTime())
    # keep track of which components have finished
    q3_instructionsComponents = [text_171]
    for thisComponent in q3_instructionsComponents:
        thisComponent.tStart = None
        thisComponent.tStop = None
        thisComponent.tStartRefresh = None
        thisComponent.tStopRefresh = None
        if hasattr(thisComponent, 'status'):
            thisComponent.status = NOT_STARTED
    # reset timers
    t = 0
    _timeToFirstFrame = win.getFutureFlipTime(clock="now")
    frameN = -1
    
    # --- Run Routine "q3_instructions" ---
    routineForceEnded = not continueRoutine
    while continueRoutine and routineTimer.getTime() < 5.0:
        # get current time
        t = routineTimer.getTime()
        tThisFlip = win.getFutureFlipTime(clock=routineTimer)
        tThisFlipGlobal = win.getFutureFlipTime(clock=None)
        frameN = frameN + 1  # number of completed frames (so 0 is the first frame)
        # update/draw components on each frame
        
        # *text_171* updates
        
        # if text_171 is starting this frame...
        if text_171.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
            # keep track of start time/frame for later
            text_171.frameNStart = frameN  # exact frame index
            text_171.tStart = t  # local t and not account for scr refresh
            text_171.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(text_171, 'tStartRefresh')  # time at next scr refresh
            # add timestamp to datafile
            thisExp.timestampOnFlip(win, 'text_171.started')
            # update status
            text_171.status = STARTED
            text_171.setAutoDraw(True)
        
        # if text_171 is active this frame...
        if text_171.status == STARTED:
            # update params
            pass
        
        # if text_171 is stopping this frame...
        if text_171.status == STARTED:
            # is it time to stop? (based on global clock, using actual start)
            if tThisFlipGlobal > text_171.tStartRefresh + 5.0-frameTolerance:
                # keep track of stop time/frame for later
                text_171.tStop = t  # not accounting for scr refresh
                text_171.frameNStop = frameN  # exact frame index
                # add timestamp to datafile
                thisExp.timestampOnFlip(win, 'text_171.stopped')
                # update status
                text_171.status = FINISHED
                text_171.setAutoDraw(False)
        
        # check for quit (typically the Esc key)
        if defaultKeyboard.getKeys(keyList=["escape"]):
            thisExp.status = FINISHED
        if thisExp.status == FINISHED or endExpNow:
            endExperiment(thisExp, inputs=inputs, win=win)
            return
        
        # check if all components have finished
        if not continueRoutine:  # a component has requested a forced-end of Routine
            routineForceEnded = True
            break
        continueRoutine = False  # will revert to True if at least one component still running
        for thisComponent in q3_instructionsComponents:
            if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:
                continueRoutine = True
                break  # at least one component has not yet finished
        
        # refresh the screen
        if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen
            win.flip()
    
    # --- Ending Routine "q3_instructions" ---
    for thisComponent in q3_instructionsComponents:
        if hasattr(thisComponent, "setAutoDraw"):
            thisComponent.setAutoDraw(False)
    thisExp.addData('q3_instructions.stopped', globalClock.getTime())
    # using non-slip timing so subtract the expected duration of this Routine (unless ended on request)
    if routineForceEnded:
        routineTimer.reset()
    else:
        routineTimer.addTime(-5.000000)
    
    # --- Prepare to start Routine "SPQ1" ---
    continueRoutine = True
    # update component parameters for each repeat
    thisExp.addData('SPQ1.started', globalClock.getTime())
    key_resp_46.keys = []
    key_resp_46.rt = []
    _key_resp_46_allKeys = []
    # keep track of which components have finished
    SPQ1Components = [text_173, text_174, key_resp_46]
    for thisComponent in SPQ1Components:
        thisComponent.tStart = None
        thisComponent.tStop = None
        thisComponent.tStartRefresh = None
        thisComponent.tStopRefresh = None
        if hasattr(thisComponent, 'status'):
            thisComponent.status = NOT_STARTED
    # reset timers
    t = 0
    _timeToFirstFrame = win.getFutureFlipTime(clock="now")
    frameN = -1
    
    # --- Run Routine "SPQ1" ---
    routineForceEnded = not continueRoutine
    while continueRoutine:
        # get current time
        t = routineTimer.getTime()
        tThisFlip = win.getFutureFlipTime(clock=routineTimer)
        tThisFlipGlobal = win.getFutureFlipTime(clock=None)
        frameN = frameN + 1  # number of completed frames (so 0 is the first frame)
        # update/draw components on each frame
        
        # *text_173* updates
        
        # if text_173 is starting this frame...
        if text_173.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
            # keep track of start time/frame for later
            text_173.frameNStart = frameN  # exact frame index
            text_173.tStart = t  # local t and not account for scr refresh
            text_173.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(text_173, 'tStartRefresh')  # time at next scr refresh
            # add timestamp to datafile
            thisExp.timestampOnFlip(win, 'text_173.started')
            # update status
            text_173.status = STARTED
            text_173.setAutoDraw(True)
        
        # if text_173 is active this frame...
        if text_173.status == STARTED:
            # update params
            pass
        
        # *text_174* updates
        
        # if text_174 is starting this frame...
        if text_174.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
            # keep track of start time/frame for later
            text_174.frameNStart = frameN  # exact frame index
            text_174.tStart = t  # local t and not account for scr refresh
            text_174.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(text_174, 'tStartRefresh')  # time at next scr refresh
            # add timestamp to datafile
            thisExp.timestampOnFlip(win, 'text_174.started')
            # update status
            text_174.status = STARTED
            text_174.setAutoDraw(True)
        
        # if text_174 is active this frame...
        if text_174.status == STARTED:
            # update params
            pass
        
        # *key_resp_46* updates
        waitOnFlip = False
        
        # if key_resp_46 is starting this frame...
        if key_resp_46.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
            # keep track of start time/frame for later
            key_resp_46.frameNStart = frameN  # exact frame index
            key_resp_46.tStart = t  # local t and not account for scr refresh
            key_resp_46.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(key_resp_46, 'tStartRefresh')  # time at next scr refresh
            # add timestamp to datafile
            thisExp.timestampOnFlip(win, 'key_resp_46.started')
            # update status
            key_resp_46.status = STARTED
            # keyboard checking is just starting
            waitOnFlip = True
            win.callOnFlip(key_resp_46.clock.reset)  # t=0 on next screen flip
            win.callOnFlip(key_resp_46.clearEvents, eventType='keyboard')  # clear events on next screen flip
        if key_resp_46.status == STARTED and not waitOnFlip:
            theseKeys = key_resp_46.getKeys(keyList=['y','n'], ignoreKeys=["escape"], waitRelease=False)
            _key_resp_46_allKeys.extend(theseKeys)
            if len(_key_resp_46_allKeys):
                key_resp_46.keys = _key_resp_46_allKeys[-1].name  # just the last key pressed
                key_resp_46.rt = _key_resp_46_allKeys[-1].rt
                key_resp_46.duration = _key_resp_46_allKeys[-1].duration
                # a response ends the routine
                continueRoutine = False
        
        # check for quit (typically the Esc key)
        if defaultKeyboard.getKeys(keyList=["escape"]):
            thisExp.status = FINISHED
        if thisExp.status == FINISHED or endExpNow:
            endExperiment(thisExp, inputs=inputs, win=win)
            return
        
        # check if all components have finished
        if not continueRoutine:  # a component has requested a forced-end of Routine
            routineForceEnded = True
            break
        continueRoutine = False  # will revert to True if at least one component still running
        for thisComponent in SPQ1Components:
            if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:
                continueRoutine = True
                break  # at least one component has not yet finished
        
        # refresh the screen
        if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen
            win.flip()
    
    # --- Ending Routine "SPQ1" ---
    for thisComponent in SPQ1Components:
        if hasattr(thisComponent, "setAutoDraw"):
            thisComponent.setAutoDraw(False)
    thisExp.addData('SPQ1.stopped', globalClock.getTime())
    # check responses
    if key_resp_46.keys in ['', [], None]:  # No response was made
        key_resp_46.keys = None
    thisExp.addData('key_resp_46.keys',key_resp_46.keys)
    if key_resp_46.keys != None:  # we had a response
        thisExp.addData('key_resp_46.rt', key_resp_46.rt)
        thisExp.addData('key_resp_46.duration', key_resp_46.duration)
    thisExp.nextEntry()
    # the Routine "SPQ1" was not non-slip safe, so reset the non-slip timer
    routineTimer.reset()
    
    # --- Prepare to start Routine "SPQ2" ---
    continueRoutine = True
    # update component parameters for each repeat
    thisExp.addData('SPQ2.started', globalClock.getTime())
    key_resp_47.keys = []
    key_resp_47.rt = []
    _key_resp_47_allKeys = []
    # keep track of which components have finished
    SPQ2Components = [text_175, text_176, key_resp_47]
    for thisComponent in SPQ2Components:
        thisComponent.tStart = None
        thisComponent.tStop = None
        thisComponent.tStartRefresh = None
        thisComponent.tStopRefresh = None
        if hasattr(thisComponent, 'status'):
            thisComponent.status = NOT_STARTED
    # reset timers
    t = 0
    _timeToFirstFrame = win.getFutureFlipTime(clock="now")
    frameN = -1
    
    # --- Run Routine "SPQ2" ---
    routineForceEnded = not continueRoutine
    while continueRoutine:
        # get current time
        t = routineTimer.getTime()
        tThisFlip = win.getFutureFlipTime(clock=routineTimer)
        tThisFlipGlobal = win.getFutureFlipTime(clock=None)
        frameN = frameN + 1  # number of completed frames (so 0 is the first frame)
        # update/draw components on each frame
        
        # *text_175* updates
        
        # if text_175 is starting this frame...
        if text_175.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
            # keep track of start time/frame for later
            text_175.frameNStart = frameN  # exact frame index
            text_175.tStart = t  # local t and not account for scr refresh
            text_175.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(text_175, 'tStartRefresh')  # time at next scr refresh
            # add timestamp to datafile
            thisExp.timestampOnFlip(win, 'text_175.started')
            # update status
            text_175.status = STARTED
            text_175.setAutoDraw(True)
        
        # if text_175 is active this frame...
        if text_175.status == STARTED:
            # update params
            pass
        
        # *text_176* updates
        
        # if text_176 is starting this frame...
        if text_176.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
            # keep track of start time/frame for later
            text_176.frameNStart = frameN  # exact frame index
            text_176.tStart = t  # local t and not account for scr refresh
            text_176.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(text_176, 'tStartRefresh')  # time at next scr refresh
            # add timestamp to datafile
            thisExp.timestampOnFlip(win, 'text_176.started')
            # update status
            text_176.status = STARTED
            text_176.setAutoDraw(True)
        
        # if text_176 is active this frame...
        if text_176.status == STARTED:
            # update params
            pass
        
        # *key_resp_47* updates
        waitOnFlip = False
        
        # if key_resp_47 is starting this frame...
        if key_resp_47.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
            # keep track of start time/frame for later
            key_resp_47.frameNStart = frameN  # exact frame index
            key_resp_47.tStart = t  # local t and not account for scr refresh
            key_resp_47.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(key_resp_47, 'tStartRefresh')  # time at next scr refresh
            # add timestamp to datafile
            thisExp.timestampOnFlip(win, 'key_resp_47.started')
            # update status
            key_resp_47.status = STARTED
            # keyboard checking is just starting
            waitOnFlip = True
            win.callOnFlip(key_resp_47.clock.reset)  # t=0 on next screen flip
            win.callOnFlip(key_resp_47.clearEvents, eventType='keyboard')  # clear events on next screen flip
        if key_resp_47.status == STARTED and not waitOnFlip:
            theseKeys = key_resp_47.getKeys(keyList=['y','n'], ignoreKeys=["escape"], waitRelease=False)
            _key_resp_47_allKeys.extend(theseKeys)
            if len(_key_resp_47_allKeys):
                key_resp_47.keys = _key_resp_47_allKeys[-1].name  # just the last key pressed
                key_resp_47.rt = _key_resp_47_allKeys[-1].rt
                key_resp_47.duration = _key_resp_47_allKeys[-1].duration
                # a response ends the routine
                continueRoutine = False
        
        # check for quit (typically the Esc key)
        if defaultKeyboard.getKeys(keyList=["escape"]):
            thisExp.status = FINISHED
        if thisExp.status == FINISHED or endExpNow:
            endExperiment(thisExp, inputs=inputs, win=win)
            return
        
        # check if all components have finished
        if not continueRoutine:  # a component has requested a forced-end of Routine
            routineForceEnded = True
            break
        continueRoutine = False  # will revert to True if at least one component still running
        for thisComponent in SPQ2Components:
            if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:
                continueRoutine = True
                break  # at least one component has not yet finished
        
        # refresh the screen
        if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen
            win.flip()
    
    # --- Ending Routine "SPQ2" ---
    for thisComponent in SPQ2Components:
        if hasattr(thisComponent, "setAutoDraw"):
            thisComponent.setAutoDraw(False)
    thisExp.addData('SPQ2.stopped', globalClock.getTime())
    # check responses
    if key_resp_47.keys in ['', [], None]:  # No response was made
        key_resp_47.keys = None
    thisExp.addData('key_resp_47.keys',key_resp_47.keys)
    if key_resp_47.keys != None:  # we had a response
        thisExp.addData('key_resp_47.rt', key_resp_47.rt)
        thisExp.addData('key_resp_47.duration', key_resp_47.duration)
    thisExp.nextEntry()
    # the Routine "SPQ2" was not non-slip safe, so reset the non-slip timer
    routineTimer.reset()
    
    # --- Prepare to start Routine "SPQ3" ---
    continueRoutine = True
    # update component parameters for each repeat
    thisExp.addData('SPQ3.started', globalClock.getTime())
    key_resp_48.keys = []
    key_resp_48.rt = []
    _key_resp_48_allKeys = []
    # keep track of which components have finished
    SPQ3Components = [text_177, text_178, key_resp_48]
    for thisComponent in SPQ3Components:
        thisComponent.tStart = None
        thisComponent.tStop = None
        thisComponent.tStartRefresh = None
        thisComponent.tStopRefresh = None
        if hasattr(thisComponent, 'status'):
            thisComponent.status = NOT_STARTED
    # reset timers
    t = 0
    _timeToFirstFrame = win.getFutureFlipTime(clock="now")
    frameN = -1
    
    # --- Run Routine "SPQ3" ---
    routineForceEnded = not continueRoutine
    while continueRoutine:
        # get current time
        t = routineTimer.getTime()
        tThisFlip = win.getFutureFlipTime(clock=routineTimer)
        tThisFlipGlobal = win.getFutureFlipTime(clock=None)
        frameN = frameN + 1  # number of completed frames (so 0 is the first frame)
        # update/draw components on each frame
        
        # *text_177* updates
        
        # if text_177 is starting this frame...
        if text_177.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
            # keep track of start time/frame for later
            text_177.frameNStart = frameN  # exact frame index
            text_177.tStart = t  # local t and not account for scr refresh
            text_177.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(text_177, 'tStartRefresh')  # time at next scr refresh
            # add timestamp to datafile
            thisExp.timestampOnFlip(win, 'text_177.started')
            # update status
            text_177.status = STARTED
            text_177.setAutoDraw(True)
        
        # if text_177 is active this frame...
        if text_177.status == STARTED:
            # update params
            pass
        
        # *text_178* updates
        
        # if text_178 is starting this frame...
        if text_178.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
            # keep track of start time/frame for later
            text_178.frameNStart = frameN  # exact frame index
            text_178.tStart = t  # local t and not account for scr refresh
            text_178.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(text_178, 'tStartRefresh')  # time at next scr refresh
            # add timestamp to datafile
            thisExp.timestampOnFlip(win, 'text_178.started')
            # update status
            text_178.status = STARTED
            text_178.setAutoDraw(True)
        
        # if text_178 is active this frame...
        if text_178.status == STARTED:
            # update params
            pass
        
        # *key_resp_48* updates
        waitOnFlip = False
        
        # if key_resp_48 is starting this frame...
        if key_resp_48.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
            # keep track of start time/frame for later
            key_resp_48.frameNStart = frameN  # exact frame index
            key_resp_48.tStart = t  # local t and not account for scr refresh
            key_resp_48.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(key_resp_48, 'tStartRefresh')  # time at next scr refresh
            # add timestamp to datafile
            thisExp.timestampOnFlip(win, 'key_resp_48.started')
            # update status
            key_resp_48.status = STARTED
            # keyboard checking is just starting
            waitOnFlip = True
            win.callOnFlip(key_resp_48.clock.reset)  # t=0 on next screen flip
            win.callOnFlip(key_resp_48.clearEvents, eventType='keyboard')  # clear events on next screen flip
        if key_resp_48.status == STARTED and not waitOnFlip:
            theseKeys = key_resp_48.getKeys(keyList=['y','n'], ignoreKeys=["escape"], waitRelease=False)
            _key_resp_48_allKeys.extend(theseKeys)
            if len(_key_resp_48_allKeys):
                key_resp_48.keys = _key_resp_48_allKeys[-1].name  # just the last key pressed
                key_resp_48.rt = _key_resp_48_allKeys[-1].rt
                key_resp_48.duration = _key_resp_48_allKeys[-1].duration
                # a response ends the routine
                continueRoutine = False
        
        # check for quit (typically the Esc key)
        if defaultKeyboard.getKeys(keyList=["escape"]):
            thisExp.status = FINISHED
        if thisExp.status == FINISHED or endExpNow:
            endExperiment(thisExp, inputs=inputs, win=win)
            return
        
        # check if all components have finished
        if not continueRoutine:  # a component has requested a forced-end of Routine
            routineForceEnded = True
            break
        continueRoutine = False  # will revert to True if at least one component still running
        for thisComponent in SPQ3Components:
            if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:
                continueRoutine = True
                break  # at least one component has not yet finished
        
        # refresh the screen
        if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen
            win.flip()
    
    # --- Ending Routine "SPQ3" ---
    for thisComponent in SPQ3Components:
        if hasattr(thisComponent, "setAutoDraw"):
            thisComponent.setAutoDraw(False)
    thisExp.addData('SPQ3.stopped', globalClock.getTime())
    # check responses
    if key_resp_48.keys in ['', [], None]:  # No response was made
        key_resp_48.keys = None
    thisExp.addData('key_resp_48.keys',key_resp_48.keys)
    if key_resp_48.keys != None:  # we had a response
        thisExp.addData('key_resp_48.rt', key_resp_48.rt)
        thisExp.addData('key_resp_48.duration', key_resp_48.duration)
    thisExp.nextEntry()
    # the Routine "SPQ3" was not non-slip safe, so reset the non-slip timer
    routineTimer.reset()
    
    # --- Prepare to start Routine "SPQ4" ---
    continueRoutine = True
    # update component parameters for each repeat
    thisExp.addData('SPQ4.started', globalClock.getTime())
    key_resp_49.keys = []
    key_resp_49.rt = []
    _key_resp_49_allKeys = []
    # keep track of which components have finished
    SPQ4Components = [text_179, text_180, key_resp_49]
    for thisComponent in SPQ4Components:
        thisComponent.tStart = None
        thisComponent.tStop = None
        thisComponent.tStartRefresh = None
        thisComponent.tStopRefresh = None
        if hasattr(thisComponent, 'status'):
            thisComponent.status = NOT_STARTED
    # reset timers
    t = 0
    _timeToFirstFrame = win.getFutureFlipTime(clock="now")
    frameN = -1
    
    # --- Run Routine "SPQ4" ---
    routineForceEnded = not continueRoutine
    while continueRoutine:
        # get current time
        t = routineTimer.getTime()
        tThisFlip = win.getFutureFlipTime(clock=routineTimer)
        tThisFlipGlobal = win.getFutureFlipTime(clock=None)
        frameN = frameN + 1  # number of completed frames (so 0 is the first frame)
        # update/draw components on each frame
        
        # *text_179* updates
        
        # if text_179 is starting this frame...
        if text_179.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
            # keep track of start time/frame for later
            text_179.frameNStart = frameN  # exact frame index
            text_179.tStart = t  # local t and not account for scr refresh
            text_179.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(text_179, 'tStartRefresh')  # time at next scr refresh
            # add timestamp to datafile
            thisExp.timestampOnFlip(win, 'text_179.started')
            # update status
            text_179.status = STARTED
            text_179.setAutoDraw(True)
        
        # if text_179 is active this frame...
        if text_179.status == STARTED:
            # update params
            pass
        
        # *text_180* updates
        
        # if text_180 is starting this frame...
        if text_180.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
            # keep track of start time/frame for later
            text_180.frameNStart = frameN  # exact frame index
            text_180.tStart = t  # local t and not account for scr refresh
            text_180.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(text_180, 'tStartRefresh')  # time at next scr refresh
            # add timestamp to datafile
            thisExp.timestampOnFlip(win, 'text_180.started')
            # update status
            text_180.status = STARTED
            text_180.setAutoDraw(True)
        
        # if text_180 is active this frame...
        if text_180.status == STARTED:
            # update params
            pass
        
        # *key_resp_49* updates
        waitOnFlip = False
        
        # if key_resp_49 is starting this frame...
        if key_resp_49.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
            # keep track of start time/frame for later
            key_resp_49.frameNStart = frameN  # exact frame index
            key_resp_49.tStart = t  # local t and not account for scr refresh
            key_resp_49.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(key_resp_49, 'tStartRefresh')  # time at next scr refresh
            # add timestamp to datafile
            thisExp.timestampOnFlip(win, 'key_resp_49.started')
            # update status
            key_resp_49.status = STARTED
            # keyboard checking is just starting
            waitOnFlip = True
            win.callOnFlip(key_resp_49.clock.reset)  # t=0 on next screen flip
            win.callOnFlip(key_resp_49.clearEvents, eventType='keyboard')  # clear events on next screen flip
        if key_resp_49.status == STARTED and not waitOnFlip:
            theseKeys = key_resp_49.getKeys(keyList=['y','n'], ignoreKeys=["escape"], waitRelease=False)
            _key_resp_49_allKeys.extend(theseKeys)
            if len(_key_resp_49_allKeys):
                key_resp_49.keys = _key_resp_49_allKeys[-1].name  # just the last key pressed
                key_resp_49.rt = _key_resp_49_allKeys[-1].rt
                key_resp_49.duration = _key_resp_49_allKeys[-1].duration
                # a response ends the routine
                continueRoutine = False
        
        # check for quit (typically the Esc key)
        if defaultKeyboard.getKeys(keyList=["escape"]):
            thisExp.status = FINISHED
        if thisExp.status == FINISHED or endExpNow:
            endExperiment(thisExp, inputs=inputs, win=win)
            return
        
        # check if all components have finished
        if not continueRoutine:  # a component has requested a forced-end of Routine
            routineForceEnded = True
            break
        continueRoutine = False  # will revert to True if at least one component still running
        for thisComponent in SPQ4Components:
            if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:
                continueRoutine = True
                break  # at least one component has not yet finished
        
        # refresh the screen
        if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen
            win.flip()
    
    # --- Ending Routine "SPQ4" ---
    for thisComponent in SPQ4Components:
        if hasattr(thisComponent, "setAutoDraw"):
            thisComponent.setAutoDraw(False)
    thisExp.addData('SPQ4.stopped', globalClock.getTime())
    # check responses
    if key_resp_49.keys in ['', [], None]:  # No response was made
        key_resp_49.keys = None
    thisExp.addData('key_resp_49.keys',key_resp_49.keys)
    if key_resp_49.keys != None:  # we had a response
        thisExp.addData('key_resp_49.rt', key_resp_49.rt)
        thisExp.addData('key_resp_49.duration', key_resp_49.duration)
    thisExp.nextEntry()
    # the Routine "SPQ4" was not non-slip safe, so reset the non-slip timer
    routineTimer.reset()
    
    # --- Prepare to start Routine "SPQ5" ---
    continueRoutine = True
    # update component parameters for each repeat
    thisExp.addData('SPQ5.started', globalClock.getTime())
    key_resp_50.keys = []
    key_resp_50.rt = []
    _key_resp_50_allKeys = []
    # keep track of which components have finished
    SPQ5Components = [text_181, text_182, key_resp_50]
    for thisComponent in SPQ5Components:
        thisComponent.tStart = None
        thisComponent.tStop = None
        thisComponent.tStartRefresh = None
        thisComponent.tStopRefresh = None
        if hasattr(thisComponent, 'status'):
            thisComponent.status = NOT_STARTED
    # reset timers
    t = 0
    _timeToFirstFrame = win.getFutureFlipTime(clock="now")
    frameN = -1
    
    # --- Run Routine "SPQ5" ---
    routineForceEnded = not continueRoutine
    while continueRoutine:
        # get current time
        t = routineTimer.getTime()
        tThisFlip = win.getFutureFlipTime(clock=routineTimer)
        tThisFlipGlobal = win.getFutureFlipTime(clock=None)
        frameN = frameN + 1  # number of completed frames (so 0 is the first frame)
        # update/draw components on each frame
        
        # *text_181* updates
        
        # if text_181 is starting this frame...
        if text_181.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
            # keep track of start time/frame for later
            text_181.frameNStart = frameN  # exact frame index
            text_181.tStart = t  # local t and not account for scr refresh
            text_181.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(text_181, 'tStartRefresh')  # time at next scr refresh
            # add timestamp to datafile
            thisExp.timestampOnFlip(win, 'text_181.started')
            # update status
            text_181.status = STARTED
            text_181.setAutoDraw(True)
        
        # if text_181 is active this frame...
        if text_181.status == STARTED:
            # update params
            pass
        
        # *text_182* updates
        
        # if text_182 is starting this frame...
        if text_182.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
            # keep track of start time/frame for later
            text_182.frameNStart = frameN  # exact frame index
            text_182.tStart = t  # local t and not account for scr refresh
            text_182.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(text_182, 'tStartRefresh')  # time at next scr refresh
            # add timestamp to datafile
            thisExp.timestampOnFlip(win, 'text_182.started')
            # update status
            text_182.status = STARTED
            text_182.setAutoDraw(True)
        
        # if text_182 is active this frame...
        if text_182.status == STARTED:
            # update params
            pass
        
        # *key_resp_50* updates
        waitOnFlip = False
        
        # if key_resp_50 is starting this frame...
        if key_resp_50.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
            # keep track of start time/frame for later
            key_resp_50.frameNStart = frameN  # exact frame index
            key_resp_50.tStart = t  # local t and not account for scr refresh
            key_resp_50.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(key_resp_50, 'tStartRefresh')  # time at next scr refresh
            # add timestamp to datafile
            thisExp.timestampOnFlip(win, 'key_resp_50.started')
            # update status
            key_resp_50.status = STARTED
            # keyboard checking is just starting
            waitOnFlip = True
            win.callOnFlip(key_resp_50.clock.reset)  # t=0 on next screen flip
            win.callOnFlip(key_resp_50.clearEvents, eventType='keyboard')  # clear events on next screen flip
        if key_resp_50.status == STARTED and not waitOnFlip:
            theseKeys = key_resp_50.getKeys(keyList=['y','n'], ignoreKeys=["escape"], waitRelease=False)
            _key_resp_50_allKeys.extend(theseKeys)
            if len(_key_resp_50_allKeys):
                key_resp_50.keys = _key_resp_50_allKeys[-1].name  # just the last key pressed
                key_resp_50.rt = _key_resp_50_allKeys[-1].rt
                key_resp_50.duration = _key_resp_50_allKeys[-1].duration
                # a response ends the routine
                continueRoutine = False
        
        # check for quit (typically the Esc key)
        if defaultKeyboard.getKeys(keyList=["escape"]):
            thisExp.status = FINISHED
        if thisExp.status == FINISHED or endExpNow:
            endExperiment(thisExp, inputs=inputs, win=win)
            return
        
        # check if all components have finished
        if not continueRoutine:  # a component has requested a forced-end of Routine
            routineForceEnded = True
            break
        continueRoutine = False  # will revert to True if at least one component still running
        for thisComponent in SPQ5Components:
            if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:
                continueRoutine = True
                break  # at least one component has not yet finished
        
        # refresh the screen
        if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen
            win.flip()
    
    # --- Ending Routine "SPQ5" ---
    for thisComponent in SPQ5Components:
        if hasattr(thisComponent, "setAutoDraw"):
            thisComponent.setAutoDraw(False)
    thisExp.addData('SPQ5.stopped', globalClock.getTime())
    # check responses
    if key_resp_50.keys in ['', [], None]:  # No response was made
        key_resp_50.keys = None
    thisExp.addData('key_resp_50.keys',key_resp_50.keys)
    if key_resp_50.keys != None:  # we had a response
        thisExp.addData('key_resp_50.rt', key_resp_50.rt)
        thisExp.addData('key_resp_50.duration', key_resp_50.duration)
    thisExp.nextEntry()
    # the Routine "SPQ5" was not non-slip safe, so reset the non-slip timer
    routineTimer.reset()
    
    # --- Prepare to start Routine "SPQ6" ---
    continueRoutine = True
    # update component parameters for each repeat
    thisExp.addData('SPQ6.started', globalClock.getTime())
    key_resp_51.keys = []
    key_resp_51.rt = []
    _key_resp_51_allKeys = []
    # keep track of which components have finished
    SPQ6Components = [text_183, text_184, key_resp_51]
    for thisComponent in SPQ6Components:
        thisComponent.tStart = None
        thisComponent.tStop = None
        thisComponent.tStartRefresh = None
        thisComponent.tStopRefresh = None
        if hasattr(thisComponent, 'status'):
            thisComponent.status = NOT_STARTED
    # reset timers
    t = 0
    _timeToFirstFrame = win.getFutureFlipTime(clock="now")
    frameN = -1
    
    # --- Run Routine "SPQ6" ---
    routineForceEnded = not continueRoutine
    while continueRoutine:
        # get current time
        t = routineTimer.getTime()
        tThisFlip = win.getFutureFlipTime(clock=routineTimer)
        tThisFlipGlobal = win.getFutureFlipTime(clock=None)
        frameN = frameN + 1  # number of completed frames (so 0 is the first frame)
        # update/draw components on each frame
        
        # *text_183* updates
        
        # if text_183 is starting this frame...
        if text_183.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
            # keep track of start time/frame for later
            text_183.frameNStart = frameN  # exact frame index
            text_183.tStart = t  # local t and not account for scr refresh
            text_183.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(text_183, 'tStartRefresh')  # time at next scr refresh
            # add timestamp to datafile
            thisExp.timestampOnFlip(win, 'text_183.started')
            # update status
            text_183.status = STARTED
            text_183.setAutoDraw(True)
        
        # if text_183 is active this frame...
        if text_183.status == STARTED:
            # update params
            pass
        
        # *text_184* updates
        
        # if text_184 is starting this frame...
        if text_184.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
            # keep track of start time/frame for later
            text_184.frameNStart = frameN  # exact frame index
            text_184.tStart = t  # local t and not account for scr refresh
            text_184.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(text_184, 'tStartRefresh')  # time at next scr refresh
            # add timestamp to datafile
            thisExp.timestampOnFlip(win, 'text_184.started')
            # update status
            text_184.status = STARTED
            text_184.setAutoDraw(True)
        
        # if text_184 is active this frame...
        if text_184.status == STARTED:
            # update params
            pass
        
        # *key_resp_51* updates
        waitOnFlip = False
        
        # if key_resp_51 is starting this frame...
        if key_resp_51.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
            # keep track of start time/frame for later
            key_resp_51.frameNStart = frameN  # exact frame index
            key_resp_51.tStart = t  # local t and not account for scr refresh
            key_resp_51.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(key_resp_51, 'tStartRefresh')  # time at next scr refresh
            # add timestamp to datafile
            thisExp.timestampOnFlip(win, 'key_resp_51.started')
            # update status
            key_resp_51.status = STARTED
            # keyboard checking is just starting
            waitOnFlip = True
            win.callOnFlip(key_resp_51.clock.reset)  # t=0 on next screen flip
            win.callOnFlip(key_resp_51.clearEvents, eventType='keyboard')  # clear events on next screen flip
        if key_resp_51.status == STARTED and not waitOnFlip:
            theseKeys = key_resp_51.getKeys(keyList=['y','n'], ignoreKeys=["escape"], waitRelease=False)
            _key_resp_51_allKeys.extend(theseKeys)
            if len(_key_resp_51_allKeys):
                key_resp_51.keys = _key_resp_51_allKeys[-1].name  # just the last key pressed
                key_resp_51.rt = _key_resp_51_allKeys[-1].rt
                key_resp_51.duration = _key_resp_51_allKeys[-1].duration
                # a response ends the routine
                continueRoutine = False
        
        # check for quit (typically the Esc key)
        if defaultKeyboard.getKeys(keyList=["escape"]):
            thisExp.status = FINISHED
        if thisExp.status == FINISHED or endExpNow:
            endExperiment(thisExp, inputs=inputs, win=win)
            return
        
        # check if all components have finished
        if not continueRoutine:  # a component has requested a forced-end of Routine
            routineForceEnded = True
            break
        continueRoutine = False  # will revert to True if at least one component still running
        for thisComponent in SPQ6Components:
            if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:
                continueRoutine = True
                break  # at least one component has not yet finished
        
        # refresh the screen
        if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen
            win.flip()
    
    # --- Ending Routine "SPQ6" ---
    for thisComponent in SPQ6Components:
        if hasattr(thisComponent, "setAutoDraw"):
            thisComponent.setAutoDraw(False)
    thisExp.addData('SPQ6.stopped', globalClock.getTime())
    # check responses
    if key_resp_51.keys in ['', [], None]:  # No response was made
        key_resp_51.keys = None
    thisExp.addData('key_resp_51.keys',key_resp_51.keys)
    if key_resp_51.keys != None:  # we had a response
        thisExp.addData('key_resp_51.rt', key_resp_51.rt)
        thisExp.addData('key_resp_51.duration', key_resp_51.duration)
    thisExp.nextEntry()
    # the Routine "SPQ6" was not non-slip safe, so reset the non-slip timer
    routineTimer.reset()
    
    # --- Prepare to start Routine "SPQ7" ---
    continueRoutine = True
    # update component parameters for each repeat
    thisExp.addData('SPQ7.started', globalClock.getTime())
    key_resp_52.keys = []
    key_resp_52.rt = []
    _key_resp_52_allKeys = []
    # keep track of which components have finished
    SPQ7Components = [text_185, text_186, key_resp_52]
    for thisComponent in SPQ7Components:
        thisComponent.tStart = None
        thisComponent.tStop = None
        thisComponent.tStartRefresh = None
        thisComponent.tStopRefresh = None
        if hasattr(thisComponent, 'status'):
            thisComponent.status = NOT_STARTED
    # reset timers
    t = 0
    _timeToFirstFrame = win.getFutureFlipTime(clock="now")
    frameN = -1
    
    # --- Run Routine "SPQ7" ---
    routineForceEnded = not continueRoutine
    while continueRoutine:
        # get current time
        t = routineTimer.getTime()
        tThisFlip = win.getFutureFlipTime(clock=routineTimer)
        tThisFlipGlobal = win.getFutureFlipTime(clock=None)
        frameN = frameN + 1  # number of completed frames (so 0 is the first frame)
        # update/draw components on each frame
        
        # *text_185* updates
        
        # if text_185 is starting this frame...
        if text_185.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
            # keep track of start time/frame for later
            text_185.frameNStart = frameN  # exact frame index
            text_185.tStart = t  # local t and not account for scr refresh
            text_185.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(text_185, 'tStartRefresh')  # time at next scr refresh
            # add timestamp to datafile
            thisExp.timestampOnFlip(win, 'text_185.started')
            # update status
            text_185.status = STARTED
            text_185.setAutoDraw(True)
        
        # if text_185 is active this frame...
        if text_185.status == STARTED:
            # update params
            pass
        
        # *text_186* updates
        
        # if text_186 is starting this frame...
        if text_186.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
            # keep track of start time/frame for later
            text_186.frameNStart = frameN  # exact frame index
            text_186.tStart = t  # local t and not account for scr refresh
            text_186.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(text_186, 'tStartRefresh')  # time at next scr refresh
            # add timestamp to datafile
            thisExp.timestampOnFlip(win, 'text_186.started')
            # update status
            text_186.status = STARTED
            text_186.setAutoDraw(True)
        
        # if text_186 is active this frame...
        if text_186.status == STARTED:
            # update params
            pass
        
        # *key_resp_52* updates
        waitOnFlip = False
        
        # if key_resp_52 is starting this frame...
        if key_resp_52.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
            # keep track of start time/frame for later
            key_resp_52.frameNStart = frameN  # exact frame index
            key_resp_52.tStart = t  # local t and not account for scr refresh
            key_resp_52.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(key_resp_52, 'tStartRefresh')  # time at next scr refresh
            # add timestamp to datafile
            thisExp.timestampOnFlip(win, 'key_resp_52.started')
            # update status
            key_resp_52.status = STARTED
            # keyboard checking is just starting
            waitOnFlip = True
            win.callOnFlip(key_resp_52.clock.reset)  # t=0 on next screen flip
            win.callOnFlip(key_resp_52.clearEvents, eventType='keyboard')  # clear events on next screen flip
        if key_resp_52.status == STARTED and not waitOnFlip:
            theseKeys = key_resp_52.getKeys(keyList=['y','n'], ignoreKeys=["escape"], waitRelease=False)
            _key_resp_52_allKeys.extend(theseKeys)
            if len(_key_resp_52_allKeys):
                key_resp_52.keys = _key_resp_52_allKeys[-1].name  # just the last key pressed
                key_resp_52.rt = _key_resp_52_allKeys[-1].rt
                key_resp_52.duration = _key_resp_52_allKeys[-1].duration
                # a response ends the routine
                continueRoutine = False
        
        # check for quit (typically the Esc key)
        if defaultKeyboard.getKeys(keyList=["escape"]):
            thisExp.status = FINISHED
        if thisExp.status == FINISHED or endExpNow:
            endExperiment(thisExp, inputs=inputs, win=win)
            return
        
        # check if all components have finished
        if not continueRoutine:  # a component has requested a forced-end of Routine
            routineForceEnded = True
            break
        continueRoutine = False  # will revert to True if at least one component still running
        for thisComponent in SPQ7Components:
            if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:
                continueRoutine = True
                break  # at least one component has not yet finished
        
        # refresh the screen
        if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen
            win.flip()
    
    # --- Ending Routine "SPQ7" ---
    for thisComponent in SPQ7Components:
        if hasattr(thisComponent, "setAutoDraw"):
            thisComponent.setAutoDraw(False)
    thisExp.addData('SPQ7.stopped', globalClock.getTime())
    # check responses
    if key_resp_52.keys in ['', [], None]:  # No response was made
        key_resp_52.keys = None
    thisExp.addData('key_resp_52.keys',key_resp_52.keys)
    if key_resp_52.keys != None:  # we had a response
        thisExp.addData('key_resp_52.rt', key_resp_52.rt)
        thisExp.addData('key_resp_52.duration', key_resp_52.duration)
    thisExp.nextEntry()
    # the Routine "SPQ7" was not non-slip safe, so reset the non-slip timer
    routineTimer.reset()
    
    # --- Prepare to start Routine "SPQ8" ---
    continueRoutine = True
    # update component parameters for each repeat
    thisExp.addData('SPQ8.started', globalClock.getTime())
    key_resp_53.keys = []
    key_resp_53.rt = []
    _key_resp_53_allKeys = []
    # keep track of which components have finished
    SPQ8Components = [text_187, text_188, key_resp_53]
    for thisComponent in SPQ8Components:
        thisComponent.tStart = None
        thisComponent.tStop = None
        thisComponent.tStartRefresh = None
        thisComponent.tStopRefresh = None
        if hasattr(thisComponent, 'status'):
            thisComponent.status = NOT_STARTED
    # reset timers
    t = 0
    _timeToFirstFrame = win.getFutureFlipTime(clock="now")
    frameN = -1
    
    # --- Run Routine "SPQ8" ---
    routineForceEnded = not continueRoutine
    while continueRoutine:
        # get current time
        t = routineTimer.getTime()
        tThisFlip = win.getFutureFlipTime(clock=routineTimer)
        tThisFlipGlobal = win.getFutureFlipTime(clock=None)
        frameN = frameN + 1  # number of completed frames (so 0 is the first frame)
        # update/draw components on each frame
        
        # *text_187* updates
        
        # if text_187 is starting this frame...
        if text_187.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
            # keep track of start time/frame for later
            text_187.frameNStart = frameN  # exact frame index
            text_187.tStart = t  # local t and not account for scr refresh
            text_187.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(text_187, 'tStartRefresh')  # time at next scr refresh
            # add timestamp to datafile
            thisExp.timestampOnFlip(win, 'text_187.started')
            # update status
            text_187.status = STARTED
            text_187.setAutoDraw(True)
        
        # if text_187 is active this frame...
        if text_187.status == STARTED:
            # update params
            pass
        
        # *text_188* updates
        
        # if text_188 is starting this frame...
        if text_188.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
            # keep track of start time/frame for later
            text_188.frameNStart = frameN  # exact frame index
            text_188.tStart = t  # local t and not account for scr refresh
            text_188.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(text_188, 'tStartRefresh')  # time at next scr refresh
            # add timestamp to datafile
            thisExp.timestampOnFlip(win, 'text_188.started')
            # update status
            text_188.status = STARTED
            text_188.setAutoDraw(True)
        
        # if text_188 is active this frame...
        if text_188.status == STARTED:
            # update params
            pass
        
        # *key_resp_53* updates
        waitOnFlip = False
        
        # if key_resp_53 is starting this frame...
        if key_resp_53.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
            # keep track of start time/frame for later
            key_resp_53.frameNStart = frameN  # exact frame index
            key_resp_53.tStart = t  # local t and not account for scr refresh
            key_resp_53.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(key_resp_53, 'tStartRefresh')  # time at next scr refresh
            # add timestamp to datafile
            thisExp.timestampOnFlip(win, 'key_resp_53.started')
            # update status
            key_resp_53.status = STARTED
            # keyboard checking is just starting
            waitOnFlip = True
            win.callOnFlip(key_resp_53.clock.reset)  # t=0 on next screen flip
            win.callOnFlip(key_resp_53.clearEvents, eventType='keyboard')  # clear events on next screen flip
        if key_resp_53.status == STARTED and not waitOnFlip:
            theseKeys = key_resp_53.getKeys(keyList=['y','n'], ignoreKeys=["escape"], waitRelease=False)
            _key_resp_53_allKeys.extend(theseKeys)
            if len(_key_resp_53_allKeys):
                key_resp_53.keys = _key_resp_53_allKeys[-1].name  # just the last key pressed
                key_resp_53.rt = _key_resp_53_allKeys[-1].rt
                key_resp_53.duration = _key_resp_53_allKeys[-1].duration
                # a response ends the routine
                continueRoutine = False
        
        # check for quit (typically the Esc key)
        if defaultKeyboard.getKeys(keyList=["escape"]):
            thisExp.status = FINISHED
        if thisExp.status == FINISHED or endExpNow:
            endExperiment(thisExp, inputs=inputs, win=win)
            return
        
        # check if all components have finished
        if not continueRoutine:  # a component has requested a forced-end of Routine
            routineForceEnded = True
            break
        continueRoutine = False  # will revert to True if at least one component still running
        for thisComponent in SPQ8Components:
            if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:
                continueRoutine = True
                break  # at least one component has not yet finished
        
        # refresh the screen
        if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen
            win.flip()
    
    # --- Ending Routine "SPQ8" ---
    for thisComponent in SPQ8Components:
        if hasattr(thisComponent, "setAutoDraw"):
            thisComponent.setAutoDraw(False)
    thisExp.addData('SPQ8.stopped', globalClock.getTime())
    # check responses
    if key_resp_53.keys in ['', [], None]:  # No response was made
        key_resp_53.keys = None
    thisExp.addData('key_resp_53.keys',key_resp_53.keys)
    if key_resp_53.keys != None:  # we had a response
        thisExp.addData('key_resp_53.rt', key_resp_53.rt)
        thisExp.addData('key_resp_53.duration', key_resp_53.duration)
    thisExp.nextEntry()
    # the Routine "SPQ8" was not non-slip safe, so reset the non-slip timer
    routineTimer.reset()
    
    # --- Prepare to start Routine "SPQ9" ---
    continueRoutine = True
    # update component parameters for each repeat
    thisExp.addData('SPQ9.started', globalClock.getTime())
    key_resp_54.keys = []
    key_resp_54.rt = []
    _key_resp_54_allKeys = []
    # keep track of which components have finished
    SPQ9Components = [text_189, text_190, key_resp_54]
    for thisComponent in SPQ9Components:
        thisComponent.tStart = None
        thisComponent.tStop = None
        thisComponent.tStartRefresh = None
        thisComponent.tStopRefresh = None
        if hasattr(thisComponent, 'status'):
            thisComponent.status = NOT_STARTED
    # reset timers
    t = 0
    _timeToFirstFrame = win.getFutureFlipTime(clock="now")
    frameN = -1
    
    # --- Run Routine "SPQ9" ---
    routineForceEnded = not continueRoutine
    while continueRoutine:
        # get current time
        t = routineTimer.getTime()
        tThisFlip = win.getFutureFlipTime(clock=routineTimer)
        tThisFlipGlobal = win.getFutureFlipTime(clock=None)
        frameN = frameN + 1  # number of completed frames (so 0 is the first frame)
        # update/draw components on each frame
        
        # *text_189* updates
        
        # if text_189 is starting this frame...
        if text_189.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
            # keep track of start time/frame for later
            text_189.frameNStart = frameN  # exact frame index
            text_189.tStart = t  # local t and not account for scr refresh
            text_189.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(text_189, 'tStartRefresh')  # time at next scr refresh
            # add timestamp to datafile
            thisExp.timestampOnFlip(win, 'text_189.started')
            # update status
            text_189.status = STARTED
            text_189.setAutoDraw(True)
        
        # if text_189 is active this frame...
        if text_189.status == STARTED:
            # update params
            pass
        
        # *text_190* updates
        
        # if text_190 is starting this frame...
        if text_190.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
            # keep track of start time/frame for later
            text_190.frameNStart = frameN  # exact frame index
            text_190.tStart = t  # local t and not account for scr refresh
            text_190.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(text_190, 'tStartRefresh')  # time at next scr refresh
            # add timestamp to datafile
            thisExp.timestampOnFlip(win, 'text_190.started')
            # update status
            text_190.status = STARTED
            text_190.setAutoDraw(True)
        
        # if text_190 is active this frame...
        if text_190.status == STARTED:
            # update params
            pass
        
        # *key_resp_54* updates
        waitOnFlip = False
        
        # if key_resp_54 is starting this frame...
        if key_resp_54.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
            # keep track of start time/frame for later
            key_resp_54.frameNStart = frameN  # exact frame index
            key_resp_54.tStart = t  # local t and not account for scr refresh
            key_resp_54.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(key_resp_54, 'tStartRefresh')  # time at next scr refresh
            # add timestamp to datafile
            thisExp.timestampOnFlip(win, 'key_resp_54.started')
            # update status
            key_resp_54.status = STARTED
            # keyboard checking is just starting
            waitOnFlip = True
            win.callOnFlip(key_resp_54.clock.reset)  # t=0 on next screen flip
            win.callOnFlip(key_resp_54.clearEvents, eventType='keyboard')  # clear events on next screen flip
        if key_resp_54.status == STARTED and not waitOnFlip:
            theseKeys = key_resp_54.getKeys(keyList=['y','n'], ignoreKeys=["escape"], waitRelease=False)
            _key_resp_54_allKeys.extend(theseKeys)
            if len(_key_resp_54_allKeys):
                key_resp_54.keys = _key_resp_54_allKeys[-1].name  # just the last key pressed
                key_resp_54.rt = _key_resp_54_allKeys[-1].rt
                key_resp_54.duration = _key_resp_54_allKeys[-1].duration
                # a response ends the routine
                continueRoutine = False
        
        # check for quit (typically the Esc key)
        if defaultKeyboard.getKeys(keyList=["escape"]):
            thisExp.status = FINISHED
        if thisExp.status == FINISHED or endExpNow:
            endExperiment(thisExp, inputs=inputs, win=win)
            return
        
        # check if all components have finished
        if not continueRoutine:  # a component has requested a forced-end of Routine
            routineForceEnded = True
            break
        continueRoutine = False  # will revert to True if at least one component still running
        for thisComponent in SPQ9Components:
            if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:
                continueRoutine = True
                break  # at least one component has not yet finished
        
        # refresh the screen
        if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen
            win.flip()
    
    # --- Ending Routine "SPQ9" ---
    for thisComponent in SPQ9Components:
        if hasattr(thisComponent, "setAutoDraw"):
            thisComponent.setAutoDraw(False)
    thisExp.addData('SPQ9.stopped', globalClock.getTime())
    # check responses
    if key_resp_54.keys in ['', [], None]:  # No response was made
        key_resp_54.keys = None
    thisExp.addData('key_resp_54.keys',key_resp_54.keys)
    if key_resp_54.keys != None:  # we had a response
        thisExp.addData('key_resp_54.rt', key_resp_54.rt)
        thisExp.addData('key_resp_54.duration', key_resp_54.duration)
    thisExp.nextEntry()
    # the Routine "SPQ9" was not non-slip safe, so reset the non-slip timer
    routineTimer.reset()
    
    # --- Prepare to start Routine "SPQ10" ---
    continueRoutine = True
    # update component parameters for each repeat
    thisExp.addData('SPQ10.started', globalClock.getTime())
    key_resp_55.keys = []
    key_resp_55.rt = []
    _key_resp_55_allKeys = []
    # keep track of which components have finished
    SPQ10Components = [text_191, text_192, key_resp_55]
    for thisComponent in SPQ10Components:
        thisComponent.tStart = None
        thisComponent.tStop = None
        thisComponent.tStartRefresh = None
        thisComponent.tStopRefresh = None
        if hasattr(thisComponent, 'status'):
            thisComponent.status = NOT_STARTED
    # reset timers
    t = 0
    _timeToFirstFrame = win.getFutureFlipTime(clock="now")
    frameN = -1
    
    # --- Run Routine "SPQ10" ---
    routineForceEnded = not continueRoutine
    while continueRoutine:
        # get current time
        t = routineTimer.getTime()
        tThisFlip = win.getFutureFlipTime(clock=routineTimer)
        tThisFlipGlobal = win.getFutureFlipTime(clock=None)
        frameN = frameN + 1  # number of completed frames (so 0 is the first frame)
        # update/draw components on each frame
        
        # *text_191* updates
        
        # if text_191 is starting this frame...
        if text_191.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
            # keep track of start time/frame for later
            text_191.frameNStart = frameN  # exact frame index
            text_191.tStart = t  # local t and not account for scr refresh
            text_191.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(text_191, 'tStartRefresh')  # time at next scr refresh
            # add timestamp to datafile
            thisExp.timestampOnFlip(win, 'text_191.started')
            # update status
            text_191.status = STARTED
            text_191.setAutoDraw(True)
        
        # if text_191 is active this frame...
        if text_191.status == STARTED:
            # update params
            pass
        
        # *text_192* updates
        
        # if text_192 is starting this frame...
        if text_192.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
            # keep track of start time/frame for later
            text_192.frameNStart = frameN  # exact frame index
            text_192.tStart = t  # local t and not account for scr refresh
            text_192.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(text_192, 'tStartRefresh')  # time at next scr refresh
            # add timestamp to datafile
            thisExp.timestampOnFlip(win, 'text_192.started')
            # update status
            text_192.status = STARTED
            text_192.setAutoDraw(True)
        
        # if text_192 is active this frame...
        if text_192.status == STARTED:
            # update params
            pass
        
        # *key_resp_55* updates
        waitOnFlip = False
        
        # if key_resp_55 is starting this frame...
        if key_resp_55.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
            # keep track of start time/frame for later
            key_resp_55.frameNStart = frameN  # exact frame index
            key_resp_55.tStart = t  # local t and not account for scr refresh
            key_resp_55.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(key_resp_55, 'tStartRefresh')  # time at next scr refresh
            # add timestamp to datafile
            thisExp.timestampOnFlip(win, 'key_resp_55.started')
            # update status
            key_resp_55.status = STARTED
            # keyboard checking is just starting
            waitOnFlip = True
            win.callOnFlip(key_resp_55.clock.reset)  # t=0 on next screen flip
            win.callOnFlip(key_resp_55.clearEvents, eventType='keyboard')  # clear events on next screen flip
        if key_resp_55.status == STARTED and not waitOnFlip:
            theseKeys = key_resp_55.getKeys(keyList=['y','n'], ignoreKeys=["escape"], waitRelease=False)
            _key_resp_55_allKeys.extend(theseKeys)
            if len(_key_resp_55_allKeys):
                key_resp_55.keys = _key_resp_55_allKeys[-1].name  # just the last key pressed
                key_resp_55.rt = _key_resp_55_allKeys[-1].rt
                key_resp_55.duration = _key_resp_55_allKeys[-1].duration
                # a response ends the routine
                continueRoutine = False
        
        # check for quit (typically the Esc key)
        if defaultKeyboard.getKeys(keyList=["escape"]):
            thisExp.status = FINISHED
        if thisExp.status == FINISHED or endExpNow:
            endExperiment(thisExp, inputs=inputs, win=win)
            return
        
        # check if all components have finished
        if not continueRoutine:  # a component has requested a forced-end of Routine
            routineForceEnded = True
            break
        continueRoutine = False  # will revert to True if at least one component still running
        for thisComponent in SPQ10Components:
            if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:
                continueRoutine = True
                break  # at least one component has not yet finished
        
        # refresh the screen
        if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen
            win.flip()
    
    # --- Ending Routine "SPQ10" ---
    for thisComponent in SPQ10Components:
        if hasattr(thisComponent, "setAutoDraw"):
            thisComponent.setAutoDraw(False)
    thisExp.addData('SPQ10.stopped', globalClock.getTime())
    # check responses
    if key_resp_55.keys in ['', [], None]:  # No response was made
        key_resp_55.keys = None
    thisExp.addData('key_resp_55.keys',key_resp_55.keys)
    if key_resp_55.keys != None:  # we had a response
        thisExp.addData('key_resp_55.rt', key_resp_55.rt)
        thisExp.addData('key_resp_55.duration', key_resp_55.duration)
    thisExp.nextEntry()
    # the Routine "SPQ10" was not non-slip safe, so reset the non-slip timer
    routineTimer.reset()
    
    # --- Prepare to start Routine "SQP11" ---
    continueRoutine = True
    # update component parameters for each repeat
    thisExp.addData('SQP11.started', globalClock.getTime())
    key_resp_56.keys = []
    key_resp_56.rt = []
    _key_resp_56_allKeys = []
    # keep track of which components have finished
    SQP11Components = [text_193, text_194, key_resp_56]
    for thisComponent in SQP11Components:
        thisComponent.tStart = None
        thisComponent.tStop = None
        thisComponent.tStartRefresh = None
        thisComponent.tStopRefresh = None
        if hasattr(thisComponent, 'status'):
            thisComponent.status = NOT_STARTED
    # reset timers
    t = 0
    _timeToFirstFrame = win.getFutureFlipTime(clock="now")
    frameN = -1
    
    # --- Run Routine "SQP11" ---
    routineForceEnded = not continueRoutine
    while continueRoutine:
        # get current time
        t = routineTimer.getTime()
        tThisFlip = win.getFutureFlipTime(clock=routineTimer)
        tThisFlipGlobal = win.getFutureFlipTime(clock=None)
        frameN = frameN + 1  # number of completed frames (so 0 is the first frame)
        # update/draw components on each frame
        
        # *text_193* updates
        
        # if text_193 is starting this frame...
        if text_193.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
            # keep track of start time/frame for later
            text_193.frameNStart = frameN  # exact frame index
            text_193.tStart = t  # local t and not account for scr refresh
            text_193.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(text_193, 'tStartRefresh')  # time at next scr refresh
            # add timestamp to datafile
            thisExp.timestampOnFlip(win, 'text_193.started')
            # update status
            text_193.status = STARTED
            text_193.setAutoDraw(True)
        
        # if text_193 is active this frame...
        if text_193.status == STARTED:
            # update params
            pass
        
        # *text_194* updates
        
        # if text_194 is starting this frame...
        if text_194.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
            # keep track of start time/frame for later
            text_194.frameNStart = frameN  # exact frame index
            text_194.tStart = t  # local t and not account for scr refresh
            text_194.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(text_194, 'tStartRefresh')  # time at next scr refresh
            # add timestamp to datafile
            thisExp.timestampOnFlip(win, 'text_194.started')
            # update status
            text_194.status = STARTED
            text_194.setAutoDraw(True)
        
        # if text_194 is active this frame...
        if text_194.status == STARTED:
            # update params
            pass
        
        # *key_resp_56* updates
        waitOnFlip = False
        
        # if key_resp_56 is starting this frame...
        if key_resp_56.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
            # keep track of start time/frame for later
            key_resp_56.frameNStart = frameN  # exact frame index
            key_resp_56.tStart = t  # local t and not account for scr refresh
            key_resp_56.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(key_resp_56, 'tStartRefresh')  # time at next scr refresh
            # add timestamp to datafile
            thisExp.timestampOnFlip(win, 'key_resp_56.started')
            # update status
            key_resp_56.status = STARTED
            # keyboard checking is just starting
            waitOnFlip = True
            win.callOnFlip(key_resp_56.clock.reset)  # t=0 on next screen flip
            win.callOnFlip(key_resp_56.clearEvents, eventType='keyboard')  # clear events on next screen flip
        if key_resp_56.status == STARTED and not waitOnFlip:
            theseKeys = key_resp_56.getKeys(keyList=['y','n'], ignoreKeys=["escape"], waitRelease=False)
            _key_resp_56_allKeys.extend(theseKeys)
            if len(_key_resp_56_allKeys):
                key_resp_56.keys = _key_resp_56_allKeys[-1].name  # just the last key pressed
                key_resp_56.rt = _key_resp_56_allKeys[-1].rt
                key_resp_56.duration = _key_resp_56_allKeys[-1].duration
                # a response ends the routine
                continueRoutine = False
        
        # check for quit (typically the Esc key)
        if defaultKeyboard.getKeys(keyList=["escape"]):
            thisExp.status = FINISHED
        if thisExp.status == FINISHED or endExpNow:
            endExperiment(thisExp, inputs=inputs, win=win)
            return
        
        # check if all components have finished
        if not continueRoutine:  # a component has requested a forced-end of Routine
            routineForceEnded = True
            break
        continueRoutine = False  # will revert to True if at least one component still running
        for thisComponent in SQP11Components:
            if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:
                continueRoutine = True
                break  # at least one component has not yet finished
        
        # refresh the screen
        if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen
            win.flip()
    
    # --- Ending Routine "SQP11" ---
    for thisComponent in SQP11Components:
        if hasattr(thisComponent, "setAutoDraw"):
            thisComponent.setAutoDraw(False)
    thisExp.addData('SQP11.stopped', globalClock.getTime())
    # check responses
    if key_resp_56.keys in ['', [], None]:  # No response was made
        key_resp_56.keys = None
    thisExp.addData('key_resp_56.keys',key_resp_56.keys)
    if key_resp_56.keys != None:  # we had a response
        thisExp.addData('key_resp_56.rt', key_resp_56.rt)
        thisExp.addData('key_resp_56.duration', key_resp_56.duration)
    thisExp.nextEntry()
    # the Routine "SQP11" was not non-slip safe, so reset the non-slip timer
    routineTimer.reset()
    
    # --- Prepare to start Routine "SPQ12" ---
    continueRoutine = True
    # update component parameters for each repeat
    thisExp.addData('SPQ12.started', globalClock.getTime())
    key_resp_57.keys = []
    key_resp_57.rt = []
    _key_resp_57_allKeys = []
    # keep track of which components have finished
    SPQ12Components = [text_195, text_196, key_resp_57]
    for thisComponent in SPQ12Components:
        thisComponent.tStart = None
        thisComponent.tStop = None
        thisComponent.tStartRefresh = None
        thisComponent.tStopRefresh = None
        if hasattr(thisComponent, 'status'):
            thisComponent.status = NOT_STARTED
    # reset timers
    t = 0
    _timeToFirstFrame = win.getFutureFlipTime(clock="now")
    frameN = -1
    
    # --- Run Routine "SPQ12" ---
    routineForceEnded = not continueRoutine
    while continueRoutine:
        # get current time
        t = routineTimer.getTime()
        tThisFlip = win.getFutureFlipTime(clock=routineTimer)
        tThisFlipGlobal = win.getFutureFlipTime(clock=None)
        frameN = frameN + 1  # number of completed frames (so 0 is the first frame)
        # update/draw components on each frame
        
        # *text_195* updates
        
        # if text_195 is starting this frame...
        if text_195.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
            # keep track of start time/frame for later
            text_195.frameNStart = frameN  # exact frame index
            text_195.tStart = t  # local t and not account for scr refresh
            text_195.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(text_195, 'tStartRefresh')  # time at next scr refresh
            # add timestamp to datafile
            thisExp.timestampOnFlip(win, 'text_195.started')
            # update status
            text_195.status = STARTED
            text_195.setAutoDraw(True)
        
        # if text_195 is active this frame...
        if text_195.status == STARTED:
            # update params
            pass
        
        # *text_196* updates
        
        # if text_196 is starting this frame...
        if text_196.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
            # keep track of start time/frame for later
            text_196.frameNStart = frameN  # exact frame index
            text_196.tStart = t  # local t and not account for scr refresh
            text_196.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(text_196, 'tStartRefresh')  # time at next scr refresh
            # add timestamp to datafile
            thisExp.timestampOnFlip(win, 'text_196.started')
            # update status
            text_196.status = STARTED
            text_196.setAutoDraw(True)
        
        # if text_196 is active this frame...
        if text_196.status == STARTED:
            # update params
            pass
        
        # *key_resp_57* updates
        waitOnFlip = False
        
        # if key_resp_57 is starting this frame...
        if key_resp_57.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
            # keep track of start time/frame for later
            key_resp_57.frameNStart = frameN  # exact frame index
            key_resp_57.tStart = t  # local t and not account for scr refresh
            key_resp_57.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(key_resp_57, 'tStartRefresh')  # time at next scr refresh
            # add timestamp to datafile
            thisExp.timestampOnFlip(win, 'key_resp_57.started')
            # update status
            key_resp_57.status = STARTED
            # keyboard checking is just starting
            waitOnFlip = True
            win.callOnFlip(key_resp_57.clock.reset)  # t=0 on next screen flip
            win.callOnFlip(key_resp_57.clearEvents, eventType='keyboard')  # clear events on next screen flip
        if key_resp_57.status == STARTED and not waitOnFlip:
            theseKeys = key_resp_57.getKeys(keyList=['y','n'], ignoreKeys=["escape"], waitRelease=False)
            _key_resp_57_allKeys.extend(theseKeys)
            if len(_key_resp_57_allKeys):
                key_resp_57.keys = _key_resp_57_allKeys[-1].name  # just the last key pressed
                key_resp_57.rt = _key_resp_57_allKeys[-1].rt
                key_resp_57.duration = _key_resp_57_allKeys[-1].duration
                # a response ends the routine
                continueRoutine = False
        
        # check for quit (typically the Esc key)
        if defaultKeyboard.getKeys(keyList=["escape"]):
            thisExp.status = FINISHED
        if thisExp.status == FINISHED or endExpNow:
            endExperiment(thisExp, inputs=inputs, win=win)
            return
        
        # check if all components have finished
        if not continueRoutine:  # a component has requested a forced-end of Routine
            routineForceEnded = True
            break
        continueRoutine = False  # will revert to True if at least one component still running
        for thisComponent in SPQ12Components:
            if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:
                continueRoutine = True
                break  # at least one component has not yet finished
        
        # refresh the screen
        if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen
            win.flip()
    
    # --- Ending Routine "SPQ12" ---
    for thisComponent in SPQ12Components:
        if hasattr(thisComponent, "setAutoDraw"):
            thisComponent.setAutoDraw(False)
    thisExp.addData('SPQ12.stopped', globalClock.getTime())
    # check responses
    if key_resp_57.keys in ['', [], None]:  # No response was made
        key_resp_57.keys = None
    thisExp.addData('key_resp_57.keys',key_resp_57.keys)
    if key_resp_57.keys != None:  # we had a response
        thisExp.addData('key_resp_57.rt', key_resp_57.rt)
        thisExp.addData('key_resp_57.duration', key_resp_57.duration)
    thisExp.nextEntry()
    # the Routine "SPQ12" was not non-slip safe, so reset the non-slip timer
    routineTimer.reset()
    
    # --- Prepare to start Routine "SPQ13" ---
    continueRoutine = True
    # update component parameters for each repeat
    thisExp.addData('SPQ13.started', globalClock.getTime())
    key_resp_58.keys = []
    key_resp_58.rt = []
    _key_resp_58_allKeys = []
    # keep track of which components have finished
    SPQ13Components = [text_197, text_198, key_resp_58]
    for thisComponent in SPQ13Components:
        thisComponent.tStart = None
        thisComponent.tStop = None
        thisComponent.tStartRefresh = None
        thisComponent.tStopRefresh = None
        if hasattr(thisComponent, 'status'):
            thisComponent.status = NOT_STARTED
    # reset timers
    t = 0
    _timeToFirstFrame = win.getFutureFlipTime(clock="now")
    frameN = -1
    
    # --- Run Routine "SPQ13" ---
    routineForceEnded = not continueRoutine
    while continueRoutine:
        # get current time
        t = routineTimer.getTime()
        tThisFlip = win.getFutureFlipTime(clock=routineTimer)
        tThisFlipGlobal = win.getFutureFlipTime(clock=None)
        frameN = frameN + 1  # number of completed frames (so 0 is the first frame)
        # update/draw components on each frame
        
        # *text_197* updates
        
        # if text_197 is starting this frame...
        if text_197.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
            # keep track of start time/frame for later
            text_197.frameNStart = frameN  # exact frame index
            text_197.tStart = t  # local t and not account for scr refresh
            text_197.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(text_197, 'tStartRefresh')  # time at next scr refresh
            # add timestamp to datafile
            thisExp.timestampOnFlip(win, 'text_197.started')
            # update status
            text_197.status = STARTED
            text_197.setAutoDraw(True)
        
        # if text_197 is active this frame...
        if text_197.status == STARTED:
            # update params
            pass
        
        # *text_198* updates
        
        # if text_198 is starting this frame...
        if text_198.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
            # keep track of start time/frame for later
            text_198.frameNStart = frameN  # exact frame index
            text_198.tStart = t  # local t and not account for scr refresh
            text_198.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(text_198, 'tStartRefresh')  # time at next scr refresh
            # add timestamp to datafile
            thisExp.timestampOnFlip(win, 'text_198.started')
            # update status
            text_198.status = STARTED
            text_198.setAutoDraw(True)
        
        # if text_198 is active this frame...
        if text_198.status == STARTED:
            # update params
            pass
        
        # *key_resp_58* updates
        waitOnFlip = False
        
        # if key_resp_58 is starting this frame...
        if key_resp_58.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
            # keep track of start time/frame for later
            key_resp_58.frameNStart = frameN  # exact frame index
            key_resp_58.tStart = t  # local t and not account for scr refresh
            key_resp_58.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(key_resp_58, 'tStartRefresh')  # time at next scr refresh
            # add timestamp to datafile
            thisExp.timestampOnFlip(win, 'key_resp_58.started')
            # update status
            key_resp_58.status = STARTED
            # keyboard checking is just starting
            waitOnFlip = True
            win.callOnFlip(key_resp_58.clock.reset)  # t=0 on next screen flip
            win.callOnFlip(key_resp_58.clearEvents, eventType='keyboard')  # clear events on next screen flip
        if key_resp_58.status == STARTED and not waitOnFlip:
            theseKeys = key_resp_58.getKeys(keyList=['y','n'], ignoreKeys=["escape"], waitRelease=False)
            _key_resp_58_allKeys.extend(theseKeys)
            if len(_key_resp_58_allKeys):
                key_resp_58.keys = _key_resp_58_allKeys[-1].name  # just the last key pressed
                key_resp_58.rt = _key_resp_58_allKeys[-1].rt
                key_resp_58.duration = _key_resp_58_allKeys[-1].duration
                # a response ends the routine
                continueRoutine = False
        
        # check for quit (typically the Esc key)
        if defaultKeyboard.getKeys(keyList=["escape"]):
            thisExp.status = FINISHED
        if thisExp.status == FINISHED or endExpNow:
            endExperiment(thisExp, inputs=inputs, win=win)
            return
        
        # check if all components have finished
        if not continueRoutine:  # a component has requested a forced-end of Routine
            routineForceEnded = True
            break
        continueRoutine = False  # will revert to True if at least one component still running
        for thisComponent in SPQ13Components:
            if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:
                continueRoutine = True
                break  # at least one component has not yet finished
        
        # refresh the screen
        if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen
            win.flip()
    
    # --- Ending Routine "SPQ13" ---
    for thisComponent in SPQ13Components:
        if hasattr(thisComponent, "setAutoDraw"):
            thisComponent.setAutoDraw(False)
    thisExp.addData('SPQ13.stopped', globalClock.getTime())
    # check responses
    if key_resp_58.keys in ['', [], None]:  # No response was made
        key_resp_58.keys = None
    thisExp.addData('key_resp_58.keys',key_resp_58.keys)
    if key_resp_58.keys != None:  # we had a response
        thisExp.addData('key_resp_58.rt', key_resp_58.rt)
        thisExp.addData('key_resp_58.duration', key_resp_58.duration)
    thisExp.nextEntry()
    # the Routine "SPQ13" was not non-slip safe, so reset the non-slip timer
    routineTimer.reset()
    
    # --- Prepare to start Routine "SPQ14" ---
    continueRoutine = True
    # update component parameters for each repeat
    thisExp.addData('SPQ14.started', globalClock.getTime())
    key_resp_59.keys = []
    key_resp_59.rt = []
    _key_resp_59_allKeys = []
    # keep track of which components have finished
    SPQ14Components = [text_199, text_200, key_resp_59]
    for thisComponent in SPQ14Components:
        thisComponent.tStart = None
        thisComponent.tStop = None
        thisComponent.tStartRefresh = None
        thisComponent.tStopRefresh = None
        if hasattr(thisComponent, 'status'):
            thisComponent.status = NOT_STARTED
    # reset timers
    t = 0
    _timeToFirstFrame = win.getFutureFlipTime(clock="now")
    frameN = -1
    
    # --- Run Routine "SPQ14" ---
    routineForceEnded = not continueRoutine
    while continueRoutine:
        # get current time
        t = routineTimer.getTime()
        tThisFlip = win.getFutureFlipTime(clock=routineTimer)
        tThisFlipGlobal = win.getFutureFlipTime(clock=None)
        frameN = frameN + 1  # number of completed frames (so 0 is the first frame)
        # update/draw components on each frame
        
        # *text_199* updates
        
        # if text_199 is starting this frame...
        if text_199.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
            # keep track of start time/frame for later
            text_199.frameNStart = frameN  # exact frame index
            text_199.tStart = t  # local t and not account for scr refresh
            text_199.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(text_199, 'tStartRefresh')  # time at next scr refresh
            # add timestamp to datafile
            thisExp.timestampOnFlip(win, 'text_199.started')
            # update status
            text_199.status = STARTED
            text_199.setAutoDraw(True)
        
        # if text_199 is active this frame...
        if text_199.status == STARTED:
            # update params
            pass
        
        # *text_200* updates
        
        # if text_200 is starting this frame...
        if text_200.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
            # keep track of start time/frame for later
            text_200.frameNStart = frameN  # exact frame index
            text_200.tStart = t  # local t and not account for scr refresh
            text_200.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(text_200, 'tStartRefresh')  # time at next scr refresh
            # add timestamp to datafile
            thisExp.timestampOnFlip(win, 'text_200.started')
            # update status
            text_200.status = STARTED
            text_200.setAutoDraw(True)
        
        # if text_200 is active this frame...
        if text_200.status == STARTED:
            # update params
            pass
        
        # *key_resp_59* updates
        waitOnFlip = False
        
        # if key_resp_59 is starting this frame...
        if key_resp_59.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
            # keep track of start time/frame for later
            key_resp_59.frameNStart = frameN  # exact frame index
            key_resp_59.tStart = t  # local t and not account for scr refresh
            key_resp_59.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(key_resp_59, 'tStartRefresh')  # time at next scr refresh
            # add timestamp to datafile
            thisExp.timestampOnFlip(win, 'key_resp_59.started')
            # update status
            key_resp_59.status = STARTED
            # keyboard checking is just starting
            waitOnFlip = True
            win.callOnFlip(key_resp_59.clock.reset)  # t=0 on next screen flip
            win.callOnFlip(key_resp_59.clearEvents, eventType='keyboard')  # clear events on next screen flip
        if key_resp_59.status == STARTED and not waitOnFlip:
            theseKeys = key_resp_59.getKeys(keyList=['y','n'], ignoreKeys=["escape"], waitRelease=False)
            _key_resp_59_allKeys.extend(theseKeys)
            if len(_key_resp_59_allKeys):
                key_resp_59.keys = _key_resp_59_allKeys[-1].name  # just the last key pressed
                key_resp_59.rt = _key_resp_59_allKeys[-1].rt
                key_resp_59.duration = _key_resp_59_allKeys[-1].duration
                # a response ends the routine
                continueRoutine = False
        
        # check for quit (typically the Esc key)
        if defaultKeyboard.getKeys(keyList=["escape"]):
            thisExp.status = FINISHED
        if thisExp.status == FINISHED or endExpNow:
            endExperiment(thisExp, inputs=inputs, win=win)
            return
        
        # check if all components have finished
        if not continueRoutine:  # a component has requested a forced-end of Routine
            routineForceEnded = True
            break
        continueRoutine = False  # will revert to True if at least one component still running
        for thisComponent in SPQ14Components:
            if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:
                continueRoutine = True
                break  # at least one component has not yet finished
        
        # refresh the screen
        if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen
            win.flip()
    
    # --- Ending Routine "SPQ14" ---
    for thisComponent in SPQ14Components:
        if hasattr(thisComponent, "setAutoDraw"):
            thisComponent.setAutoDraw(False)
    thisExp.addData('SPQ14.stopped', globalClock.getTime())
    # check responses
    if key_resp_59.keys in ['', [], None]:  # No response was made
        key_resp_59.keys = None
    thisExp.addData('key_resp_59.keys',key_resp_59.keys)
    if key_resp_59.keys != None:  # we had a response
        thisExp.addData('key_resp_59.rt', key_resp_59.rt)
        thisExp.addData('key_resp_59.duration', key_resp_59.duration)
    thisExp.nextEntry()
    # the Routine "SPQ14" was not non-slip safe, so reset the non-slip timer
    routineTimer.reset()
    
    # --- Prepare to start Routine "SPQ15" ---
    continueRoutine = True
    # update component parameters for each repeat
    thisExp.addData('SPQ15.started', globalClock.getTime())
    key_resp_60.keys = []
    key_resp_60.rt = []
    _key_resp_60_allKeys = []
    # keep track of which components have finished
    SPQ15Components = [text_201, text_202, key_resp_60]
    for thisComponent in SPQ15Components:
        thisComponent.tStart = None
        thisComponent.tStop = None
        thisComponent.tStartRefresh = None
        thisComponent.tStopRefresh = None
        if hasattr(thisComponent, 'status'):
            thisComponent.status = NOT_STARTED
    # reset timers
    t = 0
    _timeToFirstFrame = win.getFutureFlipTime(clock="now")
    frameN = -1
    
    # --- Run Routine "SPQ15" ---
    routineForceEnded = not continueRoutine
    while continueRoutine:
        # get current time
        t = routineTimer.getTime()
        tThisFlip = win.getFutureFlipTime(clock=routineTimer)
        tThisFlipGlobal = win.getFutureFlipTime(clock=None)
        frameN = frameN + 1  # number of completed frames (so 0 is the first frame)
        # update/draw components on each frame
        
        # *text_201* updates
        
        # if text_201 is starting this frame...
        if text_201.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
            # keep track of start time/frame for later
            text_201.frameNStart = frameN  # exact frame index
            text_201.tStart = t  # local t and not account for scr refresh
            text_201.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(text_201, 'tStartRefresh')  # time at next scr refresh
            # add timestamp to datafile
            thisExp.timestampOnFlip(win, 'text_201.started')
            # update status
            text_201.status = STARTED
            text_201.setAutoDraw(True)
        
        # if text_201 is active this frame...
        if text_201.status == STARTED:
            # update params
            pass
        
        # *text_202* updates
        
        # if text_202 is starting this frame...
        if text_202.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
            # keep track of start time/frame for later
            text_202.frameNStart = frameN  # exact frame index
            text_202.tStart = t  # local t and not account for scr refresh
            text_202.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(text_202, 'tStartRefresh')  # time at next scr refresh
            # add timestamp to datafile
            thisExp.timestampOnFlip(win, 'text_202.started')
            # update status
            text_202.status = STARTED
            text_202.setAutoDraw(True)
        
        # if text_202 is active this frame...
        if text_202.status == STARTED:
            # update params
            pass
        
        # *key_resp_60* updates
        waitOnFlip = False
        
        # if key_resp_60 is starting this frame...
        if key_resp_60.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
            # keep track of start time/frame for later
            key_resp_60.frameNStart = frameN  # exact frame index
            key_resp_60.tStart = t  # local t and not account for scr refresh
            key_resp_60.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(key_resp_60, 'tStartRefresh')  # time at next scr refresh
            # add timestamp to datafile
            thisExp.timestampOnFlip(win, 'key_resp_60.started')
            # update status
            key_resp_60.status = STARTED
            # keyboard checking is just starting
            waitOnFlip = True
            win.callOnFlip(key_resp_60.clock.reset)  # t=0 on next screen flip
            win.callOnFlip(key_resp_60.clearEvents, eventType='keyboard')  # clear events on next screen flip
        if key_resp_60.status == STARTED and not waitOnFlip:
            theseKeys = key_resp_60.getKeys(keyList=['y','n'], ignoreKeys=["escape"], waitRelease=False)
            _key_resp_60_allKeys.extend(theseKeys)
            if len(_key_resp_60_allKeys):
                key_resp_60.keys = _key_resp_60_allKeys[-1].name  # just the last key pressed
                key_resp_60.rt = _key_resp_60_allKeys[-1].rt
                key_resp_60.duration = _key_resp_60_allKeys[-1].duration
                # a response ends the routine
                continueRoutine = False
        
        # check for quit (typically the Esc key)
        if defaultKeyboard.getKeys(keyList=["escape"]):
            thisExp.status = FINISHED
        if thisExp.status == FINISHED or endExpNow:
            endExperiment(thisExp, inputs=inputs, win=win)
            return
        
        # check if all components have finished
        if not continueRoutine:  # a component has requested a forced-end of Routine
            routineForceEnded = True
            break
        continueRoutine = False  # will revert to True if at least one component still running
        for thisComponent in SPQ15Components:
            if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:
                continueRoutine = True
                break  # at least one component has not yet finished
        
        # refresh the screen
        if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen
            win.flip()
    
    # --- Ending Routine "SPQ15" ---
    for thisComponent in SPQ15Components:
        if hasattr(thisComponent, "setAutoDraw"):
            thisComponent.setAutoDraw(False)
    thisExp.addData('SPQ15.stopped', globalClock.getTime())
    # check responses
    if key_resp_60.keys in ['', [], None]:  # No response was made
        key_resp_60.keys = None
    thisExp.addData('key_resp_60.keys',key_resp_60.keys)
    if key_resp_60.keys != None:  # we had a response
        thisExp.addData('key_resp_60.rt', key_resp_60.rt)
        thisExp.addData('key_resp_60.duration', key_resp_60.duration)
    thisExp.nextEntry()
    # the Routine "SPQ15" was not non-slip safe, so reset the non-slip timer
    routineTimer.reset()
    
    # --- Prepare to start Routine "SPQ16" ---
    continueRoutine = True
    # update component parameters for each repeat
    thisExp.addData('SPQ16.started', globalClock.getTime())
    key_resp_61.keys = []
    key_resp_61.rt = []
    _key_resp_61_allKeys = []
    # keep track of which components have finished
    SPQ16Components = [text_203, text_204, key_resp_61]
    for thisComponent in SPQ16Components:
        thisComponent.tStart = None
        thisComponent.tStop = None
        thisComponent.tStartRefresh = None
        thisComponent.tStopRefresh = None
        if hasattr(thisComponent, 'status'):
            thisComponent.status = NOT_STARTED
    # reset timers
    t = 0
    _timeToFirstFrame = win.getFutureFlipTime(clock="now")
    frameN = -1
    
    # --- Run Routine "SPQ16" ---
    routineForceEnded = not continueRoutine
    while continueRoutine:
        # get current time
        t = routineTimer.getTime()
        tThisFlip = win.getFutureFlipTime(clock=routineTimer)
        tThisFlipGlobal = win.getFutureFlipTime(clock=None)
        frameN = frameN + 1  # number of completed frames (so 0 is the first frame)
        # update/draw components on each frame
        
        # *text_203* updates
        
        # if text_203 is starting this frame...
        if text_203.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
            # keep track of start time/frame for later
            text_203.frameNStart = frameN  # exact frame index
            text_203.tStart = t  # local t and not account for scr refresh
            text_203.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(text_203, 'tStartRefresh')  # time at next scr refresh
            # add timestamp to datafile
            thisExp.timestampOnFlip(win, 'text_203.started')
            # update status
            text_203.status = STARTED
            text_203.setAutoDraw(True)
        
        # if text_203 is active this frame...
        if text_203.status == STARTED:
            # update params
            pass
        
        # *text_204* updates
        
        # if text_204 is starting this frame...
        if text_204.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
            # keep track of start time/frame for later
            text_204.frameNStart = frameN  # exact frame index
            text_204.tStart = t  # local t and not account for scr refresh
            text_204.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(text_204, 'tStartRefresh')  # time at next scr refresh
            # add timestamp to datafile
            thisExp.timestampOnFlip(win, 'text_204.started')
            # update status
            text_204.status = STARTED
            text_204.setAutoDraw(True)
        
        # if text_204 is active this frame...
        if text_204.status == STARTED:
            # update params
            pass
        
        # *key_resp_61* updates
        waitOnFlip = False
        
        # if key_resp_61 is starting this frame...
        if key_resp_61.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
            # keep track of start time/frame for later
            key_resp_61.frameNStart = frameN  # exact frame index
            key_resp_61.tStart = t  # local t and not account for scr refresh
            key_resp_61.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(key_resp_61, 'tStartRefresh')  # time at next scr refresh
            # add timestamp to datafile
            thisExp.timestampOnFlip(win, 'key_resp_61.started')
            # update status
            key_resp_61.status = STARTED
            # keyboard checking is just starting
            waitOnFlip = True
            win.callOnFlip(key_resp_61.clock.reset)  # t=0 on next screen flip
            win.callOnFlip(key_resp_61.clearEvents, eventType='keyboard')  # clear events on next screen flip
        if key_resp_61.status == STARTED and not waitOnFlip:
            theseKeys = key_resp_61.getKeys(keyList=['y','n'], ignoreKeys=["escape"], waitRelease=False)
            _key_resp_61_allKeys.extend(theseKeys)
            if len(_key_resp_61_allKeys):
                key_resp_61.keys = _key_resp_61_allKeys[-1].name  # just the last key pressed
                key_resp_61.rt = _key_resp_61_allKeys[-1].rt
                key_resp_61.duration = _key_resp_61_allKeys[-1].duration
                # a response ends the routine
                continueRoutine = False
        
        # check for quit (typically the Esc key)
        if defaultKeyboard.getKeys(keyList=["escape"]):
            thisExp.status = FINISHED
        if thisExp.status == FINISHED or endExpNow:
            endExperiment(thisExp, inputs=inputs, win=win)
            return
        
        # check if all components have finished
        if not continueRoutine:  # a component has requested a forced-end of Routine
            routineForceEnded = True
            break
        continueRoutine = False  # will revert to True if at least one component still running
        for thisComponent in SPQ16Components:
            if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:
                continueRoutine = True
                break  # at least one component has not yet finished
        
        # refresh the screen
        if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen
            win.flip()
    
    # --- Ending Routine "SPQ16" ---
    for thisComponent in SPQ16Components:
        if hasattr(thisComponent, "setAutoDraw"):
            thisComponent.setAutoDraw(False)
    thisExp.addData('SPQ16.stopped', globalClock.getTime())
    # check responses
    if key_resp_61.keys in ['', [], None]:  # No response was made
        key_resp_61.keys = None
    thisExp.addData('key_resp_61.keys',key_resp_61.keys)
    if key_resp_61.keys != None:  # we had a response
        thisExp.addData('key_resp_61.rt', key_resp_61.rt)
        thisExp.addData('key_resp_61.duration', key_resp_61.duration)
    thisExp.nextEntry()
    # the Routine "SPQ16" was not non-slip safe, so reset the non-slip timer
    routineTimer.reset()
    
    # --- Prepare to start Routine "SPQ17" ---
    continueRoutine = True
    # update component parameters for each repeat
    thisExp.addData('SPQ17.started', globalClock.getTime())
    key_resp_62.keys = []
    key_resp_62.rt = []
    _key_resp_62_allKeys = []
    # keep track of which components have finished
    SPQ17Components = [text_205, text_206, key_resp_62]
    for thisComponent in SPQ17Components:
        thisComponent.tStart = None
        thisComponent.tStop = None
        thisComponent.tStartRefresh = None
        thisComponent.tStopRefresh = None
        if hasattr(thisComponent, 'status'):
            thisComponent.status = NOT_STARTED
    # reset timers
    t = 0
    _timeToFirstFrame = win.getFutureFlipTime(clock="now")
    frameN = -1
    
    # --- Run Routine "SPQ17" ---
    routineForceEnded = not continueRoutine
    while continueRoutine:
        # get current time
        t = routineTimer.getTime()
        tThisFlip = win.getFutureFlipTime(clock=routineTimer)
        tThisFlipGlobal = win.getFutureFlipTime(clock=None)
        frameN = frameN + 1  # number of completed frames (so 0 is the first frame)
        # update/draw components on each frame
        
        # *text_205* updates
        
        # if text_205 is starting this frame...
        if text_205.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
            # keep track of start time/frame for later
            text_205.frameNStart = frameN  # exact frame index
            text_205.tStart = t  # local t and not account for scr refresh
            text_205.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(text_205, 'tStartRefresh')  # time at next scr refresh
            # add timestamp to datafile
            thisExp.timestampOnFlip(win, 'text_205.started')
            # update status
            text_205.status = STARTED
            text_205.setAutoDraw(True)
        
        # if text_205 is active this frame...
        if text_205.status == STARTED:
            # update params
            pass
        
        # *text_206* updates
        
        # if text_206 is starting this frame...
        if text_206.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
            # keep track of start time/frame for later
            text_206.frameNStart = frameN  # exact frame index
            text_206.tStart = t  # local t and not account for scr refresh
            text_206.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(text_206, 'tStartRefresh')  # time at next scr refresh
            # add timestamp to datafile
            thisExp.timestampOnFlip(win, 'text_206.started')
            # update status
            text_206.status = STARTED
            text_206.setAutoDraw(True)
        
        # if text_206 is active this frame...
        if text_206.status == STARTED:
            # update params
            pass
        
        # *key_resp_62* updates
        waitOnFlip = False
        
        # if key_resp_62 is starting this frame...
        if key_resp_62.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
            # keep track of start time/frame for later
            key_resp_62.frameNStart = frameN  # exact frame index
            key_resp_62.tStart = t  # local t and not account for scr refresh
            key_resp_62.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(key_resp_62, 'tStartRefresh')  # time at next scr refresh
            # add timestamp to datafile
            thisExp.timestampOnFlip(win, 'key_resp_62.started')
            # update status
            key_resp_62.status = STARTED
            # keyboard checking is just starting
            waitOnFlip = True
            win.callOnFlip(key_resp_62.clock.reset)  # t=0 on next screen flip
            win.callOnFlip(key_resp_62.clearEvents, eventType='keyboard')  # clear events on next screen flip
        if key_resp_62.status == STARTED and not waitOnFlip:
            theseKeys = key_resp_62.getKeys(keyList=['y','n'], ignoreKeys=["escape"], waitRelease=False)
            _key_resp_62_allKeys.extend(theseKeys)
            if len(_key_resp_62_allKeys):
                key_resp_62.keys = _key_resp_62_allKeys[-1].name  # just the last key pressed
                key_resp_62.rt = _key_resp_62_allKeys[-1].rt
                key_resp_62.duration = _key_resp_62_allKeys[-1].duration
                # a response ends the routine
                continueRoutine = False
        
        # check for quit (typically the Esc key)
        if defaultKeyboard.getKeys(keyList=["escape"]):
            thisExp.status = FINISHED
        if thisExp.status == FINISHED or endExpNow:
            endExperiment(thisExp, inputs=inputs, win=win)
            return
        
        # check if all components have finished
        if not continueRoutine:  # a component has requested a forced-end of Routine
            routineForceEnded = True
            break
        continueRoutine = False  # will revert to True if at least one component still running
        for thisComponent in SPQ17Components:
            if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:
                continueRoutine = True
                break  # at least one component has not yet finished
        
        # refresh the screen
        if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen
            win.flip()
    
    # --- Ending Routine "SPQ17" ---
    for thisComponent in SPQ17Components:
        if hasattr(thisComponent, "setAutoDraw"):
            thisComponent.setAutoDraw(False)
    thisExp.addData('SPQ17.stopped', globalClock.getTime())
    # check responses
    if key_resp_62.keys in ['', [], None]:  # No response was made
        key_resp_62.keys = None
    thisExp.addData('key_resp_62.keys',key_resp_62.keys)
    if key_resp_62.keys != None:  # we had a response
        thisExp.addData('key_resp_62.rt', key_resp_62.rt)
        thisExp.addData('key_resp_62.duration', key_resp_62.duration)
    thisExp.nextEntry()
    # the Routine "SPQ17" was not non-slip safe, so reset the non-slip timer
    routineTimer.reset()
    
    # --- Prepare to start Routine "SPQ18" ---
    continueRoutine = True
    # update component parameters for each repeat
    thisExp.addData('SPQ18.started', globalClock.getTime())
    key_resp_63.keys = []
    key_resp_63.rt = []
    _key_resp_63_allKeys = []
    # keep track of which components have finished
    SPQ18Components = [text_207, text_208, key_resp_63]
    for thisComponent in SPQ18Components:
        thisComponent.tStart = None
        thisComponent.tStop = None
        thisComponent.tStartRefresh = None
        thisComponent.tStopRefresh = None
        if hasattr(thisComponent, 'status'):
            thisComponent.status = NOT_STARTED
    # reset timers
    t = 0
    _timeToFirstFrame = win.getFutureFlipTime(clock="now")
    frameN = -1
    
    # --- Run Routine "SPQ18" ---
    routineForceEnded = not continueRoutine
    while continueRoutine:
        # get current time
        t = routineTimer.getTime()
        tThisFlip = win.getFutureFlipTime(clock=routineTimer)
        tThisFlipGlobal = win.getFutureFlipTime(clock=None)
        frameN = frameN + 1  # number of completed frames (so 0 is the first frame)
        # update/draw components on each frame
        
        # *text_207* updates
        
        # if text_207 is starting this frame...
        if text_207.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
            # keep track of start time/frame for later
            text_207.frameNStart = frameN  # exact frame index
            text_207.tStart = t  # local t and not account for scr refresh
            text_207.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(text_207, 'tStartRefresh')  # time at next scr refresh
            # add timestamp to datafile
            thisExp.timestampOnFlip(win, 'text_207.started')
            # update status
            text_207.status = STARTED
            text_207.setAutoDraw(True)
        
        # if text_207 is active this frame...
        if text_207.status == STARTED:
            # update params
            pass
        
        # *text_208* updates
        
        # if text_208 is starting this frame...
        if text_208.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
            # keep track of start time/frame for later
            text_208.frameNStart = frameN  # exact frame index
            text_208.tStart = t  # local t and not account for scr refresh
            text_208.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(text_208, 'tStartRefresh')  # time at next scr refresh
            # add timestamp to datafile
            thisExp.timestampOnFlip(win, 'text_208.started')
            # update status
            text_208.status = STARTED
            text_208.setAutoDraw(True)
        
        # if text_208 is active this frame...
        if text_208.status == STARTED:
            # update params
            pass
        
        # *key_resp_63* updates
        waitOnFlip = False
        
        # if key_resp_63 is starting this frame...
        if key_resp_63.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
            # keep track of start time/frame for later
            key_resp_63.frameNStart = frameN  # exact frame index
            key_resp_63.tStart = t  # local t and not account for scr refresh
            key_resp_63.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(key_resp_63, 'tStartRefresh')  # time at next scr refresh
            # add timestamp to datafile
            thisExp.timestampOnFlip(win, 'key_resp_63.started')
            # update status
            key_resp_63.status = STARTED
            # keyboard checking is just starting
            waitOnFlip = True
            win.callOnFlip(key_resp_63.clock.reset)  # t=0 on next screen flip
            win.callOnFlip(key_resp_63.clearEvents, eventType='keyboard')  # clear events on next screen flip
        if key_resp_63.status == STARTED and not waitOnFlip:
            theseKeys = key_resp_63.getKeys(keyList=['y','n'], ignoreKeys=["escape"], waitRelease=False)
            _key_resp_63_allKeys.extend(theseKeys)
            if len(_key_resp_63_allKeys):
                key_resp_63.keys = _key_resp_63_allKeys[-1].name  # just the last key pressed
                key_resp_63.rt = _key_resp_63_allKeys[-1].rt
                key_resp_63.duration = _key_resp_63_allKeys[-1].duration
                # a response ends the routine
                continueRoutine = False
        
        # check for quit (typically the Esc key)
        if defaultKeyboard.getKeys(keyList=["escape"]):
            thisExp.status = FINISHED
        if thisExp.status == FINISHED or endExpNow:
            endExperiment(thisExp, inputs=inputs, win=win)
            return
        
        # check if all components have finished
        if not continueRoutine:  # a component has requested a forced-end of Routine
            routineForceEnded = True
            break
        continueRoutine = False  # will revert to True if at least one component still running
        for thisComponent in SPQ18Components:
            if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:
                continueRoutine = True
                break  # at least one component has not yet finished
        
        # refresh the screen
        if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen
            win.flip()
    
    # --- Ending Routine "SPQ18" ---
    for thisComponent in SPQ18Components:
        if hasattr(thisComponent, "setAutoDraw"):
            thisComponent.setAutoDraw(False)
    thisExp.addData('SPQ18.stopped', globalClock.getTime())
    # check responses
    if key_resp_63.keys in ['', [], None]:  # No response was made
        key_resp_63.keys = None
    thisExp.addData('key_resp_63.keys',key_resp_63.keys)
    if key_resp_63.keys != None:  # we had a response
        thisExp.addData('key_resp_63.rt', key_resp_63.rt)
        thisExp.addData('key_resp_63.duration', key_resp_63.duration)
    thisExp.nextEntry()
    # the Routine "SPQ18" was not non-slip safe, so reset the non-slip timer
    routineTimer.reset()
    
    # --- Prepare to start Routine "SPQ19" ---
    continueRoutine = True
    # update component parameters for each repeat
    thisExp.addData('SPQ19.started', globalClock.getTime())
    key_resp_64.keys = []
    key_resp_64.rt = []
    _key_resp_64_allKeys = []
    # keep track of which components have finished
    SPQ19Components = [text_209, text_210, key_resp_64]
    for thisComponent in SPQ19Components:
        thisComponent.tStart = None
        thisComponent.tStop = None
        thisComponent.tStartRefresh = None
        thisComponent.tStopRefresh = None
        if hasattr(thisComponent, 'status'):
            thisComponent.status = NOT_STARTED
    # reset timers
    t = 0
    _timeToFirstFrame = win.getFutureFlipTime(clock="now")
    frameN = -1
    
    # --- Run Routine "SPQ19" ---
    routineForceEnded = not continueRoutine
    while continueRoutine:
        # get current time
        t = routineTimer.getTime()
        tThisFlip = win.getFutureFlipTime(clock=routineTimer)
        tThisFlipGlobal = win.getFutureFlipTime(clock=None)
        frameN = frameN + 1  # number of completed frames (so 0 is the first frame)
        # update/draw components on each frame
        
        # *text_209* updates
        
        # if text_209 is starting this frame...
        if text_209.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
            # keep track of start time/frame for later
            text_209.frameNStart = frameN  # exact frame index
            text_209.tStart = t  # local t and not account for scr refresh
            text_209.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(text_209, 'tStartRefresh')  # time at next scr refresh
            # add timestamp to datafile
            thisExp.timestampOnFlip(win, 'text_209.started')
            # update status
            text_209.status = STARTED
            text_209.setAutoDraw(True)
        
        # if text_209 is active this frame...
        if text_209.status == STARTED:
            # update params
            pass
        
        # *text_210* updates
        
        # if text_210 is starting this frame...
        if text_210.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
            # keep track of start time/frame for later
            text_210.frameNStart = frameN  # exact frame index
            text_210.tStart = t  # local t and not account for scr refresh
            text_210.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(text_210, 'tStartRefresh')  # time at next scr refresh
            # add timestamp to datafile
            thisExp.timestampOnFlip(win, 'text_210.started')
            # update status
            text_210.status = STARTED
            text_210.setAutoDraw(True)
        
        # if text_210 is active this frame...
        if text_210.status == STARTED:
            # update params
            pass
        
        # *key_resp_64* updates
        waitOnFlip = False
        
        # if key_resp_64 is starting this frame...
        if key_resp_64.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
            # keep track of start time/frame for later
            key_resp_64.frameNStart = frameN  # exact frame index
            key_resp_64.tStart = t  # local t and not account for scr refresh
            key_resp_64.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(key_resp_64, 'tStartRefresh')  # time at next scr refresh
            # add timestamp to datafile
            thisExp.timestampOnFlip(win, 'key_resp_64.started')
            # update status
            key_resp_64.status = STARTED
            # keyboard checking is just starting
            waitOnFlip = True
            win.callOnFlip(key_resp_64.clock.reset)  # t=0 on next screen flip
            win.callOnFlip(key_resp_64.clearEvents, eventType='keyboard')  # clear events on next screen flip
        if key_resp_64.status == STARTED and not waitOnFlip:
            theseKeys = key_resp_64.getKeys(keyList=['y','n'], ignoreKeys=["escape"], waitRelease=False)
            _key_resp_64_allKeys.extend(theseKeys)
            if len(_key_resp_64_allKeys):
                key_resp_64.keys = _key_resp_64_allKeys[-1].name  # just the last key pressed
                key_resp_64.rt = _key_resp_64_allKeys[-1].rt
                key_resp_64.duration = _key_resp_64_allKeys[-1].duration
                # a response ends the routine
                continueRoutine = False
        
        # check for quit (typically the Esc key)
        if defaultKeyboard.getKeys(keyList=["escape"]):
            thisExp.status = FINISHED
        if thisExp.status == FINISHED or endExpNow:
            endExperiment(thisExp, inputs=inputs, win=win)
            return
        
        # check if all components have finished
        if not continueRoutine:  # a component has requested a forced-end of Routine
            routineForceEnded = True
            break
        continueRoutine = False  # will revert to True if at least one component still running
        for thisComponent in SPQ19Components:
            if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:
                continueRoutine = True
                break  # at least one component has not yet finished
        
        # refresh the screen
        if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen
            win.flip()
    
    # --- Ending Routine "SPQ19" ---
    for thisComponent in SPQ19Components:
        if hasattr(thisComponent, "setAutoDraw"):
            thisComponent.setAutoDraw(False)
    thisExp.addData('SPQ19.stopped', globalClock.getTime())
    # check responses
    if key_resp_64.keys in ['', [], None]:  # No response was made
        key_resp_64.keys = None
    thisExp.addData('key_resp_64.keys',key_resp_64.keys)
    if key_resp_64.keys != None:  # we had a response
        thisExp.addData('key_resp_64.rt', key_resp_64.rt)
        thisExp.addData('key_resp_64.duration', key_resp_64.duration)
    thisExp.nextEntry()
    # the Routine "SPQ19" was not non-slip safe, so reset the non-slip timer
    routineTimer.reset()
    
    # --- Prepare to start Routine "SPQ20" ---
    continueRoutine = True
    # update component parameters for each repeat
    thisExp.addData('SPQ20.started', globalClock.getTime())
    key_resp_65.keys = []
    key_resp_65.rt = []
    _key_resp_65_allKeys = []
    # keep track of which components have finished
    SPQ20Components = [text_211, text_212, key_resp_65]
    for thisComponent in SPQ20Components:
        thisComponent.tStart = None
        thisComponent.tStop = None
        thisComponent.tStartRefresh = None
        thisComponent.tStopRefresh = None
        if hasattr(thisComponent, 'status'):
            thisComponent.status = NOT_STARTED
    # reset timers
    t = 0
    _timeToFirstFrame = win.getFutureFlipTime(clock="now")
    frameN = -1
    
    # --- Run Routine "SPQ20" ---
    routineForceEnded = not continueRoutine
    while continueRoutine:
        # get current time
        t = routineTimer.getTime()
        tThisFlip = win.getFutureFlipTime(clock=routineTimer)
        tThisFlipGlobal = win.getFutureFlipTime(clock=None)
        frameN = frameN + 1  # number of completed frames (so 0 is the first frame)
        # update/draw components on each frame
        
        # *text_211* updates
        
        # if text_211 is starting this frame...
        if text_211.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
            # keep track of start time/frame for later
            text_211.frameNStart = frameN  # exact frame index
            text_211.tStart = t  # local t and not account for scr refresh
            text_211.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(text_211, 'tStartRefresh')  # time at next scr refresh
            # add timestamp to datafile
            thisExp.timestampOnFlip(win, 'text_211.started')
            # update status
            text_211.status = STARTED
            text_211.setAutoDraw(True)
        
        # if text_211 is active this frame...
        if text_211.status == STARTED:
            # update params
            pass
        
        # *text_212* updates
        
        # if text_212 is starting this frame...
        if text_212.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
            # keep track of start time/frame for later
            text_212.frameNStart = frameN  # exact frame index
            text_212.tStart = t  # local t and not account for scr refresh
            text_212.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(text_212, 'tStartRefresh')  # time at next scr refresh
            # add timestamp to datafile
            thisExp.timestampOnFlip(win, 'text_212.started')
            # update status
            text_212.status = STARTED
            text_212.setAutoDraw(True)
        
        # if text_212 is active this frame...
        if text_212.status == STARTED:
            # update params
            pass
        
        # *key_resp_65* updates
        waitOnFlip = False
        
        # if key_resp_65 is starting this frame...
        if key_resp_65.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
            # keep track of start time/frame for later
            key_resp_65.frameNStart = frameN  # exact frame index
            key_resp_65.tStart = t  # local t and not account for scr refresh
            key_resp_65.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(key_resp_65, 'tStartRefresh')  # time at next scr refresh
            # add timestamp to datafile
            thisExp.timestampOnFlip(win, 'key_resp_65.started')
            # update status
            key_resp_65.status = STARTED
            # keyboard checking is just starting
            waitOnFlip = True
            win.callOnFlip(key_resp_65.clock.reset)  # t=0 on next screen flip
            win.callOnFlip(key_resp_65.clearEvents, eventType='keyboard')  # clear events on next screen flip
        if key_resp_65.status == STARTED and not waitOnFlip:
            theseKeys = key_resp_65.getKeys(keyList=['y','n'], ignoreKeys=["escape"], waitRelease=False)
            _key_resp_65_allKeys.extend(theseKeys)
            if len(_key_resp_65_allKeys):
                key_resp_65.keys = _key_resp_65_allKeys[-1].name  # just the last key pressed
                key_resp_65.rt = _key_resp_65_allKeys[-1].rt
                key_resp_65.duration = _key_resp_65_allKeys[-1].duration
                # a response ends the routine
                continueRoutine = False
        
        # check for quit (typically the Esc key)
        if defaultKeyboard.getKeys(keyList=["escape"]):
            thisExp.status = FINISHED
        if thisExp.status == FINISHED or endExpNow:
            endExperiment(thisExp, inputs=inputs, win=win)
            return
        
        # check if all components have finished
        if not continueRoutine:  # a component has requested a forced-end of Routine
            routineForceEnded = True
            break
        continueRoutine = False  # will revert to True if at least one component still running
        for thisComponent in SPQ20Components:
            if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:
                continueRoutine = True
                break  # at least one component has not yet finished
        
        # refresh the screen
        if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen
            win.flip()
    
    # --- Ending Routine "SPQ20" ---
    for thisComponent in SPQ20Components:
        if hasattr(thisComponent, "setAutoDraw"):
            thisComponent.setAutoDraw(False)
    thisExp.addData('SPQ20.stopped', globalClock.getTime())
    # check responses
    if key_resp_65.keys in ['', [], None]:  # No response was made
        key_resp_65.keys = None
    thisExp.addData('key_resp_65.keys',key_resp_65.keys)
    if key_resp_65.keys != None:  # we had a response
        thisExp.addData('key_resp_65.rt', key_resp_65.rt)
        thisExp.addData('key_resp_65.duration', key_resp_65.duration)
    thisExp.nextEntry()
    # the Routine "SPQ20" was not non-slip safe, so reset the non-slip timer
    routineTimer.reset()
    
    # --- Prepare to start Routine "SPQ21" ---
    continueRoutine = True
    # update component parameters for each repeat
    thisExp.addData('SPQ21.started', globalClock.getTime())
    key_resp_66.keys = []
    key_resp_66.rt = []
    _key_resp_66_allKeys = []
    # keep track of which components have finished
    SPQ21Components = [text_213, text_214, key_resp_66]
    for thisComponent in SPQ21Components:
        thisComponent.tStart = None
        thisComponent.tStop = None
        thisComponent.tStartRefresh = None
        thisComponent.tStopRefresh = None
        if hasattr(thisComponent, 'status'):
            thisComponent.status = NOT_STARTED
    # reset timers
    t = 0
    _timeToFirstFrame = win.getFutureFlipTime(clock="now")
    frameN = -1
    
    # --- Run Routine "SPQ21" ---
    routineForceEnded = not continueRoutine
    while continueRoutine:
        # get current time
        t = routineTimer.getTime()
        tThisFlip = win.getFutureFlipTime(clock=routineTimer)
        tThisFlipGlobal = win.getFutureFlipTime(clock=None)
        frameN = frameN + 1  # number of completed frames (so 0 is the first frame)
        # update/draw components on each frame
        
        # *text_213* updates
        
        # if text_213 is starting this frame...
        if text_213.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
            # keep track of start time/frame for later
            text_213.frameNStart = frameN  # exact frame index
            text_213.tStart = t  # local t and not account for scr refresh
            text_213.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(text_213, 'tStartRefresh')  # time at next scr refresh
            # add timestamp to datafile
            thisExp.timestampOnFlip(win, 'text_213.started')
            # update status
            text_213.status = STARTED
            text_213.setAutoDraw(True)
        
        # if text_213 is active this frame...
        if text_213.status == STARTED:
            # update params
            pass
        
        # *text_214* updates
        
        # if text_214 is starting this frame...
        if text_214.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
            # keep track of start time/frame for later
            text_214.frameNStart = frameN  # exact frame index
            text_214.tStart = t  # local t and not account for scr refresh
            text_214.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(text_214, 'tStartRefresh')  # time at next scr refresh
            # add timestamp to datafile
            thisExp.timestampOnFlip(win, 'text_214.started')
            # update status
            text_214.status = STARTED
            text_214.setAutoDraw(True)
        
        # if text_214 is active this frame...
        if text_214.status == STARTED:
            # update params
            pass
        
        # *key_resp_66* updates
        waitOnFlip = False
        
        # if key_resp_66 is starting this frame...
        if key_resp_66.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
            # keep track of start time/frame for later
            key_resp_66.frameNStart = frameN  # exact frame index
            key_resp_66.tStart = t  # local t and not account for scr refresh
            key_resp_66.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(key_resp_66, 'tStartRefresh')  # time at next scr refresh
            # add timestamp to datafile
            thisExp.timestampOnFlip(win, 'key_resp_66.started')
            # update status
            key_resp_66.status = STARTED
            # keyboard checking is just starting
            waitOnFlip = True
            win.callOnFlip(key_resp_66.clock.reset)  # t=0 on next screen flip
            win.callOnFlip(key_resp_66.clearEvents, eventType='keyboard')  # clear events on next screen flip
        if key_resp_66.status == STARTED and not waitOnFlip:
            theseKeys = key_resp_66.getKeys(keyList=['y','n'], ignoreKeys=["escape"], waitRelease=False)
            _key_resp_66_allKeys.extend(theseKeys)
            if len(_key_resp_66_allKeys):
                key_resp_66.keys = _key_resp_66_allKeys[-1].name  # just the last key pressed
                key_resp_66.rt = _key_resp_66_allKeys[-1].rt
                key_resp_66.duration = _key_resp_66_allKeys[-1].duration
                # a response ends the routine
                continueRoutine = False
        
        # check for quit (typically the Esc key)
        if defaultKeyboard.getKeys(keyList=["escape"]):
            thisExp.status = FINISHED
        if thisExp.status == FINISHED or endExpNow:
            endExperiment(thisExp, inputs=inputs, win=win)
            return
        
        # check if all components have finished
        if not continueRoutine:  # a component has requested a forced-end of Routine
            routineForceEnded = True
            break
        continueRoutine = False  # will revert to True if at least one component still running
        for thisComponent in SPQ21Components:
            if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:
                continueRoutine = True
                break  # at least one component has not yet finished
        
        # refresh the screen
        if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen
            win.flip()
    
    # --- Ending Routine "SPQ21" ---
    for thisComponent in SPQ21Components:
        if hasattr(thisComponent, "setAutoDraw"):
            thisComponent.setAutoDraw(False)
    thisExp.addData('SPQ21.stopped', globalClock.getTime())
    # check responses
    if key_resp_66.keys in ['', [], None]:  # No response was made
        key_resp_66.keys = None
    thisExp.addData('key_resp_66.keys',key_resp_66.keys)
    if key_resp_66.keys != None:  # we had a response
        thisExp.addData('key_resp_66.rt', key_resp_66.rt)
        thisExp.addData('key_resp_66.duration', key_resp_66.duration)
    thisExp.nextEntry()
    # the Routine "SPQ21" was not non-slip safe, so reset the non-slip timer
    routineTimer.reset()
    
    # --- Prepare to start Routine "SPQ22" ---
    continueRoutine = True
    # update component parameters for each repeat
    thisExp.addData('SPQ22.started', globalClock.getTime())
    key_resp_67.keys = []
    key_resp_67.rt = []
    _key_resp_67_allKeys = []
    # keep track of which components have finished
    SPQ22Components = [text_215, text_216, key_resp_67]
    for thisComponent in SPQ22Components:
        thisComponent.tStart = None
        thisComponent.tStop = None
        thisComponent.tStartRefresh = None
        thisComponent.tStopRefresh = None
        if hasattr(thisComponent, 'status'):
            thisComponent.status = NOT_STARTED
    # reset timers
    t = 0
    _timeToFirstFrame = win.getFutureFlipTime(clock="now")
    frameN = -1
    
    # --- Run Routine "SPQ22" ---
    routineForceEnded = not continueRoutine
    while continueRoutine:
        # get current time
        t = routineTimer.getTime()
        tThisFlip = win.getFutureFlipTime(clock=routineTimer)
        tThisFlipGlobal = win.getFutureFlipTime(clock=None)
        frameN = frameN + 1  # number of completed frames (so 0 is the first frame)
        # update/draw components on each frame
        
        # *text_215* updates
        
        # if text_215 is starting this frame...
        if text_215.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
            # keep track of start time/frame for later
            text_215.frameNStart = frameN  # exact frame index
            text_215.tStart = t  # local t and not account for scr refresh
            text_215.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(text_215, 'tStartRefresh')  # time at next scr refresh
            # add timestamp to datafile
            thisExp.timestampOnFlip(win, 'text_215.started')
            # update status
            text_215.status = STARTED
            text_215.setAutoDraw(True)
        
        # if text_215 is active this frame...
        if text_215.status == STARTED:
            # update params
            pass
        
        # *text_216* updates
        
        # if text_216 is starting this frame...
        if text_216.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
            # keep track of start time/frame for later
            text_216.frameNStart = frameN  # exact frame index
            text_216.tStart = t  # local t and not account for scr refresh
            text_216.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(text_216, 'tStartRefresh')  # time at next scr refresh
            # add timestamp to datafile
            thisExp.timestampOnFlip(win, 'text_216.started')
            # update status
            text_216.status = STARTED
            text_216.setAutoDraw(True)
        
        # if text_216 is active this frame...
        if text_216.status == STARTED:
            # update params
            pass
        
        # *key_resp_67* updates
        waitOnFlip = False
        
        # if key_resp_67 is starting this frame...
        if key_resp_67.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
            # keep track of start time/frame for later
            key_resp_67.frameNStart = frameN  # exact frame index
            key_resp_67.tStart = t  # local t and not account for scr refresh
            key_resp_67.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(key_resp_67, 'tStartRefresh')  # time at next scr refresh
            # add timestamp to datafile
            thisExp.timestampOnFlip(win, 'key_resp_67.started')
            # update status
            key_resp_67.status = STARTED
            # keyboard checking is just starting
            waitOnFlip = True
            win.callOnFlip(key_resp_67.clock.reset)  # t=0 on next screen flip
            win.callOnFlip(key_resp_67.clearEvents, eventType='keyboard')  # clear events on next screen flip
        if key_resp_67.status == STARTED and not waitOnFlip:
            theseKeys = key_resp_67.getKeys(keyList=['y','n'], ignoreKeys=["escape"], waitRelease=False)
            _key_resp_67_allKeys.extend(theseKeys)
            if len(_key_resp_67_allKeys):
                key_resp_67.keys = _key_resp_67_allKeys[-1].name  # just the last key pressed
                key_resp_67.rt = _key_resp_67_allKeys[-1].rt
                key_resp_67.duration = _key_resp_67_allKeys[-1].duration
                # a response ends the routine
                continueRoutine = False
        
        # check for quit (typically the Esc key)
        if defaultKeyboard.getKeys(keyList=["escape"]):
            thisExp.status = FINISHED
        if thisExp.status == FINISHED or endExpNow:
            endExperiment(thisExp, inputs=inputs, win=win)
            return
        
        # check if all components have finished
        if not continueRoutine:  # a component has requested a forced-end of Routine
            routineForceEnded = True
            break
        continueRoutine = False  # will revert to True if at least one component still running
        for thisComponent in SPQ22Components:
            if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:
                continueRoutine = True
                break  # at least one component has not yet finished
        
        # refresh the screen
        if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen
            win.flip()
    
    # --- Ending Routine "SPQ22" ---
    for thisComponent in SPQ22Components:
        if hasattr(thisComponent, "setAutoDraw"):
            thisComponent.setAutoDraw(False)
    thisExp.addData('SPQ22.stopped', globalClock.getTime())
    # check responses
    if key_resp_67.keys in ['', [], None]:  # No response was made
        key_resp_67.keys = None
    thisExp.addData('key_resp_67.keys',key_resp_67.keys)
    if key_resp_67.keys != None:  # we had a response
        thisExp.addData('key_resp_67.rt', key_resp_67.rt)
        thisExp.addData('key_resp_67.duration', key_resp_67.duration)
    thisExp.nextEntry()
    # the Routine "SPQ22" was not non-slip safe, so reset the non-slip timer
    routineTimer.reset()
    
    # --- Prepare to start Routine "q4_instructions" ---
    continueRoutine = True
    # update component parameters for each repeat
    thisExp.addData('q4_instructions.started', globalClock.getTime())
    # keep track of which components have finished
    q4_instructionsComponents = [text_172]
    for thisComponent in q4_instructionsComponents:
        thisComponent.tStart = None
        thisComponent.tStop = None
        thisComponent.tStartRefresh = None
        thisComponent.tStopRefresh = None
        if hasattr(thisComponent, 'status'):
            thisComponent.status = NOT_STARTED
    # reset timers
    t = 0
    _timeToFirstFrame = win.getFutureFlipTime(clock="now")
    frameN = -1
    
    # --- Run Routine "q4_instructions" ---
    routineForceEnded = not continueRoutine
    while continueRoutine and routineTimer.getTime() < 5.0:
        # get current time
        t = routineTimer.getTime()
        tThisFlip = win.getFutureFlipTime(clock=routineTimer)
        tThisFlipGlobal = win.getFutureFlipTime(clock=None)
        frameN = frameN + 1  # number of completed frames (so 0 is the first frame)
        # update/draw components on each frame
        
        # *text_172* updates
        
        # if text_172 is starting this frame...
        if text_172.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
            # keep track of start time/frame for later
            text_172.frameNStart = frameN  # exact frame index
            text_172.tStart = t  # local t and not account for scr refresh
            text_172.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(text_172, 'tStartRefresh')  # time at next scr refresh
            # add timestamp to datafile
            thisExp.timestampOnFlip(win, 'text_172.started')
            # update status
            text_172.status = STARTED
            text_172.setAutoDraw(True)
        
        # if text_172 is active this frame...
        if text_172.status == STARTED:
            # update params
            pass
        
        # if text_172 is stopping this frame...
        if text_172.status == STARTED:
            # is it time to stop? (based on global clock, using actual start)
            if tThisFlipGlobal > text_172.tStartRefresh + 5.0-frameTolerance:
                # keep track of stop time/frame for later
                text_172.tStop = t  # not accounting for scr refresh
                text_172.frameNStop = frameN  # exact frame index
                # add timestamp to datafile
                thisExp.timestampOnFlip(win, 'text_172.stopped')
                # update status
                text_172.status = FINISHED
                text_172.setAutoDraw(False)
        
        # check for quit (typically the Esc key)
        if defaultKeyboard.getKeys(keyList=["escape"]):
            thisExp.status = FINISHED
        if thisExp.status == FINISHED or endExpNow:
            endExperiment(thisExp, inputs=inputs, win=win)
            return
        
        # check if all components have finished
        if not continueRoutine:  # a component has requested a forced-end of Routine
            routineForceEnded = True
            break
        continueRoutine = False  # will revert to True if at least one component still running
        for thisComponent in q4_instructionsComponents:
            if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:
                continueRoutine = True
                break  # at least one component has not yet finished
        
        # refresh the screen
        if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen
            win.flip()
    
    # --- Ending Routine "q4_instructions" ---
    for thisComponent in q4_instructionsComponents:
        if hasattr(thisComponent, "setAutoDraw"):
            thisComponent.setAutoDraw(False)
    thisExp.addData('q4_instructions.stopped', globalClock.getTime())
    # using non-slip timing so subtract the expected duration of this Routine (unless ended on request)
    if routineForceEnded:
        routineTimer.reset()
    else:
        routineTimer.addTime(-5.000000)
    
    # --- Prepare to start Routine "SS1" ---
    continueRoutine = True
    # update component parameters for each repeat
    thisExp.addData('SS1.started', globalClock.getTime())
    key_resp_68.keys = []
    key_resp_68.rt = []
    _key_resp_68_allKeys = []
    # keep track of which components have finished
    SS1Components = [text_217, text_218, text_219, key_resp_68]
    for thisComponent in SS1Components:
        thisComponent.tStart = None
        thisComponent.tStop = None
        thisComponent.tStartRefresh = None
        thisComponent.tStopRefresh = None
        if hasattr(thisComponent, 'status'):
            thisComponent.status = NOT_STARTED
    # reset timers
    t = 0
    _timeToFirstFrame = win.getFutureFlipTime(clock="now")
    frameN = -1
    
    # --- Run Routine "SS1" ---
    routineForceEnded = not continueRoutine
    while continueRoutine:
        # get current time
        t = routineTimer.getTime()
        tThisFlip = win.getFutureFlipTime(clock=routineTimer)
        tThisFlipGlobal = win.getFutureFlipTime(clock=None)
        frameN = frameN + 1  # number of completed frames (so 0 is the first frame)
        # update/draw components on each frame
        
        # *text_217* updates
        
        # if text_217 is starting this frame...
        if text_217.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
            # keep track of start time/frame for later
            text_217.frameNStart = frameN  # exact frame index
            text_217.tStart = t  # local t and not account for scr refresh
            text_217.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(text_217, 'tStartRefresh')  # time at next scr refresh
            # add timestamp to datafile
            thisExp.timestampOnFlip(win, 'text_217.started')
            # update status
            text_217.status = STARTED
            text_217.setAutoDraw(True)
        
        # if text_217 is active this frame...
        if text_217.status == STARTED:
            # update params
            pass
        
        # *text_218* updates
        
        # if text_218 is starting this frame...
        if text_218.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
            # keep track of start time/frame for later
            text_218.frameNStart = frameN  # exact frame index
            text_218.tStart = t  # local t and not account for scr refresh
            text_218.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(text_218, 'tStartRefresh')  # time at next scr refresh
            # add timestamp to datafile
            thisExp.timestampOnFlip(win, 'text_218.started')
            # update status
            text_218.status = STARTED
            text_218.setAutoDraw(True)
        
        # if text_218 is active this frame...
        if text_218.status == STARTED:
            # update params
            pass
        
        # *text_219* updates
        
        # if text_219 is starting this frame...
        if text_219.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
            # keep track of start time/frame for later
            text_219.frameNStart = frameN  # exact frame index
            text_219.tStart = t  # local t and not account for scr refresh
            text_219.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(text_219, 'tStartRefresh')  # time at next scr refresh
            # add timestamp to datafile
            thisExp.timestampOnFlip(win, 'text_219.started')
            # update status
            text_219.status = STARTED
            text_219.setAutoDraw(True)
        
        # if text_219 is active this frame...
        if text_219.status == STARTED:
            # update params
            pass
        
        # *key_resp_68* updates
        waitOnFlip = False
        
        # if key_resp_68 is starting this frame...
        if key_resp_68.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
            # keep track of start time/frame for later
            key_resp_68.frameNStart = frameN  # exact frame index
            key_resp_68.tStart = t  # local t and not account for scr refresh
            key_resp_68.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(key_resp_68, 'tStartRefresh')  # time at next scr refresh
            # add timestamp to datafile
            thisExp.timestampOnFlip(win, 'key_resp_68.started')
            # update status
            key_resp_68.status = STARTED
            # keyboard checking is just starting
            waitOnFlip = True
            win.callOnFlip(key_resp_68.clock.reset)  # t=0 on next screen flip
            win.callOnFlip(key_resp_68.clearEvents, eventType='keyboard')  # clear events on next screen flip
        if key_resp_68.status == STARTED and not waitOnFlip:
            theseKeys = key_resp_68.getKeys(keyList=[1,2,3,4,5,'1','2','3','4','5'], ignoreKeys=["escape"], waitRelease=False)
            _key_resp_68_allKeys.extend(theseKeys)
            if len(_key_resp_68_allKeys):
                key_resp_68.keys = _key_resp_68_allKeys[-1].name  # just the last key pressed
                key_resp_68.rt = _key_resp_68_allKeys[-1].rt
                key_resp_68.duration = _key_resp_68_allKeys[-1].duration
                # a response ends the routine
                continueRoutine = False
        
        # check for quit (typically the Esc key)
        if defaultKeyboard.getKeys(keyList=["escape"]):
            thisExp.status = FINISHED
        if thisExp.status == FINISHED or endExpNow:
            endExperiment(thisExp, inputs=inputs, win=win)
            return
        
        # check if all components have finished
        if not continueRoutine:  # a component has requested a forced-end of Routine
            routineForceEnded = True
            break
        continueRoutine = False  # will revert to True if at least one component still running
        for thisComponent in SS1Components:
            if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:
                continueRoutine = True
                break  # at least one component has not yet finished
        
        # refresh the screen
        if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen
            win.flip()
    
    # --- Ending Routine "SS1" ---
    for thisComponent in SS1Components:
        if hasattr(thisComponent, "setAutoDraw"):
            thisComponent.setAutoDraw(False)
    thisExp.addData('SS1.stopped', globalClock.getTime())
    # check responses
    if key_resp_68.keys in ['', [], None]:  # No response was made
        key_resp_68.keys = None
    thisExp.addData('key_resp_68.keys',key_resp_68.keys)
    if key_resp_68.keys != None:  # we had a response
        thisExp.addData('key_resp_68.rt', key_resp_68.rt)
        thisExp.addData('key_resp_68.duration', key_resp_68.duration)
    thisExp.nextEntry()
    # the Routine "SS1" was not non-slip safe, so reset the non-slip timer
    routineTimer.reset()
    
    # --- Prepare to start Routine "SS2" ---
    continueRoutine = True
    # update component parameters for each repeat
    thisExp.addData('SS2.started', globalClock.getTime())
    key_resp_69.keys = []
    key_resp_69.rt = []
    _key_resp_69_allKeys = []
    # keep track of which components have finished
    SS2Components = [text_220, text_221, text_222, key_resp_69]
    for thisComponent in SS2Components:
        thisComponent.tStart = None
        thisComponent.tStop = None
        thisComponent.tStartRefresh = None
        thisComponent.tStopRefresh = None
        if hasattr(thisComponent, 'status'):
            thisComponent.status = NOT_STARTED
    # reset timers
    t = 0
    _timeToFirstFrame = win.getFutureFlipTime(clock="now")
    frameN = -1
    
    # --- Run Routine "SS2" ---
    routineForceEnded = not continueRoutine
    while continueRoutine:
        # get current time
        t = routineTimer.getTime()
        tThisFlip = win.getFutureFlipTime(clock=routineTimer)
        tThisFlipGlobal = win.getFutureFlipTime(clock=None)
        frameN = frameN + 1  # number of completed frames (so 0 is the first frame)
        # update/draw components on each frame
        
        # *text_220* updates
        
        # if text_220 is starting this frame...
        if text_220.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
            # keep track of start time/frame for later
            text_220.frameNStart = frameN  # exact frame index
            text_220.tStart = t  # local t and not account for scr refresh
            text_220.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(text_220, 'tStartRefresh')  # time at next scr refresh
            # add timestamp to datafile
            thisExp.timestampOnFlip(win, 'text_220.started')
            # update status
            text_220.status = STARTED
            text_220.setAutoDraw(True)
        
        # if text_220 is active this frame...
        if text_220.status == STARTED:
            # update params
            pass
        
        # *text_221* updates
        
        # if text_221 is starting this frame...
        if text_221.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
            # keep track of start time/frame for later
            text_221.frameNStart = frameN  # exact frame index
            text_221.tStart = t  # local t and not account for scr refresh
            text_221.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(text_221, 'tStartRefresh')  # time at next scr refresh
            # add timestamp to datafile
            thisExp.timestampOnFlip(win, 'text_221.started')
            # update status
            text_221.status = STARTED
            text_221.setAutoDraw(True)
        
        # if text_221 is active this frame...
        if text_221.status == STARTED:
            # update params
            pass
        
        # *text_222* updates
        
        # if text_222 is starting this frame...
        if text_222.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
            # keep track of start time/frame for later
            text_222.frameNStart = frameN  # exact frame index
            text_222.tStart = t  # local t and not account for scr refresh
            text_222.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(text_222, 'tStartRefresh')  # time at next scr refresh
            # add timestamp to datafile
            thisExp.timestampOnFlip(win, 'text_222.started')
            # update status
            text_222.status = STARTED
            text_222.setAutoDraw(True)
        
        # if text_222 is active this frame...
        if text_222.status == STARTED:
            # update params
            pass
        
        # *key_resp_69* updates
        waitOnFlip = False
        
        # if key_resp_69 is starting this frame...
        if key_resp_69.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
            # keep track of start time/frame for later
            key_resp_69.frameNStart = frameN  # exact frame index
            key_resp_69.tStart = t  # local t and not account for scr refresh
            key_resp_69.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(key_resp_69, 'tStartRefresh')  # time at next scr refresh
            # add timestamp to datafile
            thisExp.timestampOnFlip(win, 'key_resp_69.started')
            # update status
            key_resp_69.status = STARTED
            # keyboard checking is just starting
            waitOnFlip = True
            win.callOnFlip(key_resp_69.clock.reset)  # t=0 on next screen flip
            win.callOnFlip(key_resp_69.clearEvents, eventType='keyboard')  # clear events on next screen flip
        if key_resp_69.status == STARTED and not waitOnFlip:
            theseKeys = key_resp_69.getKeys(keyList=[1,2,3,4,5,'1','2','3','4','5'], ignoreKeys=["escape"], waitRelease=False)
            _key_resp_69_allKeys.extend(theseKeys)
            if len(_key_resp_69_allKeys):
                key_resp_69.keys = _key_resp_69_allKeys[-1].name  # just the last key pressed
                key_resp_69.rt = _key_resp_69_allKeys[-1].rt
                key_resp_69.duration = _key_resp_69_allKeys[-1].duration
                # a response ends the routine
                continueRoutine = False
        
        # check for quit (typically the Esc key)
        if defaultKeyboard.getKeys(keyList=["escape"]):
            thisExp.status = FINISHED
        if thisExp.status == FINISHED or endExpNow:
            endExperiment(thisExp, inputs=inputs, win=win)
            return
        
        # check if all components have finished
        if not continueRoutine:  # a component has requested a forced-end of Routine
            routineForceEnded = True
            break
        continueRoutine = False  # will revert to True if at least one component still running
        for thisComponent in SS2Components:
            if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:
                continueRoutine = True
                break  # at least one component has not yet finished
        
        # refresh the screen
        if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen
            win.flip()
    
    # --- Ending Routine "SS2" ---
    for thisComponent in SS2Components:
        if hasattr(thisComponent, "setAutoDraw"):
            thisComponent.setAutoDraw(False)
    thisExp.addData('SS2.stopped', globalClock.getTime())
    # check responses
    if key_resp_69.keys in ['', [], None]:  # No response was made
        key_resp_69.keys = None
    thisExp.addData('key_resp_69.keys',key_resp_69.keys)
    if key_resp_69.keys != None:  # we had a response
        thisExp.addData('key_resp_69.rt', key_resp_69.rt)
        thisExp.addData('key_resp_69.duration', key_resp_69.duration)
    thisExp.nextEntry()
    # the Routine "SS2" was not non-slip safe, so reset the non-slip timer
    routineTimer.reset()
    
    # --- Prepare to start Routine "SS3" ---
    continueRoutine = True
    # update component parameters for each repeat
    thisExp.addData('SS3.started', globalClock.getTime())
    key_resp_70.keys = []
    key_resp_70.rt = []
    _key_resp_70_allKeys = []
    # keep track of which components have finished
    SS3Components = [text_223, text_224, text_225, key_resp_70]
    for thisComponent in SS3Components:
        thisComponent.tStart = None
        thisComponent.tStop = None
        thisComponent.tStartRefresh = None
        thisComponent.tStopRefresh = None
        if hasattr(thisComponent, 'status'):
            thisComponent.status = NOT_STARTED
    # reset timers
    t = 0
    _timeToFirstFrame = win.getFutureFlipTime(clock="now")
    frameN = -1
    
    # --- Run Routine "SS3" ---
    routineForceEnded = not continueRoutine
    while continueRoutine:
        # get current time
        t = routineTimer.getTime()
        tThisFlip = win.getFutureFlipTime(clock=routineTimer)
        tThisFlipGlobal = win.getFutureFlipTime(clock=None)
        frameN = frameN + 1  # number of completed frames (so 0 is the first frame)
        # update/draw components on each frame
        
        # *text_223* updates
        
        # if text_223 is starting this frame...
        if text_223.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
            # keep track of start time/frame for later
            text_223.frameNStart = frameN  # exact frame index
            text_223.tStart = t  # local t and not account for scr refresh
            text_223.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(text_223, 'tStartRefresh')  # time at next scr refresh
            # add timestamp to datafile
            thisExp.timestampOnFlip(win, 'text_223.started')
            # update status
            text_223.status = STARTED
            text_223.setAutoDraw(True)
        
        # if text_223 is active this frame...
        if text_223.status == STARTED:
            # update params
            pass
        
        # *text_224* updates
        
        # if text_224 is starting this frame...
        if text_224.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
            # keep track of start time/frame for later
            text_224.frameNStart = frameN  # exact frame index
            text_224.tStart = t  # local t and not account for scr refresh
            text_224.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(text_224, 'tStartRefresh')  # time at next scr refresh
            # add timestamp to datafile
            thisExp.timestampOnFlip(win, 'text_224.started')
            # update status
            text_224.status = STARTED
            text_224.setAutoDraw(True)
        
        # if text_224 is active this frame...
        if text_224.status == STARTED:
            # update params
            pass
        
        # *text_225* updates
        
        # if text_225 is starting this frame...
        if text_225.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
            # keep track of start time/frame for later
            text_225.frameNStart = frameN  # exact frame index
            text_225.tStart = t  # local t and not account for scr refresh
            text_225.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(text_225, 'tStartRefresh')  # time at next scr refresh
            # add timestamp to datafile
            thisExp.timestampOnFlip(win, 'text_225.started')
            # update status
            text_225.status = STARTED
            text_225.setAutoDraw(True)
        
        # if text_225 is active this frame...
        if text_225.status == STARTED:
            # update params
            pass
        
        # *key_resp_70* updates
        waitOnFlip = False
        
        # if key_resp_70 is starting this frame...
        if key_resp_70.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
            # keep track of start time/frame for later
            key_resp_70.frameNStart = frameN  # exact frame index
            key_resp_70.tStart = t  # local t and not account for scr refresh
            key_resp_70.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(key_resp_70, 'tStartRefresh')  # time at next scr refresh
            # add timestamp to datafile
            thisExp.timestampOnFlip(win, 'key_resp_70.started')
            # update status
            key_resp_70.status = STARTED
            # keyboard checking is just starting
            waitOnFlip = True
            win.callOnFlip(key_resp_70.clock.reset)  # t=0 on next screen flip
            win.callOnFlip(key_resp_70.clearEvents, eventType='keyboard')  # clear events on next screen flip
        if key_resp_70.status == STARTED and not waitOnFlip:
            theseKeys = key_resp_70.getKeys(keyList=[1,2,3,4,5,'1','2','3','4','5'], ignoreKeys=["escape"], waitRelease=False)
            _key_resp_70_allKeys.extend(theseKeys)
            if len(_key_resp_70_allKeys):
                key_resp_70.keys = _key_resp_70_allKeys[-1].name  # just the last key pressed
                key_resp_70.rt = _key_resp_70_allKeys[-1].rt
                key_resp_70.duration = _key_resp_70_allKeys[-1].duration
                # a response ends the routine
                continueRoutine = False
        
        # check for quit (typically the Esc key)
        if defaultKeyboard.getKeys(keyList=["escape"]):
            thisExp.status = FINISHED
        if thisExp.status == FINISHED or endExpNow:
            endExperiment(thisExp, inputs=inputs, win=win)
            return
        
        # check if all components have finished
        if not continueRoutine:  # a component has requested a forced-end of Routine
            routineForceEnded = True
            break
        continueRoutine = False  # will revert to True if at least one component still running
        for thisComponent in SS3Components:
            if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:
                continueRoutine = True
                break  # at least one component has not yet finished
        
        # refresh the screen
        if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen
            win.flip()
    
    # --- Ending Routine "SS3" ---
    for thisComponent in SS3Components:
        if hasattr(thisComponent, "setAutoDraw"):
            thisComponent.setAutoDraw(False)
    thisExp.addData('SS3.stopped', globalClock.getTime())
    # check responses
    if key_resp_70.keys in ['', [], None]:  # No response was made
        key_resp_70.keys = None
    thisExp.addData('key_resp_70.keys',key_resp_70.keys)
    if key_resp_70.keys != None:  # we had a response
        thisExp.addData('key_resp_70.rt', key_resp_70.rt)
        thisExp.addData('key_resp_70.duration', key_resp_70.duration)
    thisExp.nextEntry()
    # the Routine "SS3" was not non-slip safe, so reset the non-slip timer
    routineTimer.reset()
    
    # --- Prepare to start Routine "SS4" ---
    continueRoutine = True
    # update component parameters for each repeat
    thisExp.addData('SS4.started', globalClock.getTime())
    key_resp_71.keys = []
    key_resp_71.rt = []
    _key_resp_71_allKeys = []
    # keep track of which components have finished
    SS4Components = [text_226, text_227, text_228, key_resp_71]
    for thisComponent in SS4Components:
        thisComponent.tStart = None
        thisComponent.tStop = None
        thisComponent.tStartRefresh = None
        thisComponent.tStopRefresh = None
        if hasattr(thisComponent, 'status'):
            thisComponent.status = NOT_STARTED
    # reset timers
    t = 0
    _timeToFirstFrame = win.getFutureFlipTime(clock="now")
    frameN = -1
    
    # --- Run Routine "SS4" ---
    routineForceEnded = not continueRoutine
    while continueRoutine:
        # get current time
        t = routineTimer.getTime()
        tThisFlip = win.getFutureFlipTime(clock=routineTimer)
        tThisFlipGlobal = win.getFutureFlipTime(clock=None)
        frameN = frameN + 1  # number of completed frames (so 0 is the first frame)
        # update/draw components on each frame
        
        # *text_226* updates
        
        # if text_226 is starting this frame...
        if text_226.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
            # keep track of start time/frame for later
            text_226.frameNStart = frameN  # exact frame index
            text_226.tStart = t  # local t and not account for scr refresh
            text_226.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(text_226, 'tStartRefresh')  # time at next scr refresh
            # add timestamp to datafile
            thisExp.timestampOnFlip(win, 'text_226.started')
            # update status
            text_226.status = STARTED
            text_226.setAutoDraw(True)
        
        # if text_226 is active this frame...
        if text_226.status == STARTED:
            # update params
            pass
        
        # *text_227* updates
        
        # if text_227 is starting this frame...
        if text_227.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
            # keep track of start time/frame for later
            text_227.frameNStart = frameN  # exact frame index
            text_227.tStart = t  # local t and not account for scr refresh
            text_227.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(text_227, 'tStartRefresh')  # time at next scr refresh
            # add timestamp to datafile
            thisExp.timestampOnFlip(win, 'text_227.started')
            # update status
            text_227.status = STARTED
            text_227.setAutoDraw(True)
        
        # if text_227 is active this frame...
        if text_227.status == STARTED:
            # update params
            pass
        
        # *text_228* updates
        
        # if text_228 is starting this frame...
        if text_228.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
            # keep track of start time/frame for later
            text_228.frameNStart = frameN  # exact frame index
            text_228.tStart = t  # local t and not account for scr refresh
            text_228.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(text_228, 'tStartRefresh')  # time at next scr refresh
            # add timestamp to datafile
            thisExp.timestampOnFlip(win, 'text_228.started')
            # update status
            text_228.status = STARTED
            text_228.setAutoDraw(True)
        
        # if text_228 is active this frame...
        if text_228.status == STARTED:
            # update params
            pass
        
        # *key_resp_71* updates
        waitOnFlip = False
        
        # if key_resp_71 is starting this frame...
        if key_resp_71.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
            # keep track of start time/frame for later
            key_resp_71.frameNStart = frameN  # exact frame index
            key_resp_71.tStart = t  # local t and not account for scr refresh
            key_resp_71.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(key_resp_71, 'tStartRefresh')  # time at next scr refresh
            # add timestamp to datafile
            thisExp.timestampOnFlip(win, 'key_resp_71.started')
            # update status
            key_resp_71.status = STARTED
            # keyboard checking is just starting
            waitOnFlip = True
            win.callOnFlip(key_resp_71.clock.reset)  # t=0 on next screen flip
            win.callOnFlip(key_resp_71.clearEvents, eventType='keyboard')  # clear events on next screen flip
        if key_resp_71.status == STARTED and not waitOnFlip:
            theseKeys = key_resp_71.getKeys(keyList=[1,2,3,4,5,'1','2','3','4','5'], ignoreKeys=["escape"], waitRelease=False)
            _key_resp_71_allKeys.extend(theseKeys)
            if len(_key_resp_71_allKeys):
                key_resp_71.keys = _key_resp_71_allKeys[-1].name  # just the last key pressed
                key_resp_71.rt = _key_resp_71_allKeys[-1].rt
                key_resp_71.duration = _key_resp_71_allKeys[-1].duration
                # a response ends the routine
                continueRoutine = False
        
        # check for quit (typically the Esc key)
        if defaultKeyboard.getKeys(keyList=["escape"]):
            thisExp.status = FINISHED
        if thisExp.status == FINISHED or endExpNow:
            endExperiment(thisExp, inputs=inputs, win=win)
            return
        
        # check if all components have finished
        if not continueRoutine:  # a component has requested a forced-end of Routine
            routineForceEnded = True
            break
        continueRoutine = False  # will revert to True if at least one component still running
        for thisComponent in SS4Components:
            if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:
                continueRoutine = True
                break  # at least one component has not yet finished
        
        # refresh the screen
        if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen
            win.flip()
    
    # --- Ending Routine "SS4" ---
    for thisComponent in SS4Components:
        if hasattr(thisComponent, "setAutoDraw"):
            thisComponent.setAutoDraw(False)
    thisExp.addData('SS4.stopped', globalClock.getTime())
    # check responses
    if key_resp_71.keys in ['', [], None]:  # No response was made
        key_resp_71.keys = None
    thisExp.addData('key_resp_71.keys',key_resp_71.keys)
    if key_resp_71.keys != None:  # we had a response
        thisExp.addData('key_resp_71.rt', key_resp_71.rt)
        thisExp.addData('key_resp_71.duration', key_resp_71.duration)
    thisExp.nextEntry()
    # the Routine "SS4" was not non-slip safe, so reset the non-slip timer
    routineTimer.reset()
    
    # --- Prepare to start Routine "SS5" ---
    continueRoutine = True
    # update component parameters for each repeat
    thisExp.addData('SS5.started', globalClock.getTime())
    key_resp_72.keys = []
    key_resp_72.rt = []
    _key_resp_72_allKeys = []
    # keep track of which components have finished
    SS5Components = [text_229, text_230, text_231, key_resp_72]
    for thisComponent in SS5Components:
        thisComponent.tStart = None
        thisComponent.tStop = None
        thisComponent.tStartRefresh = None
        thisComponent.tStopRefresh = None
        if hasattr(thisComponent, 'status'):
            thisComponent.status = NOT_STARTED
    # reset timers
    t = 0
    _timeToFirstFrame = win.getFutureFlipTime(clock="now")
    frameN = -1
    
    # --- Run Routine "SS5" ---
    routineForceEnded = not continueRoutine
    while continueRoutine:
        # get current time
        t = routineTimer.getTime()
        tThisFlip = win.getFutureFlipTime(clock=routineTimer)
        tThisFlipGlobal = win.getFutureFlipTime(clock=None)
        frameN = frameN + 1  # number of completed frames (so 0 is the first frame)
        # update/draw components on each frame
        
        # *text_229* updates
        
        # if text_229 is starting this frame...
        if text_229.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
            # keep track of start time/frame for later
            text_229.frameNStart = frameN  # exact frame index
            text_229.tStart = t  # local t and not account for scr refresh
            text_229.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(text_229, 'tStartRefresh')  # time at next scr refresh
            # add timestamp to datafile
            thisExp.timestampOnFlip(win, 'text_229.started')
            # update status
            text_229.status = STARTED
            text_229.setAutoDraw(True)
        
        # if text_229 is active this frame...
        if text_229.status == STARTED:
            # update params
            pass
        
        # *text_230* updates
        
        # if text_230 is starting this frame...
        if text_230.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
            # keep track of start time/frame for later
            text_230.frameNStart = frameN  # exact frame index
            text_230.tStart = t  # local t and not account for scr refresh
            text_230.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(text_230, 'tStartRefresh')  # time at next scr refresh
            # add timestamp to datafile
            thisExp.timestampOnFlip(win, 'text_230.started')
            # update status
            text_230.status = STARTED
            text_230.setAutoDraw(True)
        
        # if text_230 is active this frame...
        if text_230.status == STARTED:
            # update params
            pass
        
        # *text_231* updates
        
        # if text_231 is starting this frame...
        if text_231.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
            # keep track of start time/frame for later
            text_231.frameNStart = frameN  # exact frame index
            text_231.tStart = t  # local t and not account for scr refresh
            text_231.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(text_231, 'tStartRefresh')  # time at next scr refresh
            # add timestamp to datafile
            thisExp.timestampOnFlip(win, 'text_231.started')
            # update status
            text_231.status = STARTED
            text_231.setAutoDraw(True)
        
        # if text_231 is active this frame...
        if text_231.status == STARTED:
            # update params
            pass
        
        # *key_resp_72* updates
        waitOnFlip = False
        
        # if key_resp_72 is starting this frame...
        if key_resp_72.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
            # keep track of start time/frame for later
            key_resp_72.frameNStart = frameN  # exact frame index
            key_resp_72.tStart = t  # local t and not account for scr refresh
            key_resp_72.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(key_resp_72, 'tStartRefresh')  # time at next scr refresh
            # add timestamp to datafile
            thisExp.timestampOnFlip(win, 'key_resp_72.started')
            # update status
            key_resp_72.status = STARTED
            # keyboard checking is just starting
            waitOnFlip = True
            win.callOnFlip(key_resp_72.clock.reset)  # t=0 on next screen flip
            win.callOnFlip(key_resp_72.clearEvents, eventType='keyboard')  # clear events on next screen flip
        if key_resp_72.status == STARTED and not waitOnFlip:
            theseKeys = key_resp_72.getKeys(keyList=[1,2,3,4,5,'1','2','3','4','5'], ignoreKeys=["escape"], waitRelease=False)
            _key_resp_72_allKeys.extend(theseKeys)
            if len(_key_resp_72_allKeys):
                key_resp_72.keys = _key_resp_72_allKeys[-1].name  # just the last key pressed
                key_resp_72.rt = _key_resp_72_allKeys[-1].rt
                key_resp_72.duration = _key_resp_72_allKeys[-1].duration
                # a response ends the routine
                continueRoutine = False
        
        # check for quit (typically the Esc key)
        if defaultKeyboard.getKeys(keyList=["escape"]):
            thisExp.status = FINISHED
        if thisExp.status == FINISHED or endExpNow:
            endExperiment(thisExp, inputs=inputs, win=win)
            return
        
        # check if all components have finished
        if not continueRoutine:  # a component has requested a forced-end of Routine
            routineForceEnded = True
            break
        continueRoutine = False  # will revert to True if at least one component still running
        for thisComponent in SS5Components:
            if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:
                continueRoutine = True
                break  # at least one component has not yet finished
        
        # refresh the screen
        if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen
            win.flip()
    
    # --- Ending Routine "SS5" ---
    for thisComponent in SS5Components:
        if hasattr(thisComponent, "setAutoDraw"):
            thisComponent.setAutoDraw(False)
    thisExp.addData('SS5.stopped', globalClock.getTime())
    # check responses
    if key_resp_72.keys in ['', [], None]:  # No response was made
        key_resp_72.keys = None
    thisExp.addData('key_resp_72.keys',key_resp_72.keys)
    if key_resp_72.keys != None:  # we had a response
        thisExp.addData('key_resp_72.rt', key_resp_72.rt)
        thisExp.addData('key_resp_72.duration', key_resp_72.duration)
    thisExp.nextEntry()
    # the Routine "SS5" was not non-slip safe, so reset the non-slip timer
    routineTimer.reset()
    
    # --- Prepare to start Routine "SS6" ---
    continueRoutine = True
    # update component parameters for each repeat
    thisExp.addData('SS6.started', globalClock.getTime())
    key_resp_73.keys = []
    key_resp_73.rt = []
    _key_resp_73_allKeys = []
    # keep track of which components have finished
    SS6Components = [text_232, text_233, text_234, key_resp_73]
    for thisComponent in SS6Components:
        thisComponent.tStart = None
        thisComponent.tStop = None
        thisComponent.tStartRefresh = None
        thisComponent.tStopRefresh = None
        if hasattr(thisComponent, 'status'):
            thisComponent.status = NOT_STARTED
    # reset timers
    t = 0
    _timeToFirstFrame = win.getFutureFlipTime(clock="now")
    frameN = -1
    
    # --- Run Routine "SS6" ---
    routineForceEnded = not continueRoutine
    while continueRoutine:
        # get current time
        t = routineTimer.getTime()
        tThisFlip = win.getFutureFlipTime(clock=routineTimer)
        tThisFlipGlobal = win.getFutureFlipTime(clock=None)
        frameN = frameN + 1  # number of completed frames (so 0 is the first frame)
        # update/draw components on each frame
        
        # *text_232* updates
        
        # if text_232 is starting this frame...
        if text_232.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
            # keep track of start time/frame for later
            text_232.frameNStart = frameN  # exact frame index
            text_232.tStart = t  # local t and not account for scr refresh
            text_232.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(text_232, 'tStartRefresh')  # time at next scr refresh
            # add timestamp to datafile
            thisExp.timestampOnFlip(win, 'text_232.started')
            # update status
            text_232.status = STARTED
            text_232.setAutoDraw(True)
        
        # if text_232 is active this frame...
        if text_232.status == STARTED:
            # update params
            pass
        
        # *text_233* updates
        
        # if text_233 is starting this frame...
        if text_233.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
            # keep track of start time/frame for later
            text_233.frameNStart = frameN  # exact frame index
            text_233.tStart = t  # local t and not account for scr refresh
            text_233.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(text_233, 'tStartRefresh')  # time at next scr refresh
            # add timestamp to datafile
            thisExp.timestampOnFlip(win, 'text_233.started')
            # update status
            text_233.status = STARTED
            text_233.setAutoDraw(True)
        
        # if text_233 is active this frame...
        if text_233.status == STARTED:
            # update params
            pass
        
        # *text_234* updates
        
        # if text_234 is starting this frame...
        if text_234.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
            # keep track of start time/frame for later
            text_234.frameNStart = frameN  # exact frame index
            text_234.tStart = t  # local t and not account for scr refresh
            text_234.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(text_234, 'tStartRefresh')  # time at next scr refresh
            # add timestamp to datafile
            thisExp.timestampOnFlip(win, 'text_234.started')
            # update status
            text_234.status = STARTED
            text_234.setAutoDraw(True)
        
        # if text_234 is active this frame...
        if text_234.status == STARTED:
            # update params
            pass
        
        # *key_resp_73* updates
        waitOnFlip = False
        
        # if key_resp_73 is starting this frame...
        if key_resp_73.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
            # keep track of start time/frame for later
            key_resp_73.frameNStart = frameN  # exact frame index
            key_resp_73.tStart = t  # local t and not account for scr refresh
            key_resp_73.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(key_resp_73, 'tStartRefresh')  # time at next scr refresh
            # add timestamp to datafile
            thisExp.timestampOnFlip(win, 'key_resp_73.started')
            # update status
            key_resp_73.status = STARTED
            # keyboard checking is just starting
            waitOnFlip = True
            win.callOnFlip(key_resp_73.clock.reset)  # t=0 on next screen flip
            win.callOnFlip(key_resp_73.clearEvents, eventType='keyboard')  # clear events on next screen flip
        if key_resp_73.status == STARTED and not waitOnFlip:
            theseKeys = key_resp_73.getKeys(keyList=[1,2,3,4,5,'1','2','3','4','5'], ignoreKeys=["escape"], waitRelease=False)
            _key_resp_73_allKeys.extend(theseKeys)
            if len(_key_resp_73_allKeys):
                key_resp_73.keys = _key_resp_73_allKeys[-1].name  # just the last key pressed
                key_resp_73.rt = _key_resp_73_allKeys[-1].rt
                key_resp_73.duration = _key_resp_73_allKeys[-1].duration
                # a response ends the routine
                continueRoutine = False
        
        # check for quit (typically the Esc key)
        if defaultKeyboard.getKeys(keyList=["escape"]):
            thisExp.status = FINISHED
        if thisExp.status == FINISHED or endExpNow:
            endExperiment(thisExp, inputs=inputs, win=win)
            return
        
        # check if all components have finished
        if not continueRoutine:  # a component has requested a forced-end of Routine
            routineForceEnded = True
            break
        continueRoutine = False  # will revert to True if at least one component still running
        for thisComponent in SS6Components:
            if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:
                continueRoutine = True
                break  # at least one component has not yet finished
        
        # refresh the screen
        if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen
            win.flip()
    
    # --- Ending Routine "SS6" ---
    for thisComponent in SS6Components:
        if hasattr(thisComponent, "setAutoDraw"):
            thisComponent.setAutoDraw(False)
    thisExp.addData('SS6.stopped', globalClock.getTime())
    # check responses
    if key_resp_73.keys in ['', [], None]:  # No response was made
        key_resp_73.keys = None
    thisExp.addData('key_resp_73.keys',key_resp_73.keys)
    if key_resp_73.keys != None:  # we had a response
        thisExp.addData('key_resp_73.rt', key_resp_73.rt)
        thisExp.addData('key_resp_73.duration', key_resp_73.duration)
    thisExp.nextEntry()
    # the Routine "SS6" was not non-slip safe, so reset the non-slip timer
    routineTimer.reset()
    
    # --- Prepare to start Routine "SS7" ---
    continueRoutine = True
    # update component parameters for each repeat
    thisExp.addData('SS7.started', globalClock.getTime())
    key_resp_74.keys = []
    key_resp_74.rt = []
    _key_resp_74_allKeys = []
    # keep track of which components have finished
    SS7Components = [text_235, text_236, text_237, key_resp_74]
    for thisComponent in SS7Components:
        thisComponent.tStart = None
        thisComponent.tStop = None
        thisComponent.tStartRefresh = None
        thisComponent.tStopRefresh = None
        if hasattr(thisComponent, 'status'):
            thisComponent.status = NOT_STARTED
    # reset timers
    t = 0
    _timeToFirstFrame = win.getFutureFlipTime(clock="now")
    frameN = -1
    
    # --- Run Routine "SS7" ---
    routineForceEnded = not continueRoutine
    while continueRoutine:
        # get current time
        t = routineTimer.getTime()
        tThisFlip = win.getFutureFlipTime(clock=routineTimer)
        tThisFlipGlobal = win.getFutureFlipTime(clock=None)
        frameN = frameN + 1  # number of completed frames (so 0 is the first frame)
        # update/draw components on each frame
        
        # *text_235* updates
        
        # if text_235 is starting this frame...
        if text_235.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
            # keep track of start time/frame for later
            text_235.frameNStart = frameN  # exact frame index
            text_235.tStart = t  # local t and not account for scr refresh
            text_235.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(text_235, 'tStartRefresh')  # time at next scr refresh
            # add timestamp to datafile
            thisExp.timestampOnFlip(win, 'text_235.started')
            # update status
            text_235.status = STARTED
            text_235.setAutoDraw(True)
        
        # if text_235 is active this frame...
        if text_235.status == STARTED:
            # update params
            pass
        
        # *text_236* updates
        
        # if text_236 is starting this frame...
        if text_236.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
            # keep track of start time/frame for later
            text_236.frameNStart = frameN  # exact frame index
            text_236.tStart = t  # local t and not account for scr refresh
            text_236.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(text_236, 'tStartRefresh')  # time at next scr refresh
            # add timestamp to datafile
            thisExp.timestampOnFlip(win, 'text_236.started')
            # update status
            text_236.status = STARTED
            text_236.setAutoDraw(True)
        
        # if text_236 is active this frame...
        if text_236.status == STARTED:
            # update params
            pass
        
        # *text_237* updates
        
        # if text_237 is starting this frame...
        if text_237.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
            # keep track of start time/frame for later
            text_237.frameNStart = frameN  # exact frame index
            text_237.tStart = t  # local t and not account for scr refresh
            text_237.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(text_237, 'tStartRefresh')  # time at next scr refresh
            # add timestamp to datafile
            thisExp.timestampOnFlip(win, 'text_237.started')
            # update status
            text_237.status = STARTED
            text_237.setAutoDraw(True)
        
        # if text_237 is active this frame...
        if text_237.status == STARTED:
            # update params
            pass
        
        # *key_resp_74* updates
        waitOnFlip = False
        
        # if key_resp_74 is starting this frame...
        if key_resp_74.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
            # keep track of start time/frame for later
            key_resp_74.frameNStart = frameN  # exact frame index
            key_resp_74.tStart = t  # local t and not account for scr refresh
            key_resp_74.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(key_resp_74, 'tStartRefresh')  # time at next scr refresh
            # add timestamp to datafile
            thisExp.timestampOnFlip(win, 'key_resp_74.started')
            # update status
            key_resp_74.status = STARTED
            # keyboard checking is just starting
            waitOnFlip = True
            win.callOnFlip(key_resp_74.clock.reset)  # t=0 on next screen flip
            win.callOnFlip(key_resp_74.clearEvents, eventType='keyboard')  # clear events on next screen flip
        if key_resp_74.status == STARTED and not waitOnFlip:
            theseKeys = key_resp_74.getKeys(keyList=[1,2,3,4,5,'1','2','3','4','5'], ignoreKeys=["escape"], waitRelease=False)
            _key_resp_74_allKeys.extend(theseKeys)
            if len(_key_resp_74_allKeys):
                key_resp_74.keys = _key_resp_74_allKeys[-1].name  # just the last key pressed
                key_resp_74.rt = _key_resp_74_allKeys[-1].rt
                key_resp_74.duration = _key_resp_74_allKeys[-1].duration
                # a response ends the routine
                continueRoutine = False
        
        # check for quit (typically the Esc key)
        if defaultKeyboard.getKeys(keyList=["escape"]):
            thisExp.status = FINISHED
        if thisExp.status == FINISHED or endExpNow:
            endExperiment(thisExp, inputs=inputs, win=win)
            return
        
        # check if all components have finished
        if not continueRoutine:  # a component has requested a forced-end of Routine
            routineForceEnded = True
            break
        continueRoutine = False  # will revert to True if at least one component still running
        for thisComponent in SS7Components:
            if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:
                continueRoutine = True
                break  # at least one component has not yet finished
        
        # refresh the screen
        if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen
            win.flip()
    
    # --- Ending Routine "SS7" ---
    for thisComponent in SS7Components:
        if hasattr(thisComponent, "setAutoDraw"):
            thisComponent.setAutoDraw(False)
    thisExp.addData('SS7.stopped', globalClock.getTime())
    # check responses
    if key_resp_74.keys in ['', [], None]:  # No response was made
        key_resp_74.keys = None
    thisExp.addData('key_resp_74.keys',key_resp_74.keys)
    if key_resp_74.keys != None:  # we had a response
        thisExp.addData('key_resp_74.rt', key_resp_74.rt)
        thisExp.addData('key_resp_74.duration', key_resp_74.duration)
    thisExp.nextEntry()
    # the Routine "SS7" was not non-slip safe, so reset the non-slip timer
    routineTimer.reset()
    
    # --- Prepare to start Routine "SS8" ---
    continueRoutine = True
    # update component parameters for each repeat
    thisExp.addData('SS8.started', globalClock.getTime())
    key_resp_75.keys = []
    key_resp_75.rt = []
    _key_resp_75_allKeys = []
    # keep track of which components have finished
    SS8Components = [text_238, text_239, text_240, key_resp_75]
    for thisComponent in SS8Components:
        thisComponent.tStart = None
        thisComponent.tStop = None
        thisComponent.tStartRefresh = None
        thisComponent.tStopRefresh = None
        if hasattr(thisComponent, 'status'):
            thisComponent.status = NOT_STARTED
    # reset timers
    t = 0
    _timeToFirstFrame = win.getFutureFlipTime(clock="now")
    frameN = -1
    
    # --- Run Routine "SS8" ---
    routineForceEnded = not continueRoutine
    while continueRoutine:
        # get current time
        t = routineTimer.getTime()
        tThisFlip = win.getFutureFlipTime(clock=routineTimer)
        tThisFlipGlobal = win.getFutureFlipTime(clock=None)
        frameN = frameN + 1  # number of completed frames (so 0 is the first frame)
        # update/draw components on each frame
        
        # *text_238* updates
        
        # if text_238 is starting this frame...
        if text_238.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
            # keep track of start time/frame for later
            text_238.frameNStart = frameN  # exact frame index
            text_238.tStart = t  # local t and not account for scr refresh
            text_238.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(text_238, 'tStartRefresh')  # time at next scr refresh
            # add timestamp to datafile
            thisExp.timestampOnFlip(win, 'text_238.started')
            # update status
            text_238.status = STARTED
            text_238.setAutoDraw(True)
        
        # if text_238 is active this frame...
        if text_238.status == STARTED:
            # update params
            pass
        
        # *text_239* updates
        
        # if text_239 is starting this frame...
        if text_239.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
            # keep track of start time/frame for later
            text_239.frameNStart = frameN  # exact frame index
            text_239.tStart = t  # local t and not account for scr refresh
            text_239.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(text_239, 'tStartRefresh')  # time at next scr refresh
            # add timestamp to datafile
            thisExp.timestampOnFlip(win, 'text_239.started')
            # update status
            text_239.status = STARTED
            text_239.setAutoDraw(True)
        
        # if text_239 is active this frame...
        if text_239.status == STARTED:
            # update params
            pass
        
        # *text_240* updates
        
        # if text_240 is starting this frame...
        if text_240.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
            # keep track of start time/frame for later
            text_240.frameNStart = frameN  # exact frame index
            text_240.tStart = t  # local t and not account for scr refresh
            text_240.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(text_240, 'tStartRefresh')  # time at next scr refresh
            # add timestamp to datafile
            thisExp.timestampOnFlip(win, 'text_240.started')
            # update status
            text_240.status = STARTED
            text_240.setAutoDraw(True)
        
        # if text_240 is active this frame...
        if text_240.status == STARTED:
            # update params
            pass
        
        # *key_resp_75* updates
        waitOnFlip = False
        
        # if key_resp_75 is starting this frame...
        if key_resp_75.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
            # keep track of start time/frame for later
            key_resp_75.frameNStart = frameN  # exact frame index
            key_resp_75.tStart = t  # local t and not account for scr refresh
            key_resp_75.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(key_resp_75, 'tStartRefresh')  # time at next scr refresh
            # add timestamp to datafile
            thisExp.timestampOnFlip(win, 'key_resp_75.started')
            # update status
            key_resp_75.status = STARTED
            # keyboard checking is just starting
            waitOnFlip = True
            win.callOnFlip(key_resp_75.clock.reset)  # t=0 on next screen flip
            win.callOnFlip(key_resp_75.clearEvents, eventType='keyboard')  # clear events on next screen flip
        if key_resp_75.status == STARTED and not waitOnFlip:
            theseKeys = key_resp_75.getKeys(keyList=[1,2,3,4,5,'1','2','3','4','5'], ignoreKeys=["escape"], waitRelease=False)
            _key_resp_75_allKeys.extend(theseKeys)
            if len(_key_resp_75_allKeys):
                key_resp_75.keys = _key_resp_75_allKeys[-1].name  # just the last key pressed
                key_resp_75.rt = _key_resp_75_allKeys[-1].rt
                key_resp_75.duration = _key_resp_75_allKeys[-1].duration
                # a response ends the routine
                continueRoutine = False
        
        # check for quit (typically the Esc key)
        if defaultKeyboard.getKeys(keyList=["escape"]):
            thisExp.status = FINISHED
        if thisExp.status == FINISHED or endExpNow:
            endExperiment(thisExp, inputs=inputs, win=win)
            return
        
        # check if all components have finished
        if not continueRoutine:  # a component has requested a forced-end of Routine
            routineForceEnded = True
            break
        continueRoutine = False  # will revert to True if at least one component still running
        for thisComponent in SS8Components:
            if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:
                continueRoutine = True
                break  # at least one component has not yet finished
        
        # refresh the screen
        if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen
            win.flip()
    
    # --- Ending Routine "SS8" ---
    for thisComponent in SS8Components:
        if hasattr(thisComponent, "setAutoDraw"):
            thisComponent.setAutoDraw(False)
    thisExp.addData('SS8.stopped', globalClock.getTime())
    # check responses
    if key_resp_75.keys in ['', [], None]:  # No response was made
        key_resp_75.keys = None
    thisExp.addData('key_resp_75.keys',key_resp_75.keys)
    if key_resp_75.keys != None:  # we had a response
        thisExp.addData('key_resp_75.rt', key_resp_75.rt)
        thisExp.addData('key_resp_75.duration', key_resp_75.duration)
    thisExp.nextEntry()
    # the Routine "SS8" was not non-slip safe, so reset the non-slip timer
    routineTimer.reset()
    
    # --- Prepare to start Routine "SS9" ---
    continueRoutine = True
    # update component parameters for each repeat
    thisExp.addData('SS9.started', globalClock.getTime())
    key_resp_76.keys = []
    key_resp_76.rt = []
    _key_resp_76_allKeys = []
    # keep track of which components have finished
    SS9Components = [text_241, text_242, text_243, key_resp_76]
    for thisComponent in SS9Components:
        thisComponent.tStart = None
        thisComponent.tStop = None
        thisComponent.tStartRefresh = None
        thisComponent.tStopRefresh = None
        if hasattr(thisComponent, 'status'):
            thisComponent.status = NOT_STARTED
    # reset timers
    t = 0
    _timeToFirstFrame = win.getFutureFlipTime(clock="now")
    frameN = -1
    
    # --- Run Routine "SS9" ---
    routineForceEnded = not continueRoutine
    while continueRoutine:
        # get current time
        t = routineTimer.getTime()
        tThisFlip = win.getFutureFlipTime(clock=routineTimer)
        tThisFlipGlobal = win.getFutureFlipTime(clock=None)
        frameN = frameN + 1  # number of completed frames (so 0 is the first frame)
        # update/draw components on each frame
        
        # *text_241* updates
        
        # if text_241 is starting this frame...
        if text_241.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
            # keep track of start time/frame for later
            text_241.frameNStart = frameN  # exact frame index
            text_241.tStart = t  # local t and not account for scr refresh
            text_241.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(text_241, 'tStartRefresh')  # time at next scr refresh
            # add timestamp to datafile
            thisExp.timestampOnFlip(win, 'text_241.started')
            # update status
            text_241.status = STARTED
            text_241.setAutoDraw(True)
        
        # if text_241 is active this frame...
        if text_241.status == STARTED:
            # update params
            pass
        
        # *text_242* updates
        
        # if text_242 is starting this frame...
        if text_242.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
            # keep track of start time/frame for later
            text_242.frameNStart = frameN  # exact frame index
            text_242.tStart = t  # local t and not account for scr refresh
            text_242.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(text_242, 'tStartRefresh')  # time at next scr refresh
            # add timestamp to datafile
            thisExp.timestampOnFlip(win, 'text_242.started')
            # update status
            text_242.status = STARTED
            text_242.setAutoDraw(True)
        
        # if text_242 is active this frame...
        if text_242.status == STARTED:
            # update params
            pass
        
        # *text_243* updates
        
        # if text_243 is starting this frame...
        if text_243.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
            # keep track of start time/frame for later
            text_243.frameNStart = frameN  # exact frame index
            text_243.tStart = t  # local t and not account for scr refresh
            text_243.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(text_243, 'tStartRefresh')  # time at next scr refresh
            # add timestamp to datafile
            thisExp.timestampOnFlip(win, 'text_243.started')
            # update status
            text_243.status = STARTED
            text_243.setAutoDraw(True)
        
        # if text_243 is active this frame...
        if text_243.status == STARTED:
            # update params
            pass
        
        # *key_resp_76* updates
        waitOnFlip = False
        
        # if key_resp_76 is starting this frame...
        if key_resp_76.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
            # keep track of start time/frame for later
            key_resp_76.frameNStart = frameN  # exact frame index
            key_resp_76.tStart = t  # local t and not account for scr refresh
            key_resp_76.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(key_resp_76, 'tStartRefresh')  # time at next scr refresh
            # add timestamp to datafile
            thisExp.timestampOnFlip(win, 'key_resp_76.started')
            # update status
            key_resp_76.status = STARTED
            # keyboard checking is just starting
            waitOnFlip = True
            win.callOnFlip(key_resp_76.clock.reset)  # t=0 on next screen flip
            win.callOnFlip(key_resp_76.clearEvents, eventType='keyboard')  # clear events on next screen flip
        if key_resp_76.status == STARTED and not waitOnFlip:
            theseKeys = key_resp_76.getKeys(keyList=[1,2,3,4,5,'1','2','3','4','5'], ignoreKeys=["escape"], waitRelease=False)
            _key_resp_76_allKeys.extend(theseKeys)
            if len(_key_resp_76_allKeys):
                key_resp_76.keys = _key_resp_76_allKeys[-1].name  # just the last key pressed
                key_resp_76.rt = _key_resp_76_allKeys[-1].rt
                key_resp_76.duration = _key_resp_76_allKeys[-1].duration
                # a response ends the routine
                continueRoutine = False
        
        # check for quit (typically the Esc key)
        if defaultKeyboard.getKeys(keyList=["escape"]):
            thisExp.status = FINISHED
        if thisExp.status == FINISHED or endExpNow:
            endExperiment(thisExp, inputs=inputs, win=win)
            return
        
        # check if all components have finished
        if not continueRoutine:  # a component has requested a forced-end of Routine
            routineForceEnded = True
            break
        continueRoutine = False  # will revert to True if at least one component still running
        for thisComponent in SS9Components:
            if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:
                continueRoutine = True
                break  # at least one component has not yet finished
        
        # refresh the screen
        if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen
            win.flip()
    
    # --- Ending Routine "SS9" ---
    for thisComponent in SS9Components:
        if hasattr(thisComponent, "setAutoDraw"):
            thisComponent.setAutoDraw(False)
    thisExp.addData('SS9.stopped', globalClock.getTime())
    # check responses
    if key_resp_76.keys in ['', [], None]:  # No response was made
        key_resp_76.keys = None
    thisExp.addData('key_resp_76.keys',key_resp_76.keys)
    if key_resp_76.keys != None:  # we had a response
        thisExp.addData('key_resp_76.rt', key_resp_76.rt)
        thisExp.addData('key_resp_76.duration', key_resp_76.duration)
    thisExp.nextEntry()
    # the Routine "SS9" was not non-slip safe, so reset the non-slip timer
    routineTimer.reset()
    
    # --- Prepare to start Routine "SS10" ---
    continueRoutine = True
    # update component parameters for each repeat
    thisExp.addData('SS10.started', globalClock.getTime())
    key_resp_77.keys = []
    key_resp_77.rt = []
    _key_resp_77_allKeys = []
    # keep track of which components have finished
    SS10Components = [text_244, text_245, text_246, key_resp_77]
    for thisComponent in SS10Components:
        thisComponent.tStart = None
        thisComponent.tStop = None
        thisComponent.tStartRefresh = None
        thisComponent.tStopRefresh = None
        if hasattr(thisComponent, 'status'):
            thisComponent.status = NOT_STARTED
    # reset timers
    t = 0
    _timeToFirstFrame = win.getFutureFlipTime(clock="now")
    frameN = -1
    
    # --- Run Routine "SS10" ---
    routineForceEnded = not continueRoutine
    while continueRoutine:
        # get current time
        t = routineTimer.getTime()
        tThisFlip = win.getFutureFlipTime(clock=routineTimer)
        tThisFlipGlobal = win.getFutureFlipTime(clock=None)
        frameN = frameN + 1  # number of completed frames (so 0 is the first frame)
        # update/draw components on each frame
        
        # *text_244* updates
        
        # if text_244 is starting this frame...
        if text_244.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
            # keep track of start time/frame for later
            text_244.frameNStart = frameN  # exact frame index
            text_244.tStart = t  # local t and not account for scr refresh
            text_244.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(text_244, 'tStartRefresh')  # time at next scr refresh
            # add timestamp to datafile
            thisExp.timestampOnFlip(win, 'text_244.started')
            # update status
            text_244.status = STARTED
            text_244.setAutoDraw(True)
        
        # if text_244 is active this frame...
        if text_244.status == STARTED:
            # update params
            pass
        
        # *text_245* updates
        
        # if text_245 is starting this frame...
        if text_245.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
            # keep track of start time/frame for later
            text_245.frameNStart = frameN  # exact frame index
            text_245.tStart = t  # local t and not account for scr refresh
            text_245.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(text_245, 'tStartRefresh')  # time at next scr refresh
            # add timestamp to datafile
            thisExp.timestampOnFlip(win, 'text_245.started')
            # update status
            text_245.status = STARTED
            text_245.setAutoDraw(True)
        
        # if text_245 is active this frame...
        if text_245.status == STARTED:
            # update params
            pass
        
        # *text_246* updates
        
        # if text_246 is starting this frame...
        if text_246.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
            # keep track of start time/frame for later
            text_246.frameNStart = frameN  # exact frame index
            text_246.tStart = t  # local t and not account for scr refresh
            text_246.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(text_246, 'tStartRefresh')  # time at next scr refresh
            # add timestamp to datafile
            thisExp.timestampOnFlip(win, 'text_246.started')
            # update status
            text_246.status = STARTED
            text_246.setAutoDraw(True)
        
        # if text_246 is active this frame...
        if text_246.status == STARTED:
            # update params
            pass
        
        # *key_resp_77* updates
        waitOnFlip = False
        
        # if key_resp_77 is starting this frame...
        if key_resp_77.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
            # keep track of start time/frame for later
            key_resp_77.frameNStart = frameN  # exact frame index
            key_resp_77.tStart = t  # local t and not account for scr refresh
            key_resp_77.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(key_resp_77, 'tStartRefresh')  # time at next scr refresh
            # add timestamp to datafile
            thisExp.timestampOnFlip(win, 'key_resp_77.started')
            # update status
            key_resp_77.status = STARTED
            # keyboard checking is just starting
            waitOnFlip = True
            win.callOnFlip(key_resp_77.clock.reset)  # t=0 on next screen flip
            win.callOnFlip(key_resp_77.clearEvents, eventType='keyboard')  # clear events on next screen flip
        if key_resp_77.status == STARTED and not waitOnFlip:
            theseKeys = key_resp_77.getKeys(keyList=[1,2,3,4,5,'1','2','3','4','5'], ignoreKeys=["escape"], waitRelease=False)
            _key_resp_77_allKeys.extend(theseKeys)
            if len(_key_resp_77_allKeys):
                key_resp_77.keys = _key_resp_77_allKeys[-1].name  # just the last key pressed
                key_resp_77.rt = _key_resp_77_allKeys[-1].rt
                key_resp_77.duration = _key_resp_77_allKeys[-1].duration
                # a response ends the routine
                continueRoutine = False
        
        # check for quit (typically the Esc key)
        if defaultKeyboard.getKeys(keyList=["escape"]):
            thisExp.status = FINISHED
        if thisExp.status == FINISHED or endExpNow:
            endExperiment(thisExp, inputs=inputs, win=win)
            return
        
        # check if all components have finished
        if not continueRoutine:  # a component has requested a forced-end of Routine
            routineForceEnded = True
            break
        continueRoutine = False  # will revert to True if at least one component still running
        for thisComponent in SS10Components:
            if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:
                continueRoutine = True
                break  # at least one component has not yet finished
        
        # refresh the screen
        if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen
            win.flip()
    
    # --- Ending Routine "SS10" ---
    for thisComponent in SS10Components:
        if hasattr(thisComponent, "setAutoDraw"):
            thisComponent.setAutoDraw(False)
    thisExp.addData('SS10.stopped', globalClock.getTime())
    # check responses
    if key_resp_77.keys in ['', [], None]:  # No response was made
        key_resp_77.keys = None
    thisExp.addData('key_resp_77.keys',key_resp_77.keys)
    if key_resp_77.keys != None:  # we had a response
        thisExp.addData('key_resp_77.rt', key_resp_77.rt)
        thisExp.addData('key_resp_77.duration', key_resp_77.duration)
    thisExp.nextEntry()
    # the Routine "SS10" was not non-slip safe, so reset the non-slip timer
    routineTimer.reset()
    
    # set up handler to look after randomisation of conditions etc
    instructions_get_right = data.TrialHandler(nReps=500.0, method='sequential', 
        extraInfo=expInfo, originPath=-1,
        trialList=[None],
        seed=None, name='instructions_get_right')
    thisExp.addLoop(instructions_get_right)  # add the loop to the experiment
    thisInstructions_get_right = instructions_get_right.trialList[0]  # so we can initialise stimuli with some values
    # abbreviate parameter names if possible (e.g. rgb = thisInstructions_get_right.rgb)
    if thisInstructions_get_right != None:
        for paramName in thisInstructions_get_right:
            globals()[paramName] = thisInstructions_get_right[paramName]
    
    for thisInstructions_get_right in instructions_get_right:
        currentLoop = instructions_get_right
        thisExp.timestampOnFlip(win, 'thisRow.t')
        # pause experiment here if requested
        if thisExp.status == PAUSED:
            pauseExperiment(
                thisExp=thisExp, 
                inputs=inputs, 
                win=win, 
                timers=[routineTimer], 
                playbackComponents=[]
        )
        # abbreviate parameter names if possible (e.g. rgb = thisInstructions_get_right.rgb)
        if thisInstructions_get_right != None:
            for paramName in thisInstructions_get_right:
                globals()[paramName] = thisInstructions_get_right[paramName]
        
        # --- Prepare to start Routine "instructions" ---
        continueRoutine = True
        # update component parameters for each repeat
        thisExp.addData('instructions.started', globalClock.getTime())
        end_instructions.keys = []
        end_instructions.rt = []
        _end_instructions_allKeys = []
        # keep track of which components have finished
        instructionsComponents = [instruction_test, end_instructions]
        for thisComponent in instructionsComponents:
            thisComponent.tStart = None
            thisComponent.tStop = None
            thisComponent.tStartRefresh = None
            thisComponent.tStopRefresh = None
            if hasattr(thisComponent, 'status'):
                thisComponent.status = NOT_STARTED
        # reset timers
        t = 0
        _timeToFirstFrame = win.getFutureFlipTime(clock="now")
        frameN = -1
        
        # --- Run Routine "instructions" ---
        routineForceEnded = not continueRoutine
        while continueRoutine:
            # get current time
            t = routineTimer.getTime()
            tThisFlip = win.getFutureFlipTime(clock=routineTimer)
            tThisFlipGlobal = win.getFutureFlipTime(clock=None)
            frameN = frameN + 1  # number of completed frames (so 0 is the first frame)
            # update/draw components on each frame
            
            # *instruction_test* updates
            
            # if instruction_test is starting this frame...
            if instruction_test.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
                # keep track of start time/frame for later
                instruction_test.frameNStart = frameN  # exact frame index
                instruction_test.tStart = t  # local t and not account for scr refresh
                instruction_test.tStartRefresh = tThisFlipGlobal  # on global time
                win.timeOnFlip(instruction_test, 'tStartRefresh')  # time at next scr refresh
                # add timestamp to datafile
                thisExp.timestampOnFlip(win, 'instruction_test.started')
                # update status
                instruction_test.status = STARTED
                instruction_test.setAutoDraw(True)
            
            # if instruction_test is active this frame...
            if instruction_test.status == STARTED:
                # update params
                pass
            
            # *end_instructions* updates
            waitOnFlip = False
            
            # if end_instructions is starting this frame...
            if end_instructions.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
                # keep track of start time/frame for later
                end_instructions.frameNStart = frameN  # exact frame index
                end_instructions.tStart = t  # local t and not account for scr refresh
                end_instructions.tStartRefresh = tThisFlipGlobal  # on global time
                win.timeOnFlip(end_instructions, 'tStartRefresh')  # time at next scr refresh
                # add timestamp to datafile
                thisExp.timestampOnFlip(win, 'end_instructions.started')
                # update status
                end_instructions.status = STARTED
                # keyboard checking is just starting
                waitOnFlip = True
                win.callOnFlip(end_instructions.clock.reset)  # t=0 on next screen flip
                win.callOnFlip(end_instructions.clearEvents, eventType='keyboard')  # clear events on next screen flip
            if end_instructions.status == STARTED and not waitOnFlip:
                theseKeys = end_instructions.getKeys(keyList=['space'], ignoreKeys=["escape"], waitRelease=False)
                _end_instructions_allKeys.extend(theseKeys)
                if len(_end_instructions_allKeys):
                    end_instructions.keys = _end_instructions_allKeys[-1].name  # just the last key pressed
                    end_instructions.rt = _end_instructions_allKeys[-1].rt
                    end_instructions.duration = _end_instructions_allKeys[-1].duration
                    # a response ends the routine
                    continueRoutine = False
            
            # check for quit (typically the Esc key)
            if defaultKeyboard.getKeys(keyList=["escape"]):
                thisExp.status = FINISHED
            if thisExp.status == FINISHED or endExpNow:
                endExperiment(thisExp, inputs=inputs, win=win)
                return
            
            # check if all components have finished
            if not continueRoutine:  # a component has requested a forced-end of Routine
                routineForceEnded = True
                break
            continueRoutine = False  # will revert to True if at least one component still running
            for thisComponent in instructionsComponents:
                if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:
                    continueRoutine = True
                    break  # at least one component has not yet finished
            
            # refresh the screen
            if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen
                win.flip()
        
        # --- Ending Routine "instructions" ---
        for thisComponent in instructionsComponents:
            if hasattr(thisComponent, "setAutoDraw"):
                thisComponent.setAutoDraw(False)
        thisExp.addData('instructions.stopped', globalClock.getTime())
        # the Routine "instructions" was not non-slip safe, so reset the non-slip timer
        routineTimer.reset()
        
        # --- Prepare to start Routine "second_instructions" ---
        continueRoutine = True
        # update component parameters for each repeat
        thisExp.addData('second_instructions.started', globalClock.getTime())
        key_resp_2.keys = []
        key_resp_2.rt = []
        _key_resp_2_allKeys = []
        # keep track of which components have finished
        second_instructionsComponents = [key_resp_2, text_22]
        for thisComponent in second_instructionsComponents:
            thisComponent.tStart = None
            thisComponent.tStop = None
            thisComponent.tStartRefresh = None
            thisComponent.tStopRefresh = None
            if hasattr(thisComponent, 'status'):
                thisComponent.status = NOT_STARTED
        # reset timers
        t = 0
        _timeToFirstFrame = win.getFutureFlipTime(clock="now")
        frameN = -1
        
        # --- Run Routine "second_instructions" ---
        routineForceEnded = not continueRoutine
        while continueRoutine:
            # get current time
            t = routineTimer.getTime()
            tThisFlip = win.getFutureFlipTime(clock=routineTimer)
            tThisFlipGlobal = win.getFutureFlipTime(clock=None)
            frameN = frameN + 1  # number of completed frames (so 0 is the first frame)
            # update/draw components on each frame
            
            # *key_resp_2* updates
            waitOnFlip = False
            
            # if key_resp_2 is starting this frame...
            if key_resp_2.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
                # keep track of start time/frame for later
                key_resp_2.frameNStart = frameN  # exact frame index
                key_resp_2.tStart = t  # local t and not account for scr refresh
                key_resp_2.tStartRefresh = tThisFlipGlobal  # on global time
                win.timeOnFlip(key_resp_2, 'tStartRefresh')  # time at next scr refresh
                # add timestamp to datafile
                thisExp.timestampOnFlip(win, 'key_resp_2.started')
                # update status
                key_resp_2.status = STARTED
                # keyboard checking is just starting
                waitOnFlip = True
                win.callOnFlip(key_resp_2.clock.reset)  # t=0 on next screen flip
                win.callOnFlip(key_resp_2.clearEvents, eventType='keyboard')  # clear events on next screen flip
            if key_resp_2.status == STARTED and not waitOnFlip:
                theseKeys = key_resp_2.getKeys(keyList=['space'], ignoreKeys=["escape"], waitRelease=False)
                _key_resp_2_allKeys.extend(theseKeys)
                if len(_key_resp_2_allKeys):
                    key_resp_2.keys = _key_resp_2_allKeys[-1].name  # just the last key pressed
                    key_resp_2.rt = _key_resp_2_allKeys[-1].rt
                    key_resp_2.duration = _key_resp_2_allKeys[-1].duration
                    # a response ends the routine
                    continueRoutine = False
            
            # *text_22* updates
            
            # if text_22 is starting this frame...
            if text_22.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
                # keep track of start time/frame for later
                text_22.frameNStart = frameN  # exact frame index
                text_22.tStart = t  # local t and not account for scr refresh
                text_22.tStartRefresh = tThisFlipGlobal  # on global time
                win.timeOnFlip(text_22, 'tStartRefresh')  # time at next scr refresh
                # add timestamp to datafile
                thisExp.timestampOnFlip(win, 'text_22.started')
                # update status
                text_22.status = STARTED
                text_22.setAutoDraw(True)
            
            # if text_22 is active this frame...
            if text_22.status == STARTED:
                # update params
                pass
            
            # check for quit (typically the Esc key)
            if defaultKeyboard.getKeys(keyList=["escape"]):
                thisExp.status = FINISHED
            if thisExp.status == FINISHED or endExpNow:
                endExperiment(thisExp, inputs=inputs, win=win)
                return
            
            # check if all components have finished
            if not continueRoutine:  # a component has requested a forced-end of Routine
                routineForceEnded = True
                break
            continueRoutine = False  # will revert to True if at least one component still running
            for thisComponent in second_instructionsComponents:
                if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:
                    continueRoutine = True
                    break  # at least one component has not yet finished
            
            # refresh the screen
            if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen
                win.flip()
        
        # --- Ending Routine "second_instructions" ---
        for thisComponent in second_instructionsComponents:
            if hasattr(thisComponent, "setAutoDraw"):
                thisComponent.setAutoDraw(False)
        thisExp.addData('second_instructions.stopped', globalClock.getTime())
        # the Routine "second_instructions" was not non-slip safe, so reset the non-slip timer
        routineTimer.reset()
        
        # --- Prepare to start Routine "third_instructions" ---
        continueRoutine = True
        # update component parameters for each repeat
        thisExp.addData('third_instructions.started', globalClock.getTime())
        responseleft.keys = []
        responseleft.rt = []
        _responseleft_allKeys = []
        # keep track of which components have finished
        third_instructionsComponents = [responseleft, text_23]
        for thisComponent in third_instructionsComponents:
            thisComponent.tStart = None
            thisComponent.tStop = None
            thisComponent.tStartRefresh = None
            thisComponent.tStopRefresh = None
            if hasattr(thisComponent, 'status'):
                thisComponent.status = NOT_STARTED
        # reset timers
        t = 0
        _timeToFirstFrame = win.getFutureFlipTime(clock="now")
        frameN = -1
        
        # --- Run Routine "third_instructions" ---
        routineForceEnded = not continueRoutine
        while continueRoutine:
            # get current time
            t = routineTimer.getTime()
            tThisFlip = win.getFutureFlipTime(clock=routineTimer)
            tThisFlipGlobal = win.getFutureFlipTime(clock=None)
            frameN = frameN + 1  # number of completed frames (so 0 is the first frame)
            # update/draw components on each frame
            
            # *responseleft* updates
            waitOnFlip = False
            
            # if responseleft is starting this frame...
            if responseleft.status == NOT_STARTED and tThisFlip >= 0.2-frameTolerance:
                # keep track of start time/frame for later
                responseleft.frameNStart = frameN  # exact frame index
                responseleft.tStart = t  # local t and not account for scr refresh
                responseleft.tStartRefresh = tThisFlipGlobal  # on global time
                win.timeOnFlip(responseleft, 'tStartRefresh')  # time at next scr refresh
                # add timestamp to datafile
                thisExp.timestampOnFlip(win, 'responseleft.started')
                # update status
                responseleft.status = STARTED
                # keyboard checking is just starting
                waitOnFlip = True
                win.callOnFlip(responseleft.clock.reset)  # t=0 on next screen flip
                win.callOnFlip(responseleft.clearEvents, eventType='keyboard')  # clear events on next screen flip
            if responseleft.status == STARTED and not waitOnFlip:
                theseKeys = responseleft.getKeys(keyList=['space'], ignoreKeys=["escape"], waitRelease=False)
                _responseleft_allKeys.extend(theseKeys)
                if len(_responseleft_allKeys):
                    responseleft.keys = _responseleft_allKeys[-1].name  # just the last key pressed
                    responseleft.rt = _responseleft_allKeys[-1].rt
                    responseleft.duration = _responseleft_allKeys[-1].duration
                    # a response ends the routine
                    continueRoutine = False
            
            # *text_23* updates
            
            # if text_23 is starting this frame...
            if text_23.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
                # keep track of start time/frame for later
                text_23.frameNStart = frameN  # exact frame index
                text_23.tStart = t  # local t and not account for scr refresh
                text_23.tStartRefresh = tThisFlipGlobal  # on global time
                win.timeOnFlip(text_23, 'tStartRefresh')  # time at next scr refresh
                # add timestamp to datafile
                thisExp.timestampOnFlip(win, 'text_23.started')
                # update status
                text_23.status = STARTED
                text_23.setAutoDraw(True)
            
            # if text_23 is active this frame...
            if text_23.status == STARTED:
                # update params
                pass
            
            # check for quit (typically the Esc key)
            if defaultKeyboard.getKeys(keyList=["escape"]):
                thisExp.status = FINISHED
            if thisExp.status == FINISHED or endExpNow:
                endExperiment(thisExp, inputs=inputs, win=win)
                return
            
            # check if all components have finished
            if not continueRoutine:  # a component has requested a forced-end of Routine
                routineForceEnded = True
                break
            continueRoutine = False  # will revert to True if at least one component still running
            for thisComponent in third_instructionsComponents:
                if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:
                    continueRoutine = True
                    break  # at least one component has not yet finished
            
            # refresh the screen
            if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen
                win.flip()
        
        # --- Ending Routine "third_instructions" ---
        for thisComponent in third_instructionsComponents:
            if hasattr(thisComponent, "setAutoDraw"):
                thisComponent.setAutoDraw(False)
        thisExp.addData('third_instructions.stopped', globalClock.getTime())
        # the Routine "third_instructions" was not non-slip safe, so reset the non-slip timer
        routineTimer.reset()
        
        # --- Prepare to start Routine "instructions4" ---
        continueRoutine = True
        # update component parameters for each repeat
        thisExp.addData('instructions4.started', globalClock.getTime())
        # keep track of which components have finished
        instructions4Components = [text_153]
        for thisComponent in instructions4Components:
            thisComponent.tStart = None
            thisComponent.tStop = None
            thisComponent.tStartRefresh = None
            thisComponent.tStopRefresh = None
            if hasattr(thisComponent, 'status'):
                thisComponent.status = NOT_STARTED
        # reset timers
        t = 0
        _timeToFirstFrame = win.getFutureFlipTime(clock="now")
        frameN = -1
        
        # --- Run Routine "instructions4" ---
        routineForceEnded = not continueRoutine
        while continueRoutine and routineTimer.getTime() < 1.0:
            # get current time
            t = routineTimer.getTime()
            tThisFlip = win.getFutureFlipTime(clock=routineTimer)
            tThisFlipGlobal = win.getFutureFlipTime(clock=None)
            frameN = frameN + 1  # number of completed frames (so 0 is the first frame)
            # update/draw components on each frame
            
            # *text_153* updates
            
            # if text_153 is starting this frame...
            if text_153.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
                # keep track of start time/frame for later
                text_153.frameNStart = frameN  # exact frame index
                text_153.tStart = t  # local t and not account for scr refresh
                text_153.tStartRefresh = tThisFlipGlobal  # on global time
                win.timeOnFlip(text_153, 'tStartRefresh')  # time at next scr refresh
                # add timestamp to datafile
                thisExp.timestampOnFlip(win, 'text_153.started')
                # update status
                text_153.status = STARTED
                text_153.setAutoDraw(True)
            
            # if text_153 is active this frame...
            if text_153.status == STARTED:
                # update params
                pass
            
            # if text_153 is stopping this frame...
            if text_153.status == STARTED:
                # is it time to stop? (based on global clock, using actual start)
                if tThisFlipGlobal > text_153.tStartRefresh + 1.0-frameTolerance:
                    # keep track of stop time/frame for later
                    text_153.tStop = t  # not accounting for scr refresh
                    text_153.frameNStop = frameN  # exact frame index
                    # add timestamp to datafile
                    thisExp.timestampOnFlip(win, 'text_153.stopped')
                    # update status
                    text_153.status = FINISHED
                    text_153.setAutoDraw(False)
            
            # check for quit (typically the Esc key)
            if defaultKeyboard.getKeys(keyList=["escape"]):
                thisExp.status = FINISHED
            if thisExp.status == FINISHED or endExpNow:
                endExperiment(thisExp, inputs=inputs, win=win)
                return
            
            # check if all components have finished
            if not continueRoutine:  # a component has requested a forced-end of Routine
                routineForceEnded = True
                break
            continueRoutine = False  # will revert to True if at least one component still running
            for thisComponent in instructions4Components:
                if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:
                    continueRoutine = True
                    break  # at least one component has not yet finished
            
            # refresh the screen
            if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen
                win.flip()
        
        # --- Ending Routine "instructions4" ---
        for thisComponent in instructions4Components:
            if hasattr(thisComponent, "setAutoDraw"):
                thisComponent.setAutoDraw(False)
        thisExp.addData('instructions4.stopped', globalClock.getTime())
        # using non-slip timing so subtract the expected duration of this Routine (unless ended on request)
        if routineForceEnded:
            routineTimer.reset()
        else:
            routineTimer.addTime(-1.000000)
        
        # set up handler to look after randomisation of conditions etc
        practice_loop = data.TrialHandler(nReps=500.0, method='random', 
            extraInfo=expInfo, originPath=-1,
            trialList=[None],
            seed=None, name='practice_loop')
        thisExp.addLoop(practice_loop)  # add the loop to the experiment
        thisPractice_loop = practice_loop.trialList[0]  # so we can initialise stimuli with some values
        # abbreviate parameter names if possible (e.g. rgb = thisPractice_loop.rgb)
        if thisPractice_loop != None:
            for paramName in thisPractice_loop:
                globals()[paramName] = thisPractice_loop[paramName]
        
        for thisPractice_loop in practice_loop:
            currentLoop = practice_loop
            thisExp.timestampOnFlip(win, 'thisRow.t')
            # pause experiment here if requested
            if thisExp.status == PAUSED:
                pauseExperiment(
                    thisExp=thisExp, 
                    inputs=inputs, 
                    win=win, 
                    timers=[routineTimer], 
                    playbackComponents=[]
            )
            # abbreviate parameter names if possible (e.g. rgb = thisPractice_loop.rgb)
            if thisPractice_loop != None:
                for paramName in thisPractice_loop:
                    globals()[paramName] = thisPractice_loop[paramName]
            
            # set up handler to look after randomisation of conditions etc
            practice_trials = data.TrialHandler(nReps=1.0, method='random', 
                extraInfo=expInfo, originPath=-1,
                trialList=data.importConditions('stage2_4_practice.csv'),
                seed=None, name='practice_trials')
            thisExp.addLoop(practice_trials)  # add the loop to the experiment
            thisPractice_trial = practice_trials.trialList[0]  # so we can initialise stimuli with some values
            # abbreviate parameter names if possible (e.g. rgb = thisPractice_trial.rgb)
            if thisPractice_trial != None:
                for paramName in thisPractice_trial:
                    globals()[paramName] = thisPractice_trial[paramName]
            
            for thisPractice_trial in practice_trials:
                currentLoop = practice_trials
                thisExp.timestampOnFlip(win, 'thisRow.t')
                # pause experiment here if requested
                if thisExp.status == PAUSED:
                    pauseExperiment(
                        thisExp=thisExp, 
                        inputs=inputs, 
                        win=win, 
                        timers=[routineTimer], 
                        playbackComponents=[]
                )
                # abbreviate parameter names if possible (e.g. rgb = thisPractice_trial.rgb)
                if thisPractice_trial != None:
                    for paramName in thisPractice_trial:
                        globals()[paramName] = thisPractice_trial[paramName]
                
                # --- Prepare to start Routine "practice1" ---
                continueRoutine = True
                # update component parameters for each repeat
                thisExp.addData('practice1.started', globalClock.getTime())
                image_22.setImage('apple.png')
                key_resp_10.keys = []
                key_resp_10.rt = []
                _key_resp_10_allKeys = []
                # keep track of which components have finished
                practice1Components = [image_22, key_resp_10, text_40]
                for thisComponent in practice1Components:
                    thisComponent.tStart = None
                    thisComponent.tStop = None
                    thisComponent.tStartRefresh = None
                    thisComponent.tStopRefresh = None
                    if hasattr(thisComponent, 'status'):
                        thisComponent.status = NOT_STARTED
                # reset timers
                t = 0
                _timeToFirstFrame = win.getFutureFlipTime(clock="now")
                frameN = -1
                
                # --- Run Routine "practice1" ---
                routineForceEnded = not continueRoutine
                while continueRoutine:
                    # get current time
                    t = routineTimer.getTime()
                    tThisFlip = win.getFutureFlipTime(clock=routineTimer)
                    tThisFlipGlobal = win.getFutureFlipTime(clock=None)
                    frameN = frameN + 1  # number of completed frames (so 0 is the first frame)
                    # update/draw components on each frame
                    
                    # *image_22* updates
                    
                    # if image_22 is starting this frame...
                    if image_22.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
                        # keep track of start time/frame for later
                        image_22.frameNStart = frameN  # exact frame index
                        image_22.tStart = t  # local t and not account for scr refresh
                        image_22.tStartRefresh = tThisFlipGlobal  # on global time
                        win.timeOnFlip(image_22, 'tStartRefresh')  # time at next scr refresh
                        # add timestamp to datafile
                        thisExp.timestampOnFlip(win, 'image_22.started')
                        # update status
                        image_22.status = STARTED
                        image_22.setAutoDraw(True)
                    
                    # if image_22 is active this frame...
                    if image_22.status == STARTED:
                        # update params
                        pass
                    
                    # *key_resp_10* updates
                    waitOnFlip = False
                    
                    # if key_resp_10 is starting this frame...
                    if key_resp_10.status == NOT_STARTED and tThisFlip >= 0.2-frameTolerance:
                        # keep track of start time/frame for later
                        key_resp_10.frameNStart = frameN  # exact frame index
                        key_resp_10.tStart = t  # local t and not account for scr refresh
                        key_resp_10.tStartRefresh = tThisFlipGlobal  # on global time
                        win.timeOnFlip(key_resp_10, 'tStartRefresh')  # time at next scr refresh
                        # add timestamp to datafile
                        thisExp.timestampOnFlip(win, 'key_resp_10.started')
                        # update status
                        key_resp_10.status = STARTED
                        # keyboard checking is just starting
                        waitOnFlip = True
                        win.callOnFlip(key_resp_10.clock.reset)  # t=0 on next screen flip
                        win.callOnFlip(key_resp_10.clearEvents, eventType='keyboard')  # clear events on next screen flip
                    if key_resp_10.status == STARTED and not waitOnFlip:
                        theseKeys = key_resp_10.getKeys(keyList=[1,'1','left'], ignoreKeys=["escape"], waitRelease=False)
                        _key_resp_10_allKeys.extend(theseKeys)
                        if len(_key_resp_10_allKeys):
                            key_resp_10.keys = _key_resp_10_allKeys[-1].name  # just the last key pressed
                            key_resp_10.rt = _key_resp_10_allKeys[-1].rt
                            key_resp_10.duration = _key_resp_10_allKeys[-1].duration
                            # a response ends the routine
                            continueRoutine = False
                    
                    # *text_40* updates
                    
                    # if text_40 is starting this frame...
                    if text_40.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
                        # keep track of start time/frame for later
                        text_40.frameNStart = frameN  # exact frame index
                        text_40.tStart = t  # local t and not account for scr refresh
                        text_40.tStartRefresh = tThisFlipGlobal  # on global time
                        win.timeOnFlip(text_40, 'tStartRefresh')  # time at next scr refresh
                        # add timestamp to datafile
                        thisExp.timestampOnFlip(win, 'text_40.started')
                        # update status
                        text_40.status = STARTED
                        text_40.setAutoDraw(True)
                    
                    # if text_40 is active this frame...
                    if text_40.status == STARTED:
                        # update params
                        pass
                    
                    # check for quit (typically the Esc key)
                    if defaultKeyboard.getKeys(keyList=["escape"]):
                        thisExp.status = FINISHED
                    if thisExp.status == FINISHED or endExpNow:
                        endExperiment(thisExp, inputs=inputs, win=win)
                        return
                    
                    # check if all components have finished
                    if not continueRoutine:  # a component has requested a forced-end of Routine
                        routineForceEnded = True
                        break
                    continueRoutine = False  # will revert to True if at least one component still running
                    for thisComponent in practice1Components:
                        if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:
                            continueRoutine = True
                            break  # at least one component has not yet finished
                    
                    # refresh the screen
                    if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen
                        win.flip()
                
                # --- Ending Routine "practice1" ---
                for thisComponent in practice1Components:
                    if hasattr(thisComponent, "setAutoDraw"):
                        thisComponent.setAutoDraw(False)
                thisExp.addData('practice1.stopped', globalClock.getTime())
                # check responses
                if key_resp_10.keys in ['', [], None]:  # No response was made
                    key_resp_10.keys = None
                practice_trials.addData('key_resp_10.keys',key_resp_10.keys)
                if key_resp_10.keys != None:  # we had a response
                    practice_trials.addData('key_resp_10.rt', key_resp_10.rt)
                    practice_trials.addData('key_resp_10.duration', key_resp_10.duration)
                # the Routine "practice1" was not non-slip safe, so reset the non-slip timer
                routineTimer.reset()
                
                # --- Prepare to start Routine "practice1_result" ---
                continueRoutine = True
                # update component parameters for each repeat
                thisExp.addData('practice1_result.started', globalClock.getTime())
                image_20.setImage(image_prac2)
                # keep track of which components have finished
                practice1_resultComponents = [image_20]
                for thisComponent in practice1_resultComponents:
                    thisComponent.tStart = None
                    thisComponent.tStop = None
                    thisComponent.tStartRefresh = None
                    thisComponent.tStopRefresh = None
                    if hasattr(thisComponent, 'status'):
                        thisComponent.status = NOT_STARTED
                # reset timers
                t = 0
                _timeToFirstFrame = win.getFutureFlipTime(clock="now")
                frameN = -1
                
                # --- Run Routine "practice1_result" ---
                routineForceEnded = not continueRoutine
                while continueRoutine and routineTimer.getTime() < 1.5:
                    # get current time
                    t = routineTimer.getTime()
                    tThisFlip = win.getFutureFlipTime(clock=routineTimer)
                    tThisFlipGlobal = win.getFutureFlipTime(clock=None)
                    frameN = frameN + 1  # number of completed frames (so 0 is the first frame)
                    # update/draw components on each frame
                    
                    # *image_20* updates
                    
                    # if image_20 is starting this frame...
                    if image_20.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
                        # keep track of start time/frame for later
                        image_20.frameNStart = frameN  # exact frame index
                        image_20.tStart = t  # local t and not account for scr refresh
                        image_20.tStartRefresh = tThisFlipGlobal  # on global time
                        win.timeOnFlip(image_20, 'tStartRefresh')  # time at next scr refresh
                        # add timestamp to datafile
                        thisExp.timestampOnFlip(win, 'image_20.started')
                        # update status
                        image_20.status = STARTED
                        image_20.setAutoDraw(True)
                    
                    # if image_20 is active this frame...
                    if image_20.status == STARTED:
                        # update params
                        pass
                    
                    # if image_20 is stopping this frame...
                    if image_20.status == STARTED:
                        # is it time to stop? (based on global clock, using actual start)
                        if tThisFlipGlobal > image_20.tStartRefresh + 1.5-frameTolerance:
                            # keep track of stop time/frame for later
                            image_20.tStop = t  # not accounting for scr refresh
                            image_20.frameNStop = frameN  # exact frame index
                            # add timestamp to datafile
                            thisExp.timestampOnFlip(win, 'image_20.stopped')
                            # update status
                            image_20.status = FINISHED
                            image_20.setAutoDraw(False)
                    
                    # check for quit (typically the Esc key)
                    if defaultKeyboard.getKeys(keyList=["escape"]):
                        thisExp.status = FINISHED
                    if thisExp.status == FINISHED or endExpNow:
                        endExperiment(thisExp, inputs=inputs, win=win)
                        return
                    
                    # check if all components have finished
                    if not continueRoutine:  # a component has requested a forced-end of Routine
                        routineForceEnded = True
                        break
                    continueRoutine = False  # will revert to True if at least one component still running
                    for thisComponent in practice1_resultComponents:
                        if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:
                            continueRoutine = True
                            break  # at least one component has not yet finished
                    
                    # refresh the screen
                    if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen
                        win.flip()
                
                # --- Ending Routine "practice1_result" ---
                for thisComponent in practice1_resultComponents:
                    if hasattr(thisComponent, "setAutoDraw"):
                        thisComponent.setAutoDraw(False)
                thisExp.addData('practice1_result.stopped', globalClock.getTime())
                # using non-slip timing so subtract the expected duration of this Routine (unless ended on request)
                if routineForceEnded:
                    routineTimer.reset()
                else:
                    routineTimer.addTime(-1.500000)
                
                # --- Prepare to start Routine "next_trial" ---
                continueRoutine = True
                # update component parameters for each repeat
                thisExp.addData('next_trial.started', globalClock.getTime())
                # keep track of which components have finished
                next_trialComponents = [next_trial_text]
                for thisComponent in next_trialComponents:
                    thisComponent.tStart = None
                    thisComponent.tStop = None
                    thisComponent.tStartRefresh = None
                    thisComponent.tStopRefresh = None
                    if hasattr(thisComponent, 'status'):
                        thisComponent.status = NOT_STARTED
                # reset timers
                t = 0
                _timeToFirstFrame = win.getFutureFlipTime(clock="now")
                frameN = -1
                
                # --- Run Routine "next_trial" ---
                routineForceEnded = not continueRoutine
                while continueRoutine and routineTimer.getTime() < 1.0:
                    # get current time
                    t = routineTimer.getTime()
                    tThisFlip = win.getFutureFlipTime(clock=routineTimer)
                    tThisFlipGlobal = win.getFutureFlipTime(clock=None)
                    frameN = frameN + 1  # number of completed frames (so 0 is the first frame)
                    # update/draw components on each frame
                    
                    # *next_trial_text* updates
                    
                    # if next_trial_text is starting this frame...
                    if next_trial_text.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
                        # keep track of start time/frame for later
                        next_trial_text.frameNStart = frameN  # exact frame index
                        next_trial_text.tStart = t  # local t and not account for scr refresh
                        next_trial_text.tStartRefresh = tThisFlipGlobal  # on global time
                        win.timeOnFlip(next_trial_text, 'tStartRefresh')  # time at next scr refresh
                        # add timestamp to datafile
                        thisExp.timestampOnFlip(win, 'next_trial_text.started')
                        # update status
                        next_trial_text.status = STARTED
                        next_trial_text.setAutoDraw(True)
                    
                    # if next_trial_text is active this frame...
                    if next_trial_text.status == STARTED:
                        # update params
                        pass
                    
                    # if next_trial_text is stopping this frame...
                    if next_trial_text.status == STARTED:
                        # is it time to stop? (based on global clock, using actual start)
                        if tThisFlipGlobal > next_trial_text.tStartRefresh + 1-frameTolerance:
                            # keep track of stop time/frame for later
                            next_trial_text.tStop = t  # not accounting for scr refresh
                            next_trial_text.frameNStop = frameN  # exact frame index
                            # add timestamp to datafile
                            thisExp.timestampOnFlip(win, 'next_trial_text.stopped')
                            # update status
                            next_trial_text.status = FINISHED
                            next_trial_text.setAutoDraw(False)
                    
                    # check for quit (typically the Esc key)
                    if defaultKeyboard.getKeys(keyList=["escape"]):
                        thisExp.status = FINISHED
                    if thisExp.status == FINISHED or endExpNow:
                        endExperiment(thisExp, inputs=inputs, win=win)
                        return
                    
                    # check if all components have finished
                    if not continueRoutine:  # a component has requested a forced-end of Routine
                        routineForceEnded = True
                        break
                    continueRoutine = False  # will revert to True if at least one component still running
                    for thisComponent in next_trialComponents:
                        if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:
                            continueRoutine = True
                            break  # at least one component has not yet finished
                    
                    # refresh the screen
                    if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen
                        win.flip()
                
                # --- Ending Routine "next_trial" ---
                for thisComponent in next_trialComponents:
                    if hasattr(thisComponent, "setAutoDraw"):
                        thisComponent.setAutoDraw(False)
                thisExp.addData('next_trial.stopped', globalClock.getTime())
                # using non-slip timing so subtract the expected duration of this Routine (unless ended on request)
                if routineForceEnded:
                    routineTimer.reset()
                else:
                    routineTimer.addTime(-1.000000)
                thisExp.nextEntry()
                
                if thisSession is not None:
                    # if running in a Session with a Liaison client, send data up to now
                    thisSession.sendExperimentData()
            # completed 1.0 repeats of 'practice_trials'
            
            
            # --- Prepare to start Routine "practice1_quiz" ---
            continueRoutine = True
            # update component parameters for each repeat
            thisExp.addData('practice1_quiz.started', globalClock.getTime())
            tree_2.setImage('tree.png')
            practice_answer.keys = []
            practice_answer.rt = []
            _practice_answer_allKeys = []
            # keep track of which components have finished
            practice1_quizComponents = [basket_2, fireworks_2, tree_2, text_24, text_25, text_27, practice_answer, text_26]
            for thisComponent in practice1_quizComponents:
                thisComponent.tStart = None
                thisComponent.tStop = None
                thisComponent.tStartRefresh = None
                thisComponent.tStopRefresh = None
                if hasattr(thisComponent, 'status'):
                    thisComponent.status = NOT_STARTED
            # reset timers
            t = 0
            _timeToFirstFrame = win.getFutureFlipTime(clock="now")
            frameN = -1
            
            # --- Run Routine "practice1_quiz" ---
            routineForceEnded = not continueRoutine
            while continueRoutine:
                # get current time
                t = routineTimer.getTime()
                tThisFlip = win.getFutureFlipTime(clock=routineTimer)
                tThisFlipGlobal = win.getFutureFlipTime(clock=None)
                frameN = frameN + 1  # number of completed frames (so 0 is the first frame)
                # update/draw components on each frame
                
                # *basket_2* updates
                
                # if basket_2 is starting this frame...
                if basket_2.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
                    # keep track of start time/frame for later
                    basket_2.frameNStart = frameN  # exact frame index
                    basket_2.tStart = t  # local t and not account for scr refresh
                    basket_2.tStartRefresh = tThisFlipGlobal  # on global time
                    win.timeOnFlip(basket_2, 'tStartRefresh')  # time at next scr refresh
                    # add timestamp to datafile
                    thisExp.timestampOnFlip(win, 'basket_2.started')
                    # update status
                    basket_2.status = STARTED
                    basket_2.setAutoDraw(True)
                
                # if basket_2 is active this frame...
                if basket_2.status == STARTED:
                    # update params
                    pass
                
                # *fireworks_2* updates
                
                # if fireworks_2 is starting this frame...
                if fireworks_2.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
                    # keep track of start time/frame for later
                    fireworks_2.frameNStart = frameN  # exact frame index
                    fireworks_2.tStart = t  # local t and not account for scr refresh
                    fireworks_2.tStartRefresh = tThisFlipGlobal  # on global time
                    win.timeOnFlip(fireworks_2, 'tStartRefresh')  # time at next scr refresh
                    # add timestamp to datafile
                    thisExp.timestampOnFlip(win, 'fireworks_2.started')
                    # update status
                    fireworks_2.status = STARTED
                    fireworks_2.setAutoDraw(True)
                
                # if fireworks_2 is active this frame...
                if fireworks_2.status == STARTED:
                    # update params
                    pass
                
                # *tree_2* updates
                
                # if tree_2 is starting this frame...
                if tree_2.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
                    # keep track of start time/frame for later
                    tree_2.frameNStart = frameN  # exact frame index
                    tree_2.tStart = t  # local t and not account for scr refresh
                    tree_2.tStartRefresh = tThisFlipGlobal  # on global time
                    win.timeOnFlip(tree_2, 'tStartRefresh')  # time at next scr refresh
                    # add timestamp to datafile
                    thisExp.timestampOnFlip(win, 'tree_2.started')
                    # update status
                    tree_2.status = STARTED
                    tree_2.setAutoDraw(True)
                
                # if tree_2 is active this frame...
                if tree_2.status == STARTED:
                    # update params
                    pass
                
                # *text_24* updates
                
                # if text_24 is starting this frame...
                if text_24.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
                    # keep track of start time/frame for later
                    text_24.frameNStart = frameN  # exact frame index
                    text_24.tStart = t  # local t and not account for scr refresh
                    text_24.tStartRefresh = tThisFlipGlobal  # on global time
                    win.timeOnFlip(text_24, 'tStartRefresh')  # time at next scr refresh
                    # add timestamp to datafile
                    thisExp.timestampOnFlip(win, 'text_24.started')
                    # update status
                    text_24.status = STARTED
                    text_24.setAutoDraw(True)
                
                # if text_24 is active this frame...
                if text_24.status == STARTED:
                    # update params
                    pass
                
                # *text_25* updates
                
                # if text_25 is starting this frame...
                if text_25.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
                    # keep track of start time/frame for later
                    text_25.frameNStart = frameN  # exact frame index
                    text_25.tStart = t  # local t and not account for scr refresh
                    text_25.tStartRefresh = tThisFlipGlobal  # on global time
                    win.timeOnFlip(text_25, 'tStartRefresh')  # time at next scr refresh
                    # add timestamp to datafile
                    thisExp.timestampOnFlip(win, 'text_25.started')
                    # update status
                    text_25.status = STARTED
                    text_25.setAutoDraw(True)
                
                # if text_25 is active this frame...
                if text_25.status == STARTED:
                    # update params
                    pass
                
                # *text_27* updates
                
                # if text_27 is starting this frame...
                if text_27.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
                    # keep track of start time/frame for later
                    text_27.frameNStart = frameN  # exact frame index
                    text_27.tStart = t  # local t and not account for scr refresh
                    text_27.tStartRefresh = tThisFlipGlobal  # on global time
                    win.timeOnFlip(text_27, 'tStartRefresh')  # time at next scr refresh
                    # add timestamp to datafile
                    thisExp.timestampOnFlip(win, 'text_27.started')
                    # update status
                    text_27.status = STARTED
                    text_27.setAutoDraw(True)
                
                # if text_27 is active this frame...
                if text_27.status == STARTED:
                    # update params
                    pass
                
                # *practice_answer* updates
                waitOnFlip = False
                
                # if practice_answer is starting this frame...
                if practice_answer.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
                    # keep track of start time/frame for later
                    practice_answer.frameNStart = frameN  # exact frame index
                    practice_answer.tStart = t  # local t and not account for scr refresh
                    practice_answer.tStartRefresh = tThisFlipGlobal  # on global time
                    win.timeOnFlip(practice_answer, 'tStartRefresh')  # time at next scr refresh
                    # add timestamp to datafile
                    thisExp.timestampOnFlip(win, 'practice_answer.started')
                    # update status
                    practice_answer.status = STARTED
                    # keyboard checking is just starting
                    waitOnFlip = True
                    win.callOnFlip(practice_answer.clock.reset)  # t=0 on next screen flip
                    win.callOnFlip(practice_answer.clearEvents, eventType='keyboard')  # clear events on next screen flip
                if practice_answer.status == STARTED and not waitOnFlip:
                    theseKeys = practice_answer.getKeys(keyList=['a','g','l'], ignoreKeys=["escape"], waitRelease=False)
                    _practice_answer_allKeys.extend(theseKeys)
                    if len(_practice_answer_allKeys):
                        practice_answer.keys = _practice_answer_allKeys[-1].name  # just the last key pressed
                        practice_answer.rt = _practice_answer_allKeys[-1].rt
                        practice_answer.duration = _practice_answer_allKeys[-1].duration
                        # was this correct?
                        if (practice_answer.keys == str('a')) or (practice_answer.keys == 'a'):
                            practice_answer.corr = 1
                        else:
                            practice_answer.corr = 0
                        # a response ends the routine
                        continueRoutine = False
                
                # *text_26* updates
                
                # if text_26 is starting this frame...
                if text_26.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
                    # keep track of start time/frame for later
                    text_26.frameNStart = frameN  # exact frame index
                    text_26.tStart = t  # local t and not account for scr refresh
                    text_26.tStartRefresh = tThisFlipGlobal  # on global time
                    win.timeOnFlip(text_26, 'tStartRefresh')  # time at next scr refresh
                    # add timestamp to datafile
                    thisExp.timestampOnFlip(win, 'text_26.started')
                    # update status
                    text_26.status = STARTED
                    text_26.setAutoDraw(True)
                
                # if text_26 is active this frame...
                if text_26.status == STARTED:
                    # update params
                    pass
                
                # check for quit (typically the Esc key)
                if defaultKeyboard.getKeys(keyList=["escape"]):
                    thisExp.status = FINISHED
                if thisExp.status == FINISHED or endExpNow:
                    endExperiment(thisExp, inputs=inputs, win=win)
                    return
                
                # check if all components have finished
                if not continueRoutine:  # a component has requested a forced-end of Routine
                    routineForceEnded = True
                    break
                continueRoutine = False  # will revert to True if at least one component still running
                for thisComponent in practice1_quizComponents:
                    if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:
                        continueRoutine = True
                        break  # at least one component has not yet finished
                
                # refresh the screen
                if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen
                    win.flip()
            
            # --- Ending Routine "practice1_quiz" ---
            for thisComponent in practice1_quizComponents:
                if hasattr(thisComponent, "setAutoDraw"):
                    thisComponent.setAutoDraw(False)
            thisExp.addData('practice1_quiz.stopped', globalClock.getTime())
            # check responses
            if practice_answer.keys in ['', [], None]:  # No response was made
                practice_answer.keys = None
                # was no response the correct answer?!
                if str('a').lower() == 'none':
                   practice_answer.corr = 1;  # correct non-response
                else:
                   practice_answer.corr = 0;  # failed to respond (incorrectly)
            # store data for practice_loop (TrialHandler)
            practice_loop.addData('practice_answer.keys',practice_answer.keys)
            practice_loop.addData('practice_answer.corr', practice_answer.corr)
            if practice_answer.keys != None:  # we had a response
                practice_loop.addData('practice_answer.rt', practice_answer.rt)
                practice_loop.addData('practice_answer.duration', practice_answer.duration)
            # Run 'End Routine' code from code_21
            if practice_answer.corr:
                print('correct answer')
                practice_loop.finished = True
            # the Routine "practice1_quiz" was not non-slip safe, so reset the non-slip timer
            routineTimer.reset()
            
            # --- Prepare to start Routine "practice1_quizfeedback" ---
            continueRoutine = True
            # update component parameters for each repeat
            thisExp.addData('practice1_quizfeedback.started', globalClock.getTime())
            # Run 'Begin Routine' code from code_14
            if practice_answer.corr:
              msg="Correct!" 
            else:
              msg="Wrong! Re-starting practice"
            text_30.setText(msg)
            # keep track of which components have finished
            practice1_quizfeedbackComponents = [text_30]
            for thisComponent in practice1_quizfeedbackComponents:
                thisComponent.tStart = None
                thisComponent.tStop = None
                thisComponent.tStartRefresh = None
                thisComponent.tStopRefresh = None
                if hasattr(thisComponent, 'status'):
                    thisComponent.status = NOT_STARTED
            # reset timers
            t = 0
            _timeToFirstFrame = win.getFutureFlipTime(clock="now")
            frameN = -1
            
            # --- Run Routine "practice1_quizfeedback" ---
            routineForceEnded = not continueRoutine
            while continueRoutine and routineTimer.getTime() < 1.0:
                # get current time
                t = routineTimer.getTime()
                tThisFlip = win.getFutureFlipTime(clock=routineTimer)
                tThisFlipGlobal = win.getFutureFlipTime(clock=None)
                frameN = frameN + 1  # number of completed frames (so 0 is the first frame)
                # update/draw components on each frame
                
                # *text_30* updates
                
                # if text_30 is starting this frame...
                if text_30.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
                    # keep track of start time/frame for later
                    text_30.frameNStart = frameN  # exact frame index
                    text_30.tStart = t  # local t and not account for scr refresh
                    text_30.tStartRefresh = tThisFlipGlobal  # on global time
                    win.timeOnFlip(text_30, 'tStartRefresh')  # time at next scr refresh
                    # add timestamp to datafile
                    thisExp.timestampOnFlip(win, 'text_30.started')
                    # update status
                    text_30.status = STARTED
                    text_30.setAutoDraw(True)
                
                # if text_30 is active this frame...
                if text_30.status == STARTED:
                    # update params
                    pass
                
                # if text_30 is stopping this frame...
                if text_30.status == STARTED:
                    # is it time to stop? (based on global clock, using actual start)
                    if tThisFlipGlobal > text_30.tStartRefresh + 1.0-frameTolerance:
                        # keep track of stop time/frame for later
                        text_30.tStop = t  # not accounting for scr refresh
                        text_30.frameNStop = frameN  # exact frame index
                        # add timestamp to datafile
                        thisExp.timestampOnFlip(win, 'text_30.stopped')
                        # update status
                        text_30.status = FINISHED
                        text_30.setAutoDraw(False)
                
                # check for quit (typically the Esc key)
                if defaultKeyboard.getKeys(keyList=["escape"]):
                    thisExp.status = FINISHED
                if thisExp.status == FINISHED or endExpNow:
                    endExperiment(thisExp, inputs=inputs, win=win)
                    return
                
                # check if all components have finished
                if not continueRoutine:  # a component has requested a forced-end of Routine
                    routineForceEnded = True
                    break
                continueRoutine = False  # will revert to True if at least one component still running
                for thisComponent in practice1_quizfeedbackComponents:
                    if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:
                        continueRoutine = True
                        break  # at least one component has not yet finished
                
                # refresh the screen
                if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen
                    win.flip()
            
            # --- Ending Routine "practice1_quizfeedback" ---
            for thisComponent in practice1_quizfeedbackComponents:
                if hasattr(thisComponent, "setAutoDraw"):
                    thisComponent.setAutoDraw(False)
            thisExp.addData('practice1_quizfeedback.stopped', globalClock.getTime())
            # using non-slip timing so subtract the expected duration of this Routine (unless ended on request)
            if routineForceEnded:
                routineTimer.reset()
            else:
                routineTimer.addTime(-1.000000)
            thisExp.nextEntry()
            
            if thisSession is not None:
                # if running in a Session with a Liaison client, send data up to now
                thisSession.sendExperimentData()
        # completed 500.0 repeats of 'practice_loop'
        
        
        # --- Prepare to start Routine "memory_quiz_instructions" ---
        continueRoutine = True
        # update component parameters for each repeat
        thisExp.addData('memory_quiz_instructions.started', globalClock.getTime())
        key_resp_23.keys = []
        key_resp_23.rt = []
        _key_resp_23_allKeys = []
        # keep track of which components have finished
        memory_quiz_instructionsComponents = [text_75, key_resp_23]
        for thisComponent in memory_quiz_instructionsComponents:
            thisComponent.tStart = None
            thisComponent.tStop = None
            thisComponent.tStartRefresh = None
            thisComponent.tStopRefresh = None
            if hasattr(thisComponent, 'status'):
                thisComponent.status = NOT_STARTED
        # reset timers
        t = 0
        _timeToFirstFrame = win.getFutureFlipTime(clock="now")
        frameN = -1
        
        # --- Run Routine "memory_quiz_instructions" ---
        routineForceEnded = not continueRoutine
        while continueRoutine:
            # get current time
            t = routineTimer.getTime()
            tThisFlip = win.getFutureFlipTime(clock=routineTimer)
            tThisFlipGlobal = win.getFutureFlipTime(clock=None)
            frameN = frameN + 1  # number of completed frames (so 0 is the first frame)
            # update/draw components on each frame
            
            # *text_75* updates
            
            # if text_75 is starting this frame...
            if text_75.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
                # keep track of start time/frame for later
                text_75.frameNStart = frameN  # exact frame index
                text_75.tStart = t  # local t and not account for scr refresh
                text_75.tStartRefresh = tThisFlipGlobal  # on global time
                win.timeOnFlip(text_75, 'tStartRefresh')  # time at next scr refresh
                # add timestamp to datafile
                thisExp.timestampOnFlip(win, 'text_75.started')
                # update status
                text_75.status = STARTED
                text_75.setAutoDraw(True)
            
            # if text_75 is active this frame...
            if text_75.status == STARTED:
                # update params
                pass
            
            # *key_resp_23* updates
            waitOnFlip = False
            
            # if key_resp_23 is starting this frame...
            if key_resp_23.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
                # keep track of start time/frame for later
                key_resp_23.frameNStart = frameN  # exact frame index
                key_resp_23.tStart = t  # local t and not account for scr refresh
                key_resp_23.tStartRefresh = tThisFlipGlobal  # on global time
                win.timeOnFlip(key_resp_23, 'tStartRefresh')  # time at next scr refresh
                # add timestamp to datafile
                thisExp.timestampOnFlip(win, 'key_resp_23.started')
                # update status
                key_resp_23.status = STARTED
                # keyboard checking is just starting
                waitOnFlip = True
                win.callOnFlip(key_resp_23.clock.reset)  # t=0 on next screen flip
                win.callOnFlip(key_resp_23.clearEvents, eventType='keyboard')  # clear events on next screen flip
            if key_resp_23.status == STARTED and not waitOnFlip:
                theseKeys = key_resp_23.getKeys(keyList=['space'], ignoreKeys=["escape"], waitRelease=False)
                _key_resp_23_allKeys.extend(theseKeys)
                if len(_key_resp_23_allKeys):
                    key_resp_23.keys = _key_resp_23_allKeys[-1].name  # just the last key pressed
                    key_resp_23.rt = _key_resp_23_allKeys[-1].rt
                    key_resp_23.duration = _key_resp_23_allKeys[-1].duration
                    # a response ends the routine
                    continueRoutine = False
            
            # check for quit (typically the Esc key)
            if defaultKeyboard.getKeys(keyList=["escape"]):
                thisExp.status = FINISHED
            if thisExp.status == FINISHED or endExpNow:
                endExperiment(thisExp, inputs=inputs, win=win)
                return
            
            # check if all components have finished
            if not continueRoutine:  # a component has requested a forced-end of Routine
                routineForceEnded = True
                break
            continueRoutine = False  # will revert to True if at least one component still running
            for thisComponent in memory_quiz_instructionsComponents:
                if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:
                    continueRoutine = True
                    break  # at least one component has not yet finished
            
            # refresh the screen
            if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen
                win.flip()
        
        # --- Ending Routine "memory_quiz_instructions" ---
        for thisComponent in memory_quiz_instructionsComponents:
            if hasattr(thisComponent, "setAutoDraw"):
                thisComponent.setAutoDraw(False)
        thisExp.addData('memory_quiz_instructions.stopped', globalClock.getTime())
        # check responses
        if key_resp_23.keys in ['', [], None]:  # No response was made
            key_resp_23.keys = None
        instructions_get_right.addData('key_resp_23.keys',key_resp_23.keys)
        if key_resp_23.keys != None:  # we had a response
            instructions_get_right.addData('key_resp_23.rt', key_resp_23.rt)
            instructions_get_right.addData('key_resp_23.duration', key_resp_23.duration)
        # the Routine "memory_quiz_instructions" was not non-slip safe, so reset the non-slip timer
        routineTimer.reset()
        
        # --- Prepare to start Routine "quiz1_i" ---
        continueRoutine = True
        # update component parameters for each repeat
        thisExp.addData('quiz1_i.started', globalClock.getTime())
        key_resp_17.keys = []
        key_resp_17.rt = []
        _key_resp_17_allKeys = []
        # keep track of which components have finished
        quiz1_iComponents = [text_43, key_resp_17]
        for thisComponent in quiz1_iComponents:
            thisComponent.tStart = None
            thisComponent.tStop = None
            thisComponent.tStartRefresh = None
            thisComponent.tStopRefresh = None
            if hasattr(thisComponent, 'status'):
                thisComponent.status = NOT_STARTED
        # reset timers
        t = 0
        _timeToFirstFrame = win.getFutureFlipTime(clock="now")
        frameN = -1
        
        # --- Run Routine "quiz1_i" ---
        routineForceEnded = not continueRoutine
        while continueRoutine:
            # get current time
            t = routineTimer.getTime()
            tThisFlip = win.getFutureFlipTime(clock=routineTimer)
            tThisFlipGlobal = win.getFutureFlipTime(clock=None)
            frameN = frameN + 1  # number of completed frames (so 0 is the first frame)
            # update/draw components on each frame
            
            # *text_43* updates
            
            # if text_43 is starting this frame...
            if text_43.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
                # keep track of start time/frame for later
                text_43.frameNStart = frameN  # exact frame index
                text_43.tStart = t  # local t and not account for scr refresh
                text_43.tStartRefresh = tThisFlipGlobal  # on global time
                win.timeOnFlip(text_43, 'tStartRefresh')  # time at next scr refresh
                # add timestamp to datafile
                thisExp.timestampOnFlip(win, 'text_43.started')
                # update status
                text_43.status = STARTED
                text_43.setAutoDraw(True)
            
            # if text_43 is active this frame...
            if text_43.status == STARTED:
                # update params
                pass
            
            # *key_resp_17* updates
            waitOnFlip = False
            
            # if key_resp_17 is starting this frame...
            if key_resp_17.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
                # keep track of start time/frame for later
                key_resp_17.frameNStart = frameN  # exact frame index
                key_resp_17.tStart = t  # local t and not account for scr refresh
                key_resp_17.tStartRefresh = tThisFlipGlobal  # on global time
                win.timeOnFlip(key_resp_17, 'tStartRefresh')  # time at next scr refresh
                # add timestamp to datafile
                thisExp.timestampOnFlip(win, 'key_resp_17.started')
                # update status
                key_resp_17.status = STARTED
                # keyboard checking is just starting
                waitOnFlip = True
                win.callOnFlip(key_resp_17.clock.reset)  # t=0 on next screen flip
                win.callOnFlip(key_resp_17.clearEvents, eventType='keyboard')  # clear events on next screen flip
            if key_resp_17.status == STARTED and not waitOnFlip:
                theseKeys = key_resp_17.getKeys(keyList=['a','b','c','d'], ignoreKeys=["escape"], waitRelease=False)
                _key_resp_17_allKeys.extend(theseKeys)
                if len(_key_resp_17_allKeys):
                    key_resp_17.keys = _key_resp_17_allKeys[-1].name  # just the last key pressed
                    key_resp_17.rt = _key_resp_17_allKeys[-1].rt
                    key_resp_17.duration = _key_resp_17_allKeys[-1].duration
                    # a response ends the routine
                    continueRoutine = False
            
            # check for quit (typically the Esc key)
            if defaultKeyboard.getKeys(keyList=["escape"]):
                thisExp.status = FINISHED
            if thisExp.status == FINISHED or endExpNow:
                endExperiment(thisExp, inputs=inputs, win=win)
                return
            
            # check if all components have finished
            if not continueRoutine:  # a component has requested a forced-end of Routine
                routineForceEnded = True
                break
            continueRoutine = False  # will revert to True if at least one component still running
            for thisComponent in quiz1_iComponents:
                if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:
                    continueRoutine = True
                    break  # at least one component has not yet finished
            
            # refresh the screen
            if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen
                win.flip()
        
        # --- Ending Routine "quiz1_i" ---
        for thisComponent in quiz1_iComponents:
            if hasattr(thisComponent, "setAutoDraw"):
                thisComponent.setAutoDraw(False)
        thisExp.addData('quiz1_i.stopped', globalClock.getTime())
        # Run 'End Routine' code from code_27
        correct=0
        if key_resp_17.keys=='c':
            correct+=1
        # check responses
        if key_resp_17.keys in ['', [], None]:  # No response was made
            key_resp_17.keys = None
        instructions_get_right.addData('key_resp_17.keys',key_resp_17.keys)
        if key_resp_17.keys != None:  # we had a response
            instructions_get_right.addData('key_resp_17.rt', key_resp_17.rt)
            instructions_get_right.addData('key_resp_17.duration', key_resp_17.duration)
        # the Routine "quiz1_i" was not non-slip safe, so reset the non-slip timer
        routineTimer.reset()
        
        # --- Prepare to start Routine "quiz2_i" ---
        continueRoutine = True
        # update component parameters for each repeat
        thisExp.addData('quiz2_i.started', globalClock.getTime())
        key_resp_18.keys = []
        key_resp_18.rt = []
        _key_resp_18_allKeys = []
        # keep track of which components have finished
        quiz2_iComponents = [text_70, key_resp_18]
        for thisComponent in quiz2_iComponents:
            thisComponent.tStart = None
            thisComponent.tStop = None
            thisComponent.tStartRefresh = None
            thisComponent.tStopRefresh = None
            if hasattr(thisComponent, 'status'):
                thisComponent.status = NOT_STARTED
        # reset timers
        t = 0
        _timeToFirstFrame = win.getFutureFlipTime(clock="now")
        frameN = -1
        
        # --- Run Routine "quiz2_i" ---
        routineForceEnded = not continueRoutine
        while continueRoutine:
            # get current time
            t = routineTimer.getTime()
            tThisFlip = win.getFutureFlipTime(clock=routineTimer)
            tThisFlipGlobal = win.getFutureFlipTime(clock=None)
            frameN = frameN + 1  # number of completed frames (so 0 is the first frame)
            # update/draw components on each frame
            
            # *text_70* updates
            
            # if text_70 is starting this frame...
            if text_70.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
                # keep track of start time/frame for later
                text_70.frameNStart = frameN  # exact frame index
                text_70.tStart = t  # local t and not account for scr refresh
                text_70.tStartRefresh = tThisFlipGlobal  # on global time
                win.timeOnFlip(text_70, 'tStartRefresh')  # time at next scr refresh
                # add timestamp to datafile
                thisExp.timestampOnFlip(win, 'text_70.started')
                # update status
                text_70.status = STARTED
                text_70.setAutoDraw(True)
            
            # if text_70 is active this frame...
            if text_70.status == STARTED:
                # update params
                pass
            
            # *key_resp_18* updates
            waitOnFlip = False
            
            # if key_resp_18 is starting this frame...
            if key_resp_18.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
                # keep track of start time/frame for later
                key_resp_18.frameNStart = frameN  # exact frame index
                key_resp_18.tStart = t  # local t and not account for scr refresh
                key_resp_18.tStartRefresh = tThisFlipGlobal  # on global time
                win.timeOnFlip(key_resp_18, 'tStartRefresh')  # time at next scr refresh
                # add timestamp to datafile
                thisExp.timestampOnFlip(win, 'key_resp_18.started')
                # update status
                key_resp_18.status = STARTED
                # keyboard checking is just starting
                waitOnFlip = True
                win.callOnFlip(key_resp_18.clock.reset)  # t=0 on next screen flip
                win.callOnFlip(key_resp_18.clearEvents, eventType='keyboard')  # clear events on next screen flip
            if key_resp_18.status == STARTED and not waitOnFlip:
                theseKeys = key_resp_18.getKeys(keyList=['a','b','c','d'], ignoreKeys=["escape"], waitRelease=False)
                _key_resp_18_allKeys.extend(theseKeys)
                if len(_key_resp_18_allKeys):
                    key_resp_18.keys = _key_resp_18_allKeys[-1].name  # just the last key pressed
                    key_resp_18.rt = _key_resp_18_allKeys[-1].rt
                    key_resp_18.duration = _key_resp_18_allKeys[-1].duration
                    # a response ends the routine
                    continueRoutine = False
            
            # check for quit (typically the Esc key)
            if defaultKeyboard.getKeys(keyList=["escape"]):
                thisExp.status = FINISHED
            if thisExp.status == FINISHED or endExpNow:
                endExperiment(thisExp, inputs=inputs, win=win)
                return
            
            # check if all components have finished
            if not continueRoutine:  # a component has requested a forced-end of Routine
                routineForceEnded = True
                break
            continueRoutine = False  # will revert to True if at least one component still running
            for thisComponent in quiz2_iComponents:
                if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:
                    continueRoutine = True
                    break  # at least one component has not yet finished
            
            # refresh the screen
            if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen
                win.flip()
        
        # --- Ending Routine "quiz2_i" ---
        for thisComponent in quiz2_iComponents:
            if hasattr(thisComponent, "setAutoDraw"):
                thisComponent.setAutoDraw(False)
        thisExp.addData('quiz2_i.stopped', globalClock.getTime())
        # Run 'End Routine' code from code_30
        if key_resp_18.keys=='c':
            correct+=1
        # check responses
        if key_resp_18.keys in ['', [], None]:  # No response was made
            key_resp_18.keys = None
        instructions_get_right.addData('key_resp_18.keys',key_resp_18.keys)
        if key_resp_18.keys != None:  # we had a response
            instructions_get_right.addData('key_resp_18.rt', key_resp_18.rt)
            instructions_get_right.addData('key_resp_18.duration', key_resp_18.duration)
        # the Routine "quiz2_i" was not non-slip safe, so reset the non-slip timer
        routineTimer.reset()
        
        # --- Prepare to start Routine "quiz3" ---
        continueRoutine = True
        # update component parameters for each repeat
        thisExp.addData('quiz3.started', globalClock.getTime())
        key_resp_19.keys = []
        key_resp_19.rt = []
        _key_resp_19_allKeys = []
        # keep track of which components have finished
        quiz3Components = [text_71, key_resp_19]
        for thisComponent in quiz3Components:
            thisComponent.tStart = None
            thisComponent.tStop = None
            thisComponent.tStartRefresh = None
            thisComponent.tStopRefresh = None
            if hasattr(thisComponent, 'status'):
                thisComponent.status = NOT_STARTED
        # reset timers
        t = 0
        _timeToFirstFrame = win.getFutureFlipTime(clock="now")
        frameN = -1
        
        # --- Run Routine "quiz3" ---
        routineForceEnded = not continueRoutine
        while continueRoutine:
            # get current time
            t = routineTimer.getTime()
            tThisFlip = win.getFutureFlipTime(clock=routineTimer)
            tThisFlipGlobal = win.getFutureFlipTime(clock=None)
            frameN = frameN + 1  # number of completed frames (so 0 is the first frame)
            # update/draw components on each frame
            
            # *text_71* updates
            
            # if text_71 is starting this frame...
            if text_71.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
                # keep track of start time/frame for later
                text_71.frameNStart = frameN  # exact frame index
                text_71.tStart = t  # local t and not account for scr refresh
                text_71.tStartRefresh = tThisFlipGlobal  # on global time
                win.timeOnFlip(text_71, 'tStartRefresh')  # time at next scr refresh
                # add timestamp to datafile
                thisExp.timestampOnFlip(win, 'text_71.started')
                # update status
                text_71.status = STARTED
                text_71.setAutoDraw(True)
            
            # if text_71 is active this frame...
            if text_71.status == STARTED:
                # update params
                pass
            
            # *key_resp_19* updates
            waitOnFlip = False
            
            # if key_resp_19 is starting this frame...
            if key_resp_19.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
                # keep track of start time/frame for later
                key_resp_19.frameNStart = frameN  # exact frame index
                key_resp_19.tStart = t  # local t and not account for scr refresh
                key_resp_19.tStartRefresh = tThisFlipGlobal  # on global time
                win.timeOnFlip(key_resp_19, 'tStartRefresh')  # time at next scr refresh
                # add timestamp to datafile
                thisExp.timestampOnFlip(win, 'key_resp_19.started')
                # update status
                key_resp_19.status = STARTED
                # keyboard checking is just starting
                waitOnFlip = True
                win.callOnFlip(key_resp_19.clock.reset)  # t=0 on next screen flip
                win.callOnFlip(key_resp_19.clearEvents, eventType='keyboard')  # clear events on next screen flip
            if key_resp_19.status == STARTED and not waitOnFlip:
                theseKeys = key_resp_19.getKeys(keyList=['a','b','c','d'], ignoreKeys=["escape"], waitRelease=False)
                _key_resp_19_allKeys.extend(theseKeys)
                if len(_key_resp_19_allKeys):
                    key_resp_19.keys = _key_resp_19_allKeys[-1].name  # just the last key pressed
                    key_resp_19.rt = _key_resp_19_allKeys[-1].rt
                    key_resp_19.duration = _key_resp_19_allKeys[-1].duration
                    # a response ends the routine
                    continueRoutine = False
            
            # check for quit (typically the Esc key)
            if defaultKeyboard.getKeys(keyList=["escape"]):
                thisExp.status = FINISHED
            if thisExp.status == FINISHED or endExpNow:
                endExperiment(thisExp, inputs=inputs, win=win)
                return
            
            # check if all components have finished
            if not continueRoutine:  # a component has requested a forced-end of Routine
                routineForceEnded = True
                break
            continueRoutine = False  # will revert to True if at least one component still running
            for thisComponent in quiz3Components:
                if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:
                    continueRoutine = True
                    break  # at least one component has not yet finished
            
            # refresh the screen
            if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen
                win.flip()
        
        # --- Ending Routine "quiz3" ---
        for thisComponent in quiz3Components:
            if hasattr(thisComponent, "setAutoDraw"):
                thisComponent.setAutoDraw(False)
        thisExp.addData('quiz3.stopped', globalClock.getTime())
        # Run 'End Routine' code from code_31
        if key_resp_19.keys=='b':
            correct+=1
        
        # check responses
        if key_resp_19.keys in ['', [], None]:  # No response was made
            key_resp_19.keys = None
        instructions_get_right.addData('key_resp_19.keys',key_resp_19.keys)
        if key_resp_19.keys != None:  # we had a response
            instructions_get_right.addData('key_resp_19.rt', key_resp_19.rt)
            instructions_get_right.addData('key_resp_19.duration', key_resp_19.duration)
        # the Routine "quiz3" was not non-slip safe, so reset the non-slip timer
        routineTimer.reset()
        
        # --- Prepare to start Routine "quiz4" ---
        continueRoutine = True
        # update component parameters for each repeat
        thisExp.addData('quiz4.started', globalClock.getTime())
        key_resp_20.keys = []
        key_resp_20.rt = []
        _key_resp_20_allKeys = []
        # keep track of which components have finished
        quiz4Components = [text_72, key_resp_20]
        for thisComponent in quiz4Components:
            thisComponent.tStart = None
            thisComponent.tStop = None
            thisComponent.tStartRefresh = None
            thisComponent.tStopRefresh = None
            if hasattr(thisComponent, 'status'):
                thisComponent.status = NOT_STARTED
        # reset timers
        t = 0
        _timeToFirstFrame = win.getFutureFlipTime(clock="now")
        frameN = -1
        
        # --- Run Routine "quiz4" ---
        routineForceEnded = not continueRoutine
        while continueRoutine:
            # get current time
            t = routineTimer.getTime()
            tThisFlip = win.getFutureFlipTime(clock=routineTimer)
            tThisFlipGlobal = win.getFutureFlipTime(clock=None)
            frameN = frameN + 1  # number of completed frames (so 0 is the first frame)
            # update/draw components on each frame
            
            # *text_72* updates
            
            # if text_72 is starting this frame...
            if text_72.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
                # keep track of start time/frame for later
                text_72.frameNStart = frameN  # exact frame index
                text_72.tStart = t  # local t and not account for scr refresh
                text_72.tStartRefresh = tThisFlipGlobal  # on global time
                win.timeOnFlip(text_72, 'tStartRefresh')  # time at next scr refresh
                # add timestamp to datafile
                thisExp.timestampOnFlip(win, 'text_72.started')
                # update status
                text_72.status = STARTED
                text_72.setAutoDraw(True)
            
            # if text_72 is active this frame...
            if text_72.status == STARTED:
                # update params
                pass
            
            # *key_resp_20* updates
            waitOnFlip = False
            
            # if key_resp_20 is starting this frame...
            if key_resp_20.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
                # keep track of start time/frame for later
                key_resp_20.frameNStart = frameN  # exact frame index
                key_resp_20.tStart = t  # local t and not account for scr refresh
                key_resp_20.tStartRefresh = tThisFlipGlobal  # on global time
                win.timeOnFlip(key_resp_20, 'tStartRefresh')  # time at next scr refresh
                # add timestamp to datafile
                thisExp.timestampOnFlip(win, 'key_resp_20.started')
                # update status
                key_resp_20.status = STARTED
                # keyboard checking is just starting
                waitOnFlip = True
                win.callOnFlip(key_resp_20.clock.reset)  # t=0 on next screen flip
                win.callOnFlip(key_resp_20.clearEvents, eventType='keyboard')  # clear events on next screen flip
            if key_resp_20.status == STARTED and not waitOnFlip:
                theseKeys = key_resp_20.getKeys(keyList=['a','b','c','d'], ignoreKeys=["escape"], waitRelease=False)
                _key_resp_20_allKeys.extend(theseKeys)
                if len(_key_resp_20_allKeys):
                    key_resp_20.keys = _key_resp_20_allKeys[-1].name  # just the last key pressed
                    key_resp_20.rt = _key_resp_20_allKeys[-1].rt
                    key_resp_20.duration = _key_resp_20_allKeys[-1].duration
                    # a response ends the routine
                    continueRoutine = False
            
            # check for quit (typically the Esc key)
            if defaultKeyboard.getKeys(keyList=["escape"]):
                thisExp.status = FINISHED
            if thisExp.status == FINISHED or endExpNow:
                endExperiment(thisExp, inputs=inputs, win=win)
                return
            
            # check if all components have finished
            if not continueRoutine:  # a component has requested a forced-end of Routine
                routineForceEnded = True
                break
            continueRoutine = False  # will revert to True if at least one component still running
            for thisComponent in quiz4Components:
                if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:
                    continueRoutine = True
                    break  # at least one component has not yet finished
            
            # refresh the screen
            if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen
                win.flip()
        
        # --- Ending Routine "quiz4" ---
        for thisComponent in quiz4Components:
            if hasattr(thisComponent, "setAutoDraw"):
                thisComponent.setAutoDraw(False)
        thisExp.addData('quiz4.stopped', globalClock.getTime())
        # Run 'End Routine' code from code_35
        if key_resp_20.keys=='b':
            correct+=1
        
        if correct==4:
            instructions_get_right.finished = True
            msg='Correct! You can now move on'
        else:
            msg='Incorrect! You need to repeat the instructions.'
        # check responses
        if key_resp_20.keys in ['', [], None]:  # No response was made
            key_resp_20.keys = None
        instructions_get_right.addData('key_resp_20.keys',key_resp_20.keys)
        if key_resp_20.keys != None:  # we had a response
            instructions_get_right.addData('key_resp_20.rt', key_resp_20.rt)
            instructions_get_right.addData('key_resp_20.duration', key_resp_20.duration)
        # the Routine "quiz4" was not non-slip safe, so reset the non-slip timer
        routineTimer.reset()
        
        # --- Prepare to start Routine "quiz_feedback" ---
        continueRoutine = True
        # update component parameters for each repeat
        thisExp.addData('quiz_feedback.started', globalClock.getTime())
        result_q_instr.setText(msg)
        # keep track of which components have finished
        quiz_feedbackComponents = [result_q_instr]
        for thisComponent in quiz_feedbackComponents:
            thisComponent.tStart = None
            thisComponent.tStop = None
            thisComponent.tStartRefresh = None
            thisComponent.tStopRefresh = None
            if hasattr(thisComponent, 'status'):
                thisComponent.status = NOT_STARTED
        # reset timers
        t = 0
        _timeToFirstFrame = win.getFutureFlipTime(clock="now")
        frameN = -1
        
        # --- Run Routine "quiz_feedback" ---
        routineForceEnded = not continueRoutine
        while continueRoutine and routineTimer.getTime() < 1.25:
            # get current time
            t = routineTimer.getTime()
            tThisFlip = win.getFutureFlipTime(clock=routineTimer)
            tThisFlipGlobal = win.getFutureFlipTime(clock=None)
            frameN = frameN + 1  # number of completed frames (so 0 is the first frame)
            # update/draw components on each frame
            
            # *result_q_instr* updates
            
            # if result_q_instr is starting this frame...
            if result_q_instr.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
                # keep track of start time/frame for later
                result_q_instr.frameNStart = frameN  # exact frame index
                result_q_instr.tStart = t  # local t and not account for scr refresh
                result_q_instr.tStartRefresh = tThisFlipGlobal  # on global time
                win.timeOnFlip(result_q_instr, 'tStartRefresh')  # time at next scr refresh
                # add timestamp to datafile
                thisExp.timestampOnFlip(win, 'result_q_instr.started')
                # update status
                result_q_instr.status = STARTED
                result_q_instr.setAutoDraw(True)
            
            # if result_q_instr is active this frame...
            if result_q_instr.status == STARTED:
                # update params
                pass
            
            # if result_q_instr is stopping this frame...
            if result_q_instr.status == STARTED:
                # is it time to stop? (based on global clock, using actual start)
                if tThisFlipGlobal > result_q_instr.tStartRefresh + 1.25-frameTolerance:
                    # keep track of stop time/frame for later
                    result_q_instr.tStop = t  # not accounting for scr refresh
                    result_q_instr.frameNStop = frameN  # exact frame index
                    # add timestamp to datafile
                    thisExp.timestampOnFlip(win, 'result_q_instr.stopped')
                    # update status
                    result_q_instr.status = FINISHED
                    result_q_instr.setAutoDraw(False)
            
            # check for quit (typically the Esc key)
            if defaultKeyboard.getKeys(keyList=["escape"]):
                thisExp.status = FINISHED
            if thisExp.status == FINISHED or endExpNow:
                endExperiment(thisExp, inputs=inputs, win=win)
                return
            
            # check if all components have finished
            if not continueRoutine:  # a component has requested a forced-end of Routine
                routineForceEnded = True
                break
            continueRoutine = False  # will revert to True if at least one component still running
            for thisComponent in quiz_feedbackComponents:
                if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:
                    continueRoutine = True
                    break  # at least one component has not yet finished
            
            # refresh the screen
            if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen
                win.flip()
        
        # --- Ending Routine "quiz_feedback" ---
        for thisComponent in quiz_feedbackComponents:
            if hasattr(thisComponent, "setAutoDraw"):
                thisComponent.setAutoDraw(False)
        thisExp.addData('quiz_feedback.stopped', globalClock.getTime())
        # using non-slip timing so subtract the expected duration of this Routine (unless ended on request)
        if routineForceEnded:
            routineTimer.reset()
        else:
            routineTimer.addTime(-1.250000)
        thisExp.nextEntry()
        
        if thisSession is not None:
            # if running in a Session with a Liaison client, send data up to now
            thisSession.sendExperimentData()
    # completed 500.0 repeats of 'instructions_get_right'
    
    
    # --- Prepare to start Routine "start_learning" ---
    continueRoutine = True
    # update component parameters for each repeat
    thisExp.addData('start_learning.started', globalClock.getTime())
    key_resp_7.keys = []
    key_resp_7.rt = []
    _key_resp_7_allKeys = []
    # keep track of which components have finished
    start_learningComponents = [text_31, key_resp_7]
    for thisComponent in start_learningComponents:
        thisComponent.tStart = None
        thisComponent.tStop = None
        thisComponent.tStartRefresh = None
        thisComponent.tStopRefresh = None
        if hasattr(thisComponent, 'status'):
            thisComponent.status = NOT_STARTED
    # reset timers
    t = 0
    _timeToFirstFrame = win.getFutureFlipTime(clock="now")
    frameN = -1
    
    # --- Run Routine "start_learning" ---
    routineForceEnded = not continueRoutine
    while continueRoutine:
        # get current time
        t = routineTimer.getTime()
        tThisFlip = win.getFutureFlipTime(clock=routineTimer)
        tThisFlipGlobal = win.getFutureFlipTime(clock=None)
        frameN = frameN + 1  # number of completed frames (so 0 is the first frame)
        # update/draw components on each frame
        
        # *text_31* updates
        
        # if text_31 is starting this frame...
        if text_31.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
            # keep track of start time/frame for later
            text_31.frameNStart = frameN  # exact frame index
            text_31.tStart = t  # local t and not account for scr refresh
            text_31.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(text_31, 'tStartRefresh')  # time at next scr refresh
            # add timestamp to datafile
            thisExp.timestampOnFlip(win, 'text_31.started')
            # update status
            text_31.status = STARTED
            text_31.setAutoDraw(True)
        
        # if text_31 is active this frame...
        if text_31.status == STARTED:
            # update params
            pass
        
        # *key_resp_7* updates
        waitOnFlip = False
        
        # if key_resp_7 is starting this frame...
        if key_resp_7.status == NOT_STARTED and tThisFlip >= 0-frameTolerance:
            # keep track of start time/frame for later
            key_resp_7.frameNStart = frameN  # exact frame index
            key_resp_7.tStart = t  # local t and not account for scr refresh
            key_resp_7.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(key_resp_7, 'tStartRefresh')  # time at next scr refresh
            # add timestamp to datafile
            thisExp.timestampOnFlip(win, 'key_resp_7.started')
            # update status
            key_resp_7.status = STARTED
            # keyboard checking is just starting
            waitOnFlip = True
            win.callOnFlip(key_resp_7.clock.reset)  # t=0 on next screen flip
            win.callOnFlip(key_resp_7.clearEvents, eventType='keyboard')  # clear events on next screen flip
        if key_resp_7.status == STARTED and not waitOnFlip:
            theseKeys = key_resp_7.getKeys(keyList=['space'], ignoreKeys=["escape"], waitRelease=False)
            _key_resp_7_allKeys.extend(theseKeys)
            if len(_key_resp_7_allKeys):
                key_resp_7.keys = _key_resp_7_allKeys[-1].name  # just the last key pressed
                key_resp_7.rt = _key_resp_7_allKeys[-1].rt
                key_resp_7.duration = _key_resp_7_allKeys[-1].duration
                # a response ends the routine
                continueRoutine = False
        
        # check for quit (typically the Esc key)
        if defaultKeyboard.getKeys(keyList=["escape"]):
            thisExp.status = FINISHED
        if thisExp.status == FINISHED or endExpNow:
            endExperiment(thisExp, inputs=inputs, win=win)
            return
        
        # check if all components have finished
        if not continueRoutine:  # a component has requested a forced-end of Routine
            routineForceEnded = True
            break
        continueRoutine = False  # will revert to True if at least one component still running
        for thisComponent in start_learningComponents:
            if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:
                continueRoutine = True
                break  # at least one component has not yet finished
        
        # refresh the screen
        if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen
            win.flip()
    
    # --- Ending Routine "start_learning" ---
    for thisComponent in start_learningComponents:
        if hasattr(thisComponent, "setAutoDraw"):
            thisComponent.setAutoDraw(False)
    thisExp.addData('start_learning.stopped', globalClock.getTime())
    # the Routine "start_learning" was not non-slip safe, so reset the non-slip timer
    routineTimer.reset()
    
    # set up handler to look after randomisation of conditions etc
    learning_phase = data.TrialHandler(nReps=3.0, method='random', 
        extraInfo=expInfo, originPath=-1,
        trialList=[None],
        seed=None, name='learning_phase')
    thisExp.addLoop(learning_phase)  # add the loop to the experiment
    thisLearning_phase = learning_phase.trialList[0]  # so we can initialise stimuli with some values
    # abbreviate parameter names if possible (e.g. rgb = thisLearning_phase.rgb)
    if thisLearning_phase != None:
        for paramName in thisLearning_phase:
            globals()[paramName] = thisLearning_phase[paramName]
    
    for thisLearning_phase in learning_phase:
        currentLoop = learning_phase
        thisExp.timestampOnFlip(win, 'thisRow.t')
        # pause experiment here if requested
        if thisExp.status == PAUSED:
            pauseExperiment(
                thisExp=thisExp, 
                inputs=inputs, 
                win=win, 
                timers=[routineTimer], 
                playbackComponents=[]
        )
        # abbreviate parameter names if possible (e.g. rgb = thisLearning_phase.rgb)
        if thisLearning_phase != None:
            for paramName in thisLearning_phase:
                globals()[paramName] = thisLearning_phase[paramName]
        
        # set up handler to look after randomisation of conditions etc
        learn_1 = data.TrialHandler(nReps=4.0, method='random', 
            extraInfo=expInfo, originPath=-1,
            trialList=data.importConditions('image_train_press.xlsx'),
            seed=None, name='learn_1')
        thisExp.addLoop(learn_1)  # add the loop to the experiment
        thisLearn_1 = learn_1.trialList[0]  # so we can initialise stimuli with some values
        # abbreviate parameter names if possible (e.g. rgb = thisLearn_1.rgb)
        if thisLearn_1 != None:
            for paramName in thisLearn_1:
                globals()[paramName] = thisLearn_1[paramName]
        
        for thisLearn_1 in learn_1:
            currentLoop = learn_1
            thisExp.timestampOnFlip(win, 'thisRow.t')
            # pause experiment here if requested
            if thisExp.status == PAUSED:
                pauseExperiment(
                    thisExp=thisExp, 
                    inputs=inputs, 
                    win=win, 
                    timers=[routineTimer], 
                    playbackComponents=[]
            )
            # abbreviate parameter names if possible (e.g. rgb = thisLearn_1.rgb)
            if thisLearn_1 != None:
                for paramName in thisLearn_1:
                    globals()[paramName] = thisLearn_1[paramName]
            
            # set up handler to look after randomisation of conditions etc
            incorrect_loop = data.TrialHandler(nReps=9999.0, method='random', 
                extraInfo=expInfo, originPath=-1,
                trialList=[None],
                seed=None, name='incorrect_loop')
            thisExp.addLoop(incorrect_loop)  # add the loop to the experiment
            thisIncorrect_loop = incorrect_loop.trialList[0]  # so we can initialise stimuli with some values
            # abbreviate parameter names if possible (e.g. rgb = thisIncorrect_loop.rgb)
            if thisIncorrect_loop != None:
                for paramName in thisIncorrect_loop:
                    globals()[paramName] = thisIncorrect_loop[paramName]
            
            for thisIncorrect_loop in incorrect_loop:
                currentLoop = incorrect_loop
                thisExp.timestampOnFlip(win, 'thisRow.t')
                # pause experiment here if requested
                if thisExp.status == PAUSED:
                    pauseExperiment(
                        thisExp=thisExp, 
                        inputs=inputs, 
                        win=win, 
                        timers=[routineTimer], 
                        playbackComponents=[]
                )
                # abbreviate parameter names if possible (e.g. rgb = thisIncorrect_loop.rgb)
                if thisIncorrect_loop != None:
                    for paramName in thisIncorrect_loop:
                        globals()[paramName] = thisIncorrect_loop[paramName]
                
                # --- Prepare to start Routine "learn1" ---
                continueRoutine = True
                # update component parameters for each repeat
                thisExp.addData('learn1.started', globalClock.getTime())
                key_resp.keys = []
                key_resp.rt = []
                _key_resp_allKeys = []
                image_1.setImage(image1)
                text.setText(action1)
                # keep track of which components have finished
                learn1Components = [key_resp, image_1, text]
                for thisComponent in learn1Components:
                    thisComponent.tStart = None
                    thisComponent.tStop = None
                    thisComponent.tStartRefresh = None
                    thisComponent.tStopRefresh = None
                    if hasattr(thisComponent, 'status'):
                        thisComponent.status = NOT_STARTED
                # reset timers
                t = 0
                _timeToFirstFrame = win.getFutureFlipTime(clock="now")
                frameN = -1
                
                # --- Run Routine "learn1" ---
                routineForceEnded = not continueRoutine
                while continueRoutine:
                    # get current time
                    t = routineTimer.getTime()
                    tThisFlip = win.getFutureFlipTime(clock=routineTimer)
                    tThisFlipGlobal = win.getFutureFlipTime(clock=None)
                    frameN = frameN + 1  # number of completed frames (so 0 is the first frame)
                    # update/draw components on each frame
                    
                    # *key_resp* updates
                    waitOnFlip = False
                    
                    # if key_resp is starting this frame...
                    if key_resp.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
                        # keep track of start time/frame for later
                        key_resp.frameNStart = frameN  # exact frame index
                        key_resp.tStart = t  # local t and not account for scr refresh
                        key_resp.tStartRefresh = tThisFlipGlobal  # on global time
                        win.timeOnFlip(key_resp, 'tStartRefresh')  # time at next scr refresh
                        # add timestamp to datafile
                        thisExp.timestampOnFlip(win, 'key_resp.started')
                        # update status
                        key_resp.status = STARTED
                        # keyboard checking is just starting
                        waitOnFlip = True
                        win.callOnFlip(key_resp.clock.reset)  # t=0 on next screen flip
                        win.callOnFlip(key_resp.clearEvents, eventType='keyboard')  # clear events on next screen flip
                    if key_resp.status == STARTED and not waitOnFlip:
                        theseKeys = key_resp.getKeys(keyList=['left','right'], ignoreKeys=["escape"], waitRelease=False)
                        _key_resp_allKeys.extend(theseKeys)
                        if len(_key_resp_allKeys):
                            key_resp.keys = _key_resp_allKeys[-1].name  # just the last key pressed
                            key_resp.rt = _key_resp_allKeys[-1].rt
                            key_resp.duration = _key_resp_allKeys[-1].duration
                            # was this correct?
                            if (key_resp.keys == str(corr_ans)) or (key_resp.keys == corr_ans):
                                key_resp.corr = 1
                            else:
                                key_resp.corr = 0
                            # a response ends the routine
                            continueRoutine = False
                    
                    # *image_1* updates
                    
                    # if image_1 is starting this frame...
                    if image_1.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
                        # keep track of start time/frame for later
                        image_1.frameNStart = frameN  # exact frame index
                        image_1.tStart = t  # local t and not account for scr refresh
                        image_1.tStartRefresh = tThisFlipGlobal  # on global time
                        win.timeOnFlip(image_1, 'tStartRefresh')  # time at next scr refresh
                        # add timestamp to datafile
                        thisExp.timestampOnFlip(win, 'image_1.started')
                        # update status
                        image_1.status = STARTED
                        image_1.setAutoDraw(True)
                    
                    # if image_1 is active this frame...
                    if image_1.status == STARTED:
                        # update params
                        pass
                    
                    # *text* updates
                    
                    # if text is starting this frame...
                    if text.status == NOT_STARTED and tThisFlip >= 1-frameTolerance:
                        # keep track of start time/frame for later
                        text.frameNStart = frameN  # exact frame index
                        text.tStart = t  # local t and not account for scr refresh
                        text.tStartRefresh = tThisFlipGlobal  # on global time
                        win.timeOnFlip(text, 'tStartRefresh')  # time at next scr refresh
                        # add timestamp to datafile
                        thisExp.timestampOnFlip(win, 'text.started')
                        # update status
                        text.status = STARTED
                        text.setAutoDraw(True)
                    
                    # if text is active this frame...
                    if text.status == STARTED:
                        # update params
                        pass
                    
                    # check for quit (typically the Esc key)
                    if defaultKeyboard.getKeys(keyList=["escape"]):
                        thisExp.status = FINISHED
                    if thisExp.status == FINISHED or endExpNow:
                        endExperiment(thisExp, inputs=inputs, win=win)
                        return
                    
                    # check if all components have finished
                    if not continueRoutine:  # a component has requested a forced-end of Routine
                        routineForceEnded = True
                        break
                    continueRoutine = False  # will revert to True if at least one component still running
                    for thisComponent in learn1Components:
                        if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:
                            continueRoutine = True
                            break  # at least one component has not yet finished
                    
                    # refresh the screen
                    if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen
                        win.flip()
                
                # --- Ending Routine "learn1" ---
                for thisComponent in learn1Components:
                    if hasattr(thisComponent, "setAutoDraw"):
                        thisComponent.setAutoDraw(False)
                thisExp.addData('learn1.stopped', globalClock.getTime())
                # check responses
                if key_resp.keys in ['', [], None]:  # No response was made
                    key_resp.keys = None
                    # was no response the correct answer?!
                    if str(corr_ans).lower() == 'none':
                       key_resp.corr = 1;  # correct non-response
                    else:
                       key_resp.corr = 0;  # failed to respond (incorrectly)
                # store data for incorrect_loop (TrialHandler)
                incorrect_loop.addData('key_resp.keys',key_resp.keys)
                incorrect_loop.addData('key_resp.corr', key_resp.corr)
                if key_resp.keys != None:  # we had a response
                    incorrect_loop.addData('key_resp.rt', key_resp.rt)
                    incorrect_loop.addData('key_resp.duration', key_resp.duration)
                # the Routine "learn1" was not non-slip safe, so reset the non-slip timer
                routineTimer.reset()
                
                # --- Prepare to start Routine "check_incorrect1" ---
                continueRoutine = True
                # update component parameters for each repeat
                thisExp.addData('check_incorrect1.started', globalClock.getTime())
                # Run 'Begin Routine' code from code_3
                if key_resp.corr:
                    msg_incorrect='correct'
                    incorrect_loop.finished = True
                    continueRoutine=False
                else:
                    msg_incorrect='You clicked the wrong button! If you click the wrong button 5 times, the game will stop and you will NOT GET PAID because you failed to follow instructions!'
                    incorrect_actions+=1
                    continueRoutine=True
                    if incorrect_actions>4:
                        psychoJS.quit()
                text_incorrect_2.setText(msg_incorrect)
                # keep track of which components have finished
                check_incorrect1Components = [text_incorrect_2]
                for thisComponent in check_incorrect1Components:
                    thisComponent.tStart = None
                    thisComponent.tStop = None
                    thisComponent.tStartRefresh = None
                    thisComponent.tStopRefresh = None
                    if hasattr(thisComponent, 'status'):
                        thisComponent.status = NOT_STARTED
                # reset timers
                t = 0
                _timeToFirstFrame = win.getFutureFlipTime(clock="now")
                frameN = -1
                
                # --- Run Routine "check_incorrect1" ---
                routineForceEnded = not continueRoutine
                while continueRoutine and routineTimer.getTime() < 3.0:
                    # get current time
                    t = routineTimer.getTime()
                    tThisFlip = win.getFutureFlipTime(clock=routineTimer)
                    tThisFlipGlobal = win.getFutureFlipTime(clock=None)
                    frameN = frameN + 1  # number of completed frames (so 0 is the first frame)
                    # update/draw components on each frame
                    
                    # *text_incorrect_2* updates
                    
                    # if text_incorrect_2 is starting this frame...
                    if text_incorrect_2.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
                        # keep track of start time/frame for later
                        text_incorrect_2.frameNStart = frameN  # exact frame index
                        text_incorrect_2.tStart = t  # local t and not account for scr refresh
                        text_incorrect_2.tStartRefresh = tThisFlipGlobal  # on global time
                        win.timeOnFlip(text_incorrect_2, 'tStartRefresh')  # time at next scr refresh
                        # add timestamp to datafile
                        thisExp.timestampOnFlip(win, 'text_incorrect_2.started')
                        # update status
                        text_incorrect_2.status = STARTED
                        text_incorrect_2.setAutoDraw(True)
                    
                    # if text_incorrect_2 is active this frame...
                    if text_incorrect_2.status == STARTED:
                        # update params
                        pass
                    
                    # if text_incorrect_2 is stopping this frame...
                    if text_incorrect_2.status == STARTED:
                        # is it time to stop? (based on global clock, using actual start)
                        if tThisFlipGlobal > text_incorrect_2.tStartRefresh + 3-frameTolerance:
                            # keep track of stop time/frame for later
                            text_incorrect_2.tStop = t  # not accounting for scr refresh
                            text_incorrect_2.frameNStop = frameN  # exact frame index
                            # add timestamp to datafile
                            thisExp.timestampOnFlip(win, 'text_incorrect_2.stopped')
                            # update status
                            text_incorrect_2.status = FINISHED
                            text_incorrect_2.setAutoDraw(False)
                    
                    # check for quit (typically the Esc key)
                    if defaultKeyboard.getKeys(keyList=["escape"]):
                        thisExp.status = FINISHED
                    if thisExp.status == FINISHED or endExpNow:
                        endExperiment(thisExp, inputs=inputs, win=win)
                        return
                    
                    # check if all components have finished
                    if not continueRoutine:  # a component has requested a forced-end of Routine
                        routineForceEnded = True
                        break
                    continueRoutine = False  # will revert to True if at least one component still running
                    for thisComponent in check_incorrect1Components:
                        if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:
                            continueRoutine = True
                            break  # at least one component has not yet finished
                    
                    # refresh the screen
                    if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen
                        win.flip()
                
                # --- Ending Routine "check_incorrect1" ---
                for thisComponent in check_incorrect1Components:
                    if hasattr(thisComponent, "setAutoDraw"):
                        thisComponent.setAutoDraw(False)
                thisExp.addData('check_incorrect1.stopped', globalClock.getTime())
                # using non-slip timing so subtract the expected duration of this Routine (unless ended on request)
                if routineForceEnded:
                    routineTimer.reset()
                else:
                    routineTimer.addTime(-3.000000)
                thisExp.nextEntry()
                
                if thisSession is not None:
                    # if running in a Session with a Liaison client, send data up to now
                    thisSession.sendExperimentData()
            # completed 9999.0 repeats of 'incorrect_loop'
            
            
            # --- Prepare to start Routine "learn2" ---
            continueRoutine = True
            # update component parameters for each repeat
            thisExp.addData('learn2.started', globalClock.getTime())
            image_2.setImage(image2)
            # keep track of which components have finished
            learn2Components = [image_2]
            for thisComponent in learn2Components:
                thisComponent.tStart = None
                thisComponent.tStop = None
                thisComponent.tStartRefresh = None
                thisComponent.tStopRefresh = None
                if hasattr(thisComponent, 'status'):
                    thisComponent.status = NOT_STARTED
            # reset timers
            t = 0
            _timeToFirstFrame = win.getFutureFlipTime(clock="now")
            frameN = -1
            
            # --- Run Routine "learn2" ---
            routineForceEnded = not continueRoutine
            while continueRoutine and routineTimer.getTime() < 1.0:
                # get current time
                t = routineTimer.getTime()
                tThisFlip = win.getFutureFlipTime(clock=routineTimer)
                tThisFlipGlobal = win.getFutureFlipTime(clock=None)
                frameN = frameN + 1  # number of completed frames (so 0 is the first frame)
                # update/draw components on each frame
                
                # *image_2* updates
                
                # if image_2 is starting this frame...
                if image_2.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
                    # keep track of start time/frame for later
                    image_2.frameNStart = frameN  # exact frame index
                    image_2.tStart = t  # local t and not account for scr refresh
                    image_2.tStartRefresh = tThisFlipGlobal  # on global time
                    win.timeOnFlip(image_2, 'tStartRefresh')  # time at next scr refresh
                    # add timestamp to datafile
                    thisExp.timestampOnFlip(win, 'image_2.started')
                    # update status
                    image_2.status = STARTED
                    image_2.setAutoDraw(True)
                
                # if image_2 is active this frame...
                if image_2.status == STARTED:
                    # update params
                    pass
                
                # if image_2 is stopping this frame...
                if image_2.status == STARTED:
                    # is it time to stop? (based on global clock, using actual start)
                    if tThisFlipGlobal > image_2.tStartRefresh + 1-frameTolerance:
                        # keep track of stop time/frame for later
                        image_2.tStop = t  # not accounting for scr refresh
                        image_2.frameNStop = frameN  # exact frame index
                        # add timestamp to datafile
                        thisExp.timestampOnFlip(win, 'image_2.stopped')
                        # update status
                        image_2.status = FINISHED
                        image_2.setAutoDraw(False)
                
                # check for quit (typically the Esc key)
                if defaultKeyboard.getKeys(keyList=["escape"]):
                    thisExp.status = FINISHED
                if thisExp.status == FINISHED or endExpNow:
                    endExperiment(thisExp, inputs=inputs, win=win)
                    return
                
                # check if all components have finished
                if not continueRoutine:  # a component has requested a forced-end of Routine
                    routineForceEnded = True
                    break
                continueRoutine = False  # will revert to True if at least one component still running
                for thisComponent in learn2Components:
                    if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:
                        continueRoutine = True
                        break  # at least one component has not yet finished
                
                # refresh the screen
                if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen
                    win.flip()
            
            # --- Ending Routine "learn2" ---
            for thisComponent in learn2Components:
                if hasattr(thisComponent, "setAutoDraw"):
                    thisComponent.setAutoDraw(False)
            thisExp.addData('learn2.stopped', globalClock.getTime())
            # using non-slip timing so subtract the expected duration of this Routine (unless ended on request)
            if routineForceEnded:
                routineTimer.reset()
            else:
                routineTimer.addTime(-1.000000)
            
            # --- Prepare to start Routine "next_trial" ---
            continueRoutine = True
            # update component parameters for each repeat
            thisExp.addData('next_trial.started', globalClock.getTime())
            # keep track of which components have finished
            next_trialComponents = [next_trial_text]
            for thisComponent in next_trialComponents:
                thisComponent.tStart = None
                thisComponent.tStop = None
                thisComponent.tStartRefresh = None
                thisComponent.tStopRefresh = None
                if hasattr(thisComponent, 'status'):
                    thisComponent.status = NOT_STARTED
            # reset timers
            t = 0
            _timeToFirstFrame = win.getFutureFlipTime(clock="now")
            frameN = -1
            
            # --- Run Routine "next_trial" ---
            routineForceEnded = not continueRoutine
            while continueRoutine and routineTimer.getTime() < 1.0:
                # get current time
                t = routineTimer.getTime()
                tThisFlip = win.getFutureFlipTime(clock=routineTimer)
                tThisFlipGlobal = win.getFutureFlipTime(clock=None)
                frameN = frameN + 1  # number of completed frames (so 0 is the first frame)
                # update/draw components on each frame
                
                # *next_trial_text* updates
                
                # if next_trial_text is starting this frame...
                if next_trial_text.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
                    # keep track of start time/frame for later
                    next_trial_text.frameNStart = frameN  # exact frame index
                    next_trial_text.tStart = t  # local t and not account for scr refresh
                    next_trial_text.tStartRefresh = tThisFlipGlobal  # on global time
                    win.timeOnFlip(next_trial_text, 'tStartRefresh')  # time at next scr refresh
                    # add timestamp to datafile
                    thisExp.timestampOnFlip(win, 'next_trial_text.started')
                    # update status
                    next_trial_text.status = STARTED
                    next_trial_text.setAutoDraw(True)
                
                # if next_trial_text is active this frame...
                if next_trial_text.status == STARTED:
                    # update params
                    pass
                
                # if next_trial_text is stopping this frame...
                if next_trial_text.status == STARTED:
                    # is it time to stop? (based on global clock, using actual start)
                    if tThisFlipGlobal > next_trial_text.tStartRefresh + 1-frameTolerance:
                        # keep track of stop time/frame for later
                        next_trial_text.tStop = t  # not accounting for scr refresh
                        next_trial_text.frameNStop = frameN  # exact frame index
                        # add timestamp to datafile
                        thisExp.timestampOnFlip(win, 'next_trial_text.stopped')
                        # update status
                        next_trial_text.status = FINISHED
                        next_trial_text.setAutoDraw(False)
                
                # check for quit (typically the Esc key)
                if defaultKeyboard.getKeys(keyList=["escape"]):
                    thisExp.status = FINISHED
                if thisExp.status == FINISHED or endExpNow:
                    endExperiment(thisExp, inputs=inputs, win=win)
                    return
                
                # check if all components have finished
                if not continueRoutine:  # a component has requested a forced-end of Routine
                    routineForceEnded = True
                    break
                continueRoutine = False  # will revert to True if at least one component still running
                for thisComponent in next_trialComponents:
                    if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:
                        continueRoutine = True
                        break  # at least one component has not yet finished
                
                # refresh the screen
                if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen
                    win.flip()
            
            # --- Ending Routine "next_trial" ---
            for thisComponent in next_trialComponents:
                if hasattr(thisComponent, "setAutoDraw"):
                    thisComponent.setAutoDraw(False)
            thisExp.addData('next_trial.stopped', globalClock.getTime())
            # using non-slip timing so subtract the expected duration of this Routine (unless ended on request)
            if routineForceEnded:
                routineTimer.reset()
            else:
                routineTimer.addTime(-1.000000)
            thisExp.nextEntry()
            
            if thisSession is not None:
                # if running in a Session with a Liaison client, send data up to now
                thisSession.sendExperimentData()
        # completed 4.0 repeats of 'learn_1'
        
        
        # --- Prepare to start Routine "counter_quizzes_round" ---
        continueRoutine = True
        # update component parameters for each repeat
        thisExp.addData('counter_quizzes_round.started', globalClock.getTime())
        # Run 'Begin Routine' code from code_46
        quiz1_score=0
        quiz2_score=0
        # keep track of which components have finished
        counter_quizzes_roundComponents = []
        for thisComponent in counter_quizzes_roundComponents:
            thisComponent.tStart = None
            thisComponent.tStop = None
            thisComponent.tStartRefresh = None
            thisComponent.tStopRefresh = None
            if hasattr(thisComponent, 'status'):
                thisComponent.status = NOT_STARTED
        # reset timers
        t = 0
        _timeToFirstFrame = win.getFutureFlipTime(clock="now")
        frameN = -1
        
        # --- Run Routine "counter_quizzes_round" ---
        routineForceEnded = not continueRoutine
        while continueRoutine:
            # get current time
            t = routineTimer.getTime()
            tThisFlip = win.getFutureFlipTime(clock=routineTimer)
            tThisFlipGlobal = win.getFutureFlipTime(clock=None)
            frameN = frameN + 1  # number of completed frames (so 0 is the first frame)
            # update/draw components on each frame
            
            # check for quit (typically the Esc key)
            if defaultKeyboard.getKeys(keyList=["escape"]):
                thisExp.status = FINISHED
            if thisExp.status == FINISHED or endExpNow:
                endExperiment(thisExp, inputs=inputs, win=win)
                return
            
            # check if all components have finished
            if not continueRoutine:  # a component has requested a forced-end of Routine
                routineForceEnded = True
                break
            continueRoutine = False  # will revert to True if at least one component still running
            for thisComponent in counter_quizzes_roundComponents:
                if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:
                    continueRoutine = True
                    break  # at least one component has not yet finished
            
            # refresh the screen
            if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen
                win.flip()
        
        # --- Ending Routine "counter_quizzes_round" ---
        for thisComponent in counter_quizzes_roundComponents:
            if hasattr(thisComponent, "setAutoDraw"):
                thisComponent.setAutoDraw(False)
        thisExp.addData('counter_quizzes_round.stopped', globalClock.getTime())
        # the Routine "counter_quizzes_round" was not non-slip safe, so reset the non-slip timer
        routineTimer.reset()
        
        # --- Prepare to start Routine "between" ---
        continueRoutine = True
        # update component parameters for each repeat
        thisExp.addData('between.started', globalClock.getTime())
        # Run 'Begin Routine' code from code_39
        quiz1_count=1
        quiz2_count=1
        
        # keep track of which components have finished
        betweenComponents = [text_2]
        for thisComponent in betweenComponents:
            thisComponent.tStart = None
            thisComponent.tStop = None
            thisComponent.tStartRefresh = None
            thisComponent.tStopRefresh = None
            if hasattr(thisComponent, 'status'):
                thisComponent.status = NOT_STARTED
        # reset timers
        t = 0
        _timeToFirstFrame = win.getFutureFlipTime(clock="now")
        frameN = -1
        
        # --- Run Routine "between" ---
        routineForceEnded = not continueRoutine
        while continueRoutine and routineTimer.getTime() < 5.0:
            # get current time
            t = routineTimer.getTime()
            tThisFlip = win.getFutureFlipTime(clock=routineTimer)
            tThisFlipGlobal = win.getFutureFlipTime(clock=None)
            frameN = frameN + 1  # number of completed frames (so 0 is the first frame)
            # update/draw components on each frame
            
            # *text_2* updates
            
            # if text_2 is starting this frame...
            if text_2.status == NOT_STARTED and tThisFlip >= 0-frameTolerance:
                # keep track of start time/frame for later
                text_2.frameNStart = frameN  # exact frame index
                text_2.tStart = t  # local t and not account for scr refresh
                text_2.tStartRefresh = tThisFlipGlobal  # on global time
                win.timeOnFlip(text_2, 'tStartRefresh')  # time at next scr refresh
                # add timestamp to datafile
                thisExp.timestampOnFlip(win, 'text_2.started')
                # update status
                text_2.status = STARTED
                text_2.setAutoDraw(True)
            
            # if text_2 is active this frame...
            if text_2.status == STARTED:
                # update params
                pass
            
            # if text_2 is stopping this frame...
            if text_2.status == STARTED:
                # is it time to stop? (based on global clock, using actual start)
                if tThisFlipGlobal > text_2.tStartRefresh + 5-frameTolerance:
                    # keep track of stop time/frame for later
                    text_2.tStop = t  # not accounting for scr refresh
                    text_2.frameNStop = frameN  # exact frame index
                    # add timestamp to datafile
                    thisExp.timestampOnFlip(win, 'text_2.stopped')
                    # update status
                    text_2.status = FINISHED
                    text_2.setAutoDraw(False)
            
            # check for quit (typically the Esc key)
            if defaultKeyboard.getKeys(keyList=["escape"]):
                thisExp.status = FINISHED
            if thisExp.status == FINISHED or endExpNow:
                endExperiment(thisExp, inputs=inputs, win=win)
                return
            
            # check if all components have finished
            if not continueRoutine:  # a component has requested a forced-end of Routine
                routineForceEnded = True
                break
            continueRoutine = False  # will revert to True if at least one component still running
            for thisComponent in betweenComponents:
                if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:
                    continueRoutine = True
                    break  # at least one component has not yet finished
            
            # refresh the screen
            if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen
                win.flip()
        
        # --- Ending Routine "between" ---
        for thisComponent in betweenComponents:
            if hasattr(thisComponent, "setAutoDraw"):
                thisComponent.setAutoDraw(False)
        thisExp.addData('between.stopped', globalClock.getTime())
        # using non-slip timing so subtract the expected duration of this Routine (unless ended on request)
        if routineForceEnded:
            routineTimer.reset()
        else:
            routineTimer.addTime(-5.000000)
        
        # set up handler to look after randomisation of conditions etc
        quiz_loop1 = data.TrialHandler(nReps=1.0, method='random', 
            extraInfo=expInfo, originPath=-1,
            trialList=data.importConditions('quiz_1.xlsx'),
            seed=None, name='quiz_loop1')
        thisExp.addLoop(quiz_loop1)  # add the loop to the experiment
        thisQuiz_loop1 = quiz_loop1.trialList[0]  # so we can initialise stimuli with some values
        # abbreviate parameter names if possible (e.g. rgb = thisQuiz_loop1.rgb)
        if thisQuiz_loop1 != None:
            for paramName in thisQuiz_loop1:
                globals()[paramName] = thisQuiz_loop1[paramName]
        
        for thisQuiz_loop1 in quiz_loop1:
            currentLoop = quiz_loop1
            thisExp.timestampOnFlip(win, 'thisRow.t')
            # pause experiment here if requested
            if thisExp.status == PAUSED:
                pauseExperiment(
                    thisExp=thisExp, 
                    inputs=inputs, 
                    win=win, 
                    timers=[routineTimer], 
                    playbackComponents=[]
            )
            # abbreviate parameter names if possible (e.g. rgb = thisQuiz_loop1.rgb)
            if thisQuiz_loop1 != None:
                for paramName in thisQuiz_loop1:
                    globals()[paramName] = thisQuiz_loop1[paramName]
            
            # --- Prepare to start Routine "quiz" ---
            continueRoutine = True
            # update component parameters for each repeat
            thisExp.addData('quiz.started', globalClock.getTime())
            target_quiz1.setImage(image1)
            question_quiz1.setText(question)
            answer_quiz1.keys = []
            answer_quiz1.rt = []
            _answer_quiz1_allKeys = []
            answer1.setImage(ans1)
            answer2.setImage(ans2)
            answer3.setImage(ans3)
            answer4.setImage(ans4)
            # keep track of which components have finished
            quizComponents = [target_quiz1, question_quiz1, answer_quiz1, answer1, answer2, answer3, answer4, a1, a2, a3, a4]
            for thisComponent in quizComponents:
                thisComponent.tStart = None
                thisComponent.tStop = None
                thisComponent.tStartRefresh = None
                thisComponent.tStopRefresh = None
                if hasattr(thisComponent, 'status'):
                    thisComponent.status = NOT_STARTED
            # reset timers
            t = 0
            _timeToFirstFrame = win.getFutureFlipTime(clock="now")
            frameN = -1
            
            # --- Run Routine "quiz" ---
            routineForceEnded = not continueRoutine
            while continueRoutine:
                # get current time
                t = routineTimer.getTime()
                tThisFlip = win.getFutureFlipTime(clock=routineTimer)
                tThisFlipGlobal = win.getFutureFlipTime(clock=None)
                frameN = frameN + 1  # number of completed frames (so 0 is the first frame)
                # update/draw components on each frame
                
                # *target_quiz1* updates
                
                # if target_quiz1 is starting this frame...
                if target_quiz1.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
                    # keep track of start time/frame for later
                    target_quiz1.frameNStart = frameN  # exact frame index
                    target_quiz1.tStart = t  # local t and not account for scr refresh
                    target_quiz1.tStartRefresh = tThisFlipGlobal  # on global time
                    win.timeOnFlip(target_quiz1, 'tStartRefresh')  # time at next scr refresh
                    # add timestamp to datafile
                    thisExp.timestampOnFlip(win, 'target_quiz1.started')
                    # update status
                    target_quiz1.status = STARTED
                    target_quiz1.setAutoDraw(True)
                
                # if target_quiz1 is active this frame...
                if target_quiz1.status == STARTED:
                    # update params
                    pass
                
                # *question_quiz1* updates
                
                # if question_quiz1 is starting this frame...
                if question_quiz1.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
                    # keep track of start time/frame for later
                    question_quiz1.frameNStart = frameN  # exact frame index
                    question_quiz1.tStart = t  # local t and not account for scr refresh
                    question_quiz1.tStartRefresh = tThisFlipGlobal  # on global time
                    win.timeOnFlip(question_quiz1, 'tStartRefresh')  # time at next scr refresh
                    # add timestamp to datafile
                    thisExp.timestampOnFlip(win, 'question_quiz1.started')
                    # update status
                    question_quiz1.status = STARTED
                    question_quiz1.setAutoDraw(True)
                
                # if question_quiz1 is active this frame...
                if question_quiz1.status == STARTED:
                    # update params
                    pass
                
                # *answer_quiz1* updates
                waitOnFlip = False
                
                # if answer_quiz1 is starting this frame...
                if answer_quiz1.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
                    # keep track of start time/frame for later
                    answer_quiz1.frameNStart = frameN  # exact frame index
                    answer_quiz1.tStart = t  # local t and not account for scr refresh
                    answer_quiz1.tStartRefresh = tThisFlipGlobal  # on global time
                    win.timeOnFlip(answer_quiz1, 'tStartRefresh')  # time at next scr refresh
                    # add timestamp to datafile
                    thisExp.timestampOnFlip(win, 'answer_quiz1.started')
                    # update status
                    answer_quiz1.status = STARTED
                    # keyboard checking is just starting
                    waitOnFlip = True
                    win.callOnFlip(answer_quiz1.clock.reset)  # t=0 on next screen flip
                    win.callOnFlip(answer_quiz1.clearEvents, eventType='keyboard')  # clear events on next screen flip
                if answer_quiz1.status == STARTED and not waitOnFlip:
                    theseKeys = answer_quiz1.getKeys(keyList=['1','2','3','4'], ignoreKeys=["escape"], waitRelease=False)
                    _answer_quiz1_allKeys.extend(theseKeys)
                    if len(_answer_quiz1_allKeys):
                        answer_quiz1.keys = _answer_quiz1_allKeys[-1].name  # just the last key pressed
                        answer_quiz1.rt = _answer_quiz1_allKeys[-1].rt
                        answer_quiz1.duration = _answer_quiz1_allKeys[-1].duration
                        # was this correct?
                        if (answer_quiz1.keys == str(corr_ans)) or (answer_quiz1.keys == corr_ans):
                            answer_quiz1.corr = 1
                        else:
                            answer_quiz1.corr = 0
                        # a response ends the routine
                        continueRoutine = False
                
                # *answer1* updates
                
                # if answer1 is starting this frame...
                if answer1.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
                    # keep track of start time/frame for later
                    answer1.frameNStart = frameN  # exact frame index
                    answer1.tStart = t  # local t and not account for scr refresh
                    answer1.tStartRefresh = tThisFlipGlobal  # on global time
                    win.timeOnFlip(answer1, 'tStartRefresh')  # time at next scr refresh
                    # add timestamp to datafile
                    thisExp.timestampOnFlip(win, 'answer1.started')
                    # update status
                    answer1.status = STARTED
                    answer1.setAutoDraw(True)
                
                # if answer1 is active this frame...
                if answer1.status == STARTED:
                    # update params
                    pass
                
                # *answer2* updates
                
                # if answer2 is starting this frame...
                if answer2.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
                    # keep track of start time/frame for later
                    answer2.frameNStart = frameN  # exact frame index
                    answer2.tStart = t  # local t and not account for scr refresh
                    answer2.tStartRefresh = tThisFlipGlobal  # on global time
                    win.timeOnFlip(answer2, 'tStartRefresh')  # time at next scr refresh
                    # add timestamp to datafile
                    thisExp.timestampOnFlip(win, 'answer2.started')
                    # update status
                    answer2.status = STARTED
                    answer2.setAutoDraw(True)
                
                # if answer2 is active this frame...
                if answer2.status == STARTED:
                    # update params
                    pass
                
                # *answer3* updates
                
                # if answer3 is starting this frame...
                if answer3.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
                    # keep track of start time/frame for later
                    answer3.frameNStart = frameN  # exact frame index
                    answer3.tStart = t  # local t and not account for scr refresh
                    answer3.tStartRefresh = tThisFlipGlobal  # on global time
                    win.timeOnFlip(answer3, 'tStartRefresh')  # time at next scr refresh
                    # add timestamp to datafile
                    thisExp.timestampOnFlip(win, 'answer3.started')
                    # update status
                    answer3.status = STARTED
                    answer3.setAutoDraw(True)
                
                # if answer3 is active this frame...
                if answer3.status == STARTED:
                    # update params
                    pass
                
                # *answer4* updates
                
                # if answer4 is starting this frame...
                if answer4.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
                    # keep track of start time/frame for later
                    answer4.frameNStart = frameN  # exact frame index
                    answer4.tStart = t  # local t and not account for scr refresh
                    answer4.tStartRefresh = tThisFlipGlobal  # on global time
                    win.timeOnFlip(answer4, 'tStartRefresh')  # time at next scr refresh
                    # add timestamp to datafile
                    thisExp.timestampOnFlip(win, 'answer4.started')
                    # update status
                    answer4.status = STARTED
                    answer4.setAutoDraw(True)
                
                # if answer4 is active this frame...
                if answer4.status == STARTED:
                    # update params
                    pass
                
                # *a1* updates
                
                # if a1 is starting this frame...
                if a1.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
                    # keep track of start time/frame for later
                    a1.frameNStart = frameN  # exact frame index
                    a1.tStart = t  # local t and not account for scr refresh
                    a1.tStartRefresh = tThisFlipGlobal  # on global time
                    win.timeOnFlip(a1, 'tStartRefresh')  # time at next scr refresh
                    # add timestamp to datafile
                    thisExp.timestampOnFlip(win, 'a1.started')
                    # update status
                    a1.status = STARTED
                    a1.setAutoDraw(True)
                
                # if a1 is active this frame...
                if a1.status == STARTED:
                    # update params
                    pass
                
                # *a2* updates
                
                # if a2 is starting this frame...
                if a2.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
                    # keep track of start time/frame for later
                    a2.frameNStart = frameN  # exact frame index
                    a2.tStart = t  # local t and not account for scr refresh
                    a2.tStartRefresh = tThisFlipGlobal  # on global time
                    win.timeOnFlip(a2, 'tStartRefresh')  # time at next scr refresh
                    # add timestamp to datafile
                    thisExp.timestampOnFlip(win, 'a2.started')
                    # update status
                    a2.status = STARTED
                    a2.setAutoDraw(True)
                
                # if a2 is active this frame...
                if a2.status == STARTED:
                    # update params
                    pass
                
                # *a3* updates
                
                # if a3 is starting this frame...
                if a3.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
                    # keep track of start time/frame for later
                    a3.frameNStart = frameN  # exact frame index
                    a3.tStart = t  # local t and not account for scr refresh
                    a3.tStartRefresh = tThisFlipGlobal  # on global time
                    win.timeOnFlip(a3, 'tStartRefresh')  # time at next scr refresh
                    # add timestamp to datafile
                    thisExp.timestampOnFlip(win, 'a3.started')
                    # update status
                    a3.status = STARTED
                    a3.setAutoDraw(True)
                
                # if a3 is active this frame...
                if a3.status == STARTED:
                    # update params
                    pass
                
                # *a4* updates
                
                # if a4 is starting this frame...
                if a4.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
                    # keep track of start time/frame for later
                    a4.frameNStart = frameN  # exact frame index
                    a4.tStart = t  # local t and not account for scr refresh
                    a4.tStartRefresh = tThisFlipGlobal  # on global time
                    win.timeOnFlip(a4, 'tStartRefresh')  # time at next scr refresh
                    # add timestamp to datafile
                    thisExp.timestampOnFlip(win, 'a4.started')
                    # update status
                    a4.status = STARTED
                    a4.setAutoDraw(True)
                
                # if a4 is active this frame...
                if a4.status == STARTED:
                    # update params
                    pass
                
                # check for quit (typically the Esc key)
                if defaultKeyboard.getKeys(keyList=["escape"]):
                    thisExp.status = FINISHED
                if thisExp.status == FINISHED or endExpNow:
                    endExperiment(thisExp, inputs=inputs, win=win)
                    return
                
                # check if all components have finished
                if not continueRoutine:  # a component has requested a forced-end of Routine
                    routineForceEnded = True
                    break
                continueRoutine = False  # will revert to True if at least one component still running
                for thisComponent in quizComponents:
                    if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:
                        continueRoutine = True
                        break  # at least one component has not yet finished
                
                # refresh the screen
                if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen
                    win.flip()
            
            # --- Ending Routine "quiz" ---
            for thisComponent in quizComponents:
                if hasattr(thisComponent, "setAutoDraw"):
                    thisComponent.setAutoDraw(False)
            thisExp.addData('quiz.stopped', globalClock.getTime())
            # check responses
            if answer_quiz1.keys in ['', [], None]:  # No response was made
                answer_quiz1.keys = None
                # was no response the correct answer?!
                if str(corr_ans).lower() == 'none':
                   answer_quiz1.corr = 1;  # correct non-response
                else:
                   answer_quiz1.corr = 0;  # failed to respond (incorrectly)
            # store data for quiz_loop1 (TrialHandler)
            quiz_loop1.addData('answer_quiz1.keys',answer_quiz1.keys)
            quiz_loop1.addData('answer_quiz1.corr', answer_quiz1.corr)
            if answer_quiz1.keys != None:  # we had a response
                quiz_loop1.addData('answer_quiz1.rt', answer_quiz1.rt)
                quiz_loop1.addData('answer_quiz1.duration', answer_quiz1.duration)
            # Run 'End Routine' code from code_38
            if answer_quiz1.corr:
                quiz1_score+=1
                msg="Correct! Good job!"
            else:
                msg="INCORRECT :("
            # the Routine "quiz" was not non-slip safe, so reset the non-slip timer
            routineTimer.reset()
            
            # --- Prepare to start Routine "quiz_feedback" ---
            continueRoutine = True
            # update component parameters for each repeat
            thisExp.addData('quiz_feedback.started', globalClock.getTime())
            result_q_instr.setText(msg)
            # keep track of which components have finished
            quiz_feedbackComponents = [result_q_instr]
            for thisComponent in quiz_feedbackComponents:
                thisComponent.tStart = None
                thisComponent.tStop = None
                thisComponent.tStartRefresh = None
                thisComponent.tStopRefresh = None
                if hasattr(thisComponent, 'status'):
                    thisComponent.status = NOT_STARTED
            # reset timers
            t = 0
            _timeToFirstFrame = win.getFutureFlipTime(clock="now")
            frameN = -1
            
            # --- Run Routine "quiz_feedback" ---
            routineForceEnded = not continueRoutine
            while continueRoutine and routineTimer.getTime() < 1.25:
                # get current time
                t = routineTimer.getTime()
                tThisFlip = win.getFutureFlipTime(clock=routineTimer)
                tThisFlipGlobal = win.getFutureFlipTime(clock=None)
                frameN = frameN + 1  # number of completed frames (so 0 is the first frame)
                # update/draw components on each frame
                
                # *result_q_instr* updates
                
                # if result_q_instr is starting this frame...
                if result_q_instr.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
                    # keep track of start time/frame for later
                    result_q_instr.frameNStart = frameN  # exact frame index
                    result_q_instr.tStart = t  # local t and not account for scr refresh
                    result_q_instr.tStartRefresh = tThisFlipGlobal  # on global time
                    win.timeOnFlip(result_q_instr, 'tStartRefresh')  # time at next scr refresh
                    # add timestamp to datafile
                    thisExp.timestampOnFlip(win, 'result_q_instr.started')
                    # update status
                    result_q_instr.status = STARTED
                    result_q_instr.setAutoDraw(True)
                
                # if result_q_instr is active this frame...
                if result_q_instr.status == STARTED:
                    # update params
                    pass
                
                # if result_q_instr is stopping this frame...
                if result_q_instr.status == STARTED:
                    # is it time to stop? (based on global clock, using actual start)
                    if tThisFlipGlobal > result_q_instr.tStartRefresh + 1.25-frameTolerance:
                        # keep track of stop time/frame for later
                        result_q_instr.tStop = t  # not accounting for scr refresh
                        result_q_instr.frameNStop = frameN  # exact frame index
                        # add timestamp to datafile
                        thisExp.timestampOnFlip(win, 'result_q_instr.stopped')
                        # update status
                        result_q_instr.status = FINISHED
                        result_q_instr.setAutoDraw(False)
                
                # check for quit (typically the Esc key)
                if defaultKeyboard.getKeys(keyList=["escape"]):
                    thisExp.status = FINISHED
                if thisExp.status == FINISHED or endExpNow:
                    endExperiment(thisExp, inputs=inputs, win=win)
                    return
                
                # check if all components have finished
                if not continueRoutine:  # a component has requested a forced-end of Routine
                    routineForceEnded = True
                    break
                continueRoutine = False  # will revert to True if at least one component still running
                for thisComponent in quiz_feedbackComponents:
                    if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:
                        continueRoutine = True
                        break  # at least one component has not yet finished
                
                # refresh the screen
                if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen
                    win.flip()
            
            # --- Ending Routine "quiz_feedback" ---
            for thisComponent in quiz_feedbackComponents:
                if hasattr(thisComponent, "setAutoDraw"):
                    thisComponent.setAutoDraw(False)
            thisExp.addData('quiz_feedback.stopped', globalClock.getTime())
            # using non-slip timing so subtract the expected duration of this Routine (unless ended on request)
            if routineForceEnded:
                routineTimer.reset()
            else:
                routineTimer.addTime(-1.250000)
            thisExp.nextEntry()
            
            if thisSession is not None:
                # if running in a Session with a Liaison client, send data up to now
                thisSession.sendExperimentData()
        # completed 1.0 repeats of 'quiz_loop1'
        
        
        # --- Prepare to start Routine "back_to_learn" ---
        continueRoutine = True
        # update component parameters for each repeat
        thisExp.addData('back_to_learn.started', globalClock.getTime())
        # keep track of which components have finished
        back_to_learnComponents = [text_8]
        for thisComponent in back_to_learnComponents:
            thisComponent.tStart = None
            thisComponent.tStop = None
            thisComponent.tStartRefresh = None
            thisComponent.tStopRefresh = None
            if hasattr(thisComponent, 'status'):
                thisComponent.status = NOT_STARTED
        # reset timers
        t = 0
        _timeToFirstFrame = win.getFutureFlipTime(clock="now")
        frameN = -1
        
        # --- Run Routine "back_to_learn" ---
        routineForceEnded = not continueRoutine
        while continueRoutine and routineTimer.getTime() < 10.0:
            # get current time
            t = routineTimer.getTime()
            tThisFlip = win.getFutureFlipTime(clock=routineTimer)
            tThisFlipGlobal = win.getFutureFlipTime(clock=None)
            frameN = frameN + 1  # number of completed frames (so 0 is the first frame)
            # update/draw components on each frame
            
            # *text_8* updates
            
            # if text_8 is starting this frame...
            if text_8.status == NOT_STARTED and tThisFlip >= 0-frameTolerance:
                # keep track of start time/frame for later
                text_8.frameNStart = frameN  # exact frame index
                text_8.tStart = t  # local t and not account for scr refresh
                text_8.tStartRefresh = tThisFlipGlobal  # on global time
                win.timeOnFlip(text_8, 'tStartRefresh')  # time at next scr refresh
                # add timestamp to datafile
                thisExp.timestampOnFlip(win, 'text_8.started')
                # update status
                text_8.status = STARTED
                text_8.setAutoDraw(True)
            
            # if text_8 is active this frame...
            if text_8.status == STARTED:
                # update params
                pass
            
            # if text_8 is stopping this frame...
            if text_8.status == STARTED:
                # is it time to stop? (based on global clock, using actual start)
                if tThisFlipGlobal > text_8.tStartRefresh + 10-frameTolerance:
                    # keep track of stop time/frame for later
                    text_8.tStop = t  # not accounting for scr refresh
                    text_8.frameNStop = frameN  # exact frame index
                    # add timestamp to datafile
                    thisExp.timestampOnFlip(win, 'text_8.stopped')
                    # update status
                    text_8.status = FINISHED
                    text_8.setAutoDraw(False)
            
            # check for quit (typically the Esc key)
            if defaultKeyboard.getKeys(keyList=["escape"]):
                thisExp.status = FINISHED
            if thisExp.status == FINISHED or endExpNow:
                endExperiment(thisExp, inputs=inputs, win=win)
                return
            
            # check if all components have finished
            if not continueRoutine:  # a component has requested a forced-end of Routine
                routineForceEnded = True
                break
            continueRoutine = False  # will revert to True if at least one component still running
            for thisComponent in back_to_learnComponents:
                if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:
                    continueRoutine = True
                    break  # at least one component has not yet finished
            
            # refresh the screen
            if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen
                win.flip()
        
        # --- Ending Routine "back_to_learn" ---
        for thisComponent in back_to_learnComponents:
            if hasattr(thisComponent, "setAutoDraw"):
                thisComponent.setAutoDraw(False)
        thisExp.addData('back_to_learn.stopped', globalClock.getTime())
        # using non-slip timing so subtract the expected duration of this Routine (unless ended on request)
        if routineForceEnded:
            routineTimer.reset()
        else:
            routineTimer.addTime(-10.000000)
        
        # set up handler to look after randomisation of conditions etc
        learn_1_2 = data.TrialHandler(nReps=4.0, method='random', 
            extraInfo=expInfo, originPath=-1,
            trialList=data.importConditions('image_train_press.xlsx'),
            seed=None, name='learn_1_2')
        thisExp.addLoop(learn_1_2)  # add the loop to the experiment
        thisLearn_1_2 = learn_1_2.trialList[0]  # so we can initialise stimuli with some values
        # abbreviate parameter names if possible (e.g. rgb = thisLearn_1_2.rgb)
        if thisLearn_1_2 != None:
            for paramName in thisLearn_1_2:
                globals()[paramName] = thisLearn_1_2[paramName]
        
        for thisLearn_1_2 in learn_1_2:
            currentLoop = learn_1_2
            thisExp.timestampOnFlip(win, 'thisRow.t')
            # pause experiment here if requested
            if thisExp.status == PAUSED:
                pauseExperiment(
                    thisExp=thisExp, 
                    inputs=inputs, 
                    win=win, 
                    timers=[routineTimer], 
                    playbackComponents=[]
            )
            # abbreviate parameter names if possible (e.g. rgb = thisLearn_1_2.rgb)
            if thisLearn_1_2 != None:
                for paramName in thisLearn_1_2:
                    globals()[paramName] = thisLearn_1_2[paramName]
            
            # set up handler to look after randomisation of conditions etc
            incorrect_loop2 = data.TrialHandler(nReps=9999.0, method='random', 
                extraInfo=expInfo, originPath=-1,
                trialList=[None],
                seed=None, name='incorrect_loop2')
            thisExp.addLoop(incorrect_loop2)  # add the loop to the experiment
            thisIncorrect_loop2 = incorrect_loop2.trialList[0]  # so we can initialise stimuli with some values
            # abbreviate parameter names if possible (e.g. rgb = thisIncorrect_loop2.rgb)
            if thisIncorrect_loop2 != None:
                for paramName in thisIncorrect_loop2:
                    globals()[paramName] = thisIncorrect_loop2[paramName]
            
            for thisIncorrect_loop2 in incorrect_loop2:
                currentLoop = incorrect_loop2
                thisExp.timestampOnFlip(win, 'thisRow.t')
                # pause experiment here if requested
                if thisExp.status == PAUSED:
                    pauseExperiment(
                        thisExp=thisExp, 
                        inputs=inputs, 
                        win=win, 
                        timers=[routineTimer], 
                        playbackComponents=[]
                )
                # abbreviate parameter names if possible (e.g. rgb = thisIncorrect_loop2.rgb)
                if thisIncorrect_loop2 != None:
                    for paramName in thisIncorrect_loop2:
                        globals()[paramName] = thisIncorrect_loop2[paramName]
                
                # --- Prepare to start Routine "learn1" ---
                continueRoutine = True
                # update component parameters for each repeat
                thisExp.addData('learn1.started', globalClock.getTime())
                key_resp.keys = []
                key_resp.rt = []
                _key_resp_allKeys = []
                image_1.setImage(image1)
                text.setText(action1)
                # keep track of which components have finished
                learn1Components = [key_resp, image_1, text]
                for thisComponent in learn1Components:
                    thisComponent.tStart = None
                    thisComponent.tStop = None
                    thisComponent.tStartRefresh = None
                    thisComponent.tStopRefresh = None
                    if hasattr(thisComponent, 'status'):
                        thisComponent.status = NOT_STARTED
                # reset timers
                t = 0
                _timeToFirstFrame = win.getFutureFlipTime(clock="now")
                frameN = -1
                
                # --- Run Routine "learn1" ---
                routineForceEnded = not continueRoutine
                while continueRoutine:
                    # get current time
                    t = routineTimer.getTime()
                    tThisFlip = win.getFutureFlipTime(clock=routineTimer)
                    tThisFlipGlobal = win.getFutureFlipTime(clock=None)
                    frameN = frameN + 1  # number of completed frames (so 0 is the first frame)
                    # update/draw components on each frame
                    
                    # *key_resp* updates
                    waitOnFlip = False
                    
                    # if key_resp is starting this frame...
                    if key_resp.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
                        # keep track of start time/frame for later
                        key_resp.frameNStart = frameN  # exact frame index
                        key_resp.tStart = t  # local t and not account for scr refresh
                        key_resp.tStartRefresh = tThisFlipGlobal  # on global time
                        win.timeOnFlip(key_resp, 'tStartRefresh')  # time at next scr refresh
                        # add timestamp to datafile
                        thisExp.timestampOnFlip(win, 'key_resp.started')
                        # update status
                        key_resp.status = STARTED
                        # keyboard checking is just starting
                        waitOnFlip = True
                        win.callOnFlip(key_resp.clock.reset)  # t=0 on next screen flip
                        win.callOnFlip(key_resp.clearEvents, eventType='keyboard')  # clear events on next screen flip
                    if key_resp.status == STARTED and not waitOnFlip:
                        theseKeys = key_resp.getKeys(keyList=['left','right'], ignoreKeys=["escape"], waitRelease=False)
                        _key_resp_allKeys.extend(theseKeys)
                        if len(_key_resp_allKeys):
                            key_resp.keys = _key_resp_allKeys[-1].name  # just the last key pressed
                            key_resp.rt = _key_resp_allKeys[-1].rt
                            key_resp.duration = _key_resp_allKeys[-1].duration
                            # was this correct?
                            if (key_resp.keys == str(corr_ans)) or (key_resp.keys == corr_ans):
                                key_resp.corr = 1
                            else:
                                key_resp.corr = 0
                            # a response ends the routine
                            continueRoutine = False
                    
                    # *image_1* updates
                    
                    # if image_1 is starting this frame...
                    if image_1.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
                        # keep track of start time/frame for later
                        image_1.frameNStart = frameN  # exact frame index
                        image_1.tStart = t  # local t and not account for scr refresh
                        image_1.tStartRefresh = tThisFlipGlobal  # on global time
                        win.timeOnFlip(image_1, 'tStartRefresh')  # time at next scr refresh
                        # add timestamp to datafile
                        thisExp.timestampOnFlip(win, 'image_1.started')
                        # update status
                        image_1.status = STARTED
                        image_1.setAutoDraw(True)
                    
                    # if image_1 is active this frame...
                    if image_1.status == STARTED:
                        # update params
                        pass
                    
                    # *text* updates
                    
                    # if text is starting this frame...
                    if text.status == NOT_STARTED and tThisFlip >= 1-frameTolerance:
                        # keep track of start time/frame for later
                        text.frameNStart = frameN  # exact frame index
                        text.tStart = t  # local t and not account for scr refresh
                        text.tStartRefresh = tThisFlipGlobal  # on global time
                        win.timeOnFlip(text, 'tStartRefresh')  # time at next scr refresh
                        # add timestamp to datafile
                        thisExp.timestampOnFlip(win, 'text.started')
                        # update status
                        text.status = STARTED
                        text.setAutoDraw(True)
                    
                    # if text is active this frame...
                    if text.status == STARTED:
                        # update params
                        pass
                    
                    # check for quit (typically the Esc key)
                    if defaultKeyboard.getKeys(keyList=["escape"]):
                        thisExp.status = FINISHED
                    if thisExp.status == FINISHED or endExpNow:
                        endExperiment(thisExp, inputs=inputs, win=win)
                        return
                    
                    # check if all components have finished
                    if not continueRoutine:  # a component has requested a forced-end of Routine
                        routineForceEnded = True
                        break
                    continueRoutine = False  # will revert to True if at least one component still running
                    for thisComponent in learn1Components:
                        if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:
                            continueRoutine = True
                            break  # at least one component has not yet finished
                    
                    # refresh the screen
                    if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen
                        win.flip()
                
                # --- Ending Routine "learn1" ---
                for thisComponent in learn1Components:
                    if hasattr(thisComponent, "setAutoDraw"):
                        thisComponent.setAutoDraw(False)
                thisExp.addData('learn1.stopped', globalClock.getTime())
                # check responses
                if key_resp.keys in ['', [], None]:  # No response was made
                    key_resp.keys = None
                    # was no response the correct answer?!
                    if str(corr_ans).lower() == 'none':
                       key_resp.corr = 1;  # correct non-response
                    else:
                       key_resp.corr = 0;  # failed to respond (incorrectly)
                # store data for incorrect_loop2 (TrialHandler)
                incorrect_loop2.addData('key_resp.keys',key_resp.keys)
                incorrect_loop2.addData('key_resp.corr', key_resp.corr)
                if key_resp.keys != None:  # we had a response
                    incorrect_loop2.addData('key_resp.rt', key_resp.rt)
                    incorrect_loop2.addData('key_resp.duration', key_resp.duration)
                # the Routine "learn1" was not non-slip safe, so reset the non-slip timer
                routineTimer.reset()
                
                # --- Prepare to start Routine "check_incorrect" ---
                continueRoutine = True
                # update component parameters for each repeat
                thisExp.addData('check_incorrect.started', globalClock.getTime())
                # Run 'Begin Routine' code from code
                if key_resp.corr:
                    msg_incorrect='correct'
                    incorrect_loop2.finished = True
                    continueRoutine=False
                else:
                    msg_incorrect='You clicked the wrong button! If you click the wrong button 5 times, the game will stop and you will NOT GET PAID because you failed to follow instructions!'
                    incorrect_actions+=1
                    continueRoutine=True
                    if incorrect_actions>4:
                        psychoJS.quit()
                text_incorrect.setText(msg_incorrect)
                # keep track of which components have finished
                check_incorrectComponents = [text_incorrect]
                for thisComponent in check_incorrectComponents:
                    thisComponent.tStart = None
                    thisComponent.tStop = None
                    thisComponent.tStartRefresh = None
                    thisComponent.tStopRefresh = None
                    if hasattr(thisComponent, 'status'):
                        thisComponent.status = NOT_STARTED
                # reset timers
                t = 0
                _timeToFirstFrame = win.getFutureFlipTime(clock="now")
                frameN = -1
                
                # --- Run Routine "check_incorrect" ---
                routineForceEnded = not continueRoutine
                while continueRoutine and routineTimer.getTime() < 3.0:
                    # get current time
                    t = routineTimer.getTime()
                    tThisFlip = win.getFutureFlipTime(clock=routineTimer)
                    tThisFlipGlobal = win.getFutureFlipTime(clock=None)
                    frameN = frameN + 1  # number of completed frames (so 0 is the first frame)
                    # update/draw components on each frame
                    
                    # *text_incorrect* updates
                    
                    # if text_incorrect is starting this frame...
                    if text_incorrect.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
                        # keep track of start time/frame for later
                        text_incorrect.frameNStart = frameN  # exact frame index
                        text_incorrect.tStart = t  # local t and not account for scr refresh
                        text_incorrect.tStartRefresh = tThisFlipGlobal  # on global time
                        win.timeOnFlip(text_incorrect, 'tStartRefresh')  # time at next scr refresh
                        # add timestamp to datafile
                        thisExp.timestampOnFlip(win, 'text_incorrect.started')
                        # update status
                        text_incorrect.status = STARTED
                        text_incorrect.setAutoDraw(True)
                    
                    # if text_incorrect is active this frame...
                    if text_incorrect.status == STARTED:
                        # update params
                        pass
                    
                    # if text_incorrect is stopping this frame...
                    if text_incorrect.status == STARTED:
                        # is it time to stop? (based on global clock, using actual start)
                        if tThisFlipGlobal > text_incorrect.tStartRefresh + 3-frameTolerance:
                            # keep track of stop time/frame for later
                            text_incorrect.tStop = t  # not accounting for scr refresh
                            text_incorrect.frameNStop = frameN  # exact frame index
                            # add timestamp to datafile
                            thisExp.timestampOnFlip(win, 'text_incorrect.stopped')
                            # update status
                            text_incorrect.status = FINISHED
                            text_incorrect.setAutoDraw(False)
                    
                    # check for quit (typically the Esc key)
                    if defaultKeyboard.getKeys(keyList=["escape"]):
                        thisExp.status = FINISHED
                    if thisExp.status == FINISHED or endExpNow:
                        endExperiment(thisExp, inputs=inputs, win=win)
                        return
                    
                    # check if all components have finished
                    if not continueRoutine:  # a component has requested a forced-end of Routine
                        routineForceEnded = True
                        break
                    continueRoutine = False  # will revert to True if at least one component still running
                    for thisComponent in check_incorrectComponents:
                        if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:
                            continueRoutine = True
                            break  # at least one component has not yet finished
                    
                    # refresh the screen
                    if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen
                        win.flip()
                
                # --- Ending Routine "check_incorrect" ---
                for thisComponent in check_incorrectComponents:
                    if hasattr(thisComponent, "setAutoDraw"):
                        thisComponent.setAutoDraw(False)
                thisExp.addData('check_incorrect.stopped', globalClock.getTime())
                # using non-slip timing so subtract the expected duration of this Routine (unless ended on request)
                if routineForceEnded:
                    routineTimer.reset()
                else:
                    routineTimer.addTime(-3.000000)
                thisExp.nextEntry()
                
                if thisSession is not None:
                    # if running in a Session with a Liaison client, send data up to now
                    thisSession.sendExperimentData()
            # completed 9999.0 repeats of 'incorrect_loop2'
            
            
            # --- Prepare to start Routine "learn2" ---
            continueRoutine = True
            # update component parameters for each repeat
            thisExp.addData('learn2.started', globalClock.getTime())
            image_2.setImage(image2)
            # keep track of which components have finished
            learn2Components = [image_2]
            for thisComponent in learn2Components:
                thisComponent.tStart = None
                thisComponent.tStop = None
                thisComponent.tStartRefresh = None
                thisComponent.tStopRefresh = None
                if hasattr(thisComponent, 'status'):
                    thisComponent.status = NOT_STARTED
            # reset timers
            t = 0
            _timeToFirstFrame = win.getFutureFlipTime(clock="now")
            frameN = -1
            
            # --- Run Routine "learn2" ---
            routineForceEnded = not continueRoutine
            while continueRoutine and routineTimer.getTime() < 1.0:
                # get current time
                t = routineTimer.getTime()
                tThisFlip = win.getFutureFlipTime(clock=routineTimer)
                tThisFlipGlobal = win.getFutureFlipTime(clock=None)
                frameN = frameN + 1  # number of completed frames (so 0 is the first frame)
                # update/draw components on each frame
                
                # *image_2* updates
                
                # if image_2 is starting this frame...
                if image_2.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
                    # keep track of start time/frame for later
                    image_2.frameNStart = frameN  # exact frame index
                    image_2.tStart = t  # local t and not account for scr refresh
                    image_2.tStartRefresh = tThisFlipGlobal  # on global time
                    win.timeOnFlip(image_2, 'tStartRefresh')  # time at next scr refresh
                    # add timestamp to datafile
                    thisExp.timestampOnFlip(win, 'image_2.started')
                    # update status
                    image_2.status = STARTED
                    image_2.setAutoDraw(True)
                
                # if image_2 is active this frame...
                if image_2.status == STARTED:
                    # update params
                    pass
                
                # if image_2 is stopping this frame...
                if image_2.status == STARTED:
                    # is it time to stop? (based on global clock, using actual start)
                    if tThisFlipGlobal > image_2.tStartRefresh + 1-frameTolerance:
                        # keep track of stop time/frame for later
                        image_2.tStop = t  # not accounting for scr refresh
                        image_2.frameNStop = frameN  # exact frame index
                        # add timestamp to datafile
                        thisExp.timestampOnFlip(win, 'image_2.stopped')
                        # update status
                        image_2.status = FINISHED
                        image_2.setAutoDraw(False)
                
                # check for quit (typically the Esc key)
                if defaultKeyboard.getKeys(keyList=["escape"]):
                    thisExp.status = FINISHED
                if thisExp.status == FINISHED or endExpNow:
                    endExperiment(thisExp, inputs=inputs, win=win)
                    return
                
                # check if all components have finished
                if not continueRoutine:  # a component has requested a forced-end of Routine
                    routineForceEnded = True
                    break
                continueRoutine = False  # will revert to True if at least one component still running
                for thisComponent in learn2Components:
                    if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:
                        continueRoutine = True
                        break  # at least one component has not yet finished
                
                # refresh the screen
                if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen
                    win.flip()
            
            # --- Ending Routine "learn2" ---
            for thisComponent in learn2Components:
                if hasattr(thisComponent, "setAutoDraw"):
                    thisComponent.setAutoDraw(False)
            thisExp.addData('learn2.stopped', globalClock.getTime())
            # using non-slip timing so subtract the expected duration of this Routine (unless ended on request)
            if routineForceEnded:
                routineTimer.reset()
            else:
                routineTimer.addTime(-1.000000)
            
            # --- Prepare to start Routine "next_trial" ---
            continueRoutine = True
            # update component parameters for each repeat
            thisExp.addData('next_trial.started', globalClock.getTime())
            # keep track of which components have finished
            next_trialComponents = [next_trial_text]
            for thisComponent in next_trialComponents:
                thisComponent.tStart = None
                thisComponent.tStop = None
                thisComponent.tStartRefresh = None
                thisComponent.tStopRefresh = None
                if hasattr(thisComponent, 'status'):
                    thisComponent.status = NOT_STARTED
            # reset timers
            t = 0
            _timeToFirstFrame = win.getFutureFlipTime(clock="now")
            frameN = -1
            
            # --- Run Routine "next_trial" ---
            routineForceEnded = not continueRoutine
            while continueRoutine and routineTimer.getTime() < 1.0:
                # get current time
                t = routineTimer.getTime()
                tThisFlip = win.getFutureFlipTime(clock=routineTimer)
                tThisFlipGlobal = win.getFutureFlipTime(clock=None)
                frameN = frameN + 1  # number of completed frames (so 0 is the first frame)
                # update/draw components on each frame
                
                # *next_trial_text* updates
                
                # if next_trial_text is starting this frame...
                if next_trial_text.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
                    # keep track of start time/frame for later
                    next_trial_text.frameNStart = frameN  # exact frame index
                    next_trial_text.tStart = t  # local t and not account for scr refresh
                    next_trial_text.tStartRefresh = tThisFlipGlobal  # on global time
                    win.timeOnFlip(next_trial_text, 'tStartRefresh')  # time at next scr refresh
                    # add timestamp to datafile
                    thisExp.timestampOnFlip(win, 'next_trial_text.started')
                    # update status
                    next_trial_text.status = STARTED
                    next_trial_text.setAutoDraw(True)
                
                # if next_trial_text is active this frame...
                if next_trial_text.status == STARTED:
                    # update params
                    pass
                
                # if next_trial_text is stopping this frame...
                if next_trial_text.status == STARTED:
                    # is it time to stop? (based on global clock, using actual start)
                    if tThisFlipGlobal > next_trial_text.tStartRefresh + 1-frameTolerance:
                        # keep track of stop time/frame for later
                        next_trial_text.tStop = t  # not accounting for scr refresh
                        next_trial_text.frameNStop = frameN  # exact frame index
                        # add timestamp to datafile
                        thisExp.timestampOnFlip(win, 'next_trial_text.stopped')
                        # update status
                        next_trial_text.status = FINISHED
                        next_trial_text.setAutoDraw(False)
                
                # check for quit (typically the Esc key)
                if defaultKeyboard.getKeys(keyList=["escape"]):
                    thisExp.status = FINISHED
                if thisExp.status == FINISHED or endExpNow:
                    endExperiment(thisExp, inputs=inputs, win=win)
                    return
                
                # check if all components have finished
                if not continueRoutine:  # a component has requested a forced-end of Routine
                    routineForceEnded = True
                    break
                continueRoutine = False  # will revert to True if at least one component still running
                for thisComponent in next_trialComponents:
                    if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:
                        continueRoutine = True
                        break  # at least one component has not yet finished
                
                # refresh the screen
                if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen
                    win.flip()
            
            # --- Ending Routine "next_trial" ---
            for thisComponent in next_trialComponents:
                if hasattr(thisComponent, "setAutoDraw"):
                    thisComponent.setAutoDraw(False)
            thisExp.addData('next_trial.stopped', globalClock.getTime())
            # using non-slip timing so subtract the expected duration of this Routine (unless ended on request)
            if routineForceEnded:
                routineTimer.reset()
            else:
                routineTimer.addTime(-1.000000)
            thisExp.nextEntry()
            
            if thisSession is not None:
                # if running in a Session with a Liaison client, send data up to now
                thisSession.sendExperimentData()
        # completed 4.0 repeats of 'learn_1_2'
        
        
        # --- Prepare to start Routine "between" ---
        continueRoutine = True
        # update component parameters for each repeat
        thisExp.addData('between.started', globalClock.getTime())
        # Run 'Begin Routine' code from code_39
        quiz1_count=1
        quiz2_count=1
        
        # keep track of which components have finished
        betweenComponents = [text_2]
        for thisComponent in betweenComponents:
            thisComponent.tStart = None
            thisComponent.tStop = None
            thisComponent.tStartRefresh = None
            thisComponent.tStopRefresh = None
            if hasattr(thisComponent, 'status'):
                thisComponent.status = NOT_STARTED
        # reset timers
        t = 0
        _timeToFirstFrame = win.getFutureFlipTime(clock="now")
        frameN = -1
        
        # --- Run Routine "between" ---
        routineForceEnded = not continueRoutine
        while continueRoutine and routineTimer.getTime() < 5.0:
            # get current time
            t = routineTimer.getTime()
            tThisFlip = win.getFutureFlipTime(clock=routineTimer)
            tThisFlipGlobal = win.getFutureFlipTime(clock=None)
            frameN = frameN + 1  # number of completed frames (so 0 is the first frame)
            # update/draw components on each frame
            
            # *text_2* updates
            
            # if text_2 is starting this frame...
            if text_2.status == NOT_STARTED and tThisFlip >= 0-frameTolerance:
                # keep track of start time/frame for later
                text_2.frameNStart = frameN  # exact frame index
                text_2.tStart = t  # local t and not account for scr refresh
                text_2.tStartRefresh = tThisFlipGlobal  # on global time
                win.timeOnFlip(text_2, 'tStartRefresh')  # time at next scr refresh
                # add timestamp to datafile
                thisExp.timestampOnFlip(win, 'text_2.started')
                # update status
                text_2.status = STARTED
                text_2.setAutoDraw(True)
            
            # if text_2 is active this frame...
            if text_2.status == STARTED:
                # update params
                pass
            
            # if text_2 is stopping this frame...
            if text_2.status == STARTED:
                # is it time to stop? (based on global clock, using actual start)
                if tThisFlipGlobal > text_2.tStartRefresh + 5-frameTolerance:
                    # keep track of stop time/frame for later
                    text_2.tStop = t  # not accounting for scr refresh
                    text_2.frameNStop = frameN  # exact frame index
                    # add timestamp to datafile
                    thisExp.timestampOnFlip(win, 'text_2.stopped')
                    # update status
                    text_2.status = FINISHED
                    text_2.setAutoDraw(False)
            
            # check for quit (typically the Esc key)
            if defaultKeyboard.getKeys(keyList=["escape"]):
                thisExp.status = FINISHED
            if thisExp.status == FINISHED or endExpNow:
                endExperiment(thisExp, inputs=inputs, win=win)
                return
            
            # check if all components have finished
            if not continueRoutine:  # a component has requested a forced-end of Routine
                routineForceEnded = True
                break
            continueRoutine = False  # will revert to True if at least one component still running
            for thisComponent in betweenComponents:
                if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:
                    continueRoutine = True
                    break  # at least one component has not yet finished
            
            # refresh the screen
            if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen
                win.flip()
        
        # --- Ending Routine "between" ---
        for thisComponent in betweenComponents:
            if hasattr(thisComponent, "setAutoDraw"):
                thisComponent.setAutoDraw(False)
        thisExp.addData('between.stopped', globalClock.getTime())
        # using non-slip timing so subtract the expected duration of this Routine (unless ended on request)
        if routineForceEnded:
            routineTimer.reset()
        else:
            routineTimer.addTime(-5.000000)
        
        # set up handler to look after randomisation of conditions etc
        quizloop2 = data.TrialHandler(nReps=1.0, method='random', 
            extraInfo=expInfo, originPath=-1,
            trialList=data.importConditions('quiz_1.xlsx'),
            seed=None, name='quizloop2')
        thisExp.addLoop(quizloop2)  # add the loop to the experiment
        thisQuizloop2 = quizloop2.trialList[0]  # so we can initialise stimuli with some values
        # abbreviate parameter names if possible (e.g. rgb = thisQuizloop2.rgb)
        if thisQuizloop2 != None:
            for paramName in thisQuizloop2:
                globals()[paramName] = thisQuizloop2[paramName]
        
        for thisQuizloop2 in quizloop2:
            currentLoop = quizloop2
            thisExp.timestampOnFlip(win, 'thisRow.t')
            # pause experiment here if requested
            if thisExp.status == PAUSED:
                pauseExperiment(
                    thisExp=thisExp, 
                    inputs=inputs, 
                    win=win, 
                    timers=[routineTimer], 
                    playbackComponents=[]
            )
            # abbreviate parameter names if possible (e.g. rgb = thisQuizloop2.rgb)
            if thisQuizloop2 != None:
                for paramName in thisQuizloop2:
                    globals()[paramName] = thisQuizloop2[paramName]
            
            # --- Prepare to start Routine "quiz2" ---
            continueRoutine = True
            # update component parameters for each repeat
            thisExp.addData('quiz2.started', globalClock.getTime())
            target_quiz1_2.setImage(image1)
            question_quiz1_2.setText(question)
            answer_quiz1_2.keys = []
            answer_quiz1_2.rt = []
            _answer_quiz1_2_allKeys = []
            answer1_2.setImage(ans1)
            answer2_2.setImage(ans2)
            answer3_2.setImage(ans3)
            answer4_2.setImage(ans4)
            # keep track of which components have finished
            quiz2Components = [target_quiz1_2, question_quiz1_2, answer_quiz1_2, answer1_2, answer2_2, answer3_2, answer4_2, a1_2, a2_2, a3_2, a4_2]
            for thisComponent in quiz2Components:
                thisComponent.tStart = None
                thisComponent.tStop = None
                thisComponent.tStartRefresh = None
                thisComponent.tStopRefresh = None
                if hasattr(thisComponent, 'status'):
                    thisComponent.status = NOT_STARTED
            # reset timers
            t = 0
            _timeToFirstFrame = win.getFutureFlipTime(clock="now")
            frameN = -1
            
            # --- Run Routine "quiz2" ---
            routineForceEnded = not continueRoutine
            while continueRoutine:
                # get current time
                t = routineTimer.getTime()
                tThisFlip = win.getFutureFlipTime(clock=routineTimer)
                tThisFlipGlobal = win.getFutureFlipTime(clock=None)
                frameN = frameN + 1  # number of completed frames (so 0 is the first frame)
                # update/draw components on each frame
                
                # *target_quiz1_2* updates
                
                # if target_quiz1_2 is starting this frame...
                if target_quiz1_2.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
                    # keep track of start time/frame for later
                    target_quiz1_2.frameNStart = frameN  # exact frame index
                    target_quiz1_2.tStart = t  # local t and not account for scr refresh
                    target_quiz1_2.tStartRefresh = tThisFlipGlobal  # on global time
                    win.timeOnFlip(target_quiz1_2, 'tStartRefresh')  # time at next scr refresh
                    # add timestamp to datafile
                    thisExp.timestampOnFlip(win, 'target_quiz1_2.started')
                    # update status
                    target_quiz1_2.status = STARTED
                    target_quiz1_2.setAutoDraw(True)
                
                # if target_quiz1_2 is active this frame...
                if target_quiz1_2.status == STARTED:
                    # update params
                    pass
                
                # *question_quiz1_2* updates
                
                # if question_quiz1_2 is starting this frame...
                if question_quiz1_2.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
                    # keep track of start time/frame for later
                    question_quiz1_2.frameNStart = frameN  # exact frame index
                    question_quiz1_2.tStart = t  # local t and not account for scr refresh
                    question_quiz1_2.tStartRefresh = tThisFlipGlobal  # on global time
                    win.timeOnFlip(question_quiz1_2, 'tStartRefresh')  # time at next scr refresh
                    # add timestamp to datafile
                    thisExp.timestampOnFlip(win, 'question_quiz1_2.started')
                    # update status
                    question_quiz1_2.status = STARTED
                    question_quiz1_2.setAutoDraw(True)
                
                # if question_quiz1_2 is active this frame...
                if question_quiz1_2.status == STARTED:
                    # update params
                    pass
                
                # *answer_quiz1_2* updates
                waitOnFlip = False
                
                # if answer_quiz1_2 is starting this frame...
                if answer_quiz1_2.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
                    # keep track of start time/frame for later
                    answer_quiz1_2.frameNStart = frameN  # exact frame index
                    answer_quiz1_2.tStart = t  # local t and not account for scr refresh
                    answer_quiz1_2.tStartRefresh = tThisFlipGlobal  # on global time
                    win.timeOnFlip(answer_quiz1_2, 'tStartRefresh')  # time at next scr refresh
                    # add timestamp to datafile
                    thisExp.timestampOnFlip(win, 'answer_quiz1_2.started')
                    # update status
                    answer_quiz1_2.status = STARTED
                    # keyboard checking is just starting
                    waitOnFlip = True
                    win.callOnFlip(answer_quiz1_2.clock.reset)  # t=0 on next screen flip
                    win.callOnFlip(answer_quiz1_2.clearEvents, eventType='keyboard')  # clear events on next screen flip
                if answer_quiz1_2.status == STARTED and not waitOnFlip:
                    theseKeys = answer_quiz1_2.getKeys(keyList=['1','2','3','4'], ignoreKeys=["escape"], waitRelease=False)
                    _answer_quiz1_2_allKeys.extend(theseKeys)
                    if len(_answer_quiz1_2_allKeys):
                        answer_quiz1_2.keys = _answer_quiz1_2_allKeys[-1].name  # just the last key pressed
                        answer_quiz1_2.rt = _answer_quiz1_2_allKeys[-1].rt
                        answer_quiz1_2.duration = _answer_quiz1_2_allKeys[-1].duration
                        # was this correct?
                        if (answer_quiz1_2.keys == str(corr_ans)) or (answer_quiz1_2.keys == corr_ans):
                            answer_quiz1_2.corr = 1
                        else:
                            answer_quiz1_2.corr = 0
                        # a response ends the routine
                        continueRoutine = False
                
                # *answer1_2* updates
                
                # if answer1_2 is starting this frame...
                if answer1_2.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
                    # keep track of start time/frame for later
                    answer1_2.frameNStart = frameN  # exact frame index
                    answer1_2.tStart = t  # local t and not account for scr refresh
                    answer1_2.tStartRefresh = tThisFlipGlobal  # on global time
                    win.timeOnFlip(answer1_2, 'tStartRefresh')  # time at next scr refresh
                    # add timestamp to datafile
                    thisExp.timestampOnFlip(win, 'answer1_2.started')
                    # update status
                    answer1_2.status = STARTED
                    answer1_2.setAutoDraw(True)
                
                # if answer1_2 is active this frame...
                if answer1_2.status == STARTED:
                    # update params
                    pass
                
                # *answer2_2* updates
                
                # if answer2_2 is starting this frame...
                if answer2_2.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
                    # keep track of start time/frame for later
                    answer2_2.frameNStart = frameN  # exact frame index
                    answer2_2.tStart = t  # local t and not account for scr refresh
                    answer2_2.tStartRefresh = tThisFlipGlobal  # on global time
                    win.timeOnFlip(answer2_2, 'tStartRefresh')  # time at next scr refresh
                    # add timestamp to datafile
                    thisExp.timestampOnFlip(win, 'answer2_2.started')
                    # update status
                    answer2_2.status = STARTED
                    answer2_2.setAutoDraw(True)
                
                # if answer2_2 is active this frame...
                if answer2_2.status == STARTED:
                    # update params
                    pass
                
                # *answer3_2* updates
                
                # if answer3_2 is starting this frame...
                if answer3_2.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
                    # keep track of start time/frame for later
                    answer3_2.frameNStart = frameN  # exact frame index
                    answer3_2.tStart = t  # local t and not account for scr refresh
                    answer3_2.tStartRefresh = tThisFlipGlobal  # on global time
                    win.timeOnFlip(answer3_2, 'tStartRefresh')  # time at next scr refresh
                    # add timestamp to datafile
                    thisExp.timestampOnFlip(win, 'answer3_2.started')
                    # update status
                    answer3_2.status = STARTED
                    answer3_2.setAutoDraw(True)
                
                # if answer3_2 is active this frame...
                if answer3_2.status == STARTED:
                    # update params
                    pass
                
                # *answer4_2* updates
                
                # if answer4_2 is starting this frame...
                if answer4_2.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
                    # keep track of start time/frame for later
                    answer4_2.frameNStart = frameN  # exact frame index
                    answer4_2.tStart = t  # local t and not account for scr refresh
                    answer4_2.tStartRefresh = tThisFlipGlobal  # on global time
                    win.timeOnFlip(answer4_2, 'tStartRefresh')  # time at next scr refresh
                    # add timestamp to datafile
                    thisExp.timestampOnFlip(win, 'answer4_2.started')
                    # update status
                    answer4_2.status = STARTED
                    answer4_2.setAutoDraw(True)
                
                # if answer4_2 is active this frame...
                if answer4_2.status == STARTED:
                    # update params
                    pass
                
                # *a1_2* updates
                
                # if a1_2 is starting this frame...
                if a1_2.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
                    # keep track of start time/frame for later
                    a1_2.frameNStart = frameN  # exact frame index
                    a1_2.tStart = t  # local t and not account for scr refresh
                    a1_2.tStartRefresh = tThisFlipGlobal  # on global time
                    win.timeOnFlip(a1_2, 'tStartRefresh')  # time at next scr refresh
                    # add timestamp to datafile
                    thisExp.timestampOnFlip(win, 'a1_2.started')
                    # update status
                    a1_2.status = STARTED
                    a1_2.setAutoDraw(True)
                
                # if a1_2 is active this frame...
                if a1_2.status == STARTED:
                    # update params
                    pass
                
                # *a2_2* updates
                
                # if a2_2 is starting this frame...
                if a2_2.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
                    # keep track of start time/frame for later
                    a2_2.frameNStart = frameN  # exact frame index
                    a2_2.tStart = t  # local t and not account for scr refresh
                    a2_2.tStartRefresh = tThisFlipGlobal  # on global time
                    win.timeOnFlip(a2_2, 'tStartRefresh')  # time at next scr refresh
                    # add timestamp to datafile
                    thisExp.timestampOnFlip(win, 'a2_2.started')
                    # update status
                    a2_2.status = STARTED
                    a2_2.setAutoDraw(True)
                
                # if a2_2 is active this frame...
                if a2_2.status == STARTED:
                    # update params
                    pass
                
                # *a3_2* updates
                
                # if a3_2 is starting this frame...
                if a3_2.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
                    # keep track of start time/frame for later
                    a3_2.frameNStart = frameN  # exact frame index
                    a3_2.tStart = t  # local t and not account for scr refresh
                    a3_2.tStartRefresh = tThisFlipGlobal  # on global time
                    win.timeOnFlip(a3_2, 'tStartRefresh')  # time at next scr refresh
                    # add timestamp to datafile
                    thisExp.timestampOnFlip(win, 'a3_2.started')
                    # update status
                    a3_2.status = STARTED
                    a3_2.setAutoDraw(True)
                
                # if a3_2 is active this frame...
                if a3_2.status == STARTED:
                    # update params
                    pass
                
                # *a4_2* updates
                
                # if a4_2 is starting this frame...
                if a4_2.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
                    # keep track of start time/frame for later
                    a4_2.frameNStart = frameN  # exact frame index
                    a4_2.tStart = t  # local t and not account for scr refresh
                    a4_2.tStartRefresh = tThisFlipGlobal  # on global time
                    win.timeOnFlip(a4_2, 'tStartRefresh')  # time at next scr refresh
                    # add timestamp to datafile
                    thisExp.timestampOnFlip(win, 'a4_2.started')
                    # update status
                    a4_2.status = STARTED
                    a4_2.setAutoDraw(True)
                
                # if a4_2 is active this frame...
                if a4_2.status == STARTED:
                    # update params
                    pass
                
                # check for quit (typically the Esc key)
                if defaultKeyboard.getKeys(keyList=["escape"]):
                    thisExp.status = FINISHED
                if thisExp.status == FINISHED or endExpNow:
                    endExperiment(thisExp, inputs=inputs, win=win)
                    return
                
                # check if all components have finished
                if not continueRoutine:  # a component has requested a forced-end of Routine
                    routineForceEnded = True
                    break
                continueRoutine = False  # will revert to True if at least one component still running
                for thisComponent in quiz2Components:
                    if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:
                        continueRoutine = True
                        break  # at least one component has not yet finished
                
                # refresh the screen
                if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen
                    win.flip()
            
            # --- Ending Routine "quiz2" ---
            for thisComponent in quiz2Components:
                if hasattr(thisComponent, "setAutoDraw"):
                    thisComponent.setAutoDraw(False)
            thisExp.addData('quiz2.stopped', globalClock.getTime())
            # check responses
            if answer_quiz1_2.keys in ['', [], None]:  # No response was made
                answer_quiz1_2.keys = None
                # was no response the correct answer?!
                if str(corr_ans).lower() == 'none':
                   answer_quiz1_2.corr = 1;  # correct non-response
                else:
                   answer_quiz1_2.corr = 0;  # failed to respond (incorrectly)
            # store data for quizloop2 (TrialHandler)
            quizloop2.addData('answer_quiz1_2.keys',answer_quiz1_2.keys)
            quizloop2.addData('answer_quiz1_2.corr', answer_quiz1_2.corr)
            if answer_quiz1_2.keys != None:  # we had a response
                quizloop2.addData('answer_quiz1_2.rt', answer_quiz1_2.rt)
                quizloop2.addData('answer_quiz1_2.duration', answer_quiz1_2.duration)
            # Run 'End Routine' code from code_45
            if answer_quiz1_2.corr:
                quiz2_score+=1
                msg="Correct! Good job!"
            else:
                msg="INCORRECT :("
            # the Routine "quiz2" was not non-slip safe, so reset the non-slip timer
            routineTimer.reset()
            
            # --- Prepare to start Routine "quiz_feedback" ---
            continueRoutine = True
            # update component parameters for each repeat
            thisExp.addData('quiz_feedback.started', globalClock.getTime())
            result_q_instr.setText(msg)
            # keep track of which components have finished
            quiz_feedbackComponents = [result_q_instr]
            for thisComponent in quiz_feedbackComponents:
                thisComponent.tStart = None
                thisComponent.tStop = None
                thisComponent.tStartRefresh = None
                thisComponent.tStopRefresh = None
                if hasattr(thisComponent, 'status'):
                    thisComponent.status = NOT_STARTED
            # reset timers
            t = 0
            _timeToFirstFrame = win.getFutureFlipTime(clock="now")
            frameN = -1
            
            # --- Run Routine "quiz_feedback" ---
            routineForceEnded = not continueRoutine
            while continueRoutine and routineTimer.getTime() < 1.25:
                # get current time
                t = routineTimer.getTime()
                tThisFlip = win.getFutureFlipTime(clock=routineTimer)
                tThisFlipGlobal = win.getFutureFlipTime(clock=None)
                frameN = frameN + 1  # number of completed frames (so 0 is the first frame)
                # update/draw components on each frame
                
                # *result_q_instr* updates
                
                # if result_q_instr is starting this frame...
                if result_q_instr.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
                    # keep track of start time/frame for later
                    result_q_instr.frameNStart = frameN  # exact frame index
                    result_q_instr.tStart = t  # local t and not account for scr refresh
                    result_q_instr.tStartRefresh = tThisFlipGlobal  # on global time
                    win.timeOnFlip(result_q_instr, 'tStartRefresh')  # time at next scr refresh
                    # add timestamp to datafile
                    thisExp.timestampOnFlip(win, 'result_q_instr.started')
                    # update status
                    result_q_instr.status = STARTED
                    result_q_instr.setAutoDraw(True)
                
                # if result_q_instr is active this frame...
                if result_q_instr.status == STARTED:
                    # update params
                    pass
                
                # if result_q_instr is stopping this frame...
                if result_q_instr.status == STARTED:
                    # is it time to stop? (based on global clock, using actual start)
                    if tThisFlipGlobal > result_q_instr.tStartRefresh + 1.25-frameTolerance:
                        # keep track of stop time/frame for later
                        result_q_instr.tStop = t  # not accounting for scr refresh
                        result_q_instr.frameNStop = frameN  # exact frame index
                        # add timestamp to datafile
                        thisExp.timestampOnFlip(win, 'result_q_instr.stopped')
                        # update status
                        result_q_instr.status = FINISHED
                        result_q_instr.setAutoDraw(False)
                
                # check for quit (typically the Esc key)
                if defaultKeyboard.getKeys(keyList=["escape"]):
                    thisExp.status = FINISHED
                if thisExp.status == FINISHED or endExpNow:
                    endExperiment(thisExp, inputs=inputs, win=win)
                    return
                
                # check if all components have finished
                if not continueRoutine:  # a component has requested a forced-end of Routine
                    routineForceEnded = True
                    break
                continueRoutine = False  # will revert to True if at least one component still running
                for thisComponent in quiz_feedbackComponents:
                    if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:
                        continueRoutine = True
                        break  # at least one component has not yet finished
                
                # refresh the screen
                if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen
                    win.flip()
            
            # --- Ending Routine "quiz_feedback" ---
            for thisComponent in quiz_feedbackComponents:
                if hasattr(thisComponent, "setAutoDraw"):
                    thisComponent.setAutoDraw(False)
            thisExp.addData('quiz_feedback.stopped', globalClock.getTime())
            # using non-slip timing so subtract the expected duration of this Routine (unless ended on request)
            if routineForceEnded:
                routineTimer.reset()
            else:
                routineTimer.addTime(-1.250000)
            thisExp.nextEntry()
            
            if thisSession is not None:
                # if running in a Session with a Liaison client, send data up to now
                thisSession.sendExperimentData()
        # completed 1.0 repeats of 'quizloop2'
        
        
        # --- Prepare to start Routine "planning_paths" ---
        continueRoutine = True
        # update component parameters for each repeat
        thisExp.addData('planning_paths.started', globalClock.getTime())
        # Run 'Begin Routine' code from code_42
        quiz1_count=1
        quiz_planning_corr=0
        
        key_resp_40.keys = []
        key_resp_40.rt = []
        _key_resp_40_allKeys = []
        # keep track of which components have finished
        planning_pathsComponents = [text_149, key_resp_40, text_49]
        for thisComponent in planning_pathsComponents:
            thisComponent.tStart = None
            thisComponent.tStop = None
            thisComponent.tStartRefresh = None
            thisComponent.tStopRefresh = None
            if hasattr(thisComponent, 'status'):
                thisComponent.status = NOT_STARTED
        # reset timers
        t = 0
        _timeToFirstFrame = win.getFutureFlipTime(clock="now")
        frameN = -1
        
        # --- Run Routine "planning_paths" ---
        routineForceEnded = not continueRoutine
        while continueRoutine:
            # get current time
            t = routineTimer.getTime()
            tThisFlip = win.getFutureFlipTime(clock=routineTimer)
            tThisFlipGlobal = win.getFutureFlipTime(clock=None)
            frameN = frameN + 1  # number of completed frames (so 0 is the first frame)
            # update/draw components on each frame
            
            # *text_149* updates
            
            # if text_149 is starting this frame...
            if text_149.status == NOT_STARTED and tThisFlip >= 0-frameTolerance:
                # keep track of start time/frame for later
                text_149.frameNStart = frameN  # exact frame index
                text_149.tStart = t  # local t and not account for scr refresh
                text_149.tStartRefresh = tThisFlipGlobal  # on global time
                win.timeOnFlip(text_149, 'tStartRefresh')  # time at next scr refresh
                # add timestamp to datafile
                thisExp.timestampOnFlip(win, 'text_149.started')
                # update status
                text_149.status = STARTED
                text_149.setAutoDraw(True)
            
            # if text_149 is active this frame...
            if text_149.status == STARTED:
                # update params
                pass
            
            # *key_resp_40* updates
            waitOnFlip = False
            
            # if key_resp_40 is starting this frame...
            if key_resp_40.status == NOT_STARTED and tThisFlip >= 5.0-frameTolerance:
                # keep track of start time/frame for later
                key_resp_40.frameNStart = frameN  # exact frame index
                key_resp_40.tStart = t  # local t and not account for scr refresh
                key_resp_40.tStartRefresh = tThisFlipGlobal  # on global time
                win.timeOnFlip(key_resp_40, 'tStartRefresh')  # time at next scr refresh
                # add timestamp to datafile
                thisExp.timestampOnFlip(win, 'key_resp_40.started')
                # update status
                key_resp_40.status = STARTED
                # keyboard checking is just starting
                waitOnFlip = True
                win.callOnFlip(key_resp_40.clock.reset)  # t=0 on next screen flip
                win.callOnFlip(key_resp_40.clearEvents, eventType='keyboard')  # clear events on next screen flip
            if key_resp_40.status == STARTED and not waitOnFlip:
                theseKeys = key_resp_40.getKeys(keyList=['space'], ignoreKeys=["escape"], waitRelease=False)
                _key_resp_40_allKeys.extend(theseKeys)
                if len(_key_resp_40_allKeys):
                    key_resp_40.keys = _key_resp_40_allKeys[-1].name  # just the last key pressed
                    key_resp_40.rt = _key_resp_40_allKeys[-1].rt
                    key_resp_40.duration = _key_resp_40_allKeys[-1].duration
                    # a response ends the routine
                    continueRoutine = False
            
            # *text_49* updates
            
            # if text_49 is starting this frame...
            if text_49.status == NOT_STARTED and tThisFlip >= 5.0-frameTolerance:
                # keep track of start time/frame for later
                text_49.frameNStart = frameN  # exact frame index
                text_49.tStart = t  # local t and not account for scr refresh
                text_49.tStartRefresh = tThisFlipGlobal  # on global time
                win.timeOnFlip(text_49, 'tStartRefresh')  # time at next scr refresh
                # add timestamp to datafile
                thisExp.timestampOnFlip(win, 'text_49.started')
                # update status
                text_49.status = STARTED
                text_49.setAutoDraw(True)
            
            # if text_49 is active this frame...
            if text_49.status == STARTED:
                # update params
                pass
            
            # check for quit (typically the Esc key)
            if defaultKeyboard.getKeys(keyList=["escape"]):
                thisExp.status = FINISHED
            if thisExp.status == FINISHED or endExpNow:
                endExperiment(thisExp, inputs=inputs, win=win)
                return
            
            # check if all components have finished
            if not continueRoutine:  # a component has requested a forced-end of Routine
                routineForceEnded = True
                break
            continueRoutine = False  # will revert to True if at least one component still running
            for thisComponent in planning_pathsComponents:
                if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:
                    continueRoutine = True
                    break  # at least one component has not yet finished
            
            # refresh the screen
            if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen
                win.flip()
        
        # --- Ending Routine "planning_paths" ---
        for thisComponent in planning_pathsComponents:
            if hasattr(thisComponent, "setAutoDraw"):
                thisComponent.setAutoDraw(False)
        thisExp.addData('planning_paths.stopped', globalClock.getTime())
        # check responses
        if key_resp_40.keys in ['', [], None]:  # No response was made
            key_resp_40.keys = None
        learning_phase.addData('key_resp_40.keys',key_resp_40.keys)
        if key_resp_40.keys != None:  # we had a response
            learning_phase.addData('key_resp_40.rt', key_resp_40.rt)
            learning_phase.addData('key_resp_40.duration', key_resp_40.duration)
        # the Routine "planning_paths" was not non-slip safe, so reset the non-slip timer
        routineTimer.reset()
        
        # set up handler to look after randomisation of conditions etc
        planning_during_training = data.TrialHandler(nReps=1.0, method='random', 
            extraInfo=expInfo, originPath=-1,
            trialList=data.importConditions('forgetting1.xlsx'),
            seed=None, name='planning_during_training')
        thisExp.addLoop(planning_during_training)  # add the loop to the experiment
        thisPlanning_during_training = planning_during_training.trialList[0]  # so we can initialise stimuli with some values
        # abbreviate parameter names if possible (e.g. rgb = thisPlanning_during_training.rgb)
        if thisPlanning_during_training != None:
            for paramName in thisPlanning_during_training:
                globals()[paramName] = thisPlanning_during_training[paramName]
        
        for thisPlanning_during_training in planning_during_training:
            currentLoop = planning_during_training
            thisExp.timestampOnFlip(win, 'thisRow.t')
            # pause experiment here if requested
            if thisExp.status == PAUSED:
                pauseExperiment(
                    thisExp=thisExp, 
                    inputs=inputs, 
                    win=win, 
                    timers=[routineTimer], 
                    playbackComponents=[]
            )
            # abbreviate parameter names if possible (e.g. rgb = thisPlanning_during_training.rgb)
            if thisPlanning_during_training != None:
                for paramName in thisPlanning_during_training:
                    globals()[paramName] = thisPlanning_during_training[paramName]
            
            # --- Prepare to start Routine "forgetting_paths1" ---
            continueRoutine = True
            # update component parameters for each repeat
            thisExp.addData('forgetting_paths1.started', globalClock.getTime())
            answer_quiz1_3.keys = []
            answer_quiz1_3.rt = []
            _answer_quiz1_3_allKeys = []
            answer1_3.setImage(ans1)
            answer2_3.setImage(ans2)
            answer3_3.setImage(ans3)
            # keep track of which components have finished
            forgetting_paths1Components = [question_quiz1_3, answer_quiz1_3, answer1_3, answer2_3, answer3_3, a1_3, a2_3, text_146]
            for thisComponent in forgetting_paths1Components:
                thisComponent.tStart = None
                thisComponent.tStop = None
                thisComponent.tStartRefresh = None
                thisComponent.tStopRefresh = None
                if hasattr(thisComponent, 'status'):
                    thisComponent.status = NOT_STARTED
            # reset timers
            t = 0
            _timeToFirstFrame = win.getFutureFlipTime(clock="now")
            frameN = -1
            
            # --- Run Routine "forgetting_paths1" ---
            routineForceEnded = not continueRoutine
            while continueRoutine and routineTimer.getTime() < 120.0:
                # get current time
                t = routineTimer.getTime()
                tThisFlip = win.getFutureFlipTime(clock=routineTimer)
                tThisFlipGlobal = win.getFutureFlipTime(clock=None)
                frameN = frameN + 1  # number of completed frames (so 0 is the first frame)
                # update/draw components on each frame
                
                # *question_quiz1_3* updates
                
                # if question_quiz1_3 is starting this frame...
                if question_quiz1_3.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
                    # keep track of start time/frame for later
                    question_quiz1_3.frameNStart = frameN  # exact frame index
                    question_quiz1_3.tStart = t  # local t and not account for scr refresh
                    question_quiz1_3.tStartRefresh = tThisFlipGlobal  # on global time
                    win.timeOnFlip(question_quiz1_3, 'tStartRefresh')  # time at next scr refresh
                    # add timestamp to datafile
                    thisExp.timestampOnFlip(win, 'question_quiz1_3.started')
                    # update status
                    question_quiz1_3.status = STARTED
                    question_quiz1_3.setAutoDraw(True)
                
                # if question_quiz1_3 is active this frame...
                if question_quiz1_3.status == STARTED:
                    # update params
                    pass
                
                # if question_quiz1_3 is stopping this frame...
                if question_quiz1_3.status == STARTED:
                    # is it time to stop? (based on global clock, using actual start)
                    if tThisFlipGlobal > question_quiz1_3.tStartRefresh + 120-frameTolerance:
                        # keep track of stop time/frame for later
                        question_quiz1_3.tStop = t  # not accounting for scr refresh
                        question_quiz1_3.frameNStop = frameN  # exact frame index
                        # add timestamp to datafile
                        thisExp.timestampOnFlip(win, 'question_quiz1_3.stopped')
                        # update status
                        question_quiz1_3.status = FINISHED
                        question_quiz1_3.setAutoDraw(False)
                
                # *answer_quiz1_3* updates
                waitOnFlip = False
                
                # if answer_quiz1_3 is starting this frame...
                if answer_quiz1_3.status == NOT_STARTED and tThisFlip >= 0-frameTolerance:
                    # keep track of start time/frame for later
                    answer_quiz1_3.frameNStart = frameN  # exact frame index
                    answer_quiz1_3.tStart = t  # local t and not account for scr refresh
                    answer_quiz1_3.tStartRefresh = tThisFlipGlobal  # on global time
                    win.timeOnFlip(answer_quiz1_3, 'tStartRefresh')  # time at next scr refresh
                    # add timestamp to datafile
                    thisExp.timestampOnFlip(win, 'answer_quiz1_3.started')
                    # update status
                    answer_quiz1_3.status = STARTED
                    # keyboard checking is just starting
                    waitOnFlip = True
                    win.callOnFlip(answer_quiz1_3.clock.reset)  # t=0 on next screen flip
                    win.callOnFlip(answer_quiz1_3.clearEvents, eventType='keyboard')  # clear events on next screen flip
                
                # if answer_quiz1_3 is stopping this frame...
                if answer_quiz1_3.status == STARTED:
                    # is it time to stop? (based on global clock, using actual start)
                    if tThisFlipGlobal > answer_quiz1_3.tStartRefresh + 120-frameTolerance:
                        # keep track of stop time/frame for later
                        answer_quiz1_3.tStop = t  # not accounting for scr refresh
                        answer_quiz1_3.frameNStop = frameN  # exact frame index
                        # add timestamp to datafile
                        thisExp.timestampOnFlip(win, 'answer_quiz1_3.stopped')
                        # update status
                        answer_quiz1_3.status = FINISHED
                        answer_quiz1_3.status = FINISHED
                if answer_quiz1_3.status == STARTED and not waitOnFlip:
                    theseKeys = answer_quiz1_3.getKeys(keyList=["left","right"], ignoreKeys=["escape"], waitRelease=False)
                    _answer_quiz1_3_allKeys.extend(theseKeys)
                    if len(_answer_quiz1_3_allKeys):
                        answer_quiz1_3.keys = _answer_quiz1_3_allKeys[0].name  # just the first key pressed
                        answer_quiz1_3.rt = _answer_quiz1_3_allKeys[0].rt
                        answer_quiz1_3.duration = _answer_quiz1_3_allKeys[0].duration
                        # was this correct?
                        if (answer_quiz1_3.keys == str(correct_answer1)) or (answer_quiz1_3.keys == correct_answer1):
                            answer_quiz1_3.corr = 1
                        else:
                            answer_quiz1_3.corr = 0
                        # a response ends the routine
                        continueRoutine = False
                
                # *answer1_3* updates
                
                # if answer1_3 is starting this frame...
                if answer1_3.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
                    # keep track of start time/frame for later
                    answer1_3.frameNStart = frameN  # exact frame index
                    answer1_3.tStart = t  # local t and not account for scr refresh
                    answer1_3.tStartRefresh = tThisFlipGlobal  # on global time
                    win.timeOnFlip(answer1_3, 'tStartRefresh')  # time at next scr refresh
                    # add timestamp to datafile
                    thisExp.timestampOnFlip(win, 'answer1_3.started')
                    # update status
                    answer1_3.status = STARTED
                    answer1_3.setAutoDraw(True)
                
                # if answer1_3 is active this frame...
                if answer1_3.status == STARTED:
                    # update params
                    pass
                
                # if answer1_3 is stopping this frame...
                if answer1_3.status == STARTED:
                    # is it time to stop? (based on global clock, using actual start)
                    if tThisFlipGlobal > answer1_3.tStartRefresh + 120-frameTolerance:
                        # keep track of stop time/frame for later
                        answer1_3.tStop = t  # not accounting for scr refresh
                        answer1_3.frameNStop = frameN  # exact frame index
                        # add timestamp to datafile
                        thisExp.timestampOnFlip(win, 'answer1_3.stopped')
                        # update status
                        answer1_3.status = FINISHED
                        answer1_3.setAutoDraw(False)
                
                # *answer2_3* updates
                
                # if answer2_3 is starting this frame...
                if answer2_3.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
                    # keep track of start time/frame for later
                    answer2_3.frameNStart = frameN  # exact frame index
                    answer2_3.tStart = t  # local t and not account for scr refresh
                    answer2_3.tStartRefresh = tThisFlipGlobal  # on global time
                    win.timeOnFlip(answer2_3, 'tStartRefresh')  # time at next scr refresh
                    # add timestamp to datafile
                    thisExp.timestampOnFlip(win, 'answer2_3.started')
                    # update status
                    answer2_3.status = STARTED
                    answer2_3.setAutoDraw(True)
                
                # if answer2_3 is active this frame...
                if answer2_3.status == STARTED:
                    # update params
                    pass
                
                # if answer2_3 is stopping this frame...
                if answer2_3.status == STARTED:
                    # is it time to stop? (based on global clock, using actual start)
                    if tThisFlipGlobal > answer2_3.tStartRefresh + 120-frameTolerance:
                        # keep track of stop time/frame for later
                        answer2_3.tStop = t  # not accounting for scr refresh
                        answer2_3.frameNStop = frameN  # exact frame index
                        # add timestamp to datafile
                        thisExp.timestampOnFlip(win, 'answer2_3.stopped')
                        # update status
                        answer2_3.status = FINISHED
                        answer2_3.setAutoDraw(False)
                
                # *answer3_3* updates
                
                # if answer3_3 is starting this frame...
                if answer3_3.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
                    # keep track of start time/frame for later
                    answer3_3.frameNStart = frameN  # exact frame index
                    answer3_3.tStart = t  # local t and not account for scr refresh
                    answer3_3.tStartRefresh = tThisFlipGlobal  # on global time
                    win.timeOnFlip(answer3_3, 'tStartRefresh')  # time at next scr refresh
                    # add timestamp to datafile
                    thisExp.timestampOnFlip(win, 'answer3_3.started')
                    # update status
                    answer3_3.status = STARTED
                    answer3_3.setAutoDraw(True)
                
                # if answer3_3 is active this frame...
                if answer3_3.status == STARTED:
                    # update params
                    pass
                
                # if answer3_3 is stopping this frame...
                if answer3_3.status == STARTED:
                    # is it time to stop? (based on global clock, using actual start)
                    if tThisFlipGlobal > answer3_3.tStartRefresh + 120-frameTolerance:
                        # keep track of stop time/frame for later
                        answer3_3.tStop = t  # not accounting for scr refresh
                        answer3_3.frameNStop = frameN  # exact frame index
                        # add timestamp to datafile
                        thisExp.timestampOnFlip(win, 'answer3_3.stopped')
                        # update status
                        answer3_3.status = FINISHED
                        answer3_3.setAutoDraw(False)
                
                # *a1_3* updates
                
                # if a1_3 is starting this frame...
                if a1_3.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
                    # keep track of start time/frame for later
                    a1_3.frameNStart = frameN  # exact frame index
                    a1_3.tStart = t  # local t and not account for scr refresh
                    a1_3.tStartRefresh = tThisFlipGlobal  # on global time
                    win.timeOnFlip(a1_3, 'tStartRefresh')  # time at next scr refresh
                    # add timestamp to datafile
                    thisExp.timestampOnFlip(win, 'a1_3.started')
                    # update status
                    a1_3.status = STARTED
                    a1_3.setAutoDraw(True)
                
                # if a1_3 is active this frame...
                if a1_3.status == STARTED:
                    # update params
                    pass
                
                # if a1_3 is stopping this frame...
                if a1_3.status == STARTED:
                    # is it time to stop? (based on global clock, using actual start)
                    if tThisFlipGlobal > a1_3.tStartRefresh + 120-frameTolerance:
                        # keep track of stop time/frame for later
                        a1_3.tStop = t  # not accounting for scr refresh
                        a1_3.frameNStop = frameN  # exact frame index
                        # add timestamp to datafile
                        thisExp.timestampOnFlip(win, 'a1_3.stopped')
                        # update status
                        a1_3.status = FINISHED
                        a1_3.setAutoDraw(False)
                
                # *a2_3* updates
                
                # if a2_3 is starting this frame...
                if a2_3.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
                    # keep track of start time/frame for later
                    a2_3.frameNStart = frameN  # exact frame index
                    a2_3.tStart = t  # local t and not account for scr refresh
                    a2_3.tStartRefresh = tThisFlipGlobal  # on global time
                    win.timeOnFlip(a2_3, 'tStartRefresh')  # time at next scr refresh
                    # add timestamp to datafile
                    thisExp.timestampOnFlip(win, 'a2_3.started')
                    # update status
                    a2_3.status = STARTED
                    a2_3.setAutoDraw(True)
                
                # if a2_3 is active this frame...
                if a2_3.status == STARTED:
                    # update params
                    pass
                
                # if a2_3 is stopping this frame...
                if a2_3.status == STARTED:
                    # is it time to stop? (based on global clock, using actual start)
                    if tThisFlipGlobal > a2_3.tStartRefresh + 120-frameTolerance:
                        # keep track of stop time/frame for later
                        a2_3.tStop = t  # not accounting for scr refresh
                        a2_3.frameNStop = frameN  # exact frame index
                        # add timestamp to datafile
                        thisExp.timestampOnFlip(win, 'a2_3.stopped')
                        # update status
                        a2_3.status = FINISHED
                        a2_3.setAutoDraw(False)
                
                # *text_146* updates
                
                # if text_146 is starting this frame...
                if text_146.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
                    # keep track of start time/frame for later
                    text_146.frameNStart = frameN  # exact frame index
                    text_146.tStart = t  # local t and not account for scr refresh
                    text_146.tStartRefresh = tThisFlipGlobal  # on global time
                    win.timeOnFlip(text_146, 'tStartRefresh')  # time at next scr refresh
                    # add timestamp to datafile
                    thisExp.timestampOnFlip(win, 'text_146.started')
                    # update status
                    text_146.status = STARTED
                    text_146.setAutoDraw(True)
                
                # if text_146 is active this frame...
                if text_146.status == STARTED:
                    # update params
                    pass
                
                # if text_146 is stopping this frame...
                if text_146.status == STARTED:
                    # is it time to stop? (based on global clock, using actual start)
                    if tThisFlipGlobal > text_146.tStartRefresh + 120.0-frameTolerance:
                        # keep track of stop time/frame for later
                        text_146.tStop = t  # not accounting for scr refresh
                        text_146.frameNStop = frameN  # exact frame index
                        # add timestamp to datafile
                        thisExp.timestampOnFlip(win, 'text_146.stopped')
                        # update status
                        text_146.status = FINISHED
                        text_146.setAutoDraw(False)
                
                # check for quit (typically the Esc key)
                if defaultKeyboard.getKeys(keyList=["escape"]):
                    thisExp.status = FINISHED
                if thisExp.status == FINISHED or endExpNow:
                    endExperiment(thisExp, inputs=inputs, win=win)
                    return
                
                # check if all components have finished
                if not continueRoutine:  # a component has requested a forced-end of Routine
                    routineForceEnded = True
                    break
                continueRoutine = False  # will revert to True if at least one component still running
                for thisComponent in forgetting_paths1Components:
                    if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:
                        continueRoutine = True
                        break  # at least one component has not yet finished
                
                # refresh the screen
                if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen
                    win.flip()
            
            # --- Ending Routine "forgetting_paths1" ---
            for thisComponent in forgetting_paths1Components:
                if hasattr(thisComponent, "setAutoDraw"):
                    thisComponent.setAutoDraw(False)
            thisExp.addData('forgetting_paths1.stopped', globalClock.getTime())
            # check responses
            if answer_quiz1_3.keys in ['', [], None]:  # No response was made
                answer_quiz1_3.keys = None
                # was no response the correct answer?!
                if str(correct_answer1).lower() == 'none':
                   answer_quiz1_3.corr = 1;  # correct non-response
                else:
                   answer_quiz1_3.corr = 0;  # failed to respond (incorrectly)
            # store data for planning_during_training (TrialHandler)
            planning_during_training.addData('answer_quiz1_3.keys',answer_quiz1_3.keys)
            planning_during_training.addData('answer_quiz1_3.corr', answer_quiz1_3.corr)
            if answer_quiz1_3.keys != None:  # we had a response
                planning_during_training.addData('answer_quiz1_3.rt', answer_quiz1_3.rt)
                planning_during_training.addData('answer_quiz1_3.duration', answer_quiz1_3.duration)
            # using non-slip timing so subtract the expected duration of this Routine (unless ended on request)
            if routineForceEnded:
                routineTimer.reset()
            else:
                routineTimer.addTime(-120.000000)
            
            # --- Prepare to start Routine "planningpathstraining2" ---
            continueRoutine = True
            # update component parameters for each repeat
            thisExp.addData('planningpathstraining2.started', globalClock.getTime())
            answer_quiz1_5.keys = []
            answer_quiz1_5.rt = []
            _answer_quiz1_5_allKeys = []
            answer1_5.setImage(ans1)
            answer2_5.setImage(ans2)
            answer3_5.setImage(ans3)
            # keep track of which components have finished
            planningpathstraining2Components = [question_quiz1_5, answer_quiz1_5, answer1_5, answer2_5, answer3_5, a1_5, a2_5, text_152]
            for thisComponent in planningpathstraining2Components:
                thisComponent.tStart = None
                thisComponent.tStop = None
                thisComponent.tStartRefresh = None
                thisComponent.tStopRefresh = None
                if hasattr(thisComponent, 'status'):
                    thisComponent.status = NOT_STARTED
            # reset timers
            t = 0
            _timeToFirstFrame = win.getFutureFlipTime(clock="now")
            frameN = -1
            
            # --- Run Routine "planningpathstraining2" ---
            routineForceEnded = not continueRoutine
            while continueRoutine and routineTimer.getTime() < 120.0:
                # get current time
                t = routineTimer.getTime()
                tThisFlip = win.getFutureFlipTime(clock=routineTimer)
                tThisFlipGlobal = win.getFutureFlipTime(clock=None)
                frameN = frameN + 1  # number of completed frames (so 0 is the first frame)
                # update/draw components on each frame
                
                # *question_quiz1_5* updates
                
                # if question_quiz1_5 is starting this frame...
                if question_quiz1_5.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
                    # keep track of start time/frame for later
                    question_quiz1_5.frameNStart = frameN  # exact frame index
                    question_quiz1_5.tStart = t  # local t and not account for scr refresh
                    question_quiz1_5.tStartRefresh = tThisFlipGlobal  # on global time
                    win.timeOnFlip(question_quiz1_5, 'tStartRefresh')  # time at next scr refresh
                    # add timestamp to datafile
                    thisExp.timestampOnFlip(win, 'question_quiz1_5.started')
                    # update status
                    question_quiz1_5.status = STARTED
                    question_quiz1_5.setAutoDraw(True)
                
                # if question_quiz1_5 is active this frame...
                if question_quiz1_5.status == STARTED:
                    # update params
                    pass
                
                # if question_quiz1_5 is stopping this frame...
                if question_quiz1_5.status == STARTED:
                    # is it time to stop? (based on global clock, using actual start)
                    if tThisFlipGlobal > question_quiz1_5.tStartRefresh + 120-frameTolerance:
                        # keep track of stop time/frame for later
                        question_quiz1_5.tStop = t  # not accounting for scr refresh
                        question_quiz1_5.frameNStop = frameN  # exact frame index
                        # add timestamp to datafile
                        thisExp.timestampOnFlip(win, 'question_quiz1_5.stopped')
                        # update status
                        question_quiz1_5.status = FINISHED
                        question_quiz1_5.setAutoDraw(False)
                
                # *answer_quiz1_5* updates
                waitOnFlip = False
                
                # if answer_quiz1_5 is starting this frame...
                if answer_quiz1_5.status == NOT_STARTED and tThisFlip >= 0-frameTolerance:
                    # keep track of start time/frame for later
                    answer_quiz1_5.frameNStart = frameN  # exact frame index
                    answer_quiz1_5.tStart = t  # local t and not account for scr refresh
                    answer_quiz1_5.tStartRefresh = tThisFlipGlobal  # on global time
                    win.timeOnFlip(answer_quiz1_5, 'tStartRefresh')  # time at next scr refresh
                    # add timestamp to datafile
                    thisExp.timestampOnFlip(win, 'answer_quiz1_5.started')
                    # update status
                    answer_quiz1_5.status = STARTED
                    # keyboard checking is just starting
                    waitOnFlip = True
                    win.callOnFlip(answer_quiz1_5.clock.reset)  # t=0 on next screen flip
                    win.callOnFlip(answer_quiz1_5.clearEvents, eventType='keyboard')  # clear events on next screen flip
                
                # if answer_quiz1_5 is stopping this frame...
                if answer_quiz1_5.status == STARTED:
                    # is it time to stop? (based on global clock, using actual start)
                    if tThisFlipGlobal > answer_quiz1_5.tStartRefresh + 120-frameTolerance:
                        # keep track of stop time/frame for later
                        answer_quiz1_5.tStop = t  # not accounting for scr refresh
                        answer_quiz1_5.frameNStop = frameN  # exact frame index
                        # add timestamp to datafile
                        thisExp.timestampOnFlip(win, 'answer_quiz1_5.stopped')
                        # update status
                        answer_quiz1_5.status = FINISHED
                        answer_quiz1_5.status = FINISHED
                if answer_quiz1_5.status == STARTED and not waitOnFlip:
                    theseKeys = answer_quiz1_5.getKeys(keyList=["left","right"], ignoreKeys=["escape"], waitRelease=False)
                    _answer_quiz1_5_allKeys.extend(theseKeys)
                    if len(_answer_quiz1_5_allKeys):
                        answer_quiz1_5.keys = _answer_quiz1_5_allKeys[0].name  # just the first key pressed
                        answer_quiz1_5.rt = _answer_quiz1_5_allKeys[0].rt
                        answer_quiz1_5.duration = _answer_quiz1_5_allKeys[0].duration
                        # was this correct?
                        if (answer_quiz1_5.keys == str(correct_answer2)) or (answer_quiz1_5.keys == correct_answer2):
                            answer_quiz1_5.corr = 1
                        else:
                            answer_quiz1_5.corr = 0
                        # a response ends the routine
                        continueRoutine = False
                
                # *answer1_5* updates
                
                # if answer1_5 is starting this frame...
                if answer1_5.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
                    # keep track of start time/frame for later
                    answer1_5.frameNStart = frameN  # exact frame index
                    answer1_5.tStart = t  # local t and not account for scr refresh
                    answer1_5.tStartRefresh = tThisFlipGlobal  # on global time
                    win.timeOnFlip(answer1_5, 'tStartRefresh')  # time at next scr refresh
                    # add timestamp to datafile
                    thisExp.timestampOnFlip(win, 'answer1_5.started')
                    # update status
                    answer1_5.status = STARTED
                    answer1_5.setAutoDraw(True)
                
                # if answer1_5 is active this frame...
                if answer1_5.status == STARTED:
                    # update params
                    pass
                
                # if answer1_5 is stopping this frame...
                if answer1_5.status == STARTED:
                    # is it time to stop? (based on global clock, using actual start)
                    if tThisFlipGlobal > answer1_5.tStartRefresh + 120-frameTolerance:
                        # keep track of stop time/frame for later
                        answer1_5.tStop = t  # not accounting for scr refresh
                        answer1_5.frameNStop = frameN  # exact frame index
                        # add timestamp to datafile
                        thisExp.timestampOnFlip(win, 'answer1_5.stopped')
                        # update status
                        answer1_5.status = FINISHED
                        answer1_5.setAutoDraw(False)
                
                # *answer2_5* updates
                
                # if answer2_5 is starting this frame...
                if answer2_5.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
                    # keep track of start time/frame for later
                    answer2_5.frameNStart = frameN  # exact frame index
                    answer2_5.tStart = t  # local t and not account for scr refresh
                    answer2_5.tStartRefresh = tThisFlipGlobal  # on global time
                    win.timeOnFlip(answer2_5, 'tStartRefresh')  # time at next scr refresh
                    # add timestamp to datafile
                    thisExp.timestampOnFlip(win, 'answer2_5.started')
                    # update status
                    answer2_5.status = STARTED
                    answer2_5.setAutoDraw(True)
                
                # if answer2_5 is active this frame...
                if answer2_5.status == STARTED:
                    # update params
                    pass
                
                # if answer2_5 is stopping this frame...
                if answer2_5.status == STARTED:
                    # is it time to stop? (based on global clock, using actual start)
                    if tThisFlipGlobal > answer2_5.tStartRefresh + 120-frameTolerance:
                        # keep track of stop time/frame for later
                        answer2_5.tStop = t  # not accounting for scr refresh
                        answer2_5.frameNStop = frameN  # exact frame index
                        # add timestamp to datafile
                        thisExp.timestampOnFlip(win, 'answer2_5.stopped')
                        # update status
                        answer2_5.status = FINISHED
                        answer2_5.setAutoDraw(False)
                
                # *answer3_5* updates
                
                # if answer3_5 is starting this frame...
                if answer3_5.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
                    # keep track of start time/frame for later
                    answer3_5.frameNStart = frameN  # exact frame index
                    answer3_5.tStart = t  # local t and not account for scr refresh
                    answer3_5.tStartRefresh = tThisFlipGlobal  # on global time
                    win.timeOnFlip(answer3_5, 'tStartRefresh')  # time at next scr refresh
                    # add timestamp to datafile
                    thisExp.timestampOnFlip(win, 'answer3_5.started')
                    # update status
                    answer3_5.status = STARTED
                    answer3_5.setAutoDraw(True)
                
                # if answer3_5 is active this frame...
                if answer3_5.status == STARTED:
                    # update params
                    pass
                
                # if answer3_5 is stopping this frame...
                if answer3_5.status == STARTED:
                    # is it time to stop? (based on global clock, using actual start)
                    if tThisFlipGlobal > answer3_5.tStartRefresh + 120-frameTolerance:
                        # keep track of stop time/frame for later
                        answer3_5.tStop = t  # not accounting for scr refresh
                        answer3_5.frameNStop = frameN  # exact frame index
                        # add timestamp to datafile
                        thisExp.timestampOnFlip(win, 'answer3_5.stopped')
                        # update status
                        answer3_5.status = FINISHED
                        answer3_5.setAutoDraw(False)
                
                # *a1_5* updates
                
                # if a1_5 is starting this frame...
                if a1_5.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
                    # keep track of start time/frame for later
                    a1_5.frameNStart = frameN  # exact frame index
                    a1_5.tStart = t  # local t and not account for scr refresh
                    a1_5.tStartRefresh = tThisFlipGlobal  # on global time
                    win.timeOnFlip(a1_5, 'tStartRefresh')  # time at next scr refresh
                    # add timestamp to datafile
                    thisExp.timestampOnFlip(win, 'a1_5.started')
                    # update status
                    a1_5.status = STARTED
                    a1_5.setAutoDraw(True)
                
                # if a1_5 is active this frame...
                if a1_5.status == STARTED:
                    # update params
                    pass
                
                # if a1_5 is stopping this frame...
                if a1_5.status == STARTED:
                    # is it time to stop? (based on global clock, using actual start)
                    if tThisFlipGlobal > a1_5.tStartRefresh + 120-frameTolerance:
                        # keep track of stop time/frame for later
                        a1_5.tStop = t  # not accounting for scr refresh
                        a1_5.frameNStop = frameN  # exact frame index
                        # add timestamp to datafile
                        thisExp.timestampOnFlip(win, 'a1_5.stopped')
                        # update status
                        a1_5.status = FINISHED
                        a1_5.setAutoDraw(False)
                
                # *a2_5* updates
                
                # if a2_5 is starting this frame...
                if a2_5.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
                    # keep track of start time/frame for later
                    a2_5.frameNStart = frameN  # exact frame index
                    a2_5.tStart = t  # local t and not account for scr refresh
                    a2_5.tStartRefresh = tThisFlipGlobal  # on global time
                    win.timeOnFlip(a2_5, 'tStartRefresh')  # time at next scr refresh
                    # add timestamp to datafile
                    thisExp.timestampOnFlip(win, 'a2_5.started')
                    # update status
                    a2_5.status = STARTED
                    a2_5.setAutoDraw(True)
                
                # if a2_5 is active this frame...
                if a2_5.status == STARTED:
                    # update params
                    pass
                
                # if a2_5 is stopping this frame...
                if a2_5.status == STARTED:
                    # is it time to stop? (based on global clock, using actual start)
                    if tThisFlipGlobal > a2_5.tStartRefresh + 120-frameTolerance:
                        # keep track of stop time/frame for later
                        a2_5.tStop = t  # not accounting for scr refresh
                        a2_5.frameNStop = frameN  # exact frame index
                        # add timestamp to datafile
                        thisExp.timestampOnFlip(win, 'a2_5.stopped')
                        # update status
                        a2_5.status = FINISHED
                        a2_5.setAutoDraw(False)
                
                # *text_152* updates
                
                # if text_152 is starting this frame...
                if text_152.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
                    # keep track of start time/frame for later
                    text_152.frameNStart = frameN  # exact frame index
                    text_152.tStart = t  # local t and not account for scr refresh
                    text_152.tStartRefresh = tThisFlipGlobal  # on global time
                    win.timeOnFlip(text_152, 'tStartRefresh')  # time at next scr refresh
                    # add timestamp to datafile
                    thisExp.timestampOnFlip(win, 'text_152.started')
                    # update status
                    text_152.status = STARTED
                    text_152.setAutoDraw(True)
                
                # if text_152 is active this frame...
                if text_152.status == STARTED:
                    # update params
                    pass
                
                # if text_152 is stopping this frame...
                if text_152.status == STARTED:
                    # is it time to stop? (based on global clock, using actual start)
                    if tThisFlipGlobal > text_152.tStartRefresh + 120.0-frameTolerance:
                        # keep track of stop time/frame for later
                        text_152.tStop = t  # not accounting for scr refresh
                        text_152.frameNStop = frameN  # exact frame index
                        # add timestamp to datafile
                        thisExp.timestampOnFlip(win, 'text_152.stopped')
                        # update status
                        text_152.status = FINISHED
                        text_152.setAutoDraw(False)
                
                # check for quit (typically the Esc key)
                if defaultKeyboard.getKeys(keyList=["escape"]):
                    thisExp.status = FINISHED
                if thisExp.status == FINISHED or endExpNow:
                    endExperiment(thisExp, inputs=inputs, win=win)
                    return
                
                # check if all components have finished
                if not continueRoutine:  # a component has requested a forced-end of Routine
                    routineForceEnded = True
                    break
                continueRoutine = False  # will revert to True if at least one component still running
                for thisComponent in planningpathstraining2Components:
                    if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:
                        continueRoutine = True
                        break  # at least one component has not yet finished
                
                # refresh the screen
                if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen
                    win.flip()
            
            # --- Ending Routine "planningpathstraining2" ---
            for thisComponent in planningpathstraining2Components:
                if hasattr(thisComponent, "setAutoDraw"):
                    thisComponent.setAutoDraw(False)
            thisExp.addData('planningpathstraining2.stopped', globalClock.getTime())
            # check responses
            if answer_quiz1_5.keys in ['', [], None]:  # No response was made
                answer_quiz1_5.keys = None
                # was no response the correct answer?!
                if str(correct_answer2).lower() == 'none':
                   answer_quiz1_5.corr = 1;  # correct non-response
                else:
                   answer_quiz1_5.corr = 0;  # failed to respond (incorrectly)
            # store data for planning_during_training (TrialHandler)
            planning_during_training.addData('answer_quiz1_5.keys',answer_quiz1_5.keys)
            planning_during_training.addData('answer_quiz1_5.corr', answer_quiz1_5.corr)
            if answer_quiz1_5.keys != None:  # we had a response
                planning_during_training.addData('answer_quiz1_5.rt', answer_quiz1_5.rt)
                planning_during_training.addData('answer_quiz1_5.duration', answer_quiz1_5.duration)
            # using non-slip timing so subtract the expected duration of this Routine (unless ended on request)
            if routineForceEnded:
                routineTimer.reset()
            else:
                routineTimer.addTime(-120.000000)
            
            # --- Prepare to start Routine "correct_forget_paths" ---
            continueRoutine = True
            # update component parameters for each repeat
            thisExp.addData('correct_forget_paths.started', globalClock.getTime())
            next_trial_text_2.setText(msg)
            text_151.setText(quiz_planning_corr)
            # keep track of which components have finished
            correct_forget_pathsComponents = [next_trial_text_2, text_151]
            for thisComponent in correct_forget_pathsComponents:
                thisComponent.tStart = None
                thisComponent.tStop = None
                thisComponent.tStartRefresh = None
                thisComponent.tStopRefresh = None
                if hasattr(thisComponent, 'status'):
                    thisComponent.status = NOT_STARTED
            # reset timers
            t = 0
            _timeToFirstFrame = win.getFutureFlipTime(clock="now")
            frameN = -1
            
            # --- Run Routine "correct_forget_paths" ---
            routineForceEnded = not continueRoutine
            while continueRoutine and routineTimer.getTime() < 3.0:
                # get current time
                t = routineTimer.getTime()
                tThisFlip = win.getFutureFlipTime(clock=routineTimer)
                tThisFlipGlobal = win.getFutureFlipTime(clock=None)
                frameN = frameN + 1  # number of completed frames (so 0 is the first frame)
                # update/draw components on each frame
                
                # *next_trial_text_2* updates
                
                # if next_trial_text_2 is starting this frame...
                if next_trial_text_2.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
                    # keep track of start time/frame for later
                    next_trial_text_2.frameNStart = frameN  # exact frame index
                    next_trial_text_2.tStart = t  # local t and not account for scr refresh
                    next_trial_text_2.tStartRefresh = tThisFlipGlobal  # on global time
                    win.timeOnFlip(next_trial_text_2, 'tStartRefresh')  # time at next scr refresh
                    # add timestamp to datafile
                    thisExp.timestampOnFlip(win, 'next_trial_text_2.started')
                    # update status
                    next_trial_text_2.status = STARTED
                    next_trial_text_2.setAutoDraw(True)
                
                # if next_trial_text_2 is active this frame...
                if next_trial_text_2.status == STARTED:
                    # update params
                    pass
                
                # if next_trial_text_2 is stopping this frame...
                if next_trial_text_2.status == STARTED:
                    # is it time to stop? (based on global clock, using actual start)
                    if tThisFlipGlobal > next_trial_text_2.tStartRefresh + 3-frameTolerance:
                        # keep track of stop time/frame for later
                        next_trial_text_2.tStop = t  # not accounting for scr refresh
                        next_trial_text_2.frameNStop = frameN  # exact frame index
                        # add timestamp to datafile
                        thisExp.timestampOnFlip(win, 'next_trial_text_2.stopped')
                        # update status
                        next_trial_text_2.status = FINISHED
                        next_trial_text_2.setAutoDraw(False)
                
                # *text_151* updates
                
                # if text_151 is starting this frame...
                if text_151.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
                    # keep track of start time/frame for later
                    text_151.frameNStart = frameN  # exact frame index
                    text_151.tStart = t  # local t and not account for scr refresh
                    text_151.tStartRefresh = tThisFlipGlobal  # on global time
                    win.timeOnFlip(text_151, 'tStartRefresh')  # time at next scr refresh
                    # add timestamp to datafile
                    thisExp.timestampOnFlip(win, 'text_151.started')
                    # update status
                    text_151.status = STARTED
                    text_151.setAutoDraw(True)
                
                # if text_151 is active this frame...
                if text_151.status == STARTED:
                    # update params
                    pass
                
                # if text_151 is stopping this frame...
                if text_151.status == STARTED:
                    # is it time to stop? (based on global clock, using actual start)
                    if tThisFlipGlobal > text_151.tStartRefresh + 3.0-frameTolerance:
                        # keep track of stop time/frame for later
                        text_151.tStop = t  # not accounting for scr refresh
                        text_151.frameNStop = frameN  # exact frame index
                        # add timestamp to datafile
                        thisExp.timestampOnFlip(win, 'text_151.stopped')
                        # update status
                        text_151.status = FINISHED
                        text_151.setAutoDraw(False)
                
                # check for quit (typically the Esc key)
                if defaultKeyboard.getKeys(keyList=["escape"]):
                    thisExp.status = FINISHED
                if thisExp.status == FINISHED or endExpNow:
                    endExperiment(thisExp, inputs=inputs, win=win)
                    return
                
                # check if all components have finished
                if not continueRoutine:  # a component has requested a forced-end of Routine
                    routineForceEnded = True
                    break
                continueRoutine = False  # will revert to True if at least one component still running
                for thisComponent in correct_forget_pathsComponents:
                    if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:
                        continueRoutine = True
                        break  # at least one component has not yet finished
                
                # refresh the screen
                if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen
                    win.flip()
            
            # --- Ending Routine "correct_forget_paths" ---
            for thisComponent in correct_forget_pathsComponents:
                if hasattr(thisComponent, "setAutoDraw"):
                    thisComponent.setAutoDraw(False)
            thisExp.addData('correct_forget_paths.stopped', globalClock.getTime())
            # using non-slip timing so subtract the expected duration of this Routine (unless ended on request)
            if routineForceEnded:
                routineTimer.reset()
            else:
                routineTimer.addTime(-3.000000)
            thisExp.nextEntry()
            
            if thisSession is not None:
                # if running in a Session with a Liaison client, send data up to now
                thisSession.sendExperimentData()
        # completed 1.0 repeats of 'planning_during_training'
        
        
        # --- Prepare to start Routine "total_score_planning" ---
        continueRoutine = True
        # update component parameters for each repeat
        thisExp.addData('total_score_planning.started', globalClock.getTime())
        # Run 'Begin Routine' code from code_43
        total_planning_score_training=(quiz_planning_corr/8.0)*100
        next_trial_text_3.setText(total_planning_score_training)
        # keep track of which components have finished
        total_score_planningComponents = [next_trial_text_3, text_150]
        for thisComponent in total_score_planningComponents:
            thisComponent.tStart = None
            thisComponent.tStop = None
            thisComponent.tStartRefresh = None
            thisComponent.tStopRefresh = None
            if hasattr(thisComponent, 'status'):
                thisComponent.status = NOT_STARTED
        # reset timers
        t = 0
        _timeToFirstFrame = win.getFutureFlipTime(clock="now")
        frameN = -1
        
        # --- Run Routine "total_score_planning" ---
        routineForceEnded = not continueRoutine
        while continueRoutine and routineTimer.getTime() < 3.0:
            # get current time
            t = routineTimer.getTime()
            tThisFlip = win.getFutureFlipTime(clock=routineTimer)
            tThisFlipGlobal = win.getFutureFlipTime(clock=None)
            frameN = frameN + 1  # number of completed frames (so 0 is the first frame)
            # update/draw components on each frame
            
            # *next_trial_text_3* updates
            
            # if next_trial_text_3 is starting this frame...
            if next_trial_text_3.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
                # keep track of start time/frame for later
                next_trial_text_3.frameNStart = frameN  # exact frame index
                next_trial_text_3.tStart = t  # local t and not account for scr refresh
                next_trial_text_3.tStartRefresh = tThisFlipGlobal  # on global time
                win.timeOnFlip(next_trial_text_3, 'tStartRefresh')  # time at next scr refresh
                # add timestamp to datafile
                thisExp.timestampOnFlip(win, 'next_trial_text_3.started')
                # update status
                next_trial_text_3.status = STARTED
                next_trial_text_3.setAutoDraw(True)
            
            # if next_trial_text_3 is active this frame...
            if next_trial_text_3.status == STARTED:
                # update params
                pass
            
            # if next_trial_text_3 is stopping this frame...
            if next_trial_text_3.status == STARTED:
                # is it time to stop? (based on global clock, using actual start)
                if tThisFlipGlobal > next_trial_text_3.tStartRefresh + 3-frameTolerance:
                    # keep track of stop time/frame for later
                    next_trial_text_3.tStop = t  # not accounting for scr refresh
                    next_trial_text_3.frameNStop = frameN  # exact frame index
                    # add timestamp to datafile
                    thisExp.timestampOnFlip(win, 'next_trial_text_3.stopped')
                    # update status
                    next_trial_text_3.status = FINISHED
                    next_trial_text_3.setAutoDraw(False)
            
            # *text_150* updates
            
            # if text_150 is starting this frame...
            if text_150.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
                # keep track of start time/frame for later
                text_150.frameNStart = frameN  # exact frame index
                text_150.tStart = t  # local t and not account for scr refresh
                text_150.tStartRefresh = tThisFlipGlobal  # on global time
                win.timeOnFlip(text_150, 'tStartRefresh')  # time at next scr refresh
                # add timestamp to datafile
                thisExp.timestampOnFlip(win, 'text_150.started')
                # update status
                text_150.status = STARTED
                text_150.setAutoDraw(True)
            
            # if text_150 is active this frame...
            if text_150.status == STARTED:
                # update params
                pass
            
            # if text_150 is stopping this frame...
            if text_150.status == STARTED:
                # is it time to stop? (based on global clock, using actual start)
                if tThisFlipGlobal > text_150.tStartRefresh + 3.0-frameTolerance:
                    # keep track of stop time/frame for later
                    text_150.tStop = t  # not accounting for scr refresh
                    text_150.frameNStop = frameN  # exact frame index
                    # add timestamp to datafile
                    thisExp.timestampOnFlip(win, 'text_150.stopped')
                    # update status
                    text_150.status = FINISHED
                    text_150.setAutoDraw(False)
            
            # check for quit (typically the Esc key)
            if defaultKeyboard.getKeys(keyList=["escape"]):
                thisExp.status = FINISHED
            if thisExp.status == FINISHED or endExpNow:
                endExperiment(thisExp, inputs=inputs, win=win)
                return
            
            # check if all components have finished
            if not continueRoutine:  # a component has requested a forced-end of Routine
                routineForceEnded = True
                break
            continueRoutine = False  # will revert to True if at least one component still running
            for thisComponent in total_score_planningComponents:
                if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:
                    continueRoutine = True
                    break  # at least one component has not yet finished
            
            # refresh the screen
            if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen
                win.flip()
        
        # --- Ending Routine "total_score_planning" ---
        for thisComponent in total_score_planningComponents:
            if hasattr(thisComponent, "setAutoDraw"):
                thisComponent.setAutoDraw(False)
        thisExp.addData('total_score_planning.stopped', globalClock.getTime())
        # using non-slip timing so subtract the expected duration of this Routine (unless ended on request)
        if routineForceEnded:
            routineTimer.reset()
        else:
            routineTimer.addTime(-3.000000)
        thisExp.nextEntry()
        
        if thisSession is not None:
            # if running in a Session with a Liaison client, send data up to now
            thisSession.sendExperimentData()
    # completed 3.0 repeats of 'learning_phase'
    
    
    # --- Prepare to start Routine "break_routine" ---
    continueRoutine = True
    # update component parameters for each repeat
    thisExp.addData('break_routine.started', globalClock.getTime())
    # keep track of which components have finished
    break_routineComponents = [text_9]
    for thisComponent in break_routineComponents:
        thisComponent.tStart = None
        thisComponent.tStop = None
        thisComponent.tStartRefresh = None
        thisComponent.tStopRefresh = None
        if hasattr(thisComponent, 'status'):
            thisComponent.status = NOT_STARTED
    # reset timers
    t = 0
    _timeToFirstFrame = win.getFutureFlipTime(clock="now")
    frameN = -1
    
    # --- Run Routine "break_routine" ---
    routineForceEnded = not continueRoutine
    while continueRoutine and routineTimer.getTime() < 5.0:
        # get current time
        t = routineTimer.getTime()
        tThisFlip = win.getFutureFlipTime(clock=routineTimer)
        tThisFlipGlobal = win.getFutureFlipTime(clock=None)
        frameN = frameN + 1  # number of completed frames (so 0 is the first frame)
        # update/draw components on each frame
        
        # *text_9* updates
        
        # if text_9 is starting this frame...
        if text_9.status == NOT_STARTED and tThisFlip >= 0-frameTolerance:
            # keep track of start time/frame for later
            text_9.frameNStart = frameN  # exact frame index
            text_9.tStart = t  # local t and not account for scr refresh
            text_9.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(text_9, 'tStartRefresh')  # time at next scr refresh
            # add timestamp to datafile
            thisExp.timestampOnFlip(win, 'text_9.started')
            # update status
            text_9.status = STARTED
            text_9.setAutoDraw(True)
        
        # if text_9 is active this frame...
        if text_9.status == STARTED:
            # update params
            pass
        
        # if text_9 is stopping this frame...
        if text_9.status == STARTED:
            # is it time to stop? (based on global clock, using actual start)
            if tThisFlipGlobal > text_9.tStartRefresh + 5-frameTolerance:
                # keep track of stop time/frame for later
                text_9.tStop = t  # not accounting for scr refresh
                text_9.frameNStop = frameN  # exact frame index
                # add timestamp to datafile
                thisExp.timestampOnFlip(win, 'text_9.stopped')
                # update status
                text_9.status = FINISHED
                text_9.setAutoDraw(False)
        
        # check for quit (typically the Esc key)
        if defaultKeyboard.getKeys(keyList=["escape"]):
            thisExp.status = FINISHED
        if thisExp.status == FINISHED or endExpNow:
            endExperiment(thisExp, inputs=inputs, win=win)
            return
        
        # check if all components have finished
        if not continueRoutine:  # a component has requested a forced-end of Routine
            routineForceEnded = True
            break
        continueRoutine = False  # will revert to True if at least one component still running
        for thisComponent in break_routineComponents:
            if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:
                continueRoutine = True
                break  # at least one component has not yet finished
        
        # refresh the screen
        if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen
            win.flip()
    
    # --- Ending Routine "break_routine" ---
    for thisComponent in break_routineComponents:
        if hasattr(thisComponent, "setAutoDraw"):
            thisComponent.setAutoDraw(False)
    thisExp.addData('break_routine.stopped', globalClock.getTime())
    # using non-slip timing so subtract the expected duration of this Routine (unless ended on request)
    if routineForceEnded:
        routineTimer.reset()
    else:
        routineTimer.addTime(-5.000000)
    
    # set up handler to look after randomisation of conditions etc
    instructions_planning_get_right = data.TrialHandler(nReps=999.0, method='random', 
        extraInfo=expInfo, originPath=-1,
        trialList=[None],
        seed=None, name='instructions_planning_get_right')
    thisExp.addLoop(instructions_planning_get_right)  # add the loop to the experiment
    thisInstructions_planning_get_right = instructions_planning_get_right.trialList[0]  # so we can initialise stimuli with some values
    # abbreviate parameter names if possible (e.g. rgb = thisInstructions_planning_get_right.rgb)
    if thisInstructions_planning_get_right != None:
        for paramName in thisInstructions_planning_get_right:
            globals()[paramName] = thisInstructions_planning_get_right[paramName]
    
    for thisInstructions_planning_get_right in instructions_planning_get_right:
        currentLoop = instructions_planning_get_right
        thisExp.timestampOnFlip(win, 'thisRow.t')
        # pause experiment here if requested
        if thisExp.status == PAUSED:
            pauseExperiment(
                thisExp=thisExp, 
                inputs=inputs, 
                win=win, 
                timers=[routineTimer], 
                playbackComponents=[]
        )
        # abbreviate parameter names if possible (e.g. rgb = thisInstructions_planning_get_right.rgb)
        if thisInstructions_planning_get_right != None:
            for paramName in thisInstructions_planning_get_right:
                globals()[paramName] = thisInstructions_planning_get_right[paramName]
        
        # --- Prepare to start Routine "instructions_reward" ---
        continueRoutine = True
        # update component parameters for each repeat
        thisExp.addData('instructions_reward.started', globalClock.getTime())
        key_resp_11.keys = []
        key_resp_11.rt = []
        _key_resp_11_allKeys = []
        # keep track of which components have finished
        instructions_rewardComponents = [instructions_rewardstage, key_resp_11, text_46]
        for thisComponent in instructions_rewardComponents:
            thisComponent.tStart = None
            thisComponent.tStop = None
            thisComponent.tStartRefresh = None
            thisComponent.tStopRefresh = None
            if hasattr(thisComponent, 'status'):
                thisComponent.status = NOT_STARTED
        # reset timers
        t = 0
        _timeToFirstFrame = win.getFutureFlipTime(clock="now")
        frameN = -1
        
        # --- Run Routine "instructions_reward" ---
        routineForceEnded = not continueRoutine
        while continueRoutine:
            # get current time
            t = routineTimer.getTime()
            tThisFlip = win.getFutureFlipTime(clock=routineTimer)
            tThisFlipGlobal = win.getFutureFlipTime(clock=None)
            frameN = frameN + 1  # number of completed frames (so 0 is the first frame)
            # update/draw components on each frame
            
            # *instructions_rewardstage* updates
            
            # if instructions_rewardstage is starting this frame...
            if instructions_rewardstage.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
                # keep track of start time/frame for later
                instructions_rewardstage.frameNStart = frameN  # exact frame index
                instructions_rewardstage.tStart = t  # local t and not account for scr refresh
                instructions_rewardstage.tStartRefresh = tThisFlipGlobal  # on global time
                win.timeOnFlip(instructions_rewardstage, 'tStartRefresh')  # time at next scr refresh
                # add timestamp to datafile
                thisExp.timestampOnFlip(win, 'instructions_rewardstage.started')
                # update status
                instructions_rewardstage.status = STARTED
                instructions_rewardstage.setAutoDraw(True)
            
            # if instructions_rewardstage is active this frame...
            if instructions_rewardstage.status == STARTED:
                # update params
                pass
            
            # *key_resp_11* updates
            waitOnFlip = False
            
            # if key_resp_11 is starting this frame...
            if key_resp_11.status == NOT_STARTED and tThisFlip >= 10.0-frameTolerance:
                # keep track of start time/frame for later
                key_resp_11.frameNStart = frameN  # exact frame index
                key_resp_11.tStart = t  # local t and not account for scr refresh
                key_resp_11.tStartRefresh = tThisFlipGlobal  # on global time
                win.timeOnFlip(key_resp_11, 'tStartRefresh')  # time at next scr refresh
                # add timestamp to datafile
                thisExp.timestampOnFlip(win, 'key_resp_11.started')
                # update status
                key_resp_11.status = STARTED
                # keyboard checking is just starting
                waitOnFlip = True
                win.callOnFlip(key_resp_11.clock.reset)  # t=0 on next screen flip
                win.callOnFlip(key_resp_11.clearEvents, eventType='keyboard')  # clear events on next screen flip
            if key_resp_11.status == STARTED and not waitOnFlip:
                theseKeys = key_resp_11.getKeys(keyList=['space'], ignoreKeys=["escape"], waitRelease=False)
                _key_resp_11_allKeys.extend(theseKeys)
                if len(_key_resp_11_allKeys):
                    key_resp_11.keys = _key_resp_11_allKeys[-1].name  # just the last key pressed
                    key_resp_11.rt = _key_resp_11_allKeys[-1].rt
                    key_resp_11.duration = _key_resp_11_allKeys[-1].duration
                    # a response ends the routine
                    continueRoutine = False
            
            # *text_46* updates
            
            # if text_46 is starting this frame...
            if text_46.status == NOT_STARTED and tThisFlip >= 10.0-frameTolerance:
                # keep track of start time/frame for later
                text_46.frameNStart = frameN  # exact frame index
                text_46.tStart = t  # local t and not account for scr refresh
                text_46.tStartRefresh = tThisFlipGlobal  # on global time
                win.timeOnFlip(text_46, 'tStartRefresh')  # time at next scr refresh
                # add timestamp to datafile
                thisExp.timestampOnFlip(win, 'text_46.started')
                # update status
                text_46.status = STARTED
                text_46.setAutoDraw(True)
            
            # if text_46 is active this frame...
            if text_46.status == STARTED:
                # update params
                pass
            
            # check for quit (typically the Esc key)
            if defaultKeyboard.getKeys(keyList=["escape"]):
                thisExp.status = FINISHED
            if thisExp.status == FINISHED or endExpNow:
                endExperiment(thisExp, inputs=inputs, win=win)
                return
            
            # check if all components have finished
            if not continueRoutine:  # a component has requested a forced-end of Routine
                routineForceEnded = True
                break
            continueRoutine = False  # will revert to True if at least one component still running
            for thisComponent in instructions_rewardComponents:
                if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:
                    continueRoutine = True
                    break  # at least one component has not yet finished
            
            # refresh the screen
            if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen
                win.flip()
        
        # --- Ending Routine "instructions_reward" ---
        for thisComponent in instructions_rewardComponents:
            if hasattr(thisComponent, "setAutoDraw"):
                thisComponent.setAutoDraw(False)
        thisExp.addData('instructions_reward.stopped', globalClock.getTime())
        # the Routine "instructions_reward" was not non-slip safe, so reset the non-slip timer
        routineTimer.reset()
        
        # --- Prepare to start Routine "instructions_planning_2" ---
        continueRoutine = True
        # update component parameters for each repeat
        thisExp.addData('instructions_planning_2.started', globalClock.getTime())
        key_resp_9.keys = []
        key_resp_9.rt = []
        _key_resp_9_allKeys = []
        # keep track of which components have finished
        instructions_planning_2Components = [text_50, key_resp_9]
        for thisComponent in instructions_planning_2Components:
            thisComponent.tStart = None
            thisComponent.tStop = None
            thisComponent.tStartRefresh = None
            thisComponent.tStopRefresh = None
            if hasattr(thisComponent, 'status'):
                thisComponent.status = NOT_STARTED
        # reset timers
        t = 0
        _timeToFirstFrame = win.getFutureFlipTime(clock="now")
        frameN = -1
        
        # --- Run Routine "instructions_planning_2" ---
        routineForceEnded = not continueRoutine
        while continueRoutine:
            # get current time
            t = routineTimer.getTime()
            tThisFlip = win.getFutureFlipTime(clock=routineTimer)
            tThisFlipGlobal = win.getFutureFlipTime(clock=None)
            frameN = frameN + 1  # number of completed frames (so 0 is the first frame)
            # update/draw components on each frame
            
            # *text_50* updates
            
            # if text_50 is starting this frame...
            if text_50.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
                # keep track of start time/frame for later
                text_50.frameNStart = frameN  # exact frame index
                text_50.tStart = t  # local t and not account for scr refresh
                text_50.tStartRefresh = tThisFlipGlobal  # on global time
                win.timeOnFlip(text_50, 'tStartRefresh')  # time at next scr refresh
                # add timestamp to datafile
                thisExp.timestampOnFlip(win, 'text_50.started')
                # update status
                text_50.status = STARTED
                text_50.setAutoDraw(True)
            
            # if text_50 is active this frame...
            if text_50.status == STARTED:
                # update params
                pass
            
            # *key_resp_9* updates
            waitOnFlip = False
            
            # if key_resp_9 is starting this frame...
            if key_resp_9.status == NOT_STARTED and tThisFlip >= 0-frameTolerance:
                # keep track of start time/frame for later
                key_resp_9.frameNStart = frameN  # exact frame index
                key_resp_9.tStart = t  # local t and not account for scr refresh
                key_resp_9.tStartRefresh = tThisFlipGlobal  # on global time
                win.timeOnFlip(key_resp_9, 'tStartRefresh')  # time at next scr refresh
                # add timestamp to datafile
                thisExp.timestampOnFlip(win, 'key_resp_9.started')
                # update status
                key_resp_9.status = STARTED
                # keyboard checking is just starting
                waitOnFlip = True
                win.callOnFlip(key_resp_9.clock.reset)  # t=0 on next screen flip
                win.callOnFlip(key_resp_9.clearEvents, eventType='keyboard')  # clear events on next screen flip
            if key_resp_9.status == STARTED and not waitOnFlip:
                theseKeys = key_resp_9.getKeys(keyList=['space'], ignoreKeys=["escape"], waitRelease=False)
                _key_resp_9_allKeys.extend(theseKeys)
                if len(_key_resp_9_allKeys):
                    key_resp_9.keys = _key_resp_9_allKeys[-1].name  # just the last key pressed
                    key_resp_9.rt = _key_resp_9_allKeys[-1].rt
                    key_resp_9.duration = _key_resp_9_allKeys[-1].duration
                    # a response ends the routine
                    continueRoutine = False
            
            # check for quit (typically the Esc key)
            if defaultKeyboard.getKeys(keyList=["escape"]):
                thisExp.status = FINISHED
            if thisExp.status == FINISHED or endExpNow:
                endExperiment(thisExp, inputs=inputs, win=win)
                return
            
            # check if all components have finished
            if not continueRoutine:  # a component has requested a forced-end of Routine
                routineForceEnded = True
                break
            continueRoutine = False  # will revert to True if at least one component still running
            for thisComponent in instructions_planning_2Components:
                if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:
                    continueRoutine = True
                    break  # at least one component has not yet finished
            
            # refresh the screen
            if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen
                win.flip()
        
        # --- Ending Routine "instructions_planning_2" ---
        for thisComponent in instructions_planning_2Components:
            if hasattr(thisComponent, "setAutoDraw"):
                thisComponent.setAutoDraw(False)
        thisExp.addData('instructions_planning_2.stopped', globalClock.getTime())
        # the Routine "instructions_planning_2" was not non-slip safe, so reset the non-slip timer
        routineTimer.reset()
        
        # --- Prepare to start Routine "instructions_example_trial" ---
        continueRoutine = True
        # update component parameters for each repeat
        thisExp.addData('instructions_example_trial.started', globalClock.getTime())
        # Run 'Begin Routine' code from code_13
        al1=400
        al2=50
        
        plan2_response_2.keys = []
        plan2_response_2.rt = []
        _plan2_response_2_allKeys = []
        # keep track of which components have finished
        instructions_example_trialComponents = [text_13, R1_5, R2_5, rew1_5, rew2_5, text_21, plan2_response_2, current_image_decision2_2]
        for thisComponent in instructions_example_trialComponents:
            thisComponent.tStart = None
            thisComponent.tStop = None
            thisComponent.tStartRefresh = None
            thisComponent.tStopRefresh = None
            if hasattr(thisComponent, 'status'):
                thisComponent.status = NOT_STARTED
        # reset timers
        t = 0
        _timeToFirstFrame = win.getFutureFlipTime(clock="now")
        frameN = -1
        
        # --- Run Routine "instructions_example_trial" ---
        routineForceEnded = not continueRoutine
        while continueRoutine and routineTimer.getTime() < 30.0:
            # get current time
            t = routineTimer.getTime()
            tThisFlip = win.getFutureFlipTime(clock=routineTimer)
            tThisFlipGlobal = win.getFutureFlipTime(clock=None)
            frameN = frameN + 1  # number of completed frames (so 0 is the first frame)
            # update/draw components on each frame
            
            # *text_13* updates
            
            # if text_13 is starting this frame...
            if text_13.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
                # keep track of start time/frame for later
                text_13.frameNStart = frameN  # exact frame index
                text_13.tStart = t  # local t and not account for scr refresh
                text_13.tStartRefresh = tThisFlipGlobal  # on global time
                win.timeOnFlip(text_13, 'tStartRefresh')  # time at next scr refresh
                # add timestamp to datafile
                thisExp.timestampOnFlip(win, 'text_13.started')
                # update status
                text_13.status = STARTED
                text_13.setAutoDraw(True)
            
            # if text_13 is active this frame...
            if text_13.status == STARTED:
                # update params
                pass
            
            # if text_13 is stopping this frame...
            if text_13.status == STARTED:
                # is it time to stop? (based on global clock, using actual start)
                if tThisFlipGlobal > text_13.tStartRefresh + 30.0-frameTolerance:
                    # keep track of stop time/frame for later
                    text_13.tStop = t  # not accounting for scr refresh
                    text_13.frameNStop = frameN  # exact frame index
                    # add timestamp to datafile
                    thisExp.timestampOnFlip(win, 'text_13.stopped')
                    # update status
                    text_13.status = FINISHED
                    text_13.setAutoDraw(False)
            
            # *R1_5* updates
            
            # if R1_5 is starting this frame...
            if R1_5.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
                # keep track of start time/frame for later
                R1_5.frameNStart = frameN  # exact frame index
                R1_5.tStart = t  # local t and not account for scr refresh
                R1_5.tStartRefresh = tThisFlipGlobal  # on global time
                win.timeOnFlip(R1_5, 'tStartRefresh')  # time at next scr refresh
                # add timestamp to datafile
                thisExp.timestampOnFlip(win, 'R1_5.started')
                # update status
                R1_5.status = STARTED
                R1_5.setAutoDraw(True)
            
            # if R1_5 is active this frame...
            if R1_5.status == STARTED:
                # update params
                pass
            
            # if R1_5 is stopping this frame...
            if R1_5.status == STARTED:
                # is it time to stop? (based on global clock, using actual start)
                if tThisFlipGlobal > R1_5.tStartRefresh + 30.0-frameTolerance:
                    # keep track of stop time/frame for later
                    R1_5.tStop = t  # not accounting for scr refresh
                    R1_5.frameNStop = frameN  # exact frame index
                    # add timestamp to datafile
                    thisExp.timestampOnFlip(win, 'R1_5.stopped')
                    # update status
                    R1_5.status = FINISHED
                    R1_5.setAutoDraw(False)
            
            # *R2_5* updates
            
            # if R2_5 is starting this frame...
            if R2_5.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
                # keep track of start time/frame for later
                R2_5.frameNStart = frameN  # exact frame index
                R2_5.tStart = t  # local t and not account for scr refresh
                R2_5.tStartRefresh = tThisFlipGlobal  # on global time
                win.timeOnFlip(R2_5, 'tStartRefresh')  # time at next scr refresh
                # add timestamp to datafile
                thisExp.timestampOnFlip(win, 'R2_5.started')
                # update status
                R2_5.status = STARTED
                R2_5.setAutoDraw(True)
            
            # if R2_5 is active this frame...
            if R2_5.status == STARTED:
                # update params
                pass
            
            # if R2_5 is stopping this frame...
            if R2_5.status == STARTED:
                # is it time to stop? (based on global clock, using actual start)
                if tThisFlipGlobal > R2_5.tStartRefresh + 30.0-frameTolerance:
                    # keep track of stop time/frame for later
                    R2_5.tStop = t  # not accounting for scr refresh
                    R2_5.frameNStop = frameN  # exact frame index
                    # add timestamp to datafile
                    thisExp.timestampOnFlip(win, 'R2_5.stopped')
                    # update status
                    R2_5.status = FINISHED
                    R2_5.setAutoDraw(False)
            
            # *rew1_5* updates
            
            # if rew1_5 is starting this frame...
            if rew1_5.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
                # keep track of start time/frame for later
                rew1_5.frameNStart = frameN  # exact frame index
                rew1_5.tStart = t  # local t and not account for scr refresh
                rew1_5.tStartRefresh = tThisFlipGlobal  # on global time
                win.timeOnFlip(rew1_5, 'tStartRefresh')  # time at next scr refresh
                # add timestamp to datafile
                thisExp.timestampOnFlip(win, 'rew1_5.started')
                # update status
                rew1_5.status = STARTED
                rew1_5.setAutoDraw(True)
            
            # if rew1_5 is active this frame...
            if rew1_5.status == STARTED:
                # update params
                rew1_5.setText(al1, log=False)
            
            # if rew1_5 is stopping this frame...
            if rew1_5.status == STARTED:
                # is it time to stop? (based on global clock, using actual start)
                if tThisFlipGlobal > rew1_5.tStartRefresh + 30.0-frameTolerance:
                    # keep track of stop time/frame for later
                    rew1_5.tStop = t  # not accounting for scr refresh
                    rew1_5.frameNStop = frameN  # exact frame index
                    # add timestamp to datafile
                    thisExp.timestampOnFlip(win, 'rew1_5.stopped')
                    # update status
                    rew1_5.status = FINISHED
                    rew1_5.setAutoDraw(False)
            
            # *rew2_5* updates
            
            # if rew2_5 is starting this frame...
            if rew2_5.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
                # keep track of start time/frame for later
                rew2_5.frameNStart = frameN  # exact frame index
                rew2_5.tStart = t  # local t and not account for scr refresh
                rew2_5.tStartRefresh = tThisFlipGlobal  # on global time
                win.timeOnFlip(rew2_5, 'tStartRefresh')  # time at next scr refresh
                # add timestamp to datafile
                thisExp.timestampOnFlip(win, 'rew2_5.started')
                # update status
                rew2_5.status = STARTED
                rew2_5.setAutoDraw(True)
            
            # if rew2_5 is active this frame...
            if rew2_5.status == STARTED:
                # update params
                rew2_5.setText('SPACE: Win 100\n', log=False)
            
            # if rew2_5 is stopping this frame...
            if rew2_5.status == STARTED:
                # is it time to stop? (based on global clock, using actual start)
                if tThisFlipGlobal > rew2_5.tStartRefresh + 30.0-frameTolerance:
                    # keep track of stop time/frame for later
                    rew2_5.tStop = t  # not accounting for scr refresh
                    rew2_5.frameNStop = frameN  # exact frame index
                    # add timestamp to datafile
                    thisExp.timestampOnFlip(win, 'rew2_5.stopped')
                    # update status
                    rew2_5.status = FINISHED
                    rew2_5.setAutoDraw(False)
            
            # *text_21* updates
            
            # if text_21 is starting this frame...
            if text_21.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
                # keep track of start time/frame for later
                text_21.frameNStart = frameN  # exact frame index
                text_21.tStart = t  # local t and not account for scr refresh
                text_21.tStartRefresh = tThisFlipGlobal  # on global time
                win.timeOnFlip(text_21, 'tStartRefresh')  # time at next scr refresh
                # add timestamp to datafile
                thisExp.timestampOnFlip(win, 'text_21.started')
                # update status
                text_21.status = STARTED
                text_21.setAutoDraw(True)
            
            # if text_21 is active this frame...
            if text_21.status == STARTED:
                # update params
                pass
            
            # if text_21 is stopping this frame...
            if text_21.status == STARTED:
                # is it time to stop? (based on global clock, using actual start)
                if tThisFlipGlobal > text_21.tStartRefresh + 30.0-frameTolerance:
                    # keep track of stop time/frame for later
                    text_21.tStop = t  # not accounting for scr refresh
                    text_21.frameNStop = frameN  # exact frame index
                    # add timestamp to datafile
                    thisExp.timestampOnFlip(win, 'text_21.stopped')
                    # update status
                    text_21.status = FINISHED
                    text_21.setAutoDraw(False)
            
            # *plan2_response_2* updates
            waitOnFlip = False
            
            # if plan2_response_2 is starting this frame...
            if plan2_response_2.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
                # keep track of start time/frame for later
                plan2_response_2.frameNStart = frameN  # exact frame index
                plan2_response_2.tStart = t  # local t and not account for scr refresh
                plan2_response_2.tStartRefresh = tThisFlipGlobal  # on global time
                win.timeOnFlip(plan2_response_2, 'tStartRefresh')  # time at next scr refresh
                # add timestamp to datafile
                thisExp.timestampOnFlip(win, 'plan2_response_2.started')
                # update status
                plan2_response_2.status = STARTED
                # keyboard checking is just starting
                waitOnFlip = True
                win.callOnFlip(plan2_response_2.clock.reset)  # t=0 on next screen flip
                win.callOnFlip(plan2_response_2.clearEvents, eventType='keyboard')  # clear events on next screen flip
            
            # if plan2_response_2 is stopping this frame...
            if plan2_response_2.status == STARTED:
                # is it time to stop? (based on global clock, using actual start)
                if tThisFlipGlobal > plan2_response_2.tStartRefresh + 30.0-frameTolerance:
                    # keep track of stop time/frame for later
                    plan2_response_2.tStop = t  # not accounting for scr refresh
                    plan2_response_2.frameNStop = frameN  # exact frame index
                    # add timestamp to datafile
                    thisExp.timestampOnFlip(win, 'plan2_response_2.stopped')
                    # update status
                    plan2_response_2.status = FINISHED
                    plan2_response_2.status = FINISHED
            if plan2_response_2.status == STARTED and not waitOnFlip:
                theseKeys = plan2_response_2.getKeys(keyList=['left', 'right','space'], ignoreKeys=["escape"], waitRelease=False)
                _plan2_response_2_allKeys.extend(theseKeys)
                if len(_plan2_response_2_allKeys):
                    plan2_response_2.keys = _plan2_response_2_allKeys[-1].name  # just the last key pressed
                    plan2_response_2.rt = _plan2_response_2_allKeys[-1].rt
                    plan2_response_2.duration = _plan2_response_2_allKeys[-1].duration
                    # a response ends the routine
                    continueRoutine = False
            
            # *current_image_decision2_2* updates
            
            # if current_image_decision2_2 is starting this frame...
            if current_image_decision2_2.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
                # keep track of start time/frame for later
                current_image_decision2_2.frameNStart = frameN  # exact frame index
                current_image_decision2_2.tStart = t  # local t and not account for scr refresh
                current_image_decision2_2.tStartRefresh = tThisFlipGlobal  # on global time
                win.timeOnFlip(current_image_decision2_2, 'tStartRefresh')  # time at next scr refresh
                # add timestamp to datafile
                thisExp.timestampOnFlip(win, 'current_image_decision2_2.started')
                # update status
                current_image_decision2_2.status = STARTED
                current_image_decision2_2.setAutoDraw(True)
            
            # if current_image_decision2_2 is active this frame...
            if current_image_decision2_2.status == STARTED:
                # update params
                pass
            
            # if current_image_decision2_2 is stopping this frame...
            if current_image_decision2_2.status == STARTED:
                # is it time to stop? (based on global clock, using actual start)
                if tThisFlipGlobal > current_image_decision2_2.tStartRefresh + 30.0-frameTolerance:
                    # keep track of stop time/frame for later
                    current_image_decision2_2.tStop = t  # not accounting for scr refresh
                    current_image_decision2_2.frameNStop = frameN  # exact frame index
                    # add timestamp to datafile
                    thisExp.timestampOnFlip(win, 'current_image_decision2_2.stopped')
                    # update status
                    current_image_decision2_2.status = FINISHED
                    current_image_decision2_2.setAutoDraw(False)
            
            # check for quit (typically the Esc key)
            if defaultKeyboard.getKeys(keyList=["escape"]):
                thisExp.status = FINISHED
            if thisExp.status == FINISHED or endExpNow:
                endExperiment(thisExp, inputs=inputs, win=win)
                return
            
            # check if all components have finished
            if not continueRoutine:  # a component has requested a forced-end of Routine
                routineForceEnded = True
                break
            continueRoutine = False  # will revert to True if at least one component still running
            for thisComponent in instructions_example_trialComponents:
                if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:
                    continueRoutine = True
                    break  # at least one component has not yet finished
            
            # refresh the screen
            if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen
                win.flip()
        
        # --- Ending Routine "instructions_example_trial" ---
        for thisComponent in instructions_example_trialComponents:
            if hasattr(thisComponent, "setAutoDraw"):
                thisComponent.setAutoDraw(False)
        thisExp.addData('instructions_example_trial.stopped', globalClock.getTime())
        # check responses
        if plan2_response_2.keys in ['', [], None]:  # No response was made
            plan2_response_2.keys = None
        instructions_planning_get_right.addData('plan2_response_2.keys',plan2_response_2.keys)
        if plan2_response_2.keys != None:  # we had a response
            instructions_planning_get_right.addData('plan2_response_2.rt', plan2_response_2.rt)
            instructions_planning_get_right.addData('plan2_response_2.duration', plan2_response_2.duration)
        # using non-slip timing so subtract the expected duration of this Routine (unless ended on request)
        if routineForceEnded:
            routineTimer.reset()
        else:
            routineTimer.addTime(-30.000000)
        
        # --- Prepare to start Routine "long_term_reward_instructions" ---
        continueRoutine = True
        # update component parameters for each repeat
        thisExp.addData('long_term_reward_instructions.started', globalClock.getTime())
        key_resp_12.keys = []
        key_resp_12.rt = []
        _key_resp_12_allKeys = []
        # keep track of which components have finished
        long_term_reward_instructionsComponents = [instructions_rewardstage_2, key_resp_12, text_45]
        for thisComponent in long_term_reward_instructionsComponents:
            thisComponent.tStart = None
            thisComponent.tStop = None
            thisComponent.tStartRefresh = None
            thisComponent.tStopRefresh = None
            if hasattr(thisComponent, 'status'):
                thisComponent.status = NOT_STARTED
        # reset timers
        t = 0
        _timeToFirstFrame = win.getFutureFlipTime(clock="now")
        frameN = -1
        
        # --- Run Routine "long_term_reward_instructions" ---
        routineForceEnded = not continueRoutine
        while continueRoutine:
            # get current time
            t = routineTimer.getTime()
            tThisFlip = win.getFutureFlipTime(clock=routineTimer)
            tThisFlipGlobal = win.getFutureFlipTime(clock=None)
            frameN = frameN + 1  # number of completed frames (so 0 is the first frame)
            # update/draw components on each frame
            
            # *instructions_rewardstage_2* updates
            
            # if instructions_rewardstage_2 is starting this frame...
            if instructions_rewardstage_2.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
                # keep track of start time/frame for later
                instructions_rewardstage_2.frameNStart = frameN  # exact frame index
                instructions_rewardstage_2.tStart = t  # local t and not account for scr refresh
                instructions_rewardstage_2.tStartRefresh = tThisFlipGlobal  # on global time
                win.timeOnFlip(instructions_rewardstage_2, 'tStartRefresh')  # time at next scr refresh
                # add timestamp to datafile
                thisExp.timestampOnFlip(win, 'instructions_rewardstage_2.started')
                # update status
                instructions_rewardstage_2.status = STARTED
                instructions_rewardstage_2.setAutoDraw(True)
            
            # if instructions_rewardstage_2 is active this frame...
            if instructions_rewardstage_2.status == STARTED:
                # update params
                pass
            
            # *key_resp_12* updates
            waitOnFlip = False
            
            # if key_resp_12 is starting this frame...
            if key_resp_12.status == NOT_STARTED and tThisFlip >= 10.0-frameTolerance:
                # keep track of start time/frame for later
                key_resp_12.frameNStart = frameN  # exact frame index
                key_resp_12.tStart = t  # local t and not account for scr refresh
                key_resp_12.tStartRefresh = tThisFlipGlobal  # on global time
                win.timeOnFlip(key_resp_12, 'tStartRefresh')  # time at next scr refresh
                # add timestamp to datafile
                thisExp.timestampOnFlip(win, 'key_resp_12.started')
                # update status
                key_resp_12.status = STARTED
                # keyboard checking is just starting
                waitOnFlip = True
                win.callOnFlip(key_resp_12.clock.reset)  # t=0 on next screen flip
                win.callOnFlip(key_resp_12.clearEvents, eventType='keyboard')  # clear events on next screen flip
            if key_resp_12.status == STARTED and not waitOnFlip:
                theseKeys = key_resp_12.getKeys(keyList=['space'], ignoreKeys=["escape"], waitRelease=False)
                _key_resp_12_allKeys.extend(theseKeys)
                if len(_key_resp_12_allKeys):
                    key_resp_12.keys = _key_resp_12_allKeys[-1].name  # just the last key pressed
                    key_resp_12.rt = _key_resp_12_allKeys[-1].rt
                    key_resp_12.duration = _key_resp_12_allKeys[-1].duration
                    # a response ends the routine
                    continueRoutine = False
            
            # *text_45* updates
            
            # if text_45 is starting this frame...
            if text_45.status == NOT_STARTED and tThisFlip >= 10.0-frameTolerance:
                # keep track of start time/frame for later
                text_45.frameNStart = frameN  # exact frame index
                text_45.tStart = t  # local t and not account for scr refresh
                text_45.tStartRefresh = tThisFlipGlobal  # on global time
                win.timeOnFlip(text_45, 'tStartRefresh')  # time at next scr refresh
                # add timestamp to datafile
                thisExp.timestampOnFlip(win, 'text_45.started')
                # update status
                text_45.status = STARTED
                text_45.setAutoDraw(True)
            
            # if text_45 is active this frame...
            if text_45.status == STARTED:
                # update params
                pass
            
            # check for quit (typically the Esc key)
            if defaultKeyboard.getKeys(keyList=["escape"]):
                thisExp.status = FINISHED
            if thisExp.status == FINISHED or endExpNow:
                endExperiment(thisExp, inputs=inputs, win=win)
                return
            
            # check if all components have finished
            if not continueRoutine:  # a component has requested a forced-end of Routine
                routineForceEnded = True
                break
            continueRoutine = False  # will revert to True if at least one component still running
            for thisComponent in long_term_reward_instructionsComponents:
                if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:
                    continueRoutine = True
                    break  # at least one component has not yet finished
            
            # refresh the screen
            if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen
                win.flip()
        
        # --- Ending Routine "long_term_reward_instructions" ---
        for thisComponent in long_term_reward_instructionsComponents:
            if hasattr(thisComponent, "setAutoDraw"):
                thisComponent.setAutoDraw(False)
        thisExp.addData('long_term_reward_instructions.stopped', globalClock.getTime())
        # the Routine "long_term_reward_instructions" was not non-slip safe, so reset the non-slip timer
        routineTimer.reset()
        
        # --- Prepare to start Routine "quiz_planning_1" ---
        continueRoutine = True
        # update component parameters for each repeat
        thisExp.addData('quiz_planning_1.started', globalClock.getTime())
        key_resp_21.keys = []
        key_resp_21.rt = []
        _key_resp_21_allKeys = []
        # keep track of which components have finished
        quiz_planning_1Components = [text_47, key_resp_21]
        for thisComponent in quiz_planning_1Components:
            thisComponent.tStart = None
            thisComponent.tStop = None
            thisComponent.tStartRefresh = None
            thisComponent.tStopRefresh = None
            if hasattr(thisComponent, 'status'):
                thisComponent.status = NOT_STARTED
        # reset timers
        t = 0
        _timeToFirstFrame = win.getFutureFlipTime(clock="now")
        frameN = -1
        
        # --- Run Routine "quiz_planning_1" ---
        routineForceEnded = not continueRoutine
        while continueRoutine:
            # get current time
            t = routineTimer.getTime()
            tThisFlip = win.getFutureFlipTime(clock=routineTimer)
            tThisFlipGlobal = win.getFutureFlipTime(clock=None)
            frameN = frameN + 1  # number of completed frames (so 0 is the first frame)
            # update/draw components on each frame
            
            # *text_47* updates
            
            # if text_47 is starting this frame...
            if text_47.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
                # keep track of start time/frame for later
                text_47.frameNStart = frameN  # exact frame index
                text_47.tStart = t  # local t and not account for scr refresh
                text_47.tStartRefresh = tThisFlipGlobal  # on global time
                win.timeOnFlip(text_47, 'tStartRefresh')  # time at next scr refresh
                # add timestamp to datafile
                thisExp.timestampOnFlip(win, 'text_47.started')
                # update status
                text_47.status = STARTED
                text_47.setAutoDraw(True)
            
            # if text_47 is active this frame...
            if text_47.status == STARTED:
                # update params
                pass
            
            # *key_resp_21* updates
            waitOnFlip = False
            
            # if key_resp_21 is starting this frame...
            if key_resp_21.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
                # keep track of start time/frame for later
                key_resp_21.frameNStart = frameN  # exact frame index
                key_resp_21.tStart = t  # local t and not account for scr refresh
                key_resp_21.tStartRefresh = tThisFlipGlobal  # on global time
                win.timeOnFlip(key_resp_21, 'tStartRefresh')  # time at next scr refresh
                # add timestamp to datafile
                thisExp.timestampOnFlip(win, 'key_resp_21.started')
                # update status
                key_resp_21.status = STARTED
                # keyboard checking is just starting
                waitOnFlip = True
                win.callOnFlip(key_resp_21.clock.reset)  # t=0 on next screen flip
                win.callOnFlip(key_resp_21.clearEvents, eventType='keyboard')  # clear events on next screen flip
            if key_resp_21.status == STARTED and not waitOnFlip:
                theseKeys = key_resp_21.getKeys(keyList=['a','b','c','d'], ignoreKeys=["escape"], waitRelease=False)
                _key_resp_21_allKeys.extend(theseKeys)
                if len(_key_resp_21_allKeys):
                    key_resp_21.keys = _key_resp_21_allKeys[-1].name  # just the last key pressed
                    key_resp_21.rt = _key_resp_21_allKeys[-1].rt
                    key_resp_21.duration = _key_resp_21_allKeys[-1].duration
                    # a response ends the routine
                    continueRoutine = False
            
            # check for quit (typically the Esc key)
            if defaultKeyboard.getKeys(keyList=["escape"]):
                thisExp.status = FINISHED
            if thisExp.status == FINISHED or endExpNow:
                endExperiment(thisExp, inputs=inputs, win=win)
                return
            
            # check if all components have finished
            if not continueRoutine:  # a component has requested a forced-end of Routine
                routineForceEnded = True
                break
            continueRoutine = False  # will revert to True if at least one component still running
            for thisComponent in quiz_planning_1Components:
                if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:
                    continueRoutine = True
                    break  # at least one component has not yet finished
            
            # refresh the screen
            if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen
                win.flip()
        
        # --- Ending Routine "quiz_planning_1" ---
        for thisComponent in quiz_planning_1Components:
            if hasattr(thisComponent, "setAutoDraw"):
                thisComponent.setAutoDraw(False)
        thisExp.addData('quiz_planning_1.stopped', globalClock.getTime())
        # Run 'End Routine' code from code_28
        correct=0
        if key_resp_21.keys=='c':
            correct+=1
        # check responses
        if key_resp_21.keys in ['', [], None]:  # No response was made
            key_resp_21.keys = None
        instructions_planning_get_right.addData('key_resp_21.keys',key_resp_21.keys)
        if key_resp_21.keys != None:  # we had a response
            instructions_planning_get_right.addData('key_resp_21.rt', key_resp_21.rt)
            instructions_planning_get_right.addData('key_resp_21.duration', key_resp_21.duration)
        # the Routine "quiz_planning_1" was not non-slip safe, so reset the non-slip timer
        routineTimer.reset()
        
        # --- Prepare to start Routine "quiz_planning_2" ---
        continueRoutine = True
        # update component parameters for each repeat
        thisExp.addData('quiz_planning_2.started', globalClock.getTime())
        key_resp_22.keys = []
        key_resp_22.rt = []
        _key_resp_22_allKeys = []
        # keep track of which components have finished
        quiz_planning_2Components = [text_73, key_resp_22]
        for thisComponent in quiz_planning_2Components:
            thisComponent.tStart = None
            thisComponent.tStop = None
            thisComponent.tStartRefresh = None
            thisComponent.tStopRefresh = None
            if hasattr(thisComponent, 'status'):
                thisComponent.status = NOT_STARTED
        # reset timers
        t = 0
        _timeToFirstFrame = win.getFutureFlipTime(clock="now")
        frameN = -1
        
        # --- Run Routine "quiz_planning_2" ---
        routineForceEnded = not continueRoutine
        while continueRoutine:
            # get current time
            t = routineTimer.getTime()
            tThisFlip = win.getFutureFlipTime(clock=routineTimer)
            tThisFlipGlobal = win.getFutureFlipTime(clock=None)
            frameN = frameN + 1  # number of completed frames (so 0 is the first frame)
            # update/draw components on each frame
            
            # *text_73* updates
            
            # if text_73 is starting this frame...
            if text_73.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
                # keep track of start time/frame for later
                text_73.frameNStart = frameN  # exact frame index
                text_73.tStart = t  # local t and not account for scr refresh
                text_73.tStartRefresh = tThisFlipGlobal  # on global time
                win.timeOnFlip(text_73, 'tStartRefresh')  # time at next scr refresh
                # add timestamp to datafile
                thisExp.timestampOnFlip(win, 'text_73.started')
                # update status
                text_73.status = STARTED
                text_73.setAutoDraw(True)
            
            # if text_73 is active this frame...
            if text_73.status == STARTED:
                # update params
                pass
            
            # *key_resp_22* updates
            waitOnFlip = False
            
            # if key_resp_22 is starting this frame...
            if key_resp_22.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
                # keep track of start time/frame for later
                key_resp_22.frameNStart = frameN  # exact frame index
                key_resp_22.tStart = t  # local t and not account for scr refresh
                key_resp_22.tStartRefresh = tThisFlipGlobal  # on global time
                win.timeOnFlip(key_resp_22, 'tStartRefresh')  # time at next scr refresh
                # add timestamp to datafile
                thisExp.timestampOnFlip(win, 'key_resp_22.started')
                # update status
                key_resp_22.status = STARTED
                # keyboard checking is just starting
                waitOnFlip = True
                win.callOnFlip(key_resp_22.clock.reset)  # t=0 on next screen flip
                win.callOnFlip(key_resp_22.clearEvents, eventType='keyboard')  # clear events on next screen flip
            if key_resp_22.status == STARTED and not waitOnFlip:
                theseKeys = key_resp_22.getKeys(keyList=['a','b','c','d'], ignoreKeys=["escape"], waitRelease=False)
                _key_resp_22_allKeys.extend(theseKeys)
                if len(_key_resp_22_allKeys):
                    key_resp_22.keys = _key_resp_22_allKeys[-1].name  # just the last key pressed
                    key_resp_22.rt = _key_resp_22_allKeys[-1].rt
                    key_resp_22.duration = _key_resp_22_allKeys[-1].duration
                    # a response ends the routine
                    continueRoutine = False
            
            # check for quit (typically the Esc key)
            if defaultKeyboard.getKeys(keyList=["escape"]):
                thisExp.status = FINISHED
            if thisExp.status == FINISHED or endExpNow:
                endExperiment(thisExp, inputs=inputs, win=win)
                return
            
            # check if all components have finished
            if not continueRoutine:  # a component has requested a forced-end of Routine
                routineForceEnded = True
                break
            continueRoutine = False  # will revert to True if at least one component still running
            for thisComponent in quiz_planning_2Components:
                if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:
                    continueRoutine = True
                    break  # at least one component has not yet finished
            
            # refresh the screen
            if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen
                win.flip()
        
        # --- Ending Routine "quiz_planning_2" ---
        for thisComponent in quiz_planning_2Components:
            if hasattr(thisComponent, "setAutoDraw"):
                thisComponent.setAutoDraw(False)
        thisExp.addData('quiz_planning_2.stopped', globalClock.getTime())
        # Run 'End Routine' code from code_32
        if key_resp_22.keys=='b':
            correct+=1
        
        # check responses
        if key_resp_22.keys in ['', [], None]:  # No response was made
            key_resp_22.keys = None
        instructions_planning_get_right.addData('key_resp_22.keys',key_resp_22.keys)
        if key_resp_22.keys != None:  # we had a response
            instructions_planning_get_right.addData('key_resp_22.rt', key_resp_22.rt)
            instructions_planning_get_right.addData('key_resp_22.duration', key_resp_22.duration)
        # the Routine "quiz_planning_2" was not non-slip safe, so reset the non-slip timer
        routineTimer.reset()
        
        # --- Prepare to start Routine "quiz_planning_3" ---
        continueRoutine = True
        # update component parameters for each repeat
        thisExp.addData('quiz_planning_3.started', globalClock.getTime())
        key_resp_24.keys = []
        key_resp_24.rt = []
        _key_resp_24_allKeys = []
        # keep track of which components have finished
        quiz_planning_3Components = [text_74, key_resp_24]
        for thisComponent in quiz_planning_3Components:
            thisComponent.tStart = None
            thisComponent.tStop = None
            thisComponent.tStartRefresh = None
            thisComponent.tStopRefresh = None
            if hasattr(thisComponent, 'status'):
                thisComponent.status = NOT_STARTED
        # reset timers
        t = 0
        _timeToFirstFrame = win.getFutureFlipTime(clock="now")
        frameN = -1
        
        # --- Run Routine "quiz_planning_3" ---
        routineForceEnded = not continueRoutine
        while continueRoutine:
            # get current time
            t = routineTimer.getTime()
            tThisFlip = win.getFutureFlipTime(clock=routineTimer)
            tThisFlipGlobal = win.getFutureFlipTime(clock=None)
            frameN = frameN + 1  # number of completed frames (so 0 is the first frame)
            # update/draw components on each frame
            
            # *text_74* updates
            
            # if text_74 is starting this frame...
            if text_74.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
                # keep track of start time/frame for later
                text_74.frameNStart = frameN  # exact frame index
                text_74.tStart = t  # local t and not account for scr refresh
                text_74.tStartRefresh = tThisFlipGlobal  # on global time
                win.timeOnFlip(text_74, 'tStartRefresh')  # time at next scr refresh
                # add timestamp to datafile
                thisExp.timestampOnFlip(win, 'text_74.started')
                # update status
                text_74.status = STARTED
                text_74.setAutoDraw(True)
            
            # if text_74 is active this frame...
            if text_74.status == STARTED:
                # update params
                pass
            
            # *key_resp_24* updates
            waitOnFlip = False
            
            # if key_resp_24 is starting this frame...
            if key_resp_24.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
                # keep track of start time/frame for later
                key_resp_24.frameNStart = frameN  # exact frame index
                key_resp_24.tStart = t  # local t and not account for scr refresh
                key_resp_24.tStartRefresh = tThisFlipGlobal  # on global time
                win.timeOnFlip(key_resp_24, 'tStartRefresh')  # time at next scr refresh
                # add timestamp to datafile
                thisExp.timestampOnFlip(win, 'key_resp_24.started')
                # update status
                key_resp_24.status = STARTED
                # keyboard checking is just starting
                waitOnFlip = True
                win.callOnFlip(key_resp_24.clock.reset)  # t=0 on next screen flip
                win.callOnFlip(key_resp_24.clearEvents, eventType='keyboard')  # clear events on next screen flip
            if key_resp_24.status == STARTED and not waitOnFlip:
                theseKeys = key_resp_24.getKeys(keyList=['a','b','c','d'], ignoreKeys=["escape"], waitRelease=False)
                _key_resp_24_allKeys.extend(theseKeys)
                if len(_key_resp_24_allKeys):
                    key_resp_24.keys = _key_resp_24_allKeys[-1].name  # just the last key pressed
                    key_resp_24.rt = _key_resp_24_allKeys[-1].rt
                    key_resp_24.duration = _key_resp_24_allKeys[-1].duration
                    # a response ends the routine
                    continueRoutine = False
            
            # check for quit (typically the Esc key)
            if defaultKeyboard.getKeys(keyList=["escape"]):
                thisExp.status = FINISHED
            if thisExp.status == FINISHED or endExpNow:
                endExperiment(thisExp, inputs=inputs, win=win)
                return
            
            # check if all components have finished
            if not continueRoutine:  # a component has requested a forced-end of Routine
                routineForceEnded = True
                break
            continueRoutine = False  # will revert to True if at least one component still running
            for thisComponent in quiz_planning_3Components:
                if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:
                    continueRoutine = True
                    break  # at least one component has not yet finished
            
            # refresh the screen
            if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen
                win.flip()
        
        # --- Ending Routine "quiz_planning_3" ---
        for thisComponent in quiz_planning_3Components:
            if hasattr(thisComponent, "setAutoDraw"):
                thisComponent.setAutoDraw(False)
        thisExp.addData('quiz_planning_3.stopped', globalClock.getTime())
        # Run 'End Routine' code from code_36
        if key_resp_24.keys=='b':
            correct+=1
        
        if correct==3:
            instructions_planning_get_right.finished = True
            msg='Correct! You can now move on'
        else:
            msg='Incorrect! You need to repeat the instructions.'
        # check responses
        if key_resp_24.keys in ['', [], None]:  # No response was made
            key_resp_24.keys = None
        instructions_planning_get_right.addData('key_resp_24.keys',key_resp_24.keys)
        if key_resp_24.keys != None:  # we had a response
            instructions_planning_get_right.addData('key_resp_24.rt', key_resp_24.rt)
            instructions_planning_get_right.addData('key_resp_24.duration', key_resp_24.duration)
        # the Routine "quiz_planning_3" was not non-slip safe, so reset the non-slip timer
        routineTimer.reset()
        
        # --- Prepare to start Routine "quiz_feedback" ---
        continueRoutine = True
        # update component parameters for each repeat
        thisExp.addData('quiz_feedback.started', globalClock.getTime())
        result_q_instr.setText(msg)
        # keep track of which components have finished
        quiz_feedbackComponents = [result_q_instr]
        for thisComponent in quiz_feedbackComponents:
            thisComponent.tStart = None
            thisComponent.tStop = None
            thisComponent.tStartRefresh = None
            thisComponent.tStopRefresh = None
            if hasattr(thisComponent, 'status'):
                thisComponent.status = NOT_STARTED
        # reset timers
        t = 0
        _timeToFirstFrame = win.getFutureFlipTime(clock="now")
        frameN = -1
        
        # --- Run Routine "quiz_feedback" ---
        routineForceEnded = not continueRoutine
        while continueRoutine and routineTimer.getTime() < 1.25:
            # get current time
            t = routineTimer.getTime()
            tThisFlip = win.getFutureFlipTime(clock=routineTimer)
            tThisFlipGlobal = win.getFutureFlipTime(clock=None)
            frameN = frameN + 1  # number of completed frames (so 0 is the first frame)
            # update/draw components on each frame
            
            # *result_q_instr* updates
            
            # if result_q_instr is starting this frame...
            if result_q_instr.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
                # keep track of start time/frame for later
                result_q_instr.frameNStart = frameN  # exact frame index
                result_q_instr.tStart = t  # local t and not account for scr refresh
                result_q_instr.tStartRefresh = tThisFlipGlobal  # on global time
                win.timeOnFlip(result_q_instr, 'tStartRefresh')  # time at next scr refresh
                # add timestamp to datafile
                thisExp.timestampOnFlip(win, 'result_q_instr.started')
                # update status
                result_q_instr.status = STARTED
                result_q_instr.setAutoDraw(True)
            
            # if result_q_instr is active this frame...
            if result_q_instr.status == STARTED:
                # update params
                pass
            
            # if result_q_instr is stopping this frame...
            if result_q_instr.status == STARTED:
                # is it time to stop? (based on global clock, using actual start)
                if tThisFlipGlobal > result_q_instr.tStartRefresh + 1.25-frameTolerance:
                    # keep track of stop time/frame for later
                    result_q_instr.tStop = t  # not accounting for scr refresh
                    result_q_instr.frameNStop = frameN  # exact frame index
                    # add timestamp to datafile
                    thisExp.timestampOnFlip(win, 'result_q_instr.stopped')
                    # update status
                    result_q_instr.status = FINISHED
                    result_q_instr.setAutoDraw(False)
            
            # check for quit (typically the Esc key)
            if defaultKeyboard.getKeys(keyList=["escape"]):
                thisExp.status = FINISHED
            if thisExp.status == FINISHED or endExpNow:
                endExperiment(thisExp, inputs=inputs, win=win)
                return
            
            # check if all components have finished
            if not continueRoutine:  # a component has requested a forced-end of Routine
                routineForceEnded = True
                break
            continueRoutine = False  # will revert to True if at least one component still running
            for thisComponent in quiz_feedbackComponents:
                if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:
                    continueRoutine = True
                    break  # at least one component has not yet finished
            
            # refresh the screen
            if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen
                win.flip()
        
        # --- Ending Routine "quiz_feedback" ---
        for thisComponent in quiz_feedbackComponents:
            if hasattr(thisComponent, "setAutoDraw"):
                thisComponent.setAutoDraw(False)
        thisExp.addData('quiz_feedback.stopped', globalClock.getTime())
        # using non-slip timing so subtract the expected duration of this Routine (unless ended on request)
        if routineForceEnded:
            routineTimer.reset()
        else:
            routineTimer.addTime(-1.250000)
        thisExp.nextEntry()
        
        if thisSession is not None:
            # if running in a Session with a Liaison client, send data up to now
            thisSession.sendExperimentData()
    # completed 999.0 repeats of 'instructions_planning_get_right'
    
    
    # --- Prepare to start Routine "see_planning_trials" ---
    continueRoutine = True
    # update component parameters for each repeat
    thisExp.addData('see_planning_trials.started', globalClock.getTime())
    key_resp_8.keys = []
    key_resp_8.rt = []
    _key_resp_8_allKeys = []
    # Run 'Begin Routine' code from code_12
    total_practice_planning=0
    w2=400
    # keep track of which components have finished
    see_planning_trialsComponents = [text_48, key_resp_8]
    for thisComponent in see_planning_trialsComponents:
        thisComponent.tStart = None
        thisComponent.tStop = None
        thisComponent.tStartRefresh = None
        thisComponent.tStopRefresh = None
        if hasattr(thisComponent, 'status'):
            thisComponent.status = NOT_STARTED
    # reset timers
    t = 0
    _timeToFirstFrame = win.getFutureFlipTime(clock="now")
    frameN = -1
    
    # --- Run Routine "see_planning_trials" ---
    routineForceEnded = not continueRoutine
    while continueRoutine:
        # get current time
        t = routineTimer.getTime()
        tThisFlip = win.getFutureFlipTime(clock=routineTimer)
        tThisFlipGlobal = win.getFutureFlipTime(clock=None)
        frameN = frameN + 1  # number of completed frames (so 0 is the first frame)
        # update/draw components on each frame
        
        # *text_48* updates
        
        # if text_48 is starting this frame...
        if text_48.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
            # keep track of start time/frame for later
            text_48.frameNStart = frameN  # exact frame index
            text_48.tStart = t  # local t and not account for scr refresh
            text_48.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(text_48, 'tStartRefresh')  # time at next scr refresh
            # add timestamp to datafile
            thisExp.timestampOnFlip(win, 'text_48.started')
            # update status
            text_48.status = STARTED
            text_48.setAutoDraw(True)
        
        # if text_48 is active this frame...
        if text_48.status == STARTED:
            # update params
            pass
        
        # *key_resp_8* updates
        waitOnFlip = False
        
        # if key_resp_8 is starting this frame...
        if key_resp_8.status == NOT_STARTED and tThisFlip >= 0-frameTolerance:
            # keep track of start time/frame for later
            key_resp_8.frameNStart = frameN  # exact frame index
            key_resp_8.tStart = t  # local t and not account for scr refresh
            key_resp_8.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(key_resp_8, 'tStartRefresh')  # time at next scr refresh
            # add timestamp to datafile
            thisExp.timestampOnFlip(win, 'key_resp_8.started')
            # update status
            key_resp_8.status = STARTED
            # keyboard checking is just starting
            waitOnFlip = True
            win.callOnFlip(key_resp_8.clock.reset)  # t=0 on next screen flip
            win.callOnFlip(key_resp_8.clearEvents, eventType='keyboard')  # clear events on next screen flip
        if key_resp_8.status == STARTED and not waitOnFlip:
            theseKeys = key_resp_8.getKeys(keyList=['space'], ignoreKeys=["escape"], waitRelease=False)
            _key_resp_8_allKeys.extend(theseKeys)
            if len(_key_resp_8_allKeys):
                key_resp_8.keys = _key_resp_8_allKeys[-1].name  # just the last key pressed
                key_resp_8.rt = _key_resp_8_allKeys[-1].rt
                key_resp_8.duration = _key_resp_8_allKeys[-1].duration
                # a response ends the routine
                continueRoutine = False
        
        # check for quit (typically the Esc key)
        if defaultKeyboard.getKeys(keyList=["escape"]):
            thisExp.status = FINISHED
        if thisExp.status == FINISHED or endExpNow:
            endExperiment(thisExp, inputs=inputs, win=win)
            return
        
        # check if all components have finished
        if not continueRoutine:  # a component has requested a forced-end of Routine
            routineForceEnded = True
            break
        continueRoutine = False  # will revert to True if at least one component still running
        for thisComponent in see_planning_trialsComponents:
            if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:
                continueRoutine = True
                break  # at least one component has not yet finished
        
        # refresh the screen
        if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen
            win.flip()
    
    # --- Ending Routine "see_planning_trials" ---
    for thisComponent in see_planning_trialsComponents:
        if hasattr(thisComponent, "setAutoDraw"):
            thisComponent.setAutoDraw(False)
    thisExp.addData('see_planning_trials.stopped', globalClock.getTime())
    # the Routine "see_planning_trials" was not non-slip safe, so reset the non-slip timer
    routineTimer.reset()
    
    # --- Prepare to start Routine "instructions_planning_new" ---
    continueRoutine = True
    # update component parameters for each repeat
    thisExp.addData('instructions_planning_new.started', globalClock.getTime())
    # Run 'Begin Routine' code from code_15
    al1=400
    w2=400
    
    planning_total="Total = 0"
    plan2_response_3.keys = []
    plan2_response_3.rt = []
    _plan2_response_3_allKeys = []
    text_114.setText(total_practice_planning)
    # keep track of which components have finished
    instructions_planning_newComponents = [text_32, R1_6, R2_6, rew1_6, rew2_6, plan2_response_3, text_34, text_41, text_114, text_128]
    for thisComponent in instructions_planning_newComponents:
        thisComponent.tStart = None
        thisComponent.tStop = None
        thisComponent.tStartRefresh = None
        thisComponent.tStopRefresh = None
        if hasattr(thisComponent, 'status'):
            thisComponent.status = NOT_STARTED
    # reset timers
    t = 0
    _timeToFirstFrame = win.getFutureFlipTime(clock="now")
    frameN = -1
    
    # --- Run Routine "instructions_planning_new" ---
    routineForceEnded = not continueRoutine
    while continueRoutine:
        # get current time
        t = routineTimer.getTime()
        tThisFlip = win.getFutureFlipTime(clock=routineTimer)
        tThisFlipGlobal = win.getFutureFlipTime(clock=None)
        frameN = frameN + 1  # number of completed frames (so 0 is the first frame)
        # update/draw components on each frame
        
        # *text_32* updates
        
        # if text_32 is starting this frame...
        if text_32.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
            # keep track of start time/frame for later
            text_32.frameNStart = frameN  # exact frame index
            text_32.tStart = t  # local t and not account for scr refresh
            text_32.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(text_32, 'tStartRefresh')  # time at next scr refresh
            # add timestamp to datafile
            thisExp.timestampOnFlip(win, 'text_32.started')
            # update status
            text_32.status = STARTED
            text_32.setAutoDraw(True)
        
        # if text_32 is active this frame...
        if text_32.status == STARTED:
            # update params
            pass
        
        # if text_32 is stopping this frame...
        if text_32.status == STARTED:
            # is it time to stop? (based on global clock, using actual start)
            if tThisFlipGlobal > text_32.tStartRefresh + 30.0-frameTolerance:
                # keep track of stop time/frame for later
                text_32.tStop = t  # not accounting for scr refresh
                text_32.frameNStop = frameN  # exact frame index
                # add timestamp to datafile
                thisExp.timestampOnFlip(win, 'text_32.stopped')
                # update status
                text_32.status = FINISHED
                text_32.setAutoDraw(False)
        
        # *R1_6* updates
        
        # if R1_6 is starting this frame...
        if R1_6.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
            # keep track of start time/frame for later
            R1_6.frameNStart = frameN  # exact frame index
            R1_6.tStart = t  # local t and not account for scr refresh
            R1_6.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(R1_6, 'tStartRefresh')  # time at next scr refresh
            # add timestamp to datafile
            thisExp.timestampOnFlip(win, 'R1_6.started')
            # update status
            R1_6.status = STARTED
            R1_6.setAutoDraw(True)
        
        # if R1_6 is active this frame...
        if R1_6.status == STARTED:
            # update params
            pass
        
        # if R1_6 is stopping this frame...
        if R1_6.status == STARTED:
            # is it time to stop? (based on global clock, using actual start)
            if tThisFlipGlobal > R1_6.tStartRefresh + 30.0-frameTolerance:
                # keep track of stop time/frame for later
                R1_6.tStop = t  # not accounting for scr refresh
                R1_6.frameNStop = frameN  # exact frame index
                # add timestamp to datafile
                thisExp.timestampOnFlip(win, 'R1_6.stopped')
                # update status
                R1_6.status = FINISHED
                R1_6.setAutoDraw(False)
        
        # *R2_6* updates
        
        # if R2_6 is starting this frame...
        if R2_6.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
            # keep track of start time/frame for later
            R2_6.frameNStart = frameN  # exact frame index
            R2_6.tStart = t  # local t and not account for scr refresh
            R2_6.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(R2_6, 'tStartRefresh')  # time at next scr refresh
            # add timestamp to datafile
            thisExp.timestampOnFlip(win, 'R2_6.started')
            # update status
            R2_6.status = STARTED
            R2_6.setAutoDraw(True)
        
        # if R2_6 is active this frame...
        if R2_6.status == STARTED:
            # update params
            pass
        
        # if R2_6 is stopping this frame...
        if R2_6.status == STARTED:
            # is it time to stop? (based on global clock, using actual start)
            if tThisFlipGlobal > R2_6.tStartRefresh + 30.0-frameTolerance:
                # keep track of stop time/frame for later
                R2_6.tStop = t  # not accounting for scr refresh
                R2_6.frameNStop = frameN  # exact frame index
                # add timestamp to datafile
                thisExp.timestampOnFlip(win, 'R2_6.stopped')
                # update status
                R2_6.status = FINISHED
                R2_6.setAutoDraw(False)
        
        # *rew1_6* updates
        
        # if rew1_6 is starting this frame...
        if rew1_6.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
            # keep track of start time/frame for later
            rew1_6.frameNStart = frameN  # exact frame index
            rew1_6.tStart = t  # local t and not account for scr refresh
            rew1_6.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(rew1_6, 'tStartRefresh')  # time at next scr refresh
            # add timestamp to datafile
            thisExp.timestampOnFlip(win, 'rew1_6.started')
            # update status
            rew1_6.status = STARTED
            rew1_6.setAutoDraw(True)
        
        # if rew1_6 is active this frame...
        if rew1_6.status == STARTED:
            # update params
            rew1_6.setText('SPACE for 100', log=False)
        
        # if rew1_6 is stopping this frame...
        if rew1_6.status == STARTED:
            # is it time to stop? (based on global clock, using actual start)
            if tThisFlipGlobal > rew1_6.tStartRefresh + 30.0-frameTolerance:
                # keep track of stop time/frame for later
                rew1_6.tStop = t  # not accounting for scr refresh
                rew1_6.frameNStop = frameN  # exact frame index
                # add timestamp to datafile
                thisExp.timestampOnFlip(win, 'rew1_6.stopped')
                # update status
                rew1_6.status = FINISHED
                rew1_6.setAutoDraw(False)
        
        # *rew2_6* updates
        
        # if rew2_6 is starting this frame...
        if rew2_6.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
            # keep track of start time/frame for later
            rew2_6.frameNStart = frameN  # exact frame index
            rew2_6.tStart = t  # local t and not account for scr refresh
            rew2_6.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(rew2_6, 'tStartRefresh')  # time at next scr refresh
            # add timestamp to datafile
            thisExp.timestampOnFlip(win, 'rew2_6.started')
            # update status
            rew2_6.status = STARTED
            rew2_6.setAutoDraw(True)
        
        # if rew2_6 is active this frame...
        if rew2_6.status == STARTED:
            # update params
            rew2_6.setText(w2, log=False)
        
        # if rew2_6 is stopping this frame...
        if rew2_6.status == STARTED:
            # is it time to stop? (based on global clock, using actual start)
            if tThisFlipGlobal > rew2_6.tStartRefresh + 30.0-frameTolerance:
                # keep track of stop time/frame for later
                rew2_6.tStop = t  # not accounting for scr refresh
                rew2_6.frameNStop = frameN  # exact frame index
                # add timestamp to datafile
                thisExp.timestampOnFlip(win, 'rew2_6.stopped')
                # update status
                rew2_6.status = FINISHED
                rew2_6.setAutoDraw(False)
        
        # *plan2_response_3* updates
        waitOnFlip = False
        
        # if plan2_response_3 is starting this frame...
        if plan2_response_3.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
            # keep track of start time/frame for later
            plan2_response_3.frameNStart = frameN  # exact frame index
            plan2_response_3.tStart = t  # local t and not account for scr refresh
            plan2_response_3.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(plan2_response_3, 'tStartRefresh')  # time at next scr refresh
            # add timestamp to datafile
            thisExp.timestampOnFlip(win, 'plan2_response_3.started')
            # update status
            plan2_response_3.status = STARTED
            # keyboard checking is just starting
            waitOnFlip = True
            win.callOnFlip(plan2_response_3.clock.reset)  # t=0 on next screen flip
            win.callOnFlip(plan2_response_3.clearEvents, eventType='keyboard')  # clear events on next screen flip
        
        # if plan2_response_3 is stopping this frame...
        if plan2_response_3.status == STARTED:
            # is it time to stop? (based on global clock, using actual start)
            if tThisFlipGlobal > plan2_response_3.tStartRefresh + 30.0-frameTolerance:
                # keep track of stop time/frame for later
                plan2_response_3.tStop = t  # not accounting for scr refresh
                plan2_response_3.frameNStop = frameN  # exact frame index
                # add timestamp to datafile
                thisExp.timestampOnFlip(win, 'plan2_response_3.stopped')
                # update status
                plan2_response_3.status = FINISHED
                plan2_response_3.status = FINISHED
        if plan2_response_3.status == STARTED and not waitOnFlip:
            theseKeys = plan2_response_3.getKeys(keyList=['space'], ignoreKeys=["escape"], waitRelease=False)
            _plan2_response_3_allKeys.extend(theseKeys)
            if len(_plan2_response_3_allKeys):
                plan2_response_3.keys = _plan2_response_3_allKeys[-1].name  # just the last key pressed
                plan2_response_3.rt = _plan2_response_3_allKeys[-1].rt
                plan2_response_3.duration = _plan2_response_3_allKeys[-1].duration
                # a response ends the routine
                continueRoutine = False
        
        # *text_34* updates
        
        # if text_34 is starting this frame...
        if text_34.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
            # keep track of start time/frame for later
            text_34.frameNStart = frameN  # exact frame index
            text_34.tStart = t  # local t and not account for scr refresh
            text_34.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(text_34, 'tStartRefresh')  # time at next scr refresh
            # add timestamp to datafile
            thisExp.timestampOnFlip(win, 'text_34.started')
            # update status
            text_34.status = STARTED
            text_34.setAutoDraw(True)
        
        # if text_34 is active this frame...
        if text_34.status == STARTED:
            # update params
            pass
        
        # if text_34 is stopping this frame...
        if text_34.status == STARTED:
            # is it time to stop? (based on global clock, using actual start)
            if tThisFlipGlobal > text_34.tStartRefresh + 30.0-frameTolerance:
                # keep track of stop time/frame for later
                text_34.tStop = t  # not accounting for scr refresh
                text_34.frameNStop = frameN  # exact frame index
                # add timestamp to datafile
                thisExp.timestampOnFlip(win, 'text_34.stopped')
                # update status
                text_34.status = FINISHED
                text_34.setAutoDraw(False)
        
        # *text_41* updates
        
        # if text_41 is starting this frame...
        if text_41.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
            # keep track of start time/frame for later
            text_41.frameNStart = frameN  # exact frame index
            text_41.tStart = t  # local t and not account for scr refresh
            text_41.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(text_41, 'tStartRefresh')  # time at next scr refresh
            # add timestamp to datafile
            thisExp.timestampOnFlip(win, 'text_41.started')
            # update status
            text_41.status = STARTED
            text_41.setAutoDraw(True)
        
        # if text_41 is active this frame...
        if text_41.status == STARTED:
            # update params
            pass
        
        # if text_41 is stopping this frame...
        if text_41.status == STARTED:
            # is it time to stop? (based on global clock, using actual start)
            if tThisFlipGlobal > text_41.tStartRefresh + 30.0-frameTolerance:
                # keep track of stop time/frame for later
                text_41.tStop = t  # not accounting for scr refresh
                text_41.frameNStop = frameN  # exact frame index
                # add timestamp to datafile
                thisExp.timestampOnFlip(win, 'text_41.stopped')
                # update status
                text_41.status = FINISHED
                text_41.setAutoDraw(False)
        
        # *text_114* updates
        
        # if text_114 is starting this frame...
        if text_114.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
            # keep track of start time/frame for later
            text_114.frameNStart = frameN  # exact frame index
            text_114.tStart = t  # local t and not account for scr refresh
            text_114.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(text_114, 'tStartRefresh')  # time at next scr refresh
            # add timestamp to datafile
            thisExp.timestampOnFlip(win, 'text_114.started')
            # update status
            text_114.status = STARTED
            text_114.setAutoDraw(True)
        
        # if text_114 is active this frame...
        if text_114.status == STARTED:
            # update params
            pass
        
        # *text_128* updates
        
        # if text_128 is starting this frame...
        if text_128.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
            # keep track of start time/frame for later
            text_128.frameNStart = frameN  # exact frame index
            text_128.tStart = t  # local t and not account for scr refresh
            text_128.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(text_128, 'tStartRefresh')  # time at next scr refresh
            # add timestamp to datafile
            thisExp.timestampOnFlip(win, 'text_128.started')
            # update status
            text_128.status = STARTED
            text_128.setAutoDraw(True)
        
        # if text_128 is active this frame...
        if text_128.status == STARTED:
            # update params
            pass
        
        # check for quit (typically the Esc key)
        if defaultKeyboard.getKeys(keyList=["escape"]):
            thisExp.status = FINISHED
        if thisExp.status == FINISHED or endExpNow:
            endExperiment(thisExp, inputs=inputs, win=win)
            return
        
        # check if all components have finished
        if not continueRoutine:  # a component has requested a forced-end of Routine
            routineForceEnded = True
            break
        continueRoutine = False  # will revert to True if at least one component still running
        for thisComponent in instructions_planning_newComponents:
            if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:
                continueRoutine = True
                break  # at least one component has not yet finished
        
        # refresh the screen
        if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen
            win.flip()
    
    # --- Ending Routine "instructions_planning_new" ---
    for thisComponent in instructions_planning_newComponents:
        if hasattr(thisComponent, "setAutoDraw"):
            thisComponent.setAutoDraw(False)
    thisExp.addData('instructions_planning_new.stopped', globalClock.getTime())
    # check responses
    if plan2_response_3.keys in ['', [], None]:  # No response was made
        plan2_response_3.keys = None
    thisExp.addData('plan2_response_3.keys',plan2_response_3.keys)
    if plan2_response_3.keys != None:  # we had a response
        thisExp.addData('plan2_response_3.rt', plan2_response_3.rt)
        thisExp.addData('plan2_response_3.duration', plan2_response_3.duration)
    thisExp.nextEntry()
    # the Routine "instructions_planning_new" was not non-slip safe, so reset the non-slip timer
    routineTimer.reset()
    
    # --- Prepare to start Routine "planning_2_instructions" ---
    continueRoutine = True
    # update component parameters for each repeat
    thisExp.addData('planning_2_instructions.started', globalClock.getTime())
    # Run 'Begin Routine' code from code_23
    total_practice_planning=total_practice_planning+100
    
    plan2_response_6.keys = []
    plan2_response_6.rt = []
    _plan2_response_6_allKeys = []
    text_115.setText(total_practice_planning)
    # keep track of which components have finished
    planning_2_instructionsComponents = [text_52, R1_9, R2_9, rew1_9, rew2_9, text_53, plan2_response_6, current_image_decision2_5, text_115, text_129]
    for thisComponent in planning_2_instructionsComponents:
        thisComponent.tStart = None
        thisComponent.tStop = None
        thisComponent.tStartRefresh = None
        thisComponent.tStopRefresh = None
        if hasattr(thisComponent, 'status'):
            thisComponent.status = NOT_STARTED
    # reset timers
    t = 0
    _timeToFirstFrame = win.getFutureFlipTime(clock="now")
    frameN = -1
    
    # --- Run Routine "planning_2_instructions" ---
    routineForceEnded = not continueRoutine
    while continueRoutine:
        # get current time
        t = routineTimer.getTime()
        tThisFlip = win.getFutureFlipTime(clock=routineTimer)
        tThisFlipGlobal = win.getFutureFlipTime(clock=None)
        frameN = frameN + 1  # number of completed frames (so 0 is the first frame)
        # update/draw components on each frame
        
        # *text_52* updates
        
        # if text_52 is starting this frame...
        if text_52.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
            # keep track of start time/frame for later
            text_52.frameNStart = frameN  # exact frame index
            text_52.tStart = t  # local t and not account for scr refresh
            text_52.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(text_52, 'tStartRefresh')  # time at next scr refresh
            # add timestamp to datafile
            thisExp.timestampOnFlip(win, 'text_52.started')
            # update status
            text_52.status = STARTED
            text_52.setAutoDraw(True)
        
        # if text_52 is active this frame...
        if text_52.status == STARTED:
            # update params
            pass
        
        # if text_52 is stopping this frame...
        if text_52.status == STARTED:
            # is it time to stop? (based on global clock, using actual start)
            if tThisFlipGlobal > text_52.tStartRefresh + 30.0-frameTolerance:
                # keep track of stop time/frame for later
                text_52.tStop = t  # not accounting for scr refresh
                text_52.frameNStop = frameN  # exact frame index
                # add timestamp to datafile
                thisExp.timestampOnFlip(win, 'text_52.stopped')
                # update status
                text_52.status = FINISHED
                text_52.setAutoDraw(False)
        
        # *R1_9* updates
        
        # if R1_9 is starting this frame...
        if R1_9.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
            # keep track of start time/frame for later
            R1_9.frameNStart = frameN  # exact frame index
            R1_9.tStart = t  # local t and not account for scr refresh
            R1_9.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(R1_9, 'tStartRefresh')  # time at next scr refresh
            # add timestamp to datafile
            thisExp.timestampOnFlip(win, 'R1_9.started')
            # update status
            R1_9.status = STARTED
            R1_9.setAutoDraw(True)
        
        # if R1_9 is active this frame...
        if R1_9.status == STARTED:
            # update params
            pass
        
        # if R1_9 is stopping this frame...
        if R1_9.status == STARTED:
            # is it time to stop? (based on global clock, using actual start)
            if tThisFlipGlobal > R1_9.tStartRefresh + 30.0-frameTolerance:
                # keep track of stop time/frame for later
                R1_9.tStop = t  # not accounting for scr refresh
                R1_9.frameNStop = frameN  # exact frame index
                # add timestamp to datafile
                thisExp.timestampOnFlip(win, 'R1_9.stopped')
                # update status
                R1_9.status = FINISHED
                R1_9.setAutoDraw(False)
        
        # *R2_9* updates
        
        # if R2_9 is starting this frame...
        if R2_9.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
            # keep track of start time/frame for later
            R2_9.frameNStart = frameN  # exact frame index
            R2_9.tStart = t  # local t and not account for scr refresh
            R2_9.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(R2_9, 'tStartRefresh')  # time at next scr refresh
            # add timestamp to datafile
            thisExp.timestampOnFlip(win, 'R2_9.started')
            # update status
            R2_9.status = STARTED
            R2_9.setAutoDraw(True)
        
        # if R2_9 is active this frame...
        if R2_9.status == STARTED:
            # update params
            pass
        
        # if R2_9 is stopping this frame...
        if R2_9.status == STARTED:
            # is it time to stop? (based on global clock, using actual start)
            if tThisFlipGlobal > R2_9.tStartRefresh + 30.0-frameTolerance:
                # keep track of stop time/frame for later
                R2_9.tStop = t  # not accounting for scr refresh
                R2_9.frameNStop = frameN  # exact frame index
                # add timestamp to datafile
                thisExp.timestampOnFlip(win, 'R2_9.stopped')
                # update status
                R2_9.status = FINISHED
                R2_9.setAutoDraw(False)
        
        # *rew1_9* updates
        
        # if rew1_9 is starting this frame...
        if rew1_9.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
            # keep track of start time/frame for later
            rew1_9.frameNStart = frameN  # exact frame index
            rew1_9.tStart = t  # local t and not account for scr refresh
            rew1_9.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(rew1_9, 'tStartRefresh')  # time at next scr refresh
            # add timestamp to datafile
            thisExp.timestampOnFlip(win, 'rew1_9.started')
            # update status
            rew1_9.status = STARTED
            rew1_9.setAutoDraw(True)
        
        # if rew1_9 is active this frame...
        if rew1_9.status == STARTED:
            # update params
            rew1_9.setText('SPACE for 100', log=False)
        
        # if rew1_9 is stopping this frame...
        if rew1_9.status == STARTED:
            # is it time to stop? (based on global clock, using actual start)
            if tThisFlipGlobal > rew1_9.tStartRefresh + 30.0-frameTolerance:
                # keep track of stop time/frame for later
                rew1_9.tStop = t  # not accounting for scr refresh
                rew1_9.frameNStop = frameN  # exact frame index
                # add timestamp to datafile
                thisExp.timestampOnFlip(win, 'rew1_9.stopped')
                # update status
                rew1_9.status = FINISHED
                rew1_9.setAutoDraw(False)
        
        # *rew2_9* updates
        
        # if rew2_9 is starting this frame...
        if rew2_9.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
            # keep track of start time/frame for later
            rew2_9.frameNStart = frameN  # exact frame index
            rew2_9.tStart = t  # local t and not account for scr refresh
            rew2_9.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(rew2_9, 'tStartRefresh')  # time at next scr refresh
            # add timestamp to datafile
            thisExp.timestampOnFlip(win, 'rew2_9.started')
            # update status
            rew2_9.status = STARTED
            rew2_9.setAutoDraw(True)
        
        # if rew2_9 is active this frame...
        if rew2_9.status == STARTED:
            # update params
            rew2_9.setText(w2, log=False)
        
        # if rew2_9 is stopping this frame...
        if rew2_9.status == STARTED:
            # is it time to stop? (based on global clock, using actual start)
            if tThisFlipGlobal > rew2_9.tStartRefresh + 30.0-frameTolerance:
                # keep track of stop time/frame for later
                rew2_9.tStop = t  # not accounting for scr refresh
                rew2_9.frameNStop = frameN  # exact frame index
                # add timestamp to datafile
                thisExp.timestampOnFlip(win, 'rew2_9.stopped')
                # update status
                rew2_9.status = FINISHED
                rew2_9.setAutoDraw(False)
        
        # *text_53* updates
        
        # if text_53 is starting this frame...
        if text_53.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
            # keep track of start time/frame for later
            text_53.frameNStart = frameN  # exact frame index
            text_53.tStart = t  # local t and not account for scr refresh
            text_53.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(text_53, 'tStartRefresh')  # time at next scr refresh
            # add timestamp to datafile
            thisExp.timestampOnFlip(win, 'text_53.started')
            # update status
            text_53.status = STARTED
            text_53.setAutoDraw(True)
        
        # if text_53 is active this frame...
        if text_53.status == STARTED:
            # update params
            pass
        
        # if text_53 is stopping this frame...
        if text_53.status == STARTED:
            # is it time to stop? (based on global clock, using actual start)
            if tThisFlipGlobal > text_53.tStartRefresh + 30.0-frameTolerance:
                # keep track of stop time/frame for later
                text_53.tStop = t  # not accounting for scr refresh
                text_53.frameNStop = frameN  # exact frame index
                # add timestamp to datafile
                thisExp.timestampOnFlip(win, 'text_53.stopped')
                # update status
                text_53.status = FINISHED
                text_53.setAutoDraw(False)
        
        # *plan2_response_6* updates
        waitOnFlip = False
        
        # if plan2_response_6 is starting this frame...
        if plan2_response_6.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
            # keep track of start time/frame for later
            plan2_response_6.frameNStart = frameN  # exact frame index
            plan2_response_6.tStart = t  # local t and not account for scr refresh
            plan2_response_6.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(plan2_response_6, 'tStartRefresh')  # time at next scr refresh
            # add timestamp to datafile
            thisExp.timestampOnFlip(win, 'plan2_response_6.started')
            # update status
            plan2_response_6.status = STARTED
            # keyboard checking is just starting
            waitOnFlip = True
            win.callOnFlip(plan2_response_6.clock.reset)  # t=0 on next screen flip
            win.callOnFlip(plan2_response_6.clearEvents, eventType='keyboard')  # clear events on next screen flip
        
        # if plan2_response_6 is stopping this frame...
        if plan2_response_6.status == STARTED:
            # is it time to stop? (based on global clock, using actual start)
            if tThisFlipGlobal > plan2_response_6.tStartRefresh + 30.0-frameTolerance:
                # keep track of stop time/frame for later
                plan2_response_6.tStop = t  # not accounting for scr refresh
                plan2_response_6.frameNStop = frameN  # exact frame index
                # add timestamp to datafile
                thisExp.timestampOnFlip(win, 'plan2_response_6.stopped')
                # update status
                plan2_response_6.status = FINISHED
                plan2_response_6.status = FINISHED
        if plan2_response_6.status == STARTED and not waitOnFlip:
            theseKeys = plan2_response_6.getKeys(keyList=['space'], ignoreKeys=["escape"], waitRelease=False)
            _plan2_response_6_allKeys.extend(theseKeys)
            if len(_plan2_response_6_allKeys):
                plan2_response_6.keys = _plan2_response_6_allKeys[-1].name  # just the last key pressed
                plan2_response_6.rt = _plan2_response_6_allKeys[-1].rt
                plan2_response_6.duration = _plan2_response_6_allKeys[-1].duration
                # a response ends the routine
                continueRoutine = False
        
        # *current_image_decision2_5* updates
        
        # if current_image_decision2_5 is starting this frame...
        if current_image_decision2_5.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
            # keep track of start time/frame for later
            current_image_decision2_5.frameNStart = frameN  # exact frame index
            current_image_decision2_5.tStart = t  # local t and not account for scr refresh
            current_image_decision2_5.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(current_image_decision2_5, 'tStartRefresh')  # time at next scr refresh
            # add timestamp to datafile
            thisExp.timestampOnFlip(win, 'current_image_decision2_5.started')
            # update status
            current_image_decision2_5.status = STARTED
            current_image_decision2_5.setAutoDraw(True)
        
        # if current_image_decision2_5 is active this frame...
        if current_image_decision2_5.status == STARTED:
            # update params
            pass
        
        # if current_image_decision2_5 is stopping this frame...
        if current_image_decision2_5.status == STARTED:
            # is it time to stop? (based on global clock, using actual start)
            if tThisFlipGlobal > current_image_decision2_5.tStartRefresh + 30.0-frameTolerance:
                # keep track of stop time/frame for later
                current_image_decision2_5.tStop = t  # not accounting for scr refresh
                current_image_decision2_5.frameNStop = frameN  # exact frame index
                # add timestamp to datafile
                thisExp.timestampOnFlip(win, 'current_image_decision2_5.stopped')
                # update status
                current_image_decision2_5.status = FINISHED
                current_image_decision2_5.setAutoDraw(False)
        
        # *text_115* updates
        
        # if text_115 is starting this frame...
        if text_115.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
            # keep track of start time/frame for later
            text_115.frameNStart = frameN  # exact frame index
            text_115.tStart = t  # local t and not account for scr refresh
            text_115.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(text_115, 'tStartRefresh')  # time at next scr refresh
            # add timestamp to datafile
            thisExp.timestampOnFlip(win, 'text_115.started')
            # update status
            text_115.status = STARTED
            text_115.setAutoDraw(True)
        
        # if text_115 is active this frame...
        if text_115.status == STARTED:
            # update params
            pass
        
        # *text_129* updates
        
        # if text_129 is starting this frame...
        if text_129.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
            # keep track of start time/frame for later
            text_129.frameNStart = frameN  # exact frame index
            text_129.tStart = t  # local t and not account for scr refresh
            text_129.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(text_129, 'tStartRefresh')  # time at next scr refresh
            # add timestamp to datafile
            thisExp.timestampOnFlip(win, 'text_129.started')
            # update status
            text_129.status = STARTED
            text_129.setAutoDraw(True)
        
        # if text_129 is active this frame...
        if text_129.status == STARTED:
            # update params
            pass
        
        # check for quit (typically the Esc key)
        if defaultKeyboard.getKeys(keyList=["escape"]):
            thisExp.status = FINISHED
        if thisExp.status == FINISHED or endExpNow:
            endExperiment(thisExp, inputs=inputs, win=win)
            return
        
        # check if all components have finished
        if not continueRoutine:  # a component has requested a forced-end of Routine
            routineForceEnded = True
            break
        continueRoutine = False  # will revert to True if at least one component still running
        for thisComponent in planning_2_instructionsComponents:
            if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:
                continueRoutine = True
                break  # at least one component has not yet finished
        
        # refresh the screen
        if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen
            win.flip()
    
    # --- Ending Routine "planning_2_instructions" ---
    for thisComponent in planning_2_instructionsComponents:
        if hasattr(thisComponent, "setAutoDraw"):
            thisComponent.setAutoDraw(False)
    thisExp.addData('planning_2_instructions.stopped', globalClock.getTime())
    # check responses
    if plan2_response_6.keys in ['', [], None]:  # No response was made
        plan2_response_6.keys = None
    thisExp.addData('plan2_response_6.keys',plan2_response_6.keys)
    if plan2_response_6.keys != None:  # we had a response
        thisExp.addData('plan2_response_6.rt', plan2_response_6.rt)
        thisExp.addData('plan2_response_6.duration', plan2_response_6.duration)
    thisExp.nextEntry()
    # the Routine "planning_2_instructions" was not non-slip safe, so reset the non-slip timer
    routineTimer.reset()
    
    # --- Prepare to start Routine "instructions_planning_new3" ---
    continueRoutine = True
    # update component parameters for each repeat
    thisExp.addData('instructions_planning_new3.started', globalClock.getTime())
    # Run 'Begin Routine' code from code_29
    total_practice_planning=total_practice_planning
    plan2_response_5.keys = []
    plan2_response_5.rt = []
    _plan2_response_5_allKeys = []
    text_139.setText(total_practice_planning)
    # keep track of which components have finished
    instructions_planning_new3Components = [text_136, R1_11, R2_11, rew1_11, rew2_11, plan2_response_5, current_image_decision2_6, text_137, text_138, text_139, text_140]
    for thisComponent in instructions_planning_new3Components:
        thisComponent.tStart = None
        thisComponent.tStop = None
        thisComponent.tStartRefresh = None
        thisComponent.tStopRefresh = None
        if hasattr(thisComponent, 'status'):
            thisComponent.status = NOT_STARTED
    # reset timers
    t = 0
    _timeToFirstFrame = win.getFutureFlipTime(clock="now")
    frameN = -1
    
    # --- Run Routine "instructions_planning_new3" ---
    routineForceEnded = not continueRoutine
    while continueRoutine:
        # get current time
        t = routineTimer.getTime()
        tThisFlip = win.getFutureFlipTime(clock=routineTimer)
        tThisFlipGlobal = win.getFutureFlipTime(clock=None)
        frameN = frameN + 1  # number of completed frames (so 0 is the first frame)
        # update/draw components on each frame
        
        # *text_136* updates
        
        # if text_136 is starting this frame...
        if text_136.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
            # keep track of start time/frame for later
            text_136.frameNStart = frameN  # exact frame index
            text_136.tStart = t  # local t and not account for scr refresh
            text_136.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(text_136, 'tStartRefresh')  # time at next scr refresh
            # add timestamp to datafile
            thisExp.timestampOnFlip(win, 'text_136.started')
            # update status
            text_136.status = STARTED
            text_136.setAutoDraw(True)
        
        # if text_136 is active this frame...
        if text_136.status == STARTED:
            # update params
            pass
        
        # if text_136 is stopping this frame...
        if text_136.status == STARTED:
            # is it time to stop? (based on global clock, using actual start)
            if tThisFlipGlobal > text_136.tStartRefresh + 30.0-frameTolerance:
                # keep track of stop time/frame for later
                text_136.tStop = t  # not accounting for scr refresh
                text_136.frameNStop = frameN  # exact frame index
                # add timestamp to datafile
                thisExp.timestampOnFlip(win, 'text_136.stopped')
                # update status
                text_136.status = FINISHED
                text_136.setAutoDraw(False)
        
        # *R1_11* updates
        
        # if R1_11 is starting this frame...
        if R1_11.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
            # keep track of start time/frame for later
            R1_11.frameNStart = frameN  # exact frame index
            R1_11.tStart = t  # local t and not account for scr refresh
            R1_11.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(R1_11, 'tStartRefresh')  # time at next scr refresh
            # add timestamp to datafile
            thisExp.timestampOnFlip(win, 'R1_11.started')
            # update status
            R1_11.status = STARTED
            R1_11.setAutoDraw(True)
        
        # if R1_11 is active this frame...
        if R1_11.status == STARTED:
            # update params
            pass
        
        # if R1_11 is stopping this frame...
        if R1_11.status == STARTED:
            # is it time to stop? (based on global clock, using actual start)
            if tThisFlipGlobal > R1_11.tStartRefresh + 30.0-frameTolerance:
                # keep track of stop time/frame for later
                R1_11.tStop = t  # not accounting for scr refresh
                R1_11.frameNStop = frameN  # exact frame index
                # add timestamp to datafile
                thisExp.timestampOnFlip(win, 'R1_11.stopped')
                # update status
                R1_11.status = FINISHED
                R1_11.setAutoDraw(False)
        
        # *R2_11* updates
        
        # if R2_11 is starting this frame...
        if R2_11.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
            # keep track of start time/frame for later
            R2_11.frameNStart = frameN  # exact frame index
            R2_11.tStart = t  # local t and not account for scr refresh
            R2_11.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(R2_11, 'tStartRefresh')  # time at next scr refresh
            # add timestamp to datafile
            thisExp.timestampOnFlip(win, 'R2_11.started')
            # update status
            R2_11.status = STARTED
            R2_11.setAutoDraw(True)
        
        # if R2_11 is active this frame...
        if R2_11.status == STARTED:
            # update params
            pass
        
        # if R2_11 is stopping this frame...
        if R2_11.status == STARTED:
            # is it time to stop? (based on global clock, using actual start)
            if tThisFlipGlobal > R2_11.tStartRefresh + 30.0-frameTolerance:
                # keep track of stop time/frame for later
                R2_11.tStop = t  # not accounting for scr refresh
                R2_11.frameNStop = frameN  # exact frame index
                # add timestamp to datafile
                thisExp.timestampOnFlip(win, 'R2_11.stopped')
                # update status
                R2_11.status = FINISHED
                R2_11.setAutoDraw(False)
        
        # *rew1_11* updates
        
        # if rew1_11 is starting this frame...
        if rew1_11.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
            # keep track of start time/frame for later
            rew1_11.frameNStart = frameN  # exact frame index
            rew1_11.tStart = t  # local t and not account for scr refresh
            rew1_11.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(rew1_11, 'tStartRefresh')  # time at next scr refresh
            # add timestamp to datafile
            thisExp.timestampOnFlip(win, 'rew1_11.started')
            # update status
            rew1_11.status = STARTED
            rew1_11.setAutoDraw(True)
        
        # if rew1_11 is active this frame...
        if rew1_11.status == STARTED:
            # update params
            rew1_11.setText('SPACE for 100', log=False)
        
        # if rew1_11 is stopping this frame...
        if rew1_11.status == STARTED:
            # is it time to stop? (based on global clock, using actual start)
            if tThisFlipGlobal > rew1_11.tStartRefresh + 30.0-frameTolerance:
                # keep track of stop time/frame for later
                rew1_11.tStop = t  # not accounting for scr refresh
                rew1_11.frameNStop = frameN  # exact frame index
                # add timestamp to datafile
                thisExp.timestampOnFlip(win, 'rew1_11.stopped')
                # update status
                rew1_11.status = FINISHED
                rew1_11.setAutoDraw(False)
        
        # *rew2_11* updates
        
        # if rew2_11 is starting this frame...
        if rew2_11.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
            # keep track of start time/frame for later
            rew2_11.frameNStart = frameN  # exact frame index
            rew2_11.tStart = t  # local t and not account for scr refresh
            rew2_11.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(rew2_11, 'tStartRefresh')  # time at next scr refresh
            # add timestamp to datafile
            thisExp.timestampOnFlip(win, 'rew2_11.started')
            # update status
            rew2_11.status = STARTED
            rew2_11.setAutoDraw(True)
        
        # if rew2_11 is active this frame...
        if rew2_11.status == STARTED:
            # update params
            rew2_11.setText(w2, log=False)
        
        # if rew2_11 is stopping this frame...
        if rew2_11.status == STARTED:
            # is it time to stop? (based on global clock, using actual start)
            if tThisFlipGlobal > rew2_11.tStartRefresh + 30.0-frameTolerance:
                # keep track of stop time/frame for later
                rew2_11.tStop = t  # not accounting for scr refresh
                rew2_11.frameNStop = frameN  # exact frame index
                # add timestamp to datafile
                thisExp.timestampOnFlip(win, 'rew2_11.stopped')
                # update status
                rew2_11.status = FINISHED
                rew2_11.setAutoDraw(False)
        
        # *plan2_response_5* updates
        waitOnFlip = False
        
        # if plan2_response_5 is starting this frame...
        if plan2_response_5.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
            # keep track of start time/frame for later
            plan2_response_5.frameNStart = frameN  # exact frame index
            plan2_response_5.tStart = t  # local t and not account for scr refresh
            plan2_response_5.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(plan2_response_5, 'tStartRefresh')  # time at next scr refresh
            # add timestamp to datafile
            thisExp.timestampOnFlip(win, 'plan2_response_5.started')
            # update status
            plan2_response_5.status = STARTED
            # keyboard checking is just starting
            waitOnFlip = True
            win.callOnFlip(plan2_response_5.clock.reset)  # t=0 on next screen flip
            win.callOnFlip(plan2_response_5.clearEvents, eventType='keyboard')  # clear events on next screen flip
        
        # if plan2_response_5 is stopping this frame...
        if plan2_response_5.status == STARTED:
            # is it time to stop? (based on global clock, using actual start)
            if tThisFlipGlobal > plan2_response_5.tStartRefresh + 30.0-frameTolerance:
                # keep track of stop time/frame for later
                plan2_response_5.tStop = t  # not accounting for scr refresh
                plan2_response_5.frameNStop = frameN  # exact frame index
                # add timestamp to datafile
                thisExp.timestampOnFlip(win, 'plan2_response_5.stopped')
                # update status
                plan2_response_5.status = FINISHED
                plan2_response_5.status = FINISHED
        if plan2_response_5.status == STARTED and not waitOnFlip:
            theseKeys = plan2_response_5.getKeys(keyList=['right','space','left'], ignoreKeys=["escape"], waitRelease=False)
            _plan2_response_5_allKeys.extend(theseKeys)
            if len(_plan2_response_5_allKeys):
                plan2_response_5.keys = _plan2_response_5_allKeys[-1].name  # just the last key pressed
                plan2_response_5.rt = _plan2_response_5_allKeys[-1].rt
                plan2_response_5.duration = _plan2_response_5_allKeys[-1].duration
                # a response ends the routine
                continueRoutine = False
        
        # *current_image_decision2_6* updates
        
        # if current_image_decision2_6 is starting this frame...
        if current_image_decision2_6.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
            # keep track of start time/frame for later
            current_image_decision2_6.frameNStart = frameN  # exact frame index
            current_image_decision2_6.tStart = t  # local t and not account for scr refresh
            current_image_decision2_6.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(current_image_decision2_6, 'tStartRefresh')  # time at next scr refresh
            # add timestamp to datafile
            thisExp.timestampOnFlip(win, 'current_image_decision2_6.started')
            # update status
            current_image_decision2_6.status = STARTED
            current_image_decision2_6.setAutoDraw(True)
        
        # if current_image_decision2_6 is active this frame...
        if current_image_decision2_6.status == STARTED:
            # update params
            pass
        
        # if current_image_decision2_6 is stopping this frame...
        if current_image_decision2_6.status == STARTED:
            # is it time to stop? (based on global clock, using actual start)
            if tThisFlipGlobal > current_image_decision2_6.tStartRefresh + 30.0-frameTolerance:
                # keep track of stop time/frame for later
                current_image_decision2_6.tStop = t  # not accounting for scr refresh
                current_image_decision2_6.frameNStop = frameN  # exact frame index
                # add timestamp to datafile
                thisExp.timestampOnFlip(win, 'current_image_decision2_6.stopped')
                # update status
                current_image_decision2_6.status = FINISHED
                current_image_decision2_6.setAutoDraw(False)
        
        # *text_137* updates
        
        # if text_137 is starting this frame...
        if text_137.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
            # keep track of start time/frame for later
            text_137.frameNStart = frameN  # exact frame index
            text_137.tStart = t  # local t and not account for scr refresh
            text_137.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(text_137, 'tStartRefresh')  # time at next scr refresh
            # add timestamp to datafile
            thisExp.timestampOnFlip(win, 'text_137.started')
            # update status
            text_137.status = STARTED
            text_137.setAutoDraw(True)
        
        # if text_137 is active this frame...
        if text_137.status == STARTED:
            # update params
            pass
        
        # if text_137 is stopping this frame...
        if text_137.status == STARTED:
            # is it time to stop? (based on global clock, using actual start)
            if tThisFlipGlobal > text_137.tStartRefresh + 30.0-frameTolerance:
                # keep track of stop time/frame for later
                text_137.tStop = t  # not accounting for scr refresh
                text_137.frameNStop = frameN  # exact frame index
                # add timestamp to datafile
                thisExp.timestampOnFlip(win, 'text_137.stopped')
                # update status
                text_137.status = FINISHED
                text_137.setAutoDraw(False)
        
        # *text_138* updates
        
        # if text_138 is starting this frame...
        if text_138.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
            # keep track of start time/frame for later
            text_138.frameNStart = frameN  # exact frame index
            text_138.tStart = t  # local t and not account for scr refresh
            text_138.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(text_138, 'tStartRefresh')  # time at next scr refresh
            # add timestamp to datafile
            thisExp.timestampOnFlip(win, 'text_138.started')
            # update status
            text_138.status = STARTED
            text_138.setAutoDraw(True)
        
        # if text_138 is active this frame...
        if text_138.status == STARTED:
            # update params
            pass
        
        # if text_138 is stopping this frame...
        if text_138.status == STARTED:
            # is it time to stop? (based on global clock, using actual start)
            if tThisFlipGlobal > text_138.tStartRefresh + 30.0-frameTolerance:
                # keep track of stop time/frame for later
                text_138.tStop = t  # not accounting for scr refresh
                text_138.frameNStop = frameN  # exact frame index
                # add timestamp to datafile
                thisExp.timestampOnFlip(win, 'text_138.stopped')
                # update status
                text_138.status = FINISHED
                text_138.setAutoDraw(False)
        
        # *text_139* updates
        
        # if text_139 is starting this frame...
        if text_139.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
            # keep track of start time/frame for later
            text_139.frameNStart = frameN  # exact frame index
            text_139.tStart = t  # local t and not account for scr refresh
            text_139.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(text_139, 'tStartRefresh')  # time at next scr refresh
            # add timestamp to datafile
            thisExp.timestampOnFlip(win, 'text_139.started')
            # update status
            text_139.status = STARTED
            text_139.setAutoDraw(True)
        
        # if text_139 is active this frame...
        if text_139.status == STARTED:
            # update params
            pass
        
        # *text_140* updates
        
        # if text_140 is starting this frame...
        if text_140.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
            # keep track of start time/frame for later
            text_140.frameNStart = frameN  # exact frame index
            text_140.tStart = t  # local t and not account for scr refresh
            text_140.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(text_140, 'tStartRefresh')  # time at next scr refresh
            # add timestamp to datafile
            thisExp.timestampOnFlip(win, 'text_140.started')
            # update status
            text_140.status = STARTED
            text_140.setAutoDraw(True)
        
        # if text_140 is active this frame...
        if text_140.status == STARTED:
            # update params
            pass
        
        # check for quit (typically the Esc key)
        if defaultKeyboard.getKeys(keyList=["escape"]):
            thisExp.status = FINISHED
        if thisExp.status == FINISHED or endExpNow:
            endExperiment(thisExp, inputs=inputs, win=win)
            return
        
        # check if all components have finished
        if not continueRoutine:  # a component has requested a forced-end of Routine
            routineForceEnded = True
            break
        continueRoutine = False  # will revert to True if at least one component still running
        for thisComponent in instructions_planning_new3Components:
            if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:
                continueRoutine = True
                break  # at least one component has not yet finished
        
        # refresh the screen
        if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen
            win.flip()
    
    # --- Ending Routine "instructions_planning_new3" ---
    for thisComponent in instructions_planning_new3Components:
        if hasattr(thisComponent, "setAutoDraw"):
            thisComponent.setAutoDraw(False)
    thisExp.addData('instructions_planning_new3.stopped', globalClock.getTime())
    # check responses
    if plan2_response_5.keys in ['', [], None]:  # No response was made
        plan2_response_5.keys = None
    thisExp.addData('plan2_response_5.keys',plan2_response_5.keys)
    if plan2_response_5.keys != None:  # we had a response
        thisExp.addData('plan2_response_5.rt', plan2_response_5.rt)
        thisExp.addData('plan2_response_5.duration', plan2_response_5.duration)
    thisExp.nextEntry()
    # the Routine "instructions_planning_new3" was not non-slip safe, so reset the non-slip timer
    routineTimer.reset()
    
    # --- Prepare to start Routine "practice_planning_outcomes" ---
    continueRoutine = True
    # update component parameters for each repeat
    thisExp.addData('practice_planning_outcomes.started', globalClock.getTime())
    # Run 'Begin Routine' code from code_33
    total_practice_planning+=400
    text_142.setText(total_practice_planning)
    # keep track of which components have finished
    practice_planning_outcomesComponents = [image_6, text_141, text_142, text_143]
    for thisComponent in practice_planning_outcomesComponents:
        thisComponent.tStart = None
        thisComponent.tStop = None
        thisComponent.tStartRefresh = None
        thisComponent.tStopRefresh = None
        if hasattr(thisComponent, 'status'):
            thisComponent.status = NOT_STARTED
    # reset timers
    t = 0
    _timeToFirstFrame = win.getFutureFlipTime(clock="now")
    frameN = -1
    
    # --- Run Routine "practice_planning_outcomes" ---
    routineForceEnded = not continueRoutine
    while continueRoutine and routineTimer.getTime() < 2.0:
        # get current time
        t = routineTimer.getTime()
        tThisFlip = win.getFutureFlipTime(clock=routineTimer)
        tThisFlipGlobal = win.getFutureFlipTime(clock=None)
        frameN = frameN + 1  # number of completed frames (so 0 is the first frame)
        # update/draw components on each frame
        
        # *image_6* updates
        
        # if image_6 is starting this frame...
        if image_6.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
            # keep track of start time/frame for later
            image_6.frameNStart = frameN  # exact frame index
            image_6.tStart = t  # local t and not account for scr refresh
            image_6.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(image_6, 'tStartRefresh')  # time at next scr refresh
            # add timestamp to datafile
            thisExp.timestampOnFlip(win, 'image_6.started')
            # update status
            image_6.status = STARTED
            image_6.setAutoDraw(True)
        
        # if image_6 is active this frame...
        if image_6.status == STARTED:
            # update params
            pass
        
        # if image_6 is stopping this frame...
        if image_6.status == STARTED:
            # is it time to stop? (based on global clock, using actual start)
            if tThisFlipGlobal > image_6.tStartRefresh + 2.0-frameTolerance:
                # keep track of stop time/frame for later
                image_6.tStop = t  # not accounting for scr refresh
                image_6.frameNStop = frameN  # exact frame index
                # add timestamp to datafile
                thisExp.timestampOnFlip(win, 'image_6.stopped')
                # update status
                image_6.status = FINISHED
                image_6.setAutoDraw(False)
        
        # *text_141* updates
        
        # if text_141 is starting this frame...
        if text_141.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
            # keep track of start time/frame for later
            text_141.frameNStart = frameN  # exact frame index
            text_141.tStart = t  # local t and not account for scr refresh
            text_141.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(text_141, 'tStartRefresh')  # time at next scr refresh
            # add timestamp to datafile
            thisExp.timestampOnFlip(win, 'text_141.started')
            # update status
            text_141.status = STARTED
            text_141.setAutoDraw(True)
        
        # if text_141 is active this frame...
        if text_141.status == STARTED:
            # update params
            pass
        
        # if text_141 is stopping this frame...
        if text_141.status == STARTED:
            # is it time to stop? (based on global clock, using actual start)
            if tThisFlipGlobal > text_141.tStartRefresh + 2.0-frameTolerance:
                # keep track of stop time/frame for later
                text_141.tStop = t  # not accounting for scr refresh
                text_141.frameNStop = frameN  # exact frame index
                # add timestamp to datafile
                thisExp.timestampOnFlip(win, 'text_141.stopped')
                # update status
                text_141.status = FINISHED
                text_141.setAutoDraw(False)
        
        # *text_142* updates
        
        # if text_142 is starting this frame...
        if text_142.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
            # keep track of start time/frame for later
            text_142.frameNStart = frameN  # exact frame index
            text_142.tStart = t  # local t and not account for scr refresh
            text_142.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(text_142, 'tStartRefresh')  # time at next scr refresh
            # add timestamp to datafile
            thisExp.timestampOnFlip(win, 'text_142.started')
            # update status
            text_142.status = STARTED
            text_142.setAutoDraw(True)
        
        # if text_142 is active this frame...
        if text_142.status == STARTED:
            # update params
            pass
        
        # if text_142 is stopping this frame...
        if text_142.status == STARTED:
            # is it time to stop? (based on global clock, using actual start)
            if tThisFlipGlobal > text_142.tStartRefresh + 2.0-frameTolerance:
                # keep track of stop time/frame for later
                text_142.tStop = t  # not accounting for scr refresh
                text_142.frameNStop = frameN  # exact frame index
                # add timestamp to datafile
                thisExp.timestampOnFlip(win, 'text_142.stopped')
                # update status
                text_142.status = FINISHED
                text_142.setAutoDraw(False)
        
        # *text_143* updates
        
        # if text_143 is starting this frame...
        if text_143.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
            # keep track of start time/frame for later
            text_143.frameNStart = frameN  # exact frame index
            text_143.tStart = t  # local t and not account for scr refresh
            text_143.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(text_143, 'tStartRefresh')  # time at next scr refresh
            # add timestamp to datafile
            thisExp.timestampOnFlip(win, 'text_143.started')
            # update status
            text_143.status = STARTED
            text_143.setAutoDraw(True)
        
        # if text_143 is active this frame...
        if text_143.status == STARTED:
            # update params
            pass
        
        # if text_143 is stopping this frame...
        if text_143.status == STARTED:
            # is it time to stop? (based on global clock, using actual start)
            if tThisFlipGlobal > text_143.tStartRefresh + 2.0-frameTolerance:
                # keep track of stop time/frame for later
                text_143.tStop = t  # not accounting for scr refresh
                text_143.frameNStop = frameN  # exact frame index
                # add timestamp to datafile
                thisExp.timestampOnFlip(win, 'text_143.stopped')
                # update status
                text_143.status = FINISHED
                text_143.setAutoDraw(False)
        
        # check for quit (typically the Esc key)
        if defaultKeyboard.getKeys(keyList=["escape"]):
            thisExp.status = FINISHED
        if thisExp.status == FINISHED or endExpNow:
            endExperiment(thisExp, inputs=inputs, win=win)
            return
        
        # check if all components have finished
        if not continueRoutine:  # a component has requested a forced-end of Routine
            routineForceEnded = True
            break
        continueRoutine = False  # will revert to True if at least one component still running
        for thisComponent in practice_planning_outcomesComponents:
            if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:
                continueRoutine = True
                break  # at least one component has not yet finished
        
        # refresh the screen
        if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen
            win.flip()
    
    # --- Ending Routine "practice_planning_outcomes" ---
    for thisComponent in practice_planning_outcomesComponents:
        if hasattr(thisComponent, "setAutoDraw"):
            thisComponent.setAutoDraw(False)
    thisExp.addData('practice_planning_outcomes.stopped', globalClock.getTime())
    # using non-slip timing so subtract the expected duration of this Routine (unless ended on request)
    if routineForceEnded:
        routineTimer.reset()
    else:
        routineTimer.addTime(-2.000000)
    
    # --- Prepare to start Routine "immediate_rewar_lesson" ---
    continueRoutine = True
    # update component parameters for each repeat
    thisExp.addData('immediate_rewar_lesson.started', globalClock.getTime())
    key_resp_39.keys = []
    key_resp_39.rt = []
    _key_resp_39_allKeys = []
    # Run 'Begin Routine' code from code_41
    total_practice_planning=0
    # keep track of which components have finished
    immediate_rewar_lessonComponents = [text_148, key_resp_39]
    for thisComponent in immediate_rewar_lessonComponents:
        thisComponent.tStart = None
        thisComponent.tStop = None
        thisComponent.tStartRefresh = None
        thisComponent.tStopRefresh = None
        if hasattr(thisComponent, 'status'):
            thisComponent.status = NOT_STARTED
    # reset timers
    t = 0
    _timeToFirstFrame = win.getFutureFlipTime(clock="now")
    frameN = -1
    
    # --- Run Routine "immediate_rewar_lesson" ---
    routineForceEnded = not continueRoutine
    while continueRoutine:
        # get current time
        t = routineTimer.getTime()
        tThisFlip = win.getFutureFlipTime(clock=routineTimer)
        tThisFlipGlobal = win.getFutureFlipTime(clock=None)
        frameN = frameN + 1  # number of completed frames (so 0 is the first frame)
        # update/draw components on each frame
        
        # *text_148* updates
        
        # if text_148 is starting this frame...
        if text_148.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
            # keep track of start time/frame for later
            text_148.frameNStart = frameN  # exact frame index
            text_148.tStart = t  # local t and not account for scr refresh
            text_148.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(text_148, 'tStartRefresh')  # time at next scr refresh
            # add timestamp to datafile
            thisExp.timestampOnFlip(win, 'text_148.started')
            # update status
            text_148.status = STARTED
            text_148.setAutoDraw(True)
        
        # if text_148 is active this frame...
        if text_148.status == STARTED:
            # update params
            pass
        
        # *key_resp_39* updates
        waitOnFlip = False
        
        # if key_resp_39 is starting this frame...
        if key_resp_39.status == NOT_STARTED and tThisFlip >= 0-frameTolerance:
            # keep track of start time/frame for later
            key_resp_39.frameNStart = frameN  # exact frame index
            key_resp_39.tStart = t  # local t and not account for scr refresh
            key_resp_39.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(key_resp_39, 'tStartRefresh')  # time at next scr refresh
            # add timestamp to datafile
            thisExp.timestampOnFlip(win, 'key_resp_39.started')
            # update status
            key_resp_39.status = STARTED
            # keyboard checking is just starting
            waitOnFlip = True
            win.callOnFlip(key_resp_39.clock.reset)  # t=0 on next screen flip
            win.callOnFlip(key_resp_39.clearEvents, eventType='keyboard')  # clear events on next screen flip
        if key_resp_39.status == STARTED and not waitOnFlip:
            theseKeys = key_resp_39.getKeys(keyList=['space'], ignoreKeys=["escape"], waitRelease=False)
            _key_resp_39_allKeys.extend(theseKeys)
            if len(_key_resp_39_allKeys):
                key_resp_39.keys = _key_resp_39_allKeys[-1].name  # just the last key pressed
                key_resp_39.rt = _key_resp_39_allKeys[-1].rt
                key_resp_39.duration = _key_resp_39_allKeys[-1].duration
                # a response ends the routine
                continueRoutine = False
        
        # check for quit (typically the Esc key)
        if defaultKeyboard.getKeys(keyList=["escape"]):
            thisExp.status = FINISHED
        if thisExp.status == FINISHED or endExpNow:
            endExperiment(thisExp, inputs=inputs, win=win)
            return
        
        # check if all components have finished
        if not continueRoutine:  # a component has requested a forced-end of Routine
            routineForceEnded = True
            break
        continueRoutine = False  # will revert to True if at least one component still running
        for thisComponent in immediate_rewar_lessonComponents:
            if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:
                continueRoutine = True
                break  # at least one component has not yet finished
        
        # refresh the screen
        if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen
            win.flip()
    
    # --- Ending Routine "immediate_rewar_lesson" ---
    for thisComponent in immediate_rewar_lessonComponents:
        if hasattr(thisComponent, "setAutoDraw"):
            thisComponent.setAutoDraw(False)
    thisExp.addData('immediate_rewar_lesson.stopped', globalClock.getTime())
    # the Routine "immediate_rewar_lesson" was not non-slip safe, so reset the non-slip timer
    routineTimer.reset()
    
    # --- Prepare to start Routine "lesson_practice" ---
    continueRoutine = True
    # update component parameters for each repeat
    thisExp.addData('lesson_practice.started', globalClock.getTime())
    key_resp_37.keys = []
    key_resp_37.rt = []
    _key_resp_37_allKeys = []
    # Run 'Begin Routine' code from code_34
    total_practice_planning=0
    # keep track of which components have finished
    lesson_practiceComponents = [text_144, key_resp_37]
    for thisComponent in lesson_practiceComponents:
        thisComponent.tStart = None
        thisComponent.tStop = None
        thisComponent.tStartRefresh = None
        thisComponent.tStopRefresh = None
        if hasattr(thisComponent, 'status'):
            thisComponent.status = NOT_STARTED
    # reset timers
    t = 0
    _timeToFirstFrame = win.getFutureFlipTime(clock="now")
    frameN = -1
    
    # --- Run Routine "lesson_practice" ---
    routineForceEnded = not continueRoutine
    while continueRoutine:
        # get current time
        t = routineTimer.getTime()
        tThisFlip = win.getFutureFlipTime(clock=routineTimer)
        tThisFlipGlobal = win.getFutureFlipTime(clock=None)
        frameN = frameN + 1  # number of completed frames (so 0 is the first frame)
        # update/draw components on each frame
        
        # *text_144* updates
        
        # if text_144 is starting this frame...
        if text_144.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
            # keep track of start time/frame for later
            text_144.frameNStart = frameN  # exact frame index
            text_144.tStart = t  # local t and not account for scr refresh
            text_144.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(text_144, 'tStartRefresh')  # time at next scr refresh
            # add timestamp to datafile
            thisExp.timestampOnFlip(win, 'text_144.started')
            # update status
            text_144.status = STARTED
            text_144.setAutoDraw(True)
        
        # if text_144 is active this frame...
        if text_144.status == STARTED:
            # update params
            pass
        
        # *key_resp_37* updates
        waitOnFlip = False
        
        # if key_resp_37 is starting this frame...
        if key_resp_37.status == NOT_STARTED and tThisFlip >= 0-frameTolerance:
            # keep track of start time/frame for later
            key_resp_37.frameNStart = frameN  # exact frame index
            key_resp_37.tStart = t  # local t and not account for scr refresh
            key_resp_37.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(key_resp_37, 'tStartRefresh')  # time at next scr refresh
            # add timestamp to datafile
            thisExp.timestampOnFlip(win, 'key_resp_37.started')
            # update status
            key_resp_37.status = STARTED
            # keyboard checking is just starting
            waitOnFlip = True
            win.callOnFlip(key_resp_37.clock.reset)  # t=0 on next screen flip
            win.callOnFlip(key_resp_37.clearEvents, eventType='keyboard')  # clear events on next screen flip
        if key_resp_37.status == STARTED and not waitOnFlip:
            theseKeys = key_resp_37.getKeys(keyList=['space'], ignoreKeys=["escape"], waitRelease=False)
            _key_resp_37_allKeys.extend(theseKeys)
            if len(_key_resp_37_allKeys):
                key_resp_37.keys = _key_resp_37_allKeys[-1].name  # just the last key pressed
                key_resp_37.rt = _key_resp_37_allKeys[-1].rt
                key_resp_37.duration = _key_resp_37_allKeys[-1].duration
                # a response ends the routine
                continueRoutine = False
        
        # check for quit (typically the Esc key)
        if defaultKeyboard.getKeys(keyList=["escape"]):
            thisExp.status = FINISHED
        if thisExp.status == FINISHED or endExpNow:
            endExperiment(thisExp, inputs=inputs, win=win)
            return
        
        # check if all components have finished
        if not continueRoutine:  # a component has requested a forced-end of Routine
            routineForceEnded = True
            break
        continueRoutine = False  # will revert to True if at least one component still running
        for thisComponent in lesson_practiceComponents:
            if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:
                continueRoutine = True
                break  # at least one component has not yet finished
        
        # refresh the screen
        if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen
            win.flip()
    
    # --- Ending Routine "lesson_practice" ---
    for thisComponent in lesson_practiceComponents:
        if hasattr(thisComponent, "setAutoDraw"):
            thisComponent.setAutoDraw(False)
    thisExp.addData('lesson_practice.stopped', globalClock.getTime())
    # the Routine "lesson_practice" was not non-slip safe, so reset the non-slip timer
    routineTimer.reset()
    
    # --- Prepare to start Routine "lesson_practice_2" ---
    continueRoutine = True
    # update component parameters for each repeat
    thisExp.addData('lesson_practice_2.started', globalClock.getTime())
    key_resp_38.keys = []
    key_resp_38.rt = []
    _key_resp_38_allKeys = []
    # Run 'Begin Routine' code from code_37
    total_practice_planning=0
    # keep track of which components have finished
    lesson_practice_2Components = [text_145, key_resp_38]
    for thisComponent in lesson_practice_2Components:
        thisComponent.tStart = None
        thisComponent.tStop = None
        thisComponent.tStartRefresh = None
        thisComponent.tStopRefresh = None
        if hasattr(thisComponent, 'status'):
            thisComponent.status = NOT_STARTED
    # reset timers
    t = 0
    _timeToFirstFrame = win.getFutureFlipTime(clock="now")
    frameN = -1
    
    # --- Run Routine "lesson_practice_2" ---
    routineForceEnded = not continueRoutine
    while continueRoutine:
        # get current time
        t = routineTimer.getTime()
        tThisFlip = win.getFutureFlipTime(clock=routineTimer)
        tThisFlipGlobal = win.getFutureFlipTime(clock=None)
        frameN = frameN + 1  # number of completed frames (so 0 is the first frame)
        # update/draw components on each frame
        
        # *text_145* updates
        
        # if text_145 is starting this frame...
        if text_145.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
            # keep track of start time/frame for later
            text_145.frameNStart = frameN  # exact frame index
            text_145.tStart = t  # local t and not account for scr refresh
            text_145.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(text_145, 'tStartRefresh')  # time at next scr refresh
            # add timestamp to datafile
            thisExp.timestampOnFlip(win, 'text_145.started')
            # update status
            text_145.status = STARTED
            text_145.setAutoDraw(True)
        
        # if text_145 is active this frame...
        if text_145.status == STARTED:
            # update params
            pass
        
        # *key_resp_38* updates
        waitOnFlip = False
        
        # if key_resp_38 is starting this frame...
        if key_resp_38.status == NOT_STARTED and tThisFlip >= 0-frameTolerance:
            # keep track of start time/frame for later
            key_resp_38.frameNStart = frameN  # exact frame index
            key_resp_38.tStart = t  # local t and not account for scr refresh
            key_resp_38.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(key_resp_38, 'tStartRefresh')  # time at next scr refresh
            # add timestamp to datafile
            thisExp.timestampOnFlip(win, 'key_resp_38.started')
            # update status
            key_resp_38.status = STARTED
            # keyboard checking is just starting
            waitOnFlip = True
            win.callOnFlip(key_resp_38.clock.reset)  # t=0 on next screen flip
            win.callOnFlip(key_resp_38.clearEvents, eventType='keyboard')  # clear events on next screen flip
        if key_resp_38.status == STARTED and not waitOnFlip:
            theseKeys = key_resp_38.getKeys(keyList=['space'], ignoreKeys=["escape"], waitRelease=False)
            _key_resp_38_allKeys.extend(theseKeys)
            if len(_key_resp_38_allKeys):
                key_resp_38.keys = _key_resp_38_allKeys[-1].name  # just the last key pressed
                key_resp_38.rt = _key_resp_38_allKeys[-1].rt
                key_resp_38.duration = _key_resp_38_allKeys[-1].duration
                # a response ends the routine
                continueRoutine = False
        
        # check for quit (typically the Esc key)
        if defaultKeyboard.getKeys(keyList=["escape"]):
            thisExp.status = FINISHED
        if thisExp.status == FINISHED or endExpNow:
            endExperiment(thisExp, inputs=inputs, win=win)
            return
        
        # check if all components have finished
        if not continueRoutine:  # a component has requested a forced-end of Routine
            routineForceEnded = True
            break
        continueRoutine = False  # will revert to True if at least one component still running
        for thisComponent in lesson_practice_2Components:
            if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:
                continueRoutine = True
                break  # at least one component has not yet finished
        
        # refresh the screen
        if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen
            win.flip()
    
    # --- Ending Routine "lesson_practice_2" ---
    for thisComponent in lesson_practice_2Components:
        if hasattr(thisComponent, "setAutoDraw"):
            thisComponent.setAutoDraw(False)
    thisExp.addData('lesson_practice_2.stopped', globalClock.getTime())
    # the Routine "lesson_practice_2" was not non-slip safe, so reset the non-slip timer
    routineTimer.reset()
    
    # --- Prepare to start Routine "start_real_planning" ---
    continueRoutine = True
    # update component parameters for each repeat
    thisExp.addData('start_real_planning.started', globalClock.getTime())
    key_resp_6.keys = []
    key_resp_6.rt = []
    _key_resp_6_allKeys = []
    # Run 'Begin Routine' code from code_17
    total_planning=0
    # keep track of which components have finished
    start_real_planningComponents = [text_42, key_resp_6]
    for thisComponent in start_real_planningComponents:
        thisComponent.tStart = None
        thisComponent.tStop = None
        thisComponent.tStartRefresh = None
        thisComponent.tStopRefresh = None
        if hasattr(thisComponent, 'status'):
            thisComponent.status = NOT_STARTED
    # reset timers
    t = 0
    _timeToFirstFrame = win.getFutureFlipTime(clock="now")
    frameN = -1
    
    # --- Run Routine "start_real_planning" ---
    routineForceEnded = not continueRoutine
    while continueRoutine:
        # get current time
        t = routineTimer.getTime()
        tThisFlip = win.getFutureFlipTime(clock=routineTimer)
        tThisFlipGlobal = win.getFutureFlipTime(clock=None)
        frameN = frameN + 1  # number of completed frames (so 0 is the first frame)
        # update/draw components on each frame
        
        # *text_42* updates
        
        # if text_42 is starting this frame...
        if text_42.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
            # keep track of start time/frame for later
            text_42.frameNStart = frameN  # exact frame index
            text_42.tStart = t  # local t and not account for scr refresh
            text_42.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(text_42, 'tStartRefresh')  # time at next scr refresh
            # add timestamp to datafile
            thisExp.timestampOnFlip(win, 'text_42.started')
            # update status
            text_42.status = STARTED
            text_42.setAutoDraw(True)
        
        # if text_42 is active this frame...
        if text_42.status == STARTED:
            # update params
            pass
        
        # *key_resp_6* updates
        waitOnFlip = False
        
        # if key_resp_6 is starting this frame...
        if key_resp_6.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
            # keep track of start time/frame for later
            key_resp_6.frameNStart = frameN  # exact frame index
            key_resp_6.tStart = t  # local t and not account for scr refresh
            key_resp_6.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(key_resp_6, 'tStartRefresh')  # time at next scr refresh
            # add timestamp to datafile
            thisExp.timestampOnFlip(win, 'key_resp_6.started')
            # update status
            key_resp_6.status = STARTED
            # keyboard checking is just starting
            waitOnFlip = True
            win.callOnFlip(key_resp_6.clock.reset)  # t=0 on next screen flip
            win.callOnFlip(key_resp_6.clearEvents, eventType='keyboard')  # clear events on next screen flip
        if key_resp_6.status == STARTED and not waitOnFlip:
            theseKeys = key_resp_6.getKeys(keyList=['space'], ignoreKeys=["escape"], waitRelease=False)
            _key_resp_6_allKeys.extend(theseKeys)
            if len(_key_resp_6_allKeys):
                key_resp_6.keys = _key_resp_6_allKeys[-1].name  # just the last key pressed
                key_resp_6.rt = _key_resp_6_allKeys[-1].rt
                key_resp_6.duration = _key_resp_6_allKeys[-1].duration
                # a response ends the routine
                continueRoutine = False
        
        # check for quit (typically the Esc key)
        if defaultKeyboard.getKeys(keyList=["escape"]):
            thisExp.status = FINISHED
        if thisExp.status == FINISHED or endExpNow:
            endExperiment(thisExp, inputs=inputs, win=win)
            return
        
        # check if all components have finished
        if not continueRoutine:  # a component has requested a forced-end of Routine
            routineForceEnded = True
            break
        continueRoutine = False  # will revert to True if at least one component still running
        for thisComponent in start_real_planningComponents:
            if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:
                continueRoutine = True
                break  # at least one component has not yet finished
        
        # refresh the screen
        if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen
            win.flip()
    
    # --- Ending Routine "start_real_planning" ---
    for thisComponent in start_real_planningComponents:
        if hasattr(thisComponent, "setAutoDraw"):
            thisComponent.setAutoDraw(False)
    thisExp.addData('start_real_planning.stopped', globalClock.getTime())
    # check responses
    if key_resp_6.keys in ['', [], None]:  # No response was made
        key_resp_6.keys = None
    thisExp.addData('key_resp_6.keys',key_resp_6.keys)
    if key_resp_6.keys != None:  # we had a response
        thisExp.addData('key_resp_6.rt', key_resp_6.rt)
        thisExp.addData('key_resp_6.duration', key_resp_6.duration)
    thisExp.nextEntry()
    # the Routine "start_real_planning" was not non-slip safe, so reset the non-slip timer
    routineTimer.reset()
    
    # set up handler to look after randomisation of conditions etc
    planning_loop = data.TrialHandler(nReps=1.0, method='random', 
        extraInfo=expInfo, originPath=-1,
        trialList=data.importConditions('planning_trials.xlsx'),
        seed=None, name='planning_loop')
    thisExp.addLoop(planning_loop)  # add the loop to the experiment
    thisPlanning_loop = planning_loop.trialList[0]  # so we can initialise stimuli with some values
    # abbreviate parameter names if possible (e.g. rgb = thisPlanning_loop.rgb)
    if thisPlanning_loop != None:
        for paramName in thisPlanning_loop:
            globals()[paramName] = thisPlanning_loop[paramName]
    
    for thisPlanning_loop in planning_loop:
        currentLoop = planning_loop
        thisExp.timestampOnFlip(win, 'thisRow.t')
        # pause experiment here if requested
        if thisExp.status == PAUSED:
            pauseExperiment(
                thisExp=thisExp, 
                inputs=inputs, 
                win=win, 
                timers=[routineTimer], 
                playbackComponents=[]
        )
        # abbreviate parameter names if possible (e.g. rgb = thisPlanning_loop.rgb)
        if thisPlanning_loop != None:
            for paramName in thisPlanning_loop:
                globals()[paramName] = thisPlanning_loop[paramName]
        
        # --- Prepare to start Routine "plan1_info_2" ---
        continueRoutine = True
        # update component parameters for each repeat
        thisExp.addData('plan1_info_2.started', globalClock.getTime())
        # Run 'Begin Routine' code from code_5
        w2=400
        R2.setImage(r2)
        plan1_response.keys = []
        plan1_response.rt = []
        _plan1_response_allKeys = []
        text_117.setText(total_planning)
        # keep track of which components have finished
        plan1_info_2Components = [text_5, R1, R2, rew1, rew2, text_6, plan1_response, babyleft, toothbrushright, text_117, text_120]
        for thisComponent in plan1_info_2Components:
            thisComponent.tStart = None
            thisComponent.tStop = None
            thisComponent.tStartRefresh = None
            thisComponent.tStopRefresh = None
            if hasattr(thisComponent, 'status'):
                thisComponent.status = NOT_STARTED
        # reset timers
        t = 0
        _timeToFirstFrame = win.getFutureFlipTime(clock="now")
        frameN = -1
        
        # --- Run Routine "plan1_info_2" ---
        routineForceEnded = not continueRoutine
        while continueRoutine:
            # get current time
            t = routineTimer.getTime()
            tThisFlip = win.getFutureFlipTime(clock=routineTimer)
            tThisFlipGlobal = win.getFutureFlipTime(clock=None)
            frameN = frameN + 1  # number of completed frames (so 0 is the first frame)
            # update/draw components on each frame
            
            # *text_5* updates
            
            # if text_5 is starting this frame...
            if text_5.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
                # keep track of start time/frame for later
                text_5.frameNStart = frameN  # exact frame index
                text_5.tStart = t  # local t and not account for scr refresh
                text_5.tStartRefresh = tThisFlipGlobal  # on global time
                win.timeOnFlip(text_5, 'tStartRefresh')  # time at next scr refresh
                # add timestamp to datafile
                thisExp.timestampOnFlip(win, 'text_5.started')
                # update status
                text_5.status = STARTED
                text_5.setAutoDraw(True)
            
            # if text_5 is active this frame...
            if text_5.status == STARTED:
                # update params
                pass
            
            # *R1* updates
            
            # if R1 is starting this frame...
            if R1.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
                # keep track of start time/frame for later
                R1.frameNStart = frameN  # exact frame index
                R1.tStart = t  # local t and not account for scr refresh
                R1.tStartRefresh = tThisFlipGlobal  # on global time
                win.timeOnFlip(R1, 'tStartRefresh')  # time at next scr refresh
                # add timestamp to datafile
                thisExp.timestampOnFlip(win, 'R1.started')
                # update status
                R1.status = STARTED
                R1.setAutoDraw(True)
            
            # if R1 is active this frame...
            if R1.status == STARTED:
                # update params
                pass
            
            # *R2* updates
            
            # if R2 is starting this frame...
            if R2.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
                # keep track of start time/frame for later
                R2.frameNStart = frameN  # exact frame index
                R2.tStart = t  # local t and not account for scr refresh
                R2.tStartRefresh = tThisFlipGlobal  # on global time
                win.timeOnFlip(R2, 'tStartRefresh')  # time at next scr refresh
                # add timestamp to datafile
                thisExp.timestampOnFlip(win, 'R2.started')
                # update status
                R2.status = STARTED
                R2.setAutoDraw(True)
            
            # if R2 is active this frame...
            if R2.status == STARTED:
                # update params
                pass
            
            # *rew1* updates
            
            # if rew1 is starting this frame...
            if rew1.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
                # keep track of start time/frame for later
                rew1.frameNStart = frameN  # exact frame index
                rew1.tStart = t  # local t and not account for scr refresh
                rew1.tStartRefresh = tThisFlipGlobal  # on global time
                win.timeOnFlip(rew1, 'tStartRefresh')  # time at next scr refresh
                # add timestamp to datafile
                thisExp.timestampOnFlip(win, 'rew1.started')
                # update status
                rew1.status = STARTED
                rew1.setAutoDraw(True)
            
            # if rew1 is active this frame...
            if rew1.status == STARTED:
                # update params
                pass
            
            # *rew2* updates
            
            # if rew2 is starting this frame...
            if rew2.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
                # keep track of start time/frame for later
                rew2.frameNStart = frameN  # exact frame index
                rew2.tStart = t  # local t and not account for scr refresh
                rew2.tStartRefresh = tThisFlipGlobal  # on global time
                win.timeOnFlip(rew2, 'tStartRefresh')  # time at next scr refresh
                # add timestamp to datafile
                thisExp.timestampOnFlip(win, 'rew2.started')
                # update status
                rew2.status = STARTED
                rew2.setAutoDraw(True)
            
            # if rew2 is active this frame...
            if rew2.status == STARTED:
                # update params
                rew2.setText(w2, log=False)
            
            # *text_6* updates
            
            # if text_6 is starting this frame...
            if text_6.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
                # keep track of start time/frame for later
                text_6.frameNStart = frameN  # exact frame index
                text_6.tStart = t  # local t and not account for scr refresh
                text_6.tStartRefresh = tThisFlipGlobal  # on global time
                win.timeOnFlip(text_6, 'tStartRefresh')  # time at next scr refresh
                # add timestamp to datafile
                thisExp.timestampOnFlip(win, 'text_6.started')
                # update status
                text_6.status = STARTED
                text_6.setAutoDraw(True)
            
            # if text_6 is active this frame...
            if text_6.status == STARTED:
                # update params
                pass
            
            # *plan1_response* updates
            waitOnFlip = False
            
            # if plan1_response is starting this frame...
            if plan1_response.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
                # keep track of start time/frame for later
                plan1_response.frameNStart = frameN  # exact frame index
                plan1_response.tStart = t  # local t and not account for scr refresh
                plan1_response.tStartRefresh = tThisFlipGlobal  # on global time
                win.timeOnFlip(plan1_response, 'tStartRefresh')  # time at next scr refresh
                # add timestamp to datafile
                thisExp.timestampOnFlip(win, 'plan1_response.started')
                # update status
                plan1_response.status = STARTED
                # keyboard checking is just starting
                waitOnFlip = True
                win.callOnFlip(plan1_response.clock.reset)  # t=0 on next screen flip
                win.callOnFlip(plan1_response.clearEvents, eventType='keyboard')  # clear events on next screen flip
            if plan1_response.status == STARTED and not waitOnFlip:
                theseKeys = plan1_response.getKeys(keyList=['left', 'right','space'], ignoreKeys=["escape"], waitRelease=False)
                _plan1_response_allKeys.extend(theseKeys)
                if len(_plan1_response_allKeys):
                    plan1_response.keys = _plan1_response_allKeys[-1].name  # just the last key pressed
                    plan1_response.rt = _plan1_response_allKeys[-1].rt
                    plan1_response.duration = _plan1_response_allKeys[-1].duration
                    # a response ends the routine
                    continueRoutine = False
            
            # *babyleft* updates
            
            # if babyleft is starting this frame...
            if babyleft.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
                # keep track of start time/frame for later
                babyleft.frameNStart = frameN  # exact frame index
                babyleft.tStart = t  # local t and not account for scr refresh
                babyleft.tStartRefresh = tThisFlipGlobal  # on global time
                win.timeOnFlip(babyleft, 'tStartRefresh')  # time at next scr refresh
                # add timestamp to datafile
                thisExp.timestampOnFlip(win, 'babyleft.started')
                # update status
                babyleft.status = STARTED
                babyleft.setAutoDraw(True)
            
            # if babyleft is active this frame...
            if babyleft.status == STARTED:
                # update params
                pass
            
            # *toothbrushright* updates
            
            # if toothbrushright is starting this frame...
            if toothbrushright.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
                # keep track of start time/frame for later
                toothbrushright.frameNStart = frameN  # exact frame index
                toothbrushright.tStart = t  # local t and not account for scr refresh
                toothbrushright.tStartRefresh = tThisFlipGlobal  # on global time
                win.timeOnFlip(toothbrushright, 'tStartRefresh')  # time at next scr refresh
                # add timestamp to datafile
                thisExp.timestampOnFlip(win, 'toothbrushright.started')
                # update status
                toothbrushright.status = STARTED
                toothbrushright.setAutoDraw(True)
            
            # if toothbrushright is active this frame...
            if toothbrushright.status == STARTED:
                # update params
                pass
            
            # *text_117* updates
            
            # if text_117 is starting this frame...
            if text_117.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
                # keep track of start time/frame for later
                text_117.frameNStart = frameN  # exact frame index
                text_117.tStart = t  # local t and not account for scr refresh
                text_117.tStartRefresh = tThisFlipGlobal  # on global time
                win.timeOnFlip(text_117, 'tStartRefresh')  # time at next scr refresh
                # add timestamp to datafile
                thisExp.timestampOnFlip(win, 'text_117.started')
                # update status
                text_117.status = STARTED
                text_117.setAutoDraw(True)
            
            # if text_117 is active this frame...
            if text_117.status == STARTED:
                # update params
                pass
            
            # *text_120* updates
            
            # if text_120 is starting this frame...
            if text_120.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
                # keep track of start time/frame for later
                text_120.frameNStart = frameN  # exact frame index
                text_120.tStart = t  # local t and not account for scr refresh
                text_120.tStartRefresh = tThisFlipGlobal  # on global time
                win.timeOnFlip(text_120, 'tStartRefresh')  # time at next scr refresh
                # add timestamp to datafile
                thisExp.timestampOnFlip(win, 'text_120.started')
                # update status
                text_120.status = STARTED
                text_120.setAutoDraw(True)
            
            # if text_120 is active this frame...
            if text_120.status == STARTED:
                # update params
                pass
            
            # check for quit (typically the Esc key)
            if defaultKeyboard.getKeys(keyList=["escape"]):
                thisExp.status = FINISHED
            if thisExp.status == FINISHED or endExpNow:
                endExperiment(thisExp, inputs=inputs, win=win)
                return
            
            # check if all components have finished
            if not continueRoutine:  # a component has requested a forced-end of Routine
                routineForceEnded = True
                break
            continueRoutine = False  # will revert to True if at least one component still running
            for thisComponent in plan1_info_2Components:
                if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:
                    continueRoutine = True
                    break  # at least one component has not yet finished
            
            # refresh the screen
            if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen
                win.flip()
        
        # --- Ending Routine "plan1_info_2" ---
        for thisComponent in plan1_info_2Components:
            if hasattr(thisComponent, "setAutoDraw"):
                thisComponent.setAutoDraw(False)
        thisExp.addData('plan1_info_2.stopped', globalClock.getTime())
        # check responses
        if plan1_response.keys in ['', [], None]:  # No response was made
            plan1_response.keys = None
        planning_loop.addData('plan1_response.keys',plan1_response.keys)
        if plan1_response.keys != None:  # we had a response
            planning_loop.addData('plan1_response.rt', plan1_response.rt)
            planning_loop.addData('plan1_response.duration', plan1_response.duration)
        # the Routine "plan1_info_2" was not non-slip safe, so reset the non-slip timer
        routineTimer.reset()
        
        # --- Prepare to start Routine "plan2_info" ---
        continueRoutine = True
        # update component parameters for each repeat
        thisExp.addData('plan2_info.started', globalClock.getTime())
        # Run 'Begin Routine' code from code_7
        if plan1_response.keys=='space':
            total_planning+=100
            if random.random()>0.5:
                x='baby'
            else:
                x='toothbrush'
        elif plan1_response.keys=='left':
            x='baby'
        elif plan1_response.keys=='right':
            x='toothbrush'
        current_image='images/'+x+'.png'
        R1_2.setImage('images/computer.png')
        R2_2.setImage(r2)
        plan2_response.keys = []
        plan2_response.rt = []
        _plan2_response_allKeys = []
        current_image_decision2.setImage(current_image)
        text_118.setText(total_planning)
        # keep track of which components have finished
        plan2_infoComponents = [text_7, R1_2, R2_2, rew1_2, rew2_2, text_10, plan2_response, current_image_decision2, text_118, text_121]
        for thisComponent in plan2_infoComponents:
            thisComponent.tStart = None
            thisComponent.tStop = None
            thisComponent.tStartRefresh = None
            thisComponent.tStopRefresh = None
            if hasattr(thisComponent, 'status'):
                thisComponent.status = NOT_STARTED
        # reset timers
        t = 0
        _timeToFirstFrame = win.getFutureFlipTime(clock="now")
        frameN = -1
        
        # --- Run Routine "plan2_info" ---
        routineForceEnded = not continueRoutine
        while continueRoutine:
            # get current time
            t = routineTimer.getTime()
            tThisFlip = win.getFutureFlipTime(clock=routineTimer)
            tThisFlipGlobal = win.getFutureFlipTime(clock=None)
            frameN = frameN + 1  # number of completed frames (so 0 is the first frame)
            # update/draw components on each frame
            
            # *text_7* updates
            
            # if text_7 is starting this frame...
            if text_7.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
                # keep track of start time/frame for later
                text_7.frameNStart = frameN  # exact frame index
                text_7.tStart = t  # local t and not account for scr refresh
                text_7.tStartRefresh = tThisFlipGlobal  # on global time
                win.timeOnFlip(text_7, 'tStartRefresh')  # time at next scr refresh
                # add timestamp to datafile
                thisExp.timestampOnFlip(win, 'text_7.started')
                # update status
                text_7.status = STARTED
                text_7.setAutoDraw(True)
            
            # if text_7 is active this frame...
            if text_7.status == STARTED:
                # update params
                pass
            
            # *R1_2* updates
            
            # if R1_2 is starting this frame...
            if R1_2.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
                # keep track of start time/frame for later
                R1_2.frameNStart = frameN  # exact frame index
                R1_2.tStart = t  # local t and not account for scr refresh
                R1_2.tStartRefresh = tThisFlipGlobal  # on global time
                win.timeOnFlip(R1_2, 'tStartRefresh')  # time at next scr refresh
                # add timestamp to datafile
                thisExp.timestampOnFlip(win, 'R1_2.started')
                # update status
                R1_2.status = STARTED
                R1_2.setAutoDraw(True)
            
            # if R1_2 is active this frame...
            if R1_2.status == STARTED:
                # update params
                pass
            
            # *R2_2* updates
            
            # if R2_2 is starting this frame...
            if R2_2.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
                # keep track of start time/frame for later
                R2_2.frameNStart = frameN  # exact frame index
                R2_2.tStart = t  # local t and not account for scr refresh
                R2_2.tStartRefresh = tThisFlipGlobal  # on global time
                win.timeOnFlip(R2_2, 'tStartRefresh')  # time at next scr refresh
                # add timestamp to datafile
                thisExp.timestampOnFlip(win, 'R2_2.started')
                # update status
                R2_2.status = STARTED
                R2_2.setAutoDraw(True)
            
            # if R2_2 is active this frame...
            if R2_2.status == STARTED:
                # update params
                pass
            
            # *rew1_2* updates
            
            # if rew1_2 is starting this frame...
            if rew1_2.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
                # keep track of start time/frame for later
                rew1_2.frameNStart = frameN  # exact frame index
                rew1_2.tStart = t  # local t and not account for scr refresh
                rew1_2.tStartRefresh = tThisFlipGlobal  # on global time
                win.timeOnFlip(rew1_2, 'tStartRefresh')  # time at next scr refresh
                # add timestamp to datafile
                thisExp.timestampOnFlip(win, 'rew1_2.started')
                # update status
                rew1_2.status = STARTED
                rew1_2.setAutoDraw(True)
            
            # if rew1_2 is active this frame...
            if rew1_2.status == STARTED:
                # update params
                pass
            
            # *rew2_2* updates
            
            # if rew2_2 is starting this frame...
            if rew2_2.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
                # keep track of start time/frame for later
                rew2_2.frameNStart = frameN  # exact frame index
                rew2_2.tStart = t  # local t and not account for scr refresh
                rew2_2.tStartRefresh = tThisFlipGlobal  # on global time
                win.timeOnFlip(rew2_2, 'tStartRefresh')  # time at next scr refresh
                # add timestamp to datafile
                thisExp.timestampOnFlip(win, 'rew2_2.started')
                # update status
                rew2_2.status = STARTED
                rew2_2.setAutoDraw(True)
            
            # if rew2_2 is active this frame...
            if rew2_2.status == STARTED:
                # update params
                rew2_2.setText(w2, log=False)
            
            # *text_10* updates
            
            # if text_10 is starting this frame...
            if text_10.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
                # keep track of start time/frame for later
                text_10.frameNStart = frameN  # exact frame index
                text_10.tStart = t  # local t and not account for scr refresh
                text_10.tStartRefresh = tThisFlipGlobal  # on global time
                win.timeOnFlip(text_10, 'tStartRefresh')  # time at next scr refresh
                # add timestamp to datafile
                thisExp.timestampOnFlip(win, 'text_10.started')
                # update status
                text_10.status = STARTED
                text_10.setAutoDraw(True)
            
            # if text_10 is active this frame...
            if text_10.status == STARTED:
                # update params
                pass
            
            # *plan2_response* updates
            waitOnFlip = False
            
            # if plan2_response is starting this frame...
            if plan2_response.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
                # keep track of start time/frame for later
                plan2_response.frameNStart = frameN  # exact frame index
                plan2_response.tStart = t  # local t and not account for scr refresh
                plan2_response.tStartRefresh = tThisFlipGlobal  # on global time
                win.timeOnFlip(plan2_response, 'tStartRefresh')  # time at next scr refresh
                # add timestamp to datafile
                thisExp.timestampOnFlip(win, 'plan2_response.started')
                # update status
                plan2_response.status = STARTED
                # keyboard checking is just starting
                waitOnFlip = True
                win.callOnFlip(plan2_response.clock.reset)  # t=0 on next screen flip
                win.callOnFlip(plan2_response.clearEvents, eventType='keyboard')  # clear events on next screen flip
            if plan2_response.status == STARTED and not waitOnFlip:
                theseKeys = plan2_response.getKeys(keyList=['left', 'right','space'], ignoreKeys=["escape"], waitRelease=False)
                _plan2_response_allKeys.extend(theseKeys)
                if len(_plan2_response_allKeys):
                    plan2_response.keys = _plan2_response_allKeys[-1].name  # just the last key pressed
                    plan2_response.rt = _plan2_response_allKeys[-1].rt
                    plan2_response.duration = _plan2_response_allKeys[-1].duration
                    # a response ends the routine
                    continueRoutine = False
            
            # *current_image_decision2* updates
            
            # if current_image_decision2 is starting this frame...
            if current_image_decision2.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
                # keep track of start time/frame for later
                current_image_decision2.frameNStart = frameN  # exact frame index
                current_image_decision2.tStart = t  # local t and not account for scr refresh
                current_image_decision2.tStartRefresh = tThisFlipGlobal  # on global time
                win.timeOnFlip(current_image_decision2, 'tStartRefresh')  # time at next scr refresh
                # add timestamp to datafile
                thisExp.timestampOnFlip(win, 'current_image_decision2.started')
                # update status
                current_image_decision2.status = STARTED
                current_image_decision2.setAutoDraw(True)
            
            # if current_image_decision2 is active this frame...
            if current_image_decision2.status == STARTED:
                # update params
                pass
            
            # *text_118* updates
            
            # if text_118 is starting this frame...
            if text_118.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
                # keep track of start time/frame for later
                text_118.frameNStart = frameN  # exact frame index
                text_118.tStart = t  # local t and not account for scr refresh
                text_118.tStartRefresh = tThisFlipGlobal  # on global time
                win.timeOnFlip(text_118, 'tStartRefresh')  # time at next scr refresh
                # add timestamp to datafile
                thisExp.timestampOnFlip(win, 'text_118.started')
                # update status
                text_118.status = STARTED
                text_118.setAutoDraw(True)
            
            # if text_118 is active this frame...
            if text_118.status == STARTED:
                # update params
                pass
            
            # *text_121* updates
            
            # if text_121 is starting this frame...
            if text_121.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
                # keep track of start time/frame for later
                text_121.frameNStart = frameN  # exact frame index
                text_121.tStart = t  # local t and not account for scr refresh
                text_121.tStartRefresh = tThisFlipGlobal  # on global time
                win.timeOnFlip(text_121, 'tStartRefresh')  # time at next scr refresh
                # add timestamp to datafile
                thisExp.timestampOnFlip(win, 'text_121.started')
                # update status
                text_121.status = STARTED
                text_121.setAutoDraw(True)
            
            # if text_121 is active this frame...
            if text_121.status == STARTED:
                # update params
                pass
            
            # check for quit (typically the Esc key)
            if defaultKeyboard.getKeys(keyList=["escape"]):
                thisExp.status = FINISHED
            if thisExp.status == FINISHED or endExpNow:
                endExperiment(thisExp, inputs=inputs, win=win)
                return
            
            # check if all components have finished
            if not continueRoutine:  # a component has requested a forced-end of Routine
                routineForceEnded = True
                break
            continueRoutine = False  # will revert to True if at least one component still running
            for thisComponent in plan2_infoComponents:
                if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:
                    continueRoutine = True
                    break  # at least one component has not yet finished
            
            # refresh the screen
            if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen
                win.flip()
        
        # --- Ending Routine "plan2_info" ---
        for thisComponent in plan2_infoComponents:
            if hasattr(thisComponent, "setAutoDraw"):
                thisComponent.setAutoDraw(False)
        thisExp.addData('plan2_info.stopped', globalClock.getTime())
        # check responses
        if plan2_response.keys in ['', [], None]:  # No response was made
            plan2_response.keys = None
        planning_loop.addData('plan2_response.keys',plan2_response.keys)
        if plan2_response.keys != None:  # we had a response
            planning_loop.addData('plan2_response.rt', plan2_response.rt)
            planning_loop.addData('plan2_response.duration', plan2_response.duration)
        # the Routine "plan2_info" was not non-slip safe, so reset the non-slip timer
        routineTimer.reset()
        
        # --- Prepare to start Routine "plan3_info" ---
        continueRoutine = True
        # update component parameters for each repeat
        thisExp.addData('plan3_info.started', globalClock.getTime())
        # Run 'Begin Routine' code from code_9
        if plan2_response.keys=='space':
            total_planning += 100;
            if random.random()>0.5:
                x='left'
            else:
                x='right'
        elif plan2_response.keys=='left':
            x='left'
        elif plan2_response.keys=='right':
            x='right' 
        current_image2='images/'+cogmap[current_image[7:-4]+'_'+x]+'.png'
        R2_3.setImage(r2)
        plan3_response.keys = []
        plan3_response.rt = []
        _plan3_response_allKeys = []
        current_image_decision3.setImage(current_image2)
        text_122.setText(total_planning)
        # keep track of which components have finished
        plan3_infoComponents = [text_14, R1_3, R2_3, rew1_3, rew2_3, text_15, plan3_response, current_image_decision3, text_122, text_123]
        for thisComponent in plan3_infoComponents:
            thisComponent.tStart = None
            thisComponent.tStop = None
            thisComponent.tStartRefresh = None
            thisComponent.tStopRefresh = None
            if hasattr(thisComponent, 'status'):
                thisComponent.status = NOT_STARTED
        # reset timers
        t = 0
        _timeToFirstFrame = win.getFutureFlipTime(clock="now")
        frameN = -1
        
        # --- Run Routine "plan3_info" ---
        routineForceEnded = not continueRoutine
        while continueRoutine:
            # get current time
            t = routineTimer.getTime()
            tThisFlip = win.getFutureFlipTime(clock=routineTimer)
            tThisFlipGlobal = win.getFutureFlipTime(clock=None)
            frameN = frameN + 1  # number of completed frames (so 0 is the first frame)
            # update/draw components on each frame
            
            # *text_14* updates
            
            # if text_14 is starting this frame...
            if text_14.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
                # keep track of start time/frame for later
                text_14.frameNStart = frameN  # exact frame index
                text_14.tStart = t  # local t and not account for scr refresh
                text_14.tStartRefresh = tThisFlipGlobal  # on global time
                win.timeOnFlip(text_14, 'tStartRefresh')  # time at next scr refresh
                # add timestamp to datafile
                thisExp.timestampOnFlip(win, 'text_14.started')
                # update status
                text_14.status = STARTED
                text_14.setAutoDraw(True)
            
            # if text_14 is active this frame...
            if text_14.status == STARTED:
                # update params
                pass
            
            # *R1_3* updates
            
            # if R1_3 is starting this frame...
            if R1_3.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
                # keep track of start time/frame for later
                R1_3.frameNStart = frameN  # exact frame index
                R1_3.tStart = t  # local t and not account for scr refresh
                R1_3.tStartRefresh = tThisFlipGlobal  # on global time
                win.timeOnFlip(R1_3, 'tStartRefresh')  # time at next scr refresh
                # add timestamp to datafile
                thisExp.timestampOnFlip(win, 'R1_3.started')
                # update status
                R1_3.status = STARTED
                R1_3.setAutoDraw(True)
            
            # if R1_3 is active this frame...
            if R1_3.status == STARTED:
                # update params
                pass
            
            # *R2_3* updates
            
            # if R2_3 is starting this frame...
            if R2_3.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
                # keep track of start time/frame for later
                R2_3.frameNStart = frameN  # exact frame index
                R2_3.tStart = t  # local t and not account for scr refresh
                R2_3.tStartRefresh = tThisFlipGlobal  # on global time
                win.timeOnFlip(R2_3, 'tStartRefresh')  # time at next scr refresh
                # add timestamp to datafile
                thisExp.timestampOnFlip(win, 'R2_3.started')
                # update status
                R2_3.status = STARTED
                R2_3.setAutoDraw(True)
            
            # if R2_3 is active this frame...
            if R2_3.status == STARTED:
                # update params
                pass
            
            # *rew1_3* updates
            
            # if rew1_3 is starting this frame...
            if rew1_3.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
                # keep track of start time/frame for later
                rew1_3.frameNStart = frameN  # exact frame index
                rew1_3.tStart = t  # local t and not account for scr refresh
                rew1_3.tStartRefresh = tThisFlipGlobal  # on global time
                win.timeOnFlip(rew1_3, 'tStartRefresh')  # time at next scr refresh
                # add timestamp to datafile
                thisExp.timestampOnFlip(win, 'rew1_3.started')
                # update status
                rew1_3.status = STARTED
                rew1_3.setAutoDraw(True)
            
            # if rew1_3 is active this frame...
            if rew1_3.status == STARTED:
                # update params
                pass
            
            # *rew2_3* updates
            
            # if rew2_3 is starting this frame...
            if rew2_3.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
                # keep track of start time/frame for later
                rew2_3.frameNStart = frameN  # exact frame index
                rew2_3.tStart = t  # local t and not account for scr refresh
                rew2_3.tStartRefresh = tThisFlipGlobal  # on global time
                win.timeOnFlip(rew2_3, 'tStartRefresh')  # time at next scr refresh
                # add timestamp to datafile
                thisExp.timestampOnFlip(win, 'rew2_3.started')
                # update status
                rew2_3.status = STARTED
                rew2_3.setAutoDraw(True)
            
            # if rew2_3 is active this frame...
            if rew2_3.status == STARTED:
                # update params
                rew2_3.setText(w2, log=False)
            
            # *text_15* updates
            
            # if text_15 is starting this frame...
            if text_15.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
                # keep track of start time/frame for later
                text_15.frameNStart = frameN  # exact frame index
                text_15.tStart = t  # local t and not account for scr refresh
                text_15.tStartRefresh = tThisFlipGlobal  # on global time
                win.timeOnFlip(text_15, 'tStartRefresh')  # time at next scr refresh
                # add timestamp to datafile
                thisExp.timestampOnFlip(win, 'text_15.started')
                # update status
                text_15.status = STARTED
                text_15.setAutoDraw(True)
            
            # if text_15 is active this frame...
            if text_15.status == STARTED:
                # update params
                pass
            
            # *plan3_response* updates
            waitOnFlip = False
            
            # if plan3_response is starting this frame...
            if plan3_response.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
                # keep track of start time/frame for later
                plan3_response.frameNStart = frameN  # exact frame index
                plan3_response.tStart = t  # local t and not account for scr refresh
                plan3_response.tStartRefresh = tThisFlipGlobal  # on global time
                win.timeOnFlip(plan3_response, 'tStartRefresh')  # time at next scr refresh
                # add timestamp to datafile
                thisExp.timestampOnFlip(win, 'plan3_response.started')
                # update status
                plan3_response.status = STARTED
                # keyboard checking is just starting
                waitOnFlip = True
                win.callOnFlip(plan3_response.clock.reset)  # t=0 on next screen flip
                win.callOnFlip(plan3_response.clearEvents, eventType='keyboard')  # clear events on next screen flip
            if plan3_response.status == STARTED and not waitOnFlip:
                theseKeys = plan3_response.getKeys(keyList=['left', 'right','space'], ignoreKeys=["escape"], waitRelease=False)
                _plan3_response_allKeys.extend(theseKeys)
                if len(_plan3_response_allKeys):
                    plan3_response.keys = _plan3_response_allKeys[-1].name  # just the last key pressed
                    plan3_response.rt = _plan3_response_allKeys[-1].rt
                    plan3_response.duration = _plan3_response_allKeys[-1].duration
                    # a response ends the routine
                    continueRoutine = False
            
            # *current_image_decision3* updates
            
            # if current_image_decision3 is starting this frame...
            if current_image_decision3.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
                # keep track of start time/frame for later
                current_image_decision3.frameNStart = frameN  # exact frame index
                current_image_decision3.tStart = t  # local t and not account for scr refresh
                current_image_decision3.tStartRefresh = tThisFlipGlobal  # on global time
                win.timeOnFlip(current_image_decision3, 'tStartRefresh')  # time at next scr refresh
                # add timestamp to datafile
                thisExp.timestampOnFlip(win, 'current_image_decision3.started')
                # update status
                current_image_decision3.status = STARTED
                current_image_decision3.setAutoDraw(True)
            
            # if current_image_decision3 is active this frame...
            if current_image_decision3.status == STARTED:
                # update params
                pass
            
            # *text_122* updates
            
            # if text_122 is starting this frame...
            if text_122.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
                # keep track of start time/frame for later
                text_122.frameNStart = frameN  # exact frame index
                text_122.tStart = t  # local t and not account for scr refresh
                text_122.tStartRefresh = tThisFlipGlobal  # on global time
                win.timeOnFlip(text_122, 'tStartRefresh')  # time at next scr refresh
                # add timestamp to datafile
                thisExp.timestampOnFlip(win, 'text_122.started')
                # update status
                text_122.status = STARTED
                text_122.setAutoDraw(True)
            
            # if text_122 is active this frame...
            if text_122.status == STARTED:
                # update params
                pass
            
            # *text_123* updates
            
            # if text_123 is starting this frame...
            if text_123.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
                # keep track of start time/frame for later
                text_123.frameNStart = frameN  # exact frame index
                text_123.tStart = t  # local t and not account for scr refresh
                text_123.tStartRefresh = tThisFlipGlobal  # on global time
                win.timeOnFlip(text_123, 'tStartRefresh')  # time at next scr refresh
                # add timestamp to datafile
                thisExp.timestampOnFlip(win, 'text_123.started')
                # update status
                text_123.status = STARTED
                text_123.setAutoDraw(True)
            
            # if text_123 is active this frame...
            if text_123.status == STARTED:
                # update params
                pass
            
            # check for quit (typically the Esc key)
            if defaultKeyboard.getKeys(keyList=["escape"]):
                thisExp.status = FINISHED
            if thisExp.status == FINISHED or endExpNow:
                endExperiment(thisExp, inputs=inputs, win=win)
                return
            
            # check if all components have finished
            if not continueRoutine:  # a component has requested a forced-end of Routine
                routineForceEnded = True
                break
            continueRoutine = False  # will revert to True if at least one component still running
            for thisComponent in plan3_infoComponents:
                if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:
                    continueRoutine = True
                    break  # at least one component has not yet finished
            
            # refresh the screen
            if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen
                win.flip()
        
        # --- Ending Routine "plan3_info" ---
        for thisComponent in plan3_infoComponents:
            if hasattr(thisComponent, "setAutoDraw"):
                thisComponent.setAutoDraw(False)
        thisExp.addData('plan3_info.stopped', globalClock.getTime())
        # check responses
        if plan3_response.keys in ['', [], None]:  # No response was made
            plan3_response.keys = None
        planning_loop.addData('plan3_response.keys',plan3_response.keys)
        if plan3_response.keys != None:  # we had a response
            planning_loop.addData('plan3_response.rt', plan3_response.rt)
            planning_loop.addData('plan3_response.duration', plan3_response.duration)
        # the Routine "plan3_info" was not non-slip safe, so reset the non-slip timer
        routineTimer.reset()
        
        # --- Prepare to start Routine "planning4" ---
        continueRoutine = True
        # update component parameters for each repeat
        thisExp.addData('planning4.started', globalClock.getTime())
        # Run 'Begin Routine' code from code_25
        if current_image3==r2:
            total_planning+=w2
        image_4.setImage(current_image3)
        text_119.setText(total_planning)
        # keep track of which components have finished
        planning4Components = [image_4, text_19, text_119, text_131]
        for thisComponent in planning4Components:
            thisComponent.tStart = None
            thisComponent.tStop = None
            thisComponent.tStartRefresh = None
            thisComponent.tStopRefresh = None
            if hasattr(thisComponent, 'status'):
                thisComponent.status = NOT_STARTED
        # reset timers
        t = 0
        _timeToFirstFrame = win.getFutureFlipTime(clock="now")
        frameN = -1
        
        # --- Run Routine "planning4" ---
        routineForceEnded = not continueRoutine
        while continueRoutine and routineTimer.getTime() < 2.0:
            # get current time
            t = routineTimer.getTime()
            tThisFlip = win.getFutureFlipTime(clock=routineTimer)
            tThisFlipGlobal = win.getFutureFlipTime(clock=None)
            frameN = frameN + 1  # number of completed frames (so 0 is the first frame)
            # update/draw components on each frame
            
            # *image_4* updates
            
            # if image_4 is starting this frame...
            if image_4.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
                # keep track of start time/frame for later
                image_4.frameNStart = frameN  # exact frame index
                image_4.tStart = t  # local t and not account for scr refresh
                image_4.tStartRefresh = tThisFlipGlobal  # on global time
                win.timeOnFlip(image_4, 'tStartRefresh')  # time at next scr refresh
                # add timestamp to datafile
                thisExp.timestampOnFlip(win, 'image_4.started')
                # update status
                image_4.status = STARTED
                image_4.setAutoDraw(True)
            
            # if image_4 is active this frame...
            if image_4.status == STARTED:
                # update params
                pass
            
            # if image_4 is stopping this frame...
            if image_4.status == STARTED:
                # is it time to stop? (based on global clock, using actual start)
                if tThisFlipGlobal > image_4.tStartRefresh + 2.0-frameTolerance:
                    # keep track of stop time/frame for later
                    image_4.tStop = t  # not accounting for scr refresh
                    image_4.frameNStop = frameN  # exact frame index
                    # add timestamp to datafile
                    thisExp.timestampOnFlip(win, 'image_4.stopped')
                    # update status
                    image_4.status = FINISHED
                    image_4.setAutoDraw(False)
            
            # *text_19* updates
            
            # if text_19 is starting this frame...
            if text_19.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
                # keep track of start time/frame for later
                text_19.frameNStart = frameN  # exact frame index
                text_19.tStart = t  # local t and not account for scr refresh
                text_19.tStartRefresh = tThisFlipGlobal  # on global time
                win.timeOnFlip(text_19, 'tStartRefresh')  # time at next scr refresh
                # add timestamp to datafile
                thisExp.timestampOnFlip(win, 'text_19.started')
                # update status
                text_19.status = STARTED
                text_19.setAutoDraw(True)
            
            # if text_19 is active this frame...
            if text_19.status == STARTED:
                # update params
                pass
            
            # if text_19 is stopping this frame...
            if text_19.status == STARTED:
                # is it time to stop? (based on global clock, using actual start)
                if tThisFlipGlobal > text_19.tStartRefresh + 2.0-frameTolerance:
                    # keep track of stop time/frame for later
                    text_19.tStop = t  # not accounting for scr refresh
                    text_19.frameNStop = frameN  # exact frame index
                    # add timestamp to datafile
                    thisExp.timestampOnFlip(win, 'text_19.stopped')
                    # update status
                    text_19.status = FINISHED
                    text_19.setAutoDraw(False)
            
            # *text_119* updates
            
            # if text_119 is starting this frame...
            if text_119.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
                # keep track of start time/frame for later
                text_119.frameNStart = frameN  # exact frame index
                text_119.tStart = t  # local t and not account for scr refresh
                text_119.tStartRefresh = tThisFlipGlobal  # on global time
                win.timeOnFlip(text_119, 'tStartRefresh')  # time at next scr refresh
                # add timestamp to datafile
                thisExp.timestampOnFlip(win, 'text_119.started')
                # update status
                text_119.status = STARTED
                text_119.setAutoDraw(True)
            
            # if text_119 is active this frame...
            if text_119.status == STARTED:
                # update params
                pass
            
            # if text_119 is stopping this frame...
            if text_119.status == STARTED:
                # is it time to stop? (based on global clock, using actual start)
                if tThisFlipGlobal > text_119.tStartRefresh + 2.0-frameTolerance:
                    # keep track of stop time/frame for later
                    text_119.tStop = t  # not accounting for scr refresh
                    text_119.frameNStop = frameN  # exact frame index
                    # add timestamp to datafile
                    thisExp.timestampOnFlip(win, 'text_119.stopped')
                    # update status
                    text_119.status = FINISHED
                    text_119.setAutoDraw(False)
            
            # *text_131* updates
            
            # if text_131 is starting this frame...
            if text_131.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
                # keep track of start time/frame for later
                text_131.frameNStart = frameN  # exact frame index
                text_131.tStart = t  # local t and not account for scr refresh
                text_131.tStartRefresh = tThisFlipGlobal  # on global time
                win.timeOnFlip(text_131, 'tStartRefresh')  # time at next scr refresh
                # add timestamp to datafile
                thisExp.timestampOnFlip(win, 'text_131.started')
                # update status
                text_131.status = STARTED
                text_131.setAutoDraw(True)
            
            # if text_131 is active this frame...
            if text_131.status == STARTED:
                # update params
                pass
            
            # if text_131 is stopping this frame...
            if text_131.status == STARTED:
                # is it time to stop? (based on global clock, using actual start)
                if tThisFlipGlobal > text_131.tStartRefresh + 2.0-frameTolerance:
                    # keep track of stop time/frame for later
                    text_131.tStop = t  # not accounting for scr refresh
                    text_131.frameNStop = frameN  # exact frame index
                    # add timestamp to datafile
                    thisExp.timestampOnFlip(win, 'text_131.stopped')
                    # update status
                    text_131.status = FINISHED
                    text_131.setAutoDraw(False)
            
            # check for quit (typically the Esc key)
            if defaultKeyboard.getKeys(keyList=["escape"]):
                thisExp.status = FINISHED
            if thisExp.status == FINISHED or endExpNow:
                endExperiment(thisExp, inputs=inputs, win=win)
                return
            
            # check if all components have finished
            if not continueRoutine:  # a component has requested a forced-end of Routine
                routineForceEnded = True
                break
            continueRoutine = False  # will revert to True if at least one component still running
            for thisComponent in planning4Components:
                if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:
                    continueRoutine = True
                    break  # at least one component has not yet finished
            
            # refresh the screen
            if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen
                win.flip()
        
        # --- Ending Routine "planning4" ---
        for thisComponent in planning4Components:
            if hasattr(thisComponent, "setAutoDraw"):
                thisComponent.setAutoDraw(False)
        thisExp.addData('planning4.stopped', globalClock.getTime())
        # using non-slip timing so subtract the expected duration of this Routine (unless ended on request)
        if routineForceEnded:
            routineTimer.reset()
        else:
            routineTimer.addTime(-2.000000)
        
        # --- Prepare to start Routine "next_trial" ---
        continueRoutine = True
        # update component parameters for each repeat
        thisExp.addData('next_trial.started', globalClock.getTime())
        # keep track of which components have finished
        next_trialComponents = [next_trial_text]
        for thisComponent in next_trialComponents:
            thisComponent.tStart = None
            thisComponent.tStop = None
            thisComponent.tStartRefresh = None
            thisComponent.tStopRefresh = None
            if hasattr(thisComponent, 'status'):
                thisComponent.status = NOT_STARTED
        # reset timers
        t = 0
        _timeToFirstFrame = win.getFutureFlipTime(clock="now")
        frameN = -1
        
        # --- Run Routine "next_trial" ---
        routineForceEnded = not continueRoutine
        while continueRoutine and routineTimer.getTime() < 1.0:
            # get current time
            t = routineTimer.getTime()
            tThisFlip = win.getFutureFlipTime(clock=routineTimer)
            tThisFlipGlobal = win.getFutureFlipTime(clock=None)
            frameN = frameN + 1  # number of completed frames (so 0 is the first frame)
            # update/draw components on each frame
            
            # *next_trial_text* updates
            
            # if next_trial_text is starting this frame...
            if next_trial_text.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
                # keep track of start time/frame for later
                next_trial_text.frameNStart = frameN  # exact frame index
                next_trial_text.tStart = t  # local t and not account for scr refresh
                next_trial_text.tStartRefresh = tThisFlipGlobal  # on global time
                win.timeOnFlip(next_trial_text, 'tStartRefresh')  # time at next scr refresh
                # add timestamp to datafile
                thisExp.timestampOnFlip(win, 'next_trial_text.started')
                # update status
                next_trial_text.status = STARTED
                next_trial_text.setAutoDraw(True)
            
            # if next_trial_text is active this frame...
            if next_trial_text.status == STARTED:
                # update params
                pass
            
            # if next_trial_text is stopping this frame...
            if next_trial_text.status == STARTED:
                # is it time to stop? (based on global clock, using actual start)
                if tThisFlipGlobal > next_trial_text.tStartRefresh + 1-frameTolerance:
                    # keep track of stop time/frame for later
                    next_trial_text.tStop = t  # not accounting for scr refresh
                    next_trial_text.frameNStop = frameN  # exact frame index
                    # add timestamp to datafile
                    thisExp.timestampOnFlip(win, 'next_trial_text.stopped')
                    # update status
                    next_trial_text.status = FINISHED
                    next_trial_text.setAutoDraw(False)
            
            # check for quit (typically the Esc key)
            if defaultKeyboard.getKeys(keyList=["escape"]):
                thisExp.status = FINISHED
            if thisExp.status == FINISHED or endExpNow:
                endExperiment(thisExp, inputs=inputs, win=win)
                return
            
            # check if all components have finished
            if not continueRoutine:  # a component has requested a forced-end of Routine
                routineForceEnded = True
                break
            continueRoutine = False  # will revert to True if at least one component still running
            for thisComponent in next_trialComponents:
                if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:
                    continueRoutine = True
                    break  # at least one component has not yet finished
            
            # refresh the screen
            if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen
                win.flip()
        
        # --- Ending Routine "next_trial" ---
        for thisComponent in next_trialComponents:
            if hasattr(thisComponent, "setAutoDraw"):
                thisComponent.setAutoDraw(False)
        thisExp.addData('next_trial.stopped', globalClock.getTime())
        # using non-slip timing so subtract the expected duration of this Routine (unless ended on request)
        if routineForceEnded:
            routineTimer.reset()
        else:
            routineTimer.addTime(-1.000000)
        thisExp.nextEntry()
        
        if thisSession is not None:
            # if running in a Session with a Liaison client, send data up to now
            thisSession.sendExperimentData()
    # completed 1.0 repeats of 'planning_loop'
    
    
    # --- Prepare to start Routine "planning_paths" ---
    continueRoutine = True
    # update component parameters for each repeat
    thisExp.addData('planning_paths.started', globalClock.getTime())
    # Run 'Begin Routine' code from code_42
    quiz1_count=1
    quiz_planning_corr=0
    
    key_resp_40.keys = []
    key_resp_40.rt = []
    _key_resp_40_allKeys = []
    # keep track of which components have finished
    planning_pathsComponents = [text_149, key_resp_40, text_49]
    for thisComponent in planning_pathsComponents:
        thisComponent.tStart = None
        thisComponent.tStop = None
        thisComponent.tStartRefresh = None
        thisComponent.tStopRefresh = None
        if hasattr(thisComponent, 'status'):
            thisComponent.status = NOT_STARTED
    # reset timers
    t = 0
    _timeToFirstFrame = win.getFutureFlipTime(clock="now")
    frameN = -1
    
    # --- Run Routine "planning_paths" ---
    routineForceEnded = not continueRoutine
    while continueRoutine:
        # get current time
        t = routineTimer.getTime()
        tThisFlip = win.getFutureFlipTime(clock=routineTimer)
        tThisFlipGlobal = win.getFutureFlipTime(clock=None)
        frameN = frameN + 1  # number of completed frames (so 0 is the first frame)
        # update/draw components on each frame
        
        # *text_149* updates
        
        # if text_149 is starting this frame...
        if text_149.status == NOT_STARTED and tThisFlip >= 0-frameTolerance:
            # keep track of start time/frame for later
            text_149.frameNStart = frameN  # exact frame index
            text_149.tStart = t  # local t and not account for scr refresh
            text_149.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(text_149, 'tStartRefresh')  # time at next scr refresh
            # add timestamp to datafile
            thisExp.timestampOnFlip(win, 'text_149.started')
            # update status
            text_149.status = STARTED
            text_149.setAutoDraw(True)
        
        # if text_149 is active this frame...
        if text_149.status == STARTED:
            # update params
            pass
        
        # *key_resp_40* updates
        waitOnFlip = False
        
        # if key_resp_40 is starting this frame...
        if key_resp_40.status == NOT_STARTED and tThisFlip >= 5.0-frameTolerance:
            # keep track of start time/frame for later
            key_resp_40.frameNStart = frameN  # exact frame index
            key_resp_40.tStart = t  # local t and not account for scr refresh
            key_resp_40.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(key_resp_40, 'tStartRefresh')  # time at next scr refresh
            # add timestamp to datafile
            thisExp.timestampOnFlip(win, 'key_resp_40.started')
            # update status
            key_resp_40.status = STARTED
            # keyboard checking is just starting
            waitOnFlip = True
            win.callOnFlip(key_resp_40.clock.reset)  # t=0 on next screen flip
            win.callOnFlip(key_resp_40.clearEvents, eventType='keyboard')  # clear events on next screen flip
        if key_resp_40.status == STARTED and not waitOnFlip:
            theseKeys = key_resp_40.getKeys(keyList=['space'], ignoreKeys=["escape"], waitRelease=False)
            _key_resp_40_allKeys.extend(theseKeys)
            if len(_key_resp_40_allKeys):
                key_resp_40.keys = _key_resp_40_allKeys[-1].name  # just the last key pressed
                key_resp_40.rt = _key_resp_40_allKeys[-1].rt
                key_resp_40.duration = _key_resp_40_allKeys[-1].duration
                # a response ends the routine
                continueRoutine = False
        
        # *text_49* updates
        
        # if text_49 is starting this frame...
        if text_49.status == NOT_STARTED and tThisFlip >= 5.0-frameTolerance:
            # keep track of start time/frame for later
            text_49.frameNStart = frameN  # exact frame index
            text_49.tStart = t  # local t and not account for scr refresh
            text_49.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(text_49, 'tStartRefresh')  # time at next scr refresh
            # add timestamp to datafile
            thisExp.timestampOnFlip(win, 'text_49.started')
            # update status
            text_49.status = STARTED
            text_49.setAutoDraw(True)
        
        # if text_49 is active this frame...
        if text_49.status == STARTED:
            # update params
            pass
        
        # check for quit (typically the Esc key)
        if defaultKeyboard.getKeys(keyList=["escape"]):
            thisExp.status = FINISHED
        if thisExp.status == FINISHED or endExpNow:
            endExperiment(thisExp, inputs=inputs, win=win)
            return
        
        # check if all components have finished
        if not continueRoutine:  # a component has requested a forced-end of Routine
            routineForceEnded = True
            break
        continueRoutine = False  # will revert to True if at least one component still running
        for thisComponent in planning_pathsComponents:
            if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:
                continueRoutine = True
                break  # at least one component has not yet finished
        
        # refresh the screen
        if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen
            win.flip()
    
    # --- Ending Routine "planning_paths" ---
    for thisComponent in planning_pathsComponents:
        if hasattr(thisComponent, "setAutoDraw"):
            thisComponent.setAutoDraw(False)
    thisExp.addData('planning_paths.stopped', globalClock.getTime())
    # check responses
    if key_resp_40.keys in ['', [], None]:  # No response was made
        key_resp_40.keys = None
    thisExp.addData('key_resp_40.keys',key_resp_40.keys)
    if key_resp_40.keys != None:  # we had a response
        thisExp.addData('key_resp_40.rt', key_resp_40.rt)
        thisExp.addData('key_resp_40.duration', key_resp_40.duration)
    thisExp.nextEntry()
    # the Routine "planning_paths" was not non-slip safe, so reset the non-slip timer
    routineTimer.reset()
    
    # set up handler to look after randomisation of conditions etc
    remember_planning_paths = data.TrialHandler(nReps=1.0, method='random', 
        extraInfo=expInfo, originPath=-1,
        trialList=data.importConditions('forgetting1.xlsx'),
        seed=None, name='remember_planning_paths')
    thisExp.addLoop(remember_planning_paths)  # add the loop to the experiment
    thisRemember_planning_path = remember_planning_paths.trialList[0]  # so we can initialise stimuli with some values
    # abbreviate parameter names if possible (e.g. rgb = thisRemember_planning_path.rgb)
    if thisRemember_planning_path != None:
        for paramName in thisRemember_planning_path:
            globals()[paramName] = thisRemember_planning_path[paramName]
    
    for thisRemember_planning_path in remember_planning_paths:
        currentLoop = remember_planning_paths
        thisExp.timestampOnFlip(win, 'thisRow.t')
        # pause experiment here if requested
        if thisExp.status == PAUSED:
            pauseExperiment(
                thisExp=thisExp, 
                inputs=inputs, 
                win=win, 
                timers=[routineTimer], 
                playbackComponents=[]
        )
        # abbreviate parameter names if possible (e.g. rgb = thisRemember_planning_path.rgb)
        if thisRemember_planning_path != None:
            for paramName in thisRemember_planning_path:
                globals()[paramName] = thisRemember_planning_path[paramName]
        
        # --- Prepare to start Routine "forgetting_paths1" ---
        continueRoutine = True
        # update component parameters for each repeat
        thisExp.addData('forgetting_paths1.started', globalClock.getTime())
        answer_quiz1_3.keys = []
        answer_quiz1_3.rt = []
        _answer_quiz1_3_allKeys = []
        answer1_3.setImage(ans1)
        answer2_3.setImage(ans2)
        answer3_3.setImage(ans3)
        # keep track of which components have finished
        forgetting_paths1Components = [question_quiz1_3, answer_quiz1_3, answer1_3, answer2_3, answer3_3, a1_3, a2_3, text_146]
        for thisComponent in forgetting_paths1Components:
            thisComponent.tStart = None
            thisComponent.tStop = None
            thisComponent.tStartRefresh = None
            thisComponent.tStopRefresh = None
            if hasattr(thisComponent, 'status'):
                thisComponent.status = NOT_STARTED
        # reset timers
        t = 0
        _timeToFirstFrame = win.getFutureFlipTime(clock="now")
        frameN = -1
        
        # --- Run Routine "forgetting_paths1" ---
        routineForceEnded = not continueRoutine
        while continueRoutine and routineTimer.getTime() < 120.0:
            # get current time
            t = routineTimer.getTime()
            tThisFlip = win.getFutureFlipTime(clock=routineTimer)
            tThisFlipGlobal = win.getFutureFlipTime(clock=None)
            frameN = frameN + 1  # number of completed frames (so 0 is the first frame)
            # update/draw components on each frame
            
            # *question_quiz1_3* updates
            
            # if question_quiz1_3 is starting this frame...
            if question_quiz1_3.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
                # keep track of start time/frame for later
                question_quiz1_3.frameNStart = frameN  # exact frame index
                question_quiz1_3.tStart = t  # local t and not account for scr refresh
                question_quiz1_3.tStartRefresh = tThisFlipGlobal  # on global time
                win.timeOnFlip(question_quiz1_3, 'tStartRefresh')  # time at next scr refresh
                # add timestamp to datafile
                thisExp.timestampOnFlip(win, 'question_quiz1_3.started')
                # update status
                question_quiz1_3.status = STARTED
                question_quiz1_3.setAutoDraw(True)
            
            # if question_quiz1_3 is active this frame...
            if question_quiz1_3.status == STARTED:
                # update params
                pass
            
            # if question_quiz1_3 is stopping this frame...
            if question_quiz1_3.status == STARTED:
                # is it time to stop? (based on global clock, using actual start)
                if tThisFlipGlobal > question_quiz1_3.tStartRefresh + 120-frameTolerance:
                    # keep track of stop time/frame for later
                    question_quiz1_3.tStop = t  # not accounting for scr refresh
                    question_quiz1_3.frameNStop = frameN  # exact frame index
                    # add timestamp to datafile
                    thisExp.timestampOnFlip(win, 'question_quiz1_3.stopped')
                    # update status
                    question_quiz1_3.status = FINISHED
                    question_quiz1_3.setAutoDraw(False)
            
            # *answer_quiz1_3* updates
            waitOnFlip = False
            
            # if answer_quiz1_3 is starting this frame...
            if answer_quiz1_3.status == NOT_STARTED and tThisFlip >= 0-frameTolerance:
                # keep track of start time/frame for later
                answer_quiz1_3.frameNStart = frameN  # exact frame index
                answer_quiz1_3.tStart = t  # local t and not account for scr refresh
                answer_quiz1_3.tStartRefresh = tThisFlipGlobal  # on global time
                win.timeOnFlip(answer_quiz1_3, 'tStartRefresh')  # time at next scr refresh
                # add timestamp to datafile
                thisExp.timestampOnFlip(win, 'answer_quiz1_3.started')
                # update status
                answer_quiz1_3.status = STARTED
                # keyboard checking is just starting
                waitOnFlip = True
                win.callOnFlip(answer_quiz1_3.clock.reset)  # t=0 on next screen flip
                win.callOnFlip(answer_quiz1_3.clearEvents, eventType='keyboard')  # clear events on next screen flip
            
            # if answer_quiz1_3 is stopping this frame...
            if answer_quiz1_3.status == STARTED:
                # is it time to stop? (based on global clock, using actual start)
                if tThisFlipGlobal > answer_quiz1_3.tStartRefresh + 120-frameTolerance:
                    # keep track of stop time/frame for later
                    answer_quiz1_3.tStop = t  # not accounting for scr refresh
                    answer_quiz1_3.frameNStop = frameN  # exact frame index
                    # add timestamp to datafile
                    thisExp.timestampOnFlip(win, 'answer_quiz1_3.stopped')
                    # update status
                    answer_quiz1_3.status = FINISHED
                    answer_quiz1_3.status = FINISHED
            if answer_quiz1_3.status == STARTED and not waitOnFlip:
                theseKeys = answer_quiz1_3.getKeys(keyList=["left","right"], ignoreKeys=["escape"], waitRelease=False)
                _answer_quiz1_3_allKeys.extend(theseKeys)
                if len(_answer_quiz1_3_allKeys):
                    answer_quiz1_3.keys = _answer_quiz1_3_allKeys[0].name  # just the first key pressed
                    answer_quiz1_3.rt = _answer_quiz1_3_allKeys[0].rt
                    answer_quiz1_3.duration = _answer_quiz1_3_allKeys[0].duration
                    # was this correct?
                    if (answer_quiz1_3.keys == str(correct_answer1)) or (answer_quiz1_3.keys == correct_answer1):
                        answer_quiz1_3.corr = 1
                    else:
                        answer_quiz1_3.corr = 0
                    # a response ends the routine
                    continueRoutine = False
            
            # *answer1_3* updates
            
            # if answer1_3 is starting this frame...
            if answer1_3.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
                # keep track of start time/frame for later
                answer1_3.frameNStart = frameN  # exact frame index
                answer1_3.tStart = t  # local t and not account for scr refresh
                answer1_3.tStartRefresh = tThisFlipGlobal  # on global time
                win.timeOnFlip(answer1_3, 'tStartRefresh')  # time at next scr refresh
                # add timestamp to datafile
                thisExp.timestampOnFlip(win, 'answer1_3.started')
                # update status
                answer1_3.status = STARTED
                answer1_3.setAutoDraw(True)
            
            # if answer1_3 is active this frame...
            if answer1_3.status == STARTED:
                # update params
                pass
            
            # if answer1_3 is stopping this frame...
            if answer1_3.status == STARTED:
                # is it time to stop? (based on global clock, using actual start)
                if tThisFlipGlobal > answer1_3.tStartRefresh + 120-frameTolerance:
                    # keep track of stop time/frame for later
                    answer1_3.tStop = t  # not accounting for scr refresh
                    answer1_3.frameNStop = frameN  # exact frame index
                    # add timestamp to datafile
                    thisExp.timestampOnFlip(win, 'answer1_3.stopped')
                    # update status
                    answer1_3.status = FINISHED
                    answer1_3.setAutoDraw(False)
            
            # *answer2_3* updates
            
            # if answer2_3 is starting this frame...
            if answer2_3.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
                # keep track of start time/frame for later
                answer2_3.frameNStart = frameN  # exact frame index
                answer2_3.tStart = t  # local t and not account for scr refresh
                answer2_3.tStartRefresh = tThisFlipGlobal  # on global time
                win.timeOnFlip(answer2_3, 'tStartRefresh')  # time at next scr refresh
                # add timestamp to datafile
                thisExp.timestampOnFlip(win, 'answer2_3.started')
                # update status
                answer2_3.status = STARTED
                answer2_3.setAutoDraw(True)
            
            # if answer2_3 is active this frame...
            if answer2_3.status == STARTED:
                # update params
                pass
            
            # if answer2_3 is stopping this frame...
            if answer2_3.status == STARTED:
                # is it time to stop? (based on global clock, using actual start)
                if tThisFlipGlobal > answer2_3.tStartRefresh + 120-frameTolerance:
                    # keep track of stop time/frame for later
                    answer2_3.tStop = t  # not accounting for scr refresh
                    answer2_3.frameNStop = frameN  # exact frame index
                    # add timestamp to datafile
                    thisExp.timestampOnFlip(win, 'answer2_3.stopped')
                    # update status
                    answer2_3.status = FINISHED
                    answer2_3.setAutoDraw(False)
            
            # *answer3_3* updates
            
            # if answer3_3 is starting this frame...
            if answer3_3.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
                # keep track of start time/frame for later
                answer3_3.frameNStart = frameN  # exact frame index
                answer3_3.tStart = t  # local t and not account for scr refresh
                answer3_3.tStartRefresh = tThisFlipGlobal  # on global time
                win.timeOnFlip(answer3_3, 'tStartRefresh')  # time at next scr refresh
                # add timestamp to datafile
                thisExp.timestampOnFlip(win, 'answer3_3.started')
                # update status
                answer3_3.status = STARTED
                answer3_3.setAutoDraw(True)
            
            # if answer3_3 is active this frame...
            if answer3_3.status == STARTED:
                # update params
                pass
            
            # if answer3_3 is stopping this frame...
            if answer3_3.status == STARTED:
                # is it time to stop? (based on global clock, using actual start)
                if tThisFlipGlobal > answer3_3.tStartRefresh + 120-frameTolerance:
                    # keep track of stop time/frame for later
                    answer3_3.tStop = t  # not accounting for scr refresh
                    answer3_3.frameNStop = frameN  # exact frame index
                    # add timestamp to datafile
                    thisExp.timestampOnFlip(win, 'answer3_3.stopped')
                    # update status
                    answer3_3.status = FINISHED
                    answer3_3.setAutoDraw(False)
            
            # *a1_3* updates
            
            # if a1_3 is starting this frame...
            if a1_3.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
                # keep track of start time/frame for later
                a1_3.frameNStart = frameN  # exact frame index
                a1_3.tStart = t  # local t and not account for scr refresh
                a1_3.tStartRefresh = tThisFlipGlobal  # on global time
                win.timeOnFlip(a1_3, 'tStartRefresh')  # time at next scr refresh
                # add timestamp to datafile
                thisExp.timestampOnFlip(win, 'a1_3.started')
                # update status
                a1_3.status = STARTED
                a1_3.setAutoDraw(True)
            
            # if a1_3 is active this frame...
            if a1_3.status == STARTED:
                # update params
                pass
            
            # if a1_3 is stopping this frame...
            if a1_3.status == STARTED:
                # is it time to stop? (based on global clock, using actual start)
                if tThisFlipGlobal > a1_3.tStartRefresh + 120-frameTolerance:
                    # keep track of stop time/frame for later
                    a1_3.tStop = t  # not accounting for scr refresh
                    a1_3.frameNStop = frameN  # exact frame index
                    # add timestamp to datafile
                    thisExp.timestampOnFlip(win, 'a1_3.stopped')
                    # update status
                    a1_3.status = FINISHED
                    a1_3.setAutoDraw(False)
            
            # *a2_3* updates
            
            # if a2_3 is starting this frame...
            if a2_3.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
                # keep track of start time/frame for later
                a2_3.frameNStart = frameN  # exact frame index
                a2_3.tStart = t  # local t and not account for scr refresh
                a2_3.tStartRefresh = tThisFlipGlobal  # on global time
                win.timeOnFlip(a2_3, 'tStartRefresh')  # time at next scr refresh
                # add timestamp to datafile
                thisExp.timestampOnFlip(win, 'a2_3.started')
                # update status
                a2_3.status = STARTED
                a2_3.setAutoDraw(True)
            
            # if a2_3 is active this frame...
            if a2_3.status == STARTED:
                # update params
                pass
            
            # if a2_3 is stopping this frame...
            if a2_3.status == STARTED:
                # is it time to stop? (based on global clock, using actual start)
                if tThisFlipGlobal > a2_3.tStartRefresh + 120-frameTolerance:
                    # keep track of stop time/frame for later
                    a2_3.tStop = t  # not accounting for scr refresh
                    a2_3.frameNStop = frameN  # exact frame index
                    # add timestamp to datafile
                    thisExp.timestampOnFlip(win, 'a2_3.stopped')
                    # update status
                    a2_3.status = FINISHED
                    a2_3.setAutoDraw(False)
            
            # *text_146* updates
            
            # if text_146 is starting this frame...
            if text_146.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
                # keep track of start time/frame for later
                text_146.frameNStart = frameN  # exact frame index
                text_146.tStart = t  # local t and not account for scr refresh
                text_146.tStartRefresh = tThisFlipGlobal  # on global time
                win.timeOnFlip(text_146, 'tStartRefresh')  # time at next scr refresh
                # add timestamp to datafile
                thisExp.timestampOnFlip(win, 'text_146.started')
                # update status
                text_146.status = STARTED
                text_146.setAutoDraw(True)
            
            # if text_146 is active this frame...
            if text_146.status == STARTED:
                # update params
                pass
            
            # if text_146 is stopping this frame...
            if text_146.status == STARTED:
                # is it time to stop? (based on global clock, using actual start)
                if tThisFlipGlobal > text_146.tStartRefresh + 120.0-frameTolerance:
                    # keep track of stop time/frame for later
                    text_146.tStop = t  # not accounting for scr refresh
                    text_146.frameNStop = frameN  # exact frame index
                    # add timestamp to datafile
                    thisExp.timestampOnFlip(win, 'text_146.stopped')
                    # update status
                    text_146.status = FINISHED
                    text_146.setAutoDraw(False)
            
            # check for quit (typically the Esc key)
            if defaultKeyboard.getKeys(keyList=["escape"]):
                thisExp.status = FINISHED
            if thisExp.status == FINISHED or endExpNow:
                endExperiment(thisExp, inputs=inputs, win=win)
                return
            
            # check if all components have finished
            if not continueRoutine:  # a component has requested a forced-end of Routine
                routineForceEnded = True
                break
            continueRoutine = False  # will revert to True if at least one component still running
            for thisComponent in forgetting_paths1Components:
                if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:
                    continueRoutine = True
                    break  # at least one component has not yet finished
            
            # refresh the screen
            if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen
                win.flip()
        
        # --- Ending Routine "forgetting_paths1" ---
        for thisComponent in forgetting_paths1Components:
            if hasattr(thisComponent, "setAutoDraw"):
                thisComponent.setAutoDraw(False)
        thisExp.addData('forgetting_paths1.stopped', globalClock.getTime())
        # check responses
        if answer_quiz1_3.keys in ['', [], None]:  # No response was made
            answer_quiz1_3.keys = None
            # was no response the correct answer?!
            if str(correct_answer1).lower() == 'none':
               answer_quiz1_3.corr = 1;  # correct non-response
            else:
               answer_quiz1_3.corr = 0;  # failed to respond (incorrectly)
        # store data for remember_planning_paths (TrialHandler)
        remember_planning_paths.addData('answer_quiz1_3.keys',answer_quiz1_3.keys)
        remember_planning_paths.addData('answer_quiz1_3.corr', answer_quiz1_3.corr)
        if answer_quiz1_3.keys != None:  # we had a response
            remember_planning_paths.addData('answer_quiz1_3.rt', answer_quiz1_3.rt)
            remember_planning_paths.addData('answer_quiz1_3.duration', answer_quiz1_3.duration)
        # using non-slip timing so subtract the expected duration of this Routine (unless ended on request)
        if routineForceEnded:
            routineTimer.reset()
        else:
            routineTimer.addTime(-120.000000)
        
        # --- Prepare to start Routine "planningpathstraining2" ---
        continueRoutine = True
        # update component parameters for each repeat
        thisExp.addData('planningpathstraining2.started', globalClock.getTime())
        answer_quiz1_5.keys = []
        answer_quiz1_5.rt = []
        _answer_quiz1_5_allKeys = []
        answer1_5.setImage(ans1)
        answer2_5.setImage(ans2)
        answer3_5.setImage(ans3)
        # keep track of which components have finished
        planningpathstraining2Components = [question_quiz1_5, answer_quiz1_5, answer1_5, answer2_5, answer3_5, a1_5, a2_5, text_152]
        for thisComponent in planningpathstraining2Components:
            thisComponent.tStart = None
            thisComponent.tStop = None
            thisComponent.tStartRefresh = None
            thisComponent.tStopRefresh = None
            if hasattr(thisComponent, 'status'):
                thisComponent.status = NOT_STARTED
        # reset timers
        t = 0
        _timeToFirstFrame = win.getFutureFlipTime(clock="now")
        frameN = -1
        
        # --- Run Routine "planningpathstraining2" ---
        routineForceEnded = not continueRoutine
        while continueRoutine and routineTimer.getTime() < 120.0:
            # get current time
            t = routineTimer.getTime()
            tThisFlip = win.getFutureFlipTime(clock=routineTimer)
            tThisFlipGlobal = win.getFutureFlipTime(clock=None)
            frameN = frameN + 1  # number of completed frames (so 0 is the first frame)
            # update/draw components on each frame
            
            # *question_quiz1_5* updates
            
            # if question_quiz1_5 is starting this frame...
            if question_quiz1_5.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
                # keep track of start time/frame for later
                question_quiz1_5.frameNStart = frameN  # exact frame index
                question_quiz1_5.tStart = t  # local t and not account for scr refresh
                question_quiz1_5.tStartRefresh = tThisFlipGlobal  # on global time
                win.timeOnFlip(question_quiz1_5, 'tStartRefresh')  # time at next scr refresh
                # add timestamp to datafile
                thisExp.timestampOnFlip(win, 'question_quiz1_5.started')
                # update status
                question_quiz1_5.status = STARTED
                question_quiz1_5.setAutoDraw(True)
            
            # if question_quiz1_5 is active this frame...
            if question_quiz1_5.status == STARTED:
                # update params
                pass
            
            # if question_quiz1_5 is stopping this frame...
            if question_quiz1_5.status == STARTED:
                # is it time to stop? (based on global clock, using actual start)
                if tThisFlipGlobal > question_quiz1_5.tStartRefresh + 120-frameTolerance:
                    # keep track of stop time/frame for later
                    question_quiz1_5.tStop = t  # not accounting for scr refresh
                    question_quiz1_5.frameNStop = frameN  # exact frame index
                    # add timestamp to datafile
                    thisExp.timestampOnFlip(win, 'question_quiz1_5.stopped')
                    # update status
                    question_quiz1_5.status = FINISHED
                    question_quiz1_5.setAutoDraw(False)
            
            # *answer_quiz1_5* updates
            waitOnFlip = False
            
            # if answer_quiz1_5 is starting this frame...
            if answer_quiz1_5.status == NOT_STARTED and tThisFlip >= 0-frameTolerance:
                # keep track of start time/frame for later
                answer_quiz1_5.frameNStart = frameN  # exact frame index
                answer_quiz1_5.tStart = t  # local t and not account for scr refresh
                answer_quiz1_5.tStartRefresh = tThisFlipGlobal  # on global time
                win.timeOnFlip(answer_quiz1_5, 'tStartRefresh')  # time at next scr refresh
                # add timestamp to datafile
                thisExp.timestampOnFlip(win, 'answer_quiz1_5.started')
                # update status
                answer_quiz1_5.status = STARTED
                # keyboard checking is just starting
                waitOnFlip = True
                win.callOnFlip(answer_quiz1_5.clock.reset)  # t=0 on next screen flip
                win.callOnFlip(answer_quiz1_5.clearEvents, eventType='keyboard')  # clear events on next screen flip
            
            # if answer_quiz1_5 is stopping this frame...
            if answer_quiz1_5.status == STARTED:
                # is it time to stop? (based on global clock, using actual start)
                if tThisFlipGlobal > answer_quiz1_5.tStartRefresh + 120-frameTolerance:
                    # keep track of stop time/frame for later
                    answer_quiz1_5.tStop = t  # not accounting for scr refresh
                    answer_quiz1_5.frameNStop = frameN  # exact frame index
                    # add timestamp to datafile
                    thisExp.timestampOnFlip(win, 'answer_quiz1_5.stopped')
                    # update status
                    answer_quiz1_5.status = FINISHED
                    answer_quiz1_5.status = FINISHED
            if answer_quiz1_5.status == STARTED and not waitOnFlip:
                theseKeys = answer_quiz1_5.getKeys(keyList=["left","right"], ignoreKeys=["escape"], waitRelease=False)
                _answer_quiz1_5_allKeys.extend(theseKeys)
                if len(_answer_quiz1_5_allKeys):
                    answer_quiz1_5.keys = _answer_quiz1_5_allKeys[0].name  # just the first key pressed
                    answer_quiz1_5.rt = _answer_quiz1_5_allKeys[0].rt
                    answer_quiz1_5.duration = _answer_quiz1_5_allKeys[0].duration
                    # was this correct?
                    if (answer_quiz1_5.keys == str(correct_answer2)) or (answer_quiz1_5.keys == correct_answer2):
                        answer_quiz1_5.corr = 1
                    else:
                        answer_quiz1_5.corr = 0
                    # a response ends the routine
                    continueRoutine = False
            
            # *answer1_5* updates
            
            # if answer1_5 is starting this frame...
            if answer1_5.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
                # keep track of start time/frame for later
                answer1_5.frameNStart = frameN  # exact frame index
                answer1_5.tStart = t  # local t and not account for scr refresh
                answer1_5.tStartRefresh = tThisFlipGlobal  # on global time
                win.timeOnFlip(answer1_5, 'tStartRefresh')  # time at next scr refresh
                # add timestamp to datafile
                thisExp.timestampOnFlip(win, 'answer1_5.started')
                # update status
                answer1_5.status = STARTED
                answer1_5.setAutoDraw(True)
            
            # if answer1_5 is active this frame...
            if answer1_5.status == STARTED:
                # update params
                pass
            
            # if answer1_5 is stopping this frame...
            if answer1_5.status == STARTED:
                # is it time to stop? (based on global clock, using actual start)
                if tThisFlipGlobal > answer1_5.tStartRefresh + 120-frameTolerance:
                    # keep track of stop time/frame for later
                    answer1_5.tStop = t  # not accounting for scr refresh
                    answer1_5.frameNStop = frameN  # exact frame index
                    # add timestamp to datafile
                    thisExp.timestampOnFlip(win, 'answer1_5.stopped')
                    # update status
                    answer1_5.status = FINISHED
                    answer1_5.setAutoDraw(False)
            
            # *answer2_5* updates
            
            # if answer2_5 is starting this frame...
            if answer2_5.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
                # keep track of start time/frame for later
                answer2_5.frameNStart = frameN  # exact frame index
                answer2_5.tStart = t  # local t and not account for scr refresh
                answer2_5.tStartRefresh = tThisFlipGlobal  # on global time
                win.timeOnFlip(answer2_5, 'tStartRefresh')  # time at next scr refresh
                # add timestamp to datafile
                thisExp.timestampOnFlip(win, 'answer2_5.started')
                # update status
                answer2_5.status = STARTED
                answer2_5.setAutoDraw(True)
            
            # if answer2_5 is active this frame...
            if answer2_5.status == STARTED:
                # update params
                pass
            
            # if answer2_5 is stopping this frame...
            if answer2_5.status == STARTED:
                # is it time to stop? (based on global clock, using actual start)
                if tThisFlipGlobal > answer2_5.tStartRefresh + 120-frameTolerance:
                    # keep track of stop time/frame for later
                    answer2_5.tStop = t  # not accounting for scr refresh
                    answer2_5.frameNStop = frameN  # exact frame index
                    # add timestamp to datafile
                    thisExp.timestampOnFlip(win, 'answer2_5.stopped')
                    # update status
                    answer2_5.status = FINISHED
                    answer2_5.setAutoDraw(False)
            
            # *answer3_5* updates
            
            # if answer3_5 is starting this frame...
            if answer3_5.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
                # keep track of start time/frame for later
                answer3_5.frameNStart = frameN  # exact frame index
                answer3_5.tStart = t  # local t and not account for scr refresh
                answer3_5.tStartRefresh = tThisFlipGlobal  # on global time
                win.timeOnFlip(answer3_5, 'tStartRefresh')  # time at next scr refresh
                # add timestamp to datafile
                thisExp.timestampOnFlip(win, 'answer3_5.started')
                # update status
                answer3_5.status = STARTED
                answer3_5.setAutoDraw(True)
            
            # if answer3_5 is active this frame...
            if answer3_5.status == STARTED:
                # update params
                pass
            
            # if answer3_5 is stopping this frame...
            if answer3_5.status == STARTED:
                # is it time to stop? (based on global clock, using actual start)
                if tThisFlipGlobal > answer3_5.tStartRefresh + 120-frameTolerance:
                    # keep track of stop time/frame for later
                    answer3_5.tStop = t  # not accounting for scr refresh
                    answer3_5.frameNStop = frameN  # exact frame index
                    # add timestamp to datafile
                    thisExp.timestampOnFlip(win, 'answer3_5.stopped')
                    # update status
                    answer3_5.status = FINISHED
                    answer3_5.setAutoDraw(False)
            
            # *a1_5* updates
            
            # if a1_5 is starting this frame...
            if a1_5.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
                # keep track of start time/frame for later
                a1_5.frameNStart = frameN  # exact frame index
                a1_5.tStart = t  # local t and not account for scr refresh
                a1_5.tStartRefresh = tThisFlipGlobal  # on global time
                win.timeOnFlip(a1_5, 'tStartRefresh')  # time at next scr refresh
                # add timestamp to datafile
                thisExp.timestampOnFlip(win, 'a1_5.started')
                # update status
                a1_5.status = STARTED
                a1_5.setAutoDraw(True)
            
            # if a1_5 is active this frame...
            if a1_5.status == STARTED:
                # update params
                pass
            
            # if a1_5 is stopping this frame...
            if a1_5.status == STARTED:
                # is it time to stop? (based on global clock, using actual start)
                if tThisFlipGlobal > a1_5.tStartRefresh + 120-frameTolerance:
                    # keep track of stop time/frame for later
                    a1_5.tStop = t  # not accounting for scr refresh
                    a1_5.frameNStop = frameN  # exact frame index
                    # add timestamp to datafile
                    thisExp.timestampOnFlip(win, 'a1_5.stopped')
                    # update status
                    a1_5.status = FINISHED
                    a1_5.setAutoDraw(False)
            
            # *a2_5* updates
            
            # if a2_5 is starting this frame...
            if a2_5.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
                # keep track of start time/frame for later
                a2_5.frameNStart = frameN  # exact frame index
                a2_5.tStart = t  # local t and not account for scr refresh
                a2_5.tStartRefresh = tThisFlipGlobal  # on global time
                win.timeOnFlip(a2_5, 'tStartRefresh')  # time at next scr refresh
                # add timestamp to datafile
                thisExp.timestampOnFlip(win, 'a2_5.started')
                # update status
                a2_5.status = STARTED
                a2_5.setAutoDraw(True)
            
            # if a2_5 is active this frame...
            if a2_5.status == STARTED:
                # update params
                pass
            
            # if a2_5 is stopping this frame...
            if a2_5.status == STARTED:
                # is it time to stop? (based on global clock, using actual start)
                if tThisFlipGlobal > a2_5.tStartRefresh + 120-frameTolerance:
                    # keep track of stop time/frame for later
                    a2_5.tStop = t  # not accounting for scr refresh
                    a2_5.frameNStop = frameN  # exact frame index
                    # add timestamp to datafile
                    thisExp.timestampOnFlip(win, 'a2_5.stopped')
                    # update status
                    a2_5.status = FINISHED
                    a2_5.setAutoDraw(False)
            
            # *text_152* updates
            
            # if text_152 is starting this frame...
            if text_152.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
                # keep track of start time/frame for later
                text_152.frameNStart = frameN  # exact frame index
                text_152.tStart = t  # local t and not account for scr refresh
                text_152.tStartRefresh = tThisFlipGlobal  # on global time
                win.timeOnFlip(text_152, 'tStartRefresh')  # time at next scr refresh
                # add timestamp to datafile
                thisExp.timestampOnFlip(win, 'text_152.started')
                # update status
                text_152.status = STARTED
                text_152.setAutoDraw(True)
            
            # if text_152 is active this frame...
            if text_152.status == STARTED:
                # update params
                pass
            
            # if text_152 is stopping this frame...
            if text_152.status == STARTED:
                # is it time to stop? (based on global clock, using actual start)
                if tThisFlipGlobal > text_152.tStartRefresh + 120.0-frameTolerance:
                    # keep track of stop time/frame for later
                    text_152.tStop = t  # not accounting for scr refresh
                    text_152.frameNStop = frameN  # exact frame index
                    # add timestamp to datafile
                    thisExp.timestampOnFlip(win, 'text_152.stopped')
                    # update status
                    text_152.status = FINISHED
                    text_152.setAutoDraw(False)
            
            # check for quit (typically the Esc key)
            if defaultKeyboard.getKeys(keyList=["escape"]):
                thisExp.status = FINISHED
            if thisExp.status == FINISHED or endExpNow:
                endExperiment(thisExp, inputs=inputs, win=win)
                return
            
            # check if all components have finished
            if not continueRoutine:  # a component has requested a forced-end of Routine
                routineForceEnded = True
                break
            continueRoutine = False  # will revert to True if at least one component still running
            for thisComponent in planningpathstraining2Components:
                if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:
                    continueRoutine = True
                    break  # at least one component has not yet finished
            
            # refresh the screen
            if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen
                win.flip()
        
        # --- Ending Routine "planningpathstraining2" ---
        for thisComponent in planningpathstraining2Components:
            if hasattr(thisComponent, "setAutoDraw"):
                thisComponent.setAutoDraw(False)
        thisExp.addData('planningpathstraining2.stopped', globalClock.getTime())
        # check responses
        if answer_quiz1_5.keys in ['', [], None]:  # No response was made
            answer_quiz1_5.keys = None
            # was no response the correct answer?!
            if str(correct_answer2).lower() == 'none':
               answer_quiz1_5.corr = 1;  # correct non-response
            else:
               answer_quiz1_5.corr = 0;  # failed to respond (incorrectly)
        # store data for remember_planning_paths (TrialHandler)
        remember_planning_paths.addData('answer_quiz1_5.keys',answer_quiz1_5.keys)
        remember_planning_paths.addData('answer_quiz1_5.corr', answer_quiz1_5.corr)
        if answer_quiz1_5.keys != None:  # we had a response
            remember_planning_paths.addData('answer_quiz1_5.rt', answer_quiz1_5.rt)
            remember_planning_paths.addData('answer_quiz1_5.duration', answer_quiz1_5.duration)
        # using non-slip timing so subtract the expected duration of this Routine (unless ended on request)
        if routineForceEnded:
            routineTimer.reset()
        else:
            routineTimer.addTime(-120.000000)
        
        # --- Prepare to start Routine "correct_forget_paths" ---
        continueRoutine = True
        # update component parameters for each repeat
        thisExp.addData('correct_forget_paths.started', globalClock.getTime())
        next_trial_text_2.setText(msg)
        text_151.setText(quiz_planning_corr)
        # keep track of which components have finished
        correct_forget_pathsComponents = [next_trial_text_2, text_151]
        for thisComponent in correct_forget_pathsComponents:
            thisComponent.tStart = None
            thisComponent.tStop = None
            thisComponent.tStartRefresh = None
            thisComponent.tStopRefresh = None
            if hasattr(thisComponent, 'status'):
                thisComponent.status = NOT_STARTED
        # reset timers
        t = 0
        _timeToFirstFrame = win.getFutureFlipTime(clock="now")
        frameN = -1
        
        # --- Run Routine "correct_forget_paths" ---
        routineForceEnded = not continueRoutine
        while continueRoutine and routineTimer.getTime() < 3.0:
            # get current time
            t = routineTimer.getTime()
            tThisFlip = win.getFutureFlipTime(clock=routineTimer)
            tThisFlipGlobal = win.getFutureFlipTime(clock=None)
            frameN = frameN + 1  # number of completed frames (so 0 is the first frame)
            # update/draw components on each frame
            
            # *next_trial_text_2* updates
            
            # if next_trial_text_2 is starting this frame...
            if next_trial_text_2.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
                # keep track of start time/frame for later
                next_trial_text_2.frameNStart = frameN  # exact frame index
                next_trial_text_2.tStart = t  # local t and not account for scr refresh
                next_trial_text_2.tStartRefresh = tThisFlipGlobal  # on global time
                win.timeOnFlip(next_trial_text_2, 'tStartRefresh')  # time at next scr refresh
                # add timestamp to datafile
                thisExp.timestampOnFlip(win, 'next_trial_text_2.started')
                # update status
                next_trial_text_2.status = STARTED
                next_trial_text_2.setAutoDraw(True)
            
            # if next_trial_text_2 is active this frame...
            if next_trial_text_2.status == STARTED:
                # update params
                pass
            
            # if next_trial_text_2 is stopping this frame...
            if next_trial_text_2.status == STARTED:
                # is it time to stop? (based on global clock, using actual start)
                if tThisFlipGlobal > next_trial_text_2.tStartRefresh + 3-frameTolerance:
                    # keep track of stop time/frame for later
                    next_trial_text_2.tStop = t  # not accounting for scr refresh
                    next_trial_text_2.frameNStop = frameN  # exact frame index
                    # add timestamp to datafile
                    thisExp.timestampOnFlip(win, 'next_trial_text_2.stopped')
                    # update status
                    next_trial_text_2.status = FINISHED
                    next_trial_text_2.setAutoDraw(False)
            
            # *text_151* updates
            
            # if text_151 is starting this frame...
            if text_151.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
                # keep track of start time/frame for later
                text_151.frameNStart = frameN  # exact frame index
                text_151.tStart = t  # local t and not account for scr refresh
                text_151.tStartRefresh = tThisFlipGlobal  # on global time
                win.timeOnFlip(text_151, 'tStartRefresh')  # time at next scr refresh
                # add timestamp to datafile
                thisExp.timestampOnFlip(win, 'text_151.started')
                # update status
                text_151.status = STARTED
                text_151.setAutoDraw(True)
            
            # if text_151 is active this frame...
            if text_151.status == STARTED:
                # update params
                pass
            
            # if text_151 is stopping this frame...
            if text_151.status == STARTED:
                # is it time to stop? (based on global clock, using actual start)
                if tThisFlipGlobal > text_151.tStartRefresh + 3.0-frameTolerance:
                    # keep track of stop time/frame for later
                    text_151.tStop = t  # not accounting for scr refresh
                    text_151.frameNStop = frameN  # exact frame index
                    # add timestamp to datafile
                    thisExp.timestampOnFlip(win, 'text_151.stopped')
                    # update status
                    text_151.status = FINISHED
                    text_151.setAutoDraw(False)
            
            # check for quit (typically the Esc key)
            if defaultKeyboard.getKeys(keyList=["escape"]):
                thisExp.status = FINISHED
            if thisExp.status == FINISHED or endExpNow:
                endExperiment(thisExp, inputs=inputs, win=win)
                return
            
            # check if all components have finished
            if not continueRoutine:  # a component has requested a forced-end of Routine
                routineForceEnded = True
                break
            continueRoutine = False  # will revert to True if at least one component still running
            for thisComponent in correct_forget_pathsComponents:
                if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:
                    continueRoutine = True
                    break  # at least one component has not yet finished
            
            # refresh the screen
            if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen
                win.flip()
        
        # --- Ending Routine "correct_forget_paths" ---
        for thisComponent in correct_forget_pathsComponents:
            if hasattr(thisComponent, "setAutoDraw"):
                thisComponent.setAutoDraw(False)
        thisExp.addData('correct_forget_paths.stopped', globalClock.getTime())
        # using non-slip timing so subtract the expected duration of this Routine (unless ended on request)
        if routineForceEnded:
            routineTimer.reset()
        else:
            routineTimer.addTime(-3.000000)
        thisExp.nextEntry()
        
        if thisSession is not None:
            # if running in a Session with a Liaison client, send data up to now
            thisSession.sendExperimentData()
    # completed 1.0 repeats of 'remember_planning_paths'
    
    
    # --- Prepare to start Routine "total_score_planning" ---
    continueRoutine = True
    # update component parameters for each repeat
    thisExp.addData('total_score_planning.started', globalClock.getTime())
    # Run 'Begin Routine' code from code_43
    total_planning_score_training=(quiz_planning_corr/8.0)*100
    next_trial_text_3.setText(total_planning_score_training)
    # keep track of which components have finished
    total_score_planningComponents = [next_trial_text_3, text_150]
    for thisComponent in total_score_planningComponents:
        thisComponent.tStart = None
        thisComponent.tStop = None
        thisComponent.tStartRefresh = None
        thisComponent.tStopRefresh = None
        if hasattr(thisComponent, 'status'):
            thisComponent.status = NOT_STARTED
    # reset timers
    t = 0
    _timeToFirstFrame = win.getFutureFlipTime(clock="now")
    frameN = -1
    
    # --- Run Routine "total_score_planning" ---
    routineForceEnded = not continueRoutine
    while continueRoutine and routineTimer.getTime() < 3.0:
        # get current time
        t = routineTimer.getTime()
        tThisFlip = win.getFutureFlipTime(clock=routineTimer)
        tThisFlipGlobal = win.getFutureFlipTime(clock=None)
        frameN = frameN + 1  # number of completed frames (so 0 is the first frame)
        # update/draw components on each frame
        
        # *next_trial_text_3* updates
        
        # if next_trial_text_3 is starting this frame...
        if next_trial_text_3.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
            # keep track of start time/frame for later
            next_trial_text_3.frameNStart = frameN  # exact frame index
            next_trial_text_3.tStart = t  # local t and not account for scr refresh
            next_trial_text_3.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(next_trial_text_3, 'tStartRefresh')  # time at next scr refresh
            # add timestamp to datafile
            thisExp.timestampOnFlip(win, 'next_trial_text_3.started')
            # update status
            next_trial_text_3.status = STARTED
            next_trial_text_3.setAutoDraw(True)
        
        # if next_trial_text_3 is active this frame...
        if next_trial_text_3.status == STARTED:
            # update params
            pass
        
        # if next_trial_text_3 is stopping this frame...
        if next_trial_text_3.status == STARTED:
            # is it time to stop? (based on global clock, using actual start)
            if tThisFlipGlobal > next_trial_text_3.tStartRefresh + 3-frameTolerance:
                # keep track of stop time/frame for later
                next_trial_text_3.tStop = t  # not accounting for scr refresh
                next_trial_text_3.frameNStop = frameN  # exact frame index
                # add timestamp to datafile
                thisExp.timestampOnFlip(win, 'next_trial_text_3.stopped')
                # update status
                next_trial_text_3.status = FINISHED
                next_trial_text_3.setAutoDraw(False)
        
        # *text_150* updates
        
        # if text_150 is starting this frame...
        if text_150.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
            # keep track of start time/frame for later
            text_150.frameNStart = frameN  # exact frame index
            text_150.tStart = t  # local t and not account for scr refresh
            text_150.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(text_150, 'tStartRefresh')  # time at next scr refresh
            # add timestamp to datafile
            thisExp.timestampOnFlip(win, 'text_150.started')
            # update status
            text_150.status = STARTED
            text_150.setAutoDraw(True)
        
        # if text_150 is active this frame...
        if text_150.status == STARTED:
            # update params
            pass
        
        # if text_150 is stopping this frame...
        if text_150.status == STARTED:
            # is it time to stop? (based on global clock, using actual start)
            if tThisFlipGlobal > text_150.tStartRefresh + 3.0-frameTolerance:
                # keep track of stop time/frame for later
                text_150.tStop = t  # not accounting for scr refresh
                text_150.frameNStop = frameN  # exact frame index
                # add timestamp to datafile
                thisExp.timestampOnFlip(win, 'text_150.stopped')
                # update status
                text_150.status = FINISHED
                text_150.setAutoDraw(False)
        
        # check for quit (typically the Esc key)
        if defaultKeyboard.getKeys(keyList=["escape"]):
            thisExp.status = FINISHED
        if thisExp.status == FINISHED or endExpNow:
            endExperiment(thisExp, inputs=inputs, win=win)
            return
        
        # check if all components have finished
        if not continueRoutine:  # a component has requested a forced-end of Routine
            routineForceEnded = True
            break
        continueRoutine = False  # will revert to True if at least one component still running
        for thisComponent in total_score_planningComponents:
            if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:
                continueRoutine = True
                break  # at least one component has not yet finished
        
        # refresh the screen
        if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen
            win.flip()
    
    # --- Ending Routine "total_score_planning" ---
    for thisComponent in total_score_planningComponents:
        if hasattr(thisComponent, "setAutoDraw"):
            thisComponent.setAutoDraw(False)
    thisExp.addData('total_score_planning.stopped', globalClock.getTime())
    # using non-slip timing so subtract the expected duration of this Routine (unless ended on request)
    if routineForceEnded:
        routineTimer.reset()
    else:
        routineTimer.addTime(-3.000000)
    
    # --- Prepare to start Routine "end" ---
    continueRoutine = True
    # update component parameters for each repeat
    thisExp.addData('end.started', globalClock.getTime())
    # keep track of which components have finished
    endComponents = [text_20]
    for thisComponent in endComponents:
        thisComponent.tStart = None
        thisComponent.tStop = None
        thisComponent.tStartRefresh = None
        thisComponent.tStopRefresh = None
        if hasattr(thisComponent, 'status'):
            thisComponent.status = NOT_STARTED
    # reset timers
    t = 0
    _timeToFirstFrame = win.getFutureFlipTime(clock="now")
    frameN = -1
    
    # --- Run Routine "end" ---
    routineForceEnded = not continueRoutine
    while continueRoutine and routineTimer.getTime() < 4.0:
        # get current time
        t = routineTimer.getTime()
        tThisFlip = win.getFutureFlipTime(clock=routineTimer)
        tThisFlipGlobal = win.getFutureFlipTime(clock=None)
        frameN = frameN + 1  # number of completed frames (so 0 is the first frame)
        # update/draw components on each frame
        
        # *text_20* updates
        
        # if text_20 is starting this frame...
        if text_20.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
            # keep track of start time/frame for later
            text_20.frameNStart = frameN  # exact frame index
            text_20.tStart = t  # local t and not account for scr refresh
            text_20.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(text_20, 'tStartRefresh')  # time at next scr refresh
            # add timestamp to datafile
            thisExp.timestampOnFlip(win, 'text_20.started')
            # update status
            text_20.status = STARTED
            text_20.setAutoDraw(True)
        
        # if text_20 is active this frame...
        if text_20.status == STARTED:
            # update params
            pass
        
        # if text_20 is stopping this frame...
        if text_20.status == STARTED:
            # is it time to stop? (based on global clock, using actual start)
            if tThisFlipGlobal > text_20.tStartRefresh + 4.0-frameTolerance:
                # keep track of stop time/frame for later
                text_20.tStop = t  # not accounting for scr refresh
                text_20.frameNStop = frameN  # exact frame index
                # add timestamp to datafile
                thisExp.timestampOnFlip(win, 'text_20.stopped')
                # update status
                text_20.status = FINISHED
                text_20.setAutoDraw(False)
        
        # check for quit (typically the Esc key)
        if defaultKeyboard.getKeys(keyList=["escape"]):
            thisExp.status = FINISHED
        if thisExp.status == FINISHED or endExpNow:
            endExperiment(thisExp, inputs=inputs, win=win)
            return
        
        # check if all components have finished
        if not continueRoutine:  # a component has requested a forced-end of Routine
            routineForceEnded = True
            break
        continueRoutine = False  # will revert to True if at least one component still running
        for thisComponent in endComponents:
            if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:
                continueRoutine = True
                break  # at least one component has not yet finished
        
        # refresh the screen
        if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen
            win.flip()
    
    # --- Ending Routine "end" ---
    for thisComponent in endComponents:
        if hasattr(thisComponent, "setAutoDraw"):
            thisComponent.setAutoDraw(False)
    thisExp.addData('end.stopped', globalClock.getTime())
    # using non-slip timing so subtract the expected duration of this Routine (unless ended on request)
    if routineForceEnded:
        routineTimer.reset()
    else:
        routineTimer.addTime(-4.000000)
    
    # mark experiment as finished
    endExperiment(thisExp, win=win, inputs=inputs)


def saveData(thisExp):
    """
    Save data from this experiment
    
    Parameters
    ==========
    thisExp : psychopy.data.ExperimentHandler
        Handler object for this experiment, contains the data to save and information about 
        where to save it to.
    """
    filename = thisExp.dataFileName
    # these shouldn't be strictly necessary (should auto-save)
    thisExp.saveAsWideText(filename + '.csv', delim='auto')
    thisExp.saveAsPickle(filename)


def endExperiment(thisExp, inputs=None, win=None):
    """
    End this experiment, performing final shut down operations.
    
    This function does NOT close the window or end the Python process - use `quit` for this.
    
    Parameters
    ==========
    thisExp : psychopy.data.ExperimentHandler
        Handler object for this experiment, contains the data to save and information about 
        where to save it to.
    inputs : dict
        Dictionary of input devices by name.
    win : psychopy.visual.Window
        Window for this experiment.
    """
    if win is not None:
        # remove autodraw from all current components
        win.clearAutoDraw()
        # Flip one final time so any remaining win.callOnFlip() 
        # and win.timeOnFlip() tasks get executed
        win.flip()
    # mark experiment handler as finished
    thisExp.status = FINISHED
    # shut down eyetracker, if there is one
    if inputs is not None:
        if 'eyetracker' in inputs and inputs['eyetracker'] is not None:
            inputs['eyetracker'].setConnectionState(False)
    logging.flush()


def quit(thisExp, win=None, inputs=None, thisSession=None):
    """
    Fully quit, closing the window and ending the Python process.
    
    Parameters
    ==========
    win : psychopy.visual.Window
        Window to close.
    inputs : dict
        Dictionary of input devices by name.
    thisSession : psychopy.session.Session or None
        Handle of the Session object this experiment is being run from, if any.
    """
    thisExp.abort()  # or data files will save again on exit
    # make sure everything is closed down
    if win is not None:
        # Flip one final time so any remaining win.callOnFlip() 
        # and win.timeOnFlip() tasks get executed before quitting
        win.flip()
        win.close()
    if inputs is not None:
        if 'eyetracker' in inputs and inputs['eyetracker'] is not None:
            inputs['eyetracker'].setConnectionState(False)
    logging.flush()
    if thisSession is not None:
        thisSession.stop()
    # terminate Python process
    core.quit()


# if running this experiment as a script...
if __name__ == '__main__':
    # call all functions in order
    expInfo = showExpInfoDlg(expInfo=expInfo)
    thisExp = setupData(expInfo=expInfo)
    logFile = setupLogging(filename=thisExp.dataFileName)
    win = setupWindow(expInfo=expInfo)
    inputs = setupInputs(expInfo=expInfo, thisExp=thisExp, win=win)
    run(
        expInfo=expInfo, 
        thisExp=thisExp, 
        win=win, 
        inputs=inputs
    )
    saveData(thisExp=thisExp)
    quit(thisExp=thisExp, win=win, inputs=inputs)
