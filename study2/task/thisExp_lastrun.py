#!/usr/bin/env python
# -*- coding: utf-8 -*-
"""
This experiment was created using PsychoPy3 Experiment Builder (v2024.2.4),
    on December 25, 2024, at 13:21
If you publish work using this script the most relevant publication is:

    Peirce J, Gray JR, Simpson S, MacAskill M, Höchenberger R, Sogo H, Kastman E, Lindeløv JK. (2019) 
        PsychoPy2: Experiments in behavior made easy Behav Res 51: 195. 
        https://doi.org/10.3758/s13428-018-01193-y

"""

# --- Import packages ---
from psychopy import locale_setup
from psychopy import prefs
from psychopy import plugins
plugins.activatePlugins()
from psychopy import sound, gui, visual, core, data, event, logging, clock, colors, layout, hardware
from psychopy.tools import environmenttools
from psychopy.constants import (NOT_STARTED, STARTED, PLAYING, PAUSED,
                                STOPPED, FINISHED, PRESSED, RELEASED, FOREVER, priority)

import numpy as np  # whole numpy lib is available, prepend 'np.'
from numpy import (sin, cos, tan, log, log10, pi, average,
                   sqrt, std, deg2rad, rad2deg, linspace, asarray)
from numpy.random import random, randint, normal, shuffle, choice as randchoice
import os  # handy system and path functions
import sys  # to get file system encoding

import psychopy.iohub as io
from psychopy.hardware import keyboard

# --- Setup global variables (available in all functions) ---
# create a device manager to handle hardware (keyboards, mice, mirophones, speakers, etc.)
deviceManager = hardware.DeviceManager()
# ensure that relative paths start from the same directory as this script
_thisDir = os.path.dirname(os.path.abspath(__file__))
# store info about the experiment session
psychopyVersion = '2024.2.4'
expName = 'thisExp'  # from the Builder filename that created this script
# information about this experiment
expInfo = {
    'participant': '',
    'session': '001',
    'date|hid': data.getDateStr(),
    'expName|hid': expName,
    'psychopyVersion|hid': psychopyVersion,
}

# --- Define some variables which will change depending on pilot mode ---
'''
To run in pilot mode, either use the run/pilot toggle in Builder, Coder and Runner, 
or run the experiment with `--pilot` as an argument. To change what pilot 
#mode does, check out the 'Pilot mode' tab in preferences.
'''
# work out from system args whether we are running in pilot mode
PILOTING = core.setPilotModeFromArgs()
# start off with values from experiment settings
_fullScr = True
_winSize = [1512, 982]
# if in pilot mode, apply overrides according to preferences
if PILOTING:
    # force windowed mode
    if prefs.piloting['forceWindowed']:
        _fullScr = False
        # set window size
        _winSize = prefs.piloting['forcedWindowSize']

def showExpInfoDlg(expInfo):
    """
    Show participant info dialog.
    Parameters
    ==========
    expInfo : dict
        Information about this experiment.
    
    Returns
    ==========
    dict
        Information about this experiment.
    """
    # show participant info dialog
    dlg = gui.DlgFromDict(
        dictionary=expInfo, sortKeys=False, title=expName, alwaysOnTop=True
    )
    if dlg.OK == False:
        core.quit()  # user pressed cancel
    # return expInfo
    return expInfo


def setupData(expInfo, dataDir=None):
    """
    Make an ExperimentHandler to handle trials and saving.
    
    Parameters
    ==========
    expInfo : dict
        Information about this experiment, created by the `setupExpInfo` function.
    dataDir : Path, str or None
        Folder to save the data to, leave as None to create a folder in the current directory.    
    Returns
    ==========
    psychopy.data.ExperimentHandler
        Handler object for this experiment, contains the data to save and information about 
        where to save it to.
    """
    # remove dialog-specific syntax from expInfo
    for key, val in expInfo.copy().items():
        newKey, _ = data.utils.parsePipeSyntax(key)
        expInfo[newKey] = expInfo.pop(key)
    
    # data file name stem = absolute path + name; later add .psyexp, .csv, .log, etc
    if dataDir is None:
        dataDir = _thisDir
    filename = u'data/%s_%s_%s' % (expInfo['participant'], expName, expInfo['date'])
    # make sure filename is relative to dataDir
    if os.path.isabs(filename):
        dataDir = os.path.commonprefix([dataDir, filename])
        filename = os.path.relpath(filename, dataDir)
    
    # an ExperimentHandler isn't essential but helps with data saving
    thisExp = data.ExperimentHandler(
        name=expName, version='',
        extraInfo=expInfo, runtimeInfo=None,
        originPath='\\\\wsl.localhost\\Ubuntu\\home\\paul\\projects_ubuntu\\DelayedPlanning_2023_HU\\task\\thisExp_lastrun.py',
        savePickle=True, saveWideText=True,
        dataFileName=dataDir + os.sep + filename, sortColumns='time'
    )
    thisExp.setPriority('thisRow.t', priority.CRITICAL)
    thisExp.setPriority('expName', priority.LOW)
    # return experiment handler
    return thisExp


def setupLogging(filename):
    """
    Setup a log file and tell it what level to log at.
    
    Parameters
    ==========
    filename : str or pathlib.Path
        Filename to save log file and data files as, doesn't need an extension.
    
    Returns
    ==========
    psychopy.logging.LogFile
        Text stream to receive inputs from the logging system.
    """
    # set how much information should be printed to the console / app
    if PILOTING:
        logging.console.setLevel(
            prefs.piloting['pilotConsoleLoggingLevel']
        )
    else:
        logging.console.setLevel('warning')
    # save a log file for detail verbose info
    logFile = logging.LogFile(filename+'.log')
    if PILOTING:
        logFile.setLevel(
            prefs.piloting['pilotLoggingLevel']
        )
    else:
        logFile.setLevel(
            logging.getLevel('debug')
        )
    
    return logFile


def setupWindow(expInfo=None, win=None):
    """
    Setup the Window
    
    Parameters
    ==========
    expInfo : dict
        Information about this experiment, created by the `setupExpInfo` function.
    win : psychopy.visual.Window
        Window to setup - leave as None to create a new window.
    
    Returns
    ==========
    psychopy.visual.Window
        Window in which to run this experiment.
    """
    if PILOTING:
        logging.debug('Fullscreen settings ignored as running in pilot mode.')
    
    if win is None:
        # if not given a window to setup, make one
        win = visual.Window(
            size=_winSize, fullscr=_fullScr, screen=0,
            winType='pyglet', allowGUI=False, allowStencil=False,
            monitor='testMonitor', color=[0,0,0], colorSpace='rgb',
            backgroundImage='', backgroundFit='none',
            blendMode='avg', useFBO=True,
            units=None,
            checkTiming=False  # we're going to do this ourselves in a moment
        )
    else:
        # if we have a window, just set the attributes which are safe to set
        win.color = [0,0,0]
        win.colorSpace = 'rgb'
        win.backgroundImage = ''
        win.backgroundFit = 'none'
        win.units = None
    if expInfo is not None:
        # get/measure frame rate if not already in expInfo
        if win._monitorFrameRate is None:
            win._monitorFrameRate = win.getActualFrameRate(infoMsg='Attempting to measure frame rate of screen, please wait...')
        expInfo['frameRate'] = win._monitorFrameRate
    win.hideMessage()
    # show a visual indicator if we're in piloting mode
    if PILOTING and prefs.piloting['showPilotingIndicator']:
        win.showPilotingIndicator()
    
    return win


def setupDevices(expInfo, thisExp, win):
    """
    Setup whatever devices are available (mouse, keyboard, speaker, eyetracker, etc.) and add them to 
    the device manager (deviceManager)
    
    Parameters
    ==========
    expInfo : dict
        Information about this experiment, created by the `setupExpInfo` function.
    thisExp : psychopy.data.ExperimentHandler
        Handler object for this experiment, contains the data to save and information about 
        where to save it to.
    win : psychopy.visual.Window
        Window in which to run this experiment.
    Returns
    ==========
    bool
        True if completed successfully.
    """
    # --- Setup input devices ---
    ioConfig = {}
    
    # Setup iohub keyboard
    ioConfig['Keyboard'] = dict(use_keymap='psychopy')
    
    # Setup iohub experiment
    ioConfig['Experiment'] = dict(filename=thisExp.dataFileName)
    
    # Start ioHub server
    ioServer = io.launchHubServer(window=win, **ioConfig)
    
    # store ioServer object in the device manager
    deviceManager.ioServer = ioServer
    
    # create a default keyboard (e.g. to check for escape)
    if deviceManager.getDevice('defaultKeyboard') is None:
        deviceManager.addDevice(
            deviceClass='keyboard', deviceName='defaultKeyboard', backend='iohub'
        )
    if deviceManager.getDevice('consent1_next') is None:
        # initialise consent1_next
        consent1_next = deviceManager.addDevice(
            deviceClass='keyboard',
            deviceName='consent1_next',
        )
    if deviceManager.getDevice('consent1_next_2') is None:
        # initialise consent1_next_2
        consent1_next_2 = deviceManager.addDevice(
            deviceClass='keyboard',
            deviceName='consent1_next_2',
        )
    if deviceManager.getDevice('key_resp_34') is None:
        # initialise key_resp_34
        key_resp_34 = deviceManager.addDevice(
            deviceClass='keyboard',
            deviceName='key_resp_34',
        )
    if deviceManager.getDevice('key_resp_35') is None:
        # initialise key_resp_35
        key_resp_35 = deviceManager.addDevice(
            deviceClass='keyboard',
            deviceName='key_resp_35',
        )
    if deviceManager.getDevice('key_resp_41') is None:
        # initialise key_resp_41
        key_resp_41 = deviceManager.addDevice(
            deviceClass='keyboard',
            deviceName='key_resp_41',
        )
    if deviceManager.getDevice('key_resp_42') is None:
        # initialise key_resp_42
        key_resp_42 = deviceManager.addDevice(
            deviceClass='keyboard',
            deviceName='key_resp_42',
        )
    if deviceManager.getDevice('key_resp_43') is None:
        # initialise key_resp_43
        key_resp_43 = deviceManager.addDevice(
            deviceClass='keyboard',
            deviceName='key_resp_43',
        )
    if deviceManager.getDevice('key_resp_44') is None:
        # initialise key_resp_44
        key_resp_44 = deviceManager.addDevice(
            deviceClass='keyboard',
            deviceName='key_resp_44',
        )
    if deviceManager.getDevice('key_resp_45') is None:
        # initialise key_resp_45
        key_resp_45 = deviceManager.addDevice(
            deviceClass='keyboard',
            deviceName='key_resp_45',
        )
    if deviceManager.getDevice('key_resp_46') is None:
        # initialise key_resp_46
        key_resp_46 = deviceManager.addDevice(
            deviceClass='keyboard',
            deviceName='key_resp_46',
        )
    if deviceManager.getDevice('key_resp_47') is None:
        # initialise key_resp_47
        key_resp_47 = deviceManager.addDevice(
            deviceClass='keyboard',
            deviceName='key_resp_47',
        )
    if deviceManager.getDevice('key_resp_48') is None:
        # initialise key_resp_48
        key_resp_48 = deviceManager.addDevice(
            deviceClass='keyboard',
            deviceName='key_resp_48',
        )
    if deviceManager.getDevice('key_resp_49') is None:
        # initialise key_resp_49
        key_resp_49 = deviceManager.addDevice(
            deviceClass='keyboard',
            deviceName='key_resp_49',
        )
    if deviceManager.getDevice('key_resp_50') is None:
        # initialise key_resp_50
        key_resp_50 = deviceManager.addDevice(
            deviceClass='keyboard',
            deviceName='key_resp_50',
        )
    if deviceManager.getDevice('key_resp_51') is None:
        # initialise key_resp_51
        key_resp_51 = deviceManager.addDevice(
            deviceClass='keyboard',
            deviceName='key_resp_51',
        )
    if deviceManager.getDevice('key_resp_52') is None:
        # initialise key_resp_52
        key_resp_52 = deviceManager.addDevice(
            deviceClass='keyboard',
            deviceName='key_resp_52',
        )
    if deviceManager.getDevice('key_resp_53') is None:
        # initialise key_resp_53
        key_resp_53 = deviceManager.addDevice(
            deviceClass='keyboard',
            deviceName='key_resp_53',
        )
    if deviceManager.getDevice('key_resp_54') is None:
        # initialise key_resp_54
        key_resp_54 = deviceManager.addDevice(
            deviceClass='keyboard',
            deviceName='key_resp_54',
        )
    if deviceManager.getDevice('key_resp_55') is None:
        # initialise key_resp_55
        key_resp_55 = deviceManager.addDevice(
            deviceClass='keyboard',
            deviceName='key_resp_55',
        )
    if deviceManager.getDevice('key_resp_56') is None:
        # initialise key_resp_56
        key_resp_56 = deviceManager.addDevice(
            deviceClass='keyboard',
            deviceName='key_resp_56',
        )
    if deviceManager.getDevice('key_resp_57') is None:
        # initialise key_resp_57
        key_resp_57 = deviceManager.addDevice(
            deviceClass='keyboard',
            deviceName='key_resp_57',
        )
    if deviceManager.getDevice('key_resp_58') is None:
        # initialise key_resp_58
        key_resp_58 = deviceManager.addDevice(
            deviceClass='keyboard',
            deviceName='key_resp_58',
        )
    if deviceManager.getDevice('key_resp_59') is None:
        # initialise key_resp_59
        key_resp_59 = deviceManager.addDevice(
            deviceClass='keyboard',
            deviceName='key_resp_59',
        )
    if deviceManager.getDevice('key_resp_60') is None:
        # initialise key_resp_60
        key_resp_60 = deviceManager.addDevice(
            deviceClass='keyboard',
            deviceName='key_resp_60',
        )
    if deviceManager.getDevice('key_resp_61') is None:
        # initialise key_resp_61
        key_resp_61 = deviceManager.addDevice(
            deviceClass='keyboard',
            deviceName='key_resp_61',
        )
    if deviceManager.getDevice('key_resp_62') is None:
        # initialise key_resp_62
        key_resp_62 = deviceManager.addDevice(
            deviceClass='keyboard',
            deviceName='key_resp_62',
        )
    if deviceManager.getDevice('key_resp_63') is None:
        # initialise key_resp_63
        key_resp_63 = deviceManager.addDevice(
            deviceClass='keyboard',
            deviceName='key_resp_63',
        )
    if deviceManager.getDevice('key_resp_64') is None:
        # initialise key_resp_64
        key_resp_64 = deviceManager.addDevice(
            deviceClass='keyboard',
            deviceName='key_resp_64',
        )
    if deviceManager.getDevice('key_resp_65') is None:
        # initialise key_resp_65
        key_resp_65 = deviceManager.addDevice(
            deviceClass='keyboard',
            deviceName='key_resp_65',
        )
    if deviceManager.getDevice('key_resp_66') is None:
        # initialise key_resp_66
        key_resp_66 = deviceManager.addDevice(
            deviceClass='keyboard',
            deviceName='key_resp_66',
        )
    if deviceManager.getDevice('key_resp_67') is None:
        # initialise key_resp_67
        key_resp_67 = deviceManager.addDevice(
            deviceClass='keyboard',
            deviceName='key_resp_67',
        )
    if deviceManager.getDevice('key_resp_68') is None:
        # initialise key_resp_68
        key_resp_68 = deviceManager.addDevice(
            deviceClass='keyboard',
            deviceName='key_resp_68',
        )
    if deviceManager.getDevice('key_resp_69') is None:
        # initialise key_resp_69
        key_resp_69 = deviceManager.addDevice(
            deviceClass='keyboard',
            deviceName='key_resp_69',
        )
    if deviceManager.getDevice('key_resp_70') is None:
        # initialise key_resp_70
        key_resp_70 = deviceManager.addDevice(
            deviceClass='keyboard',
            deviceName='key_resp_70',
        )
    if deviceManager.getDevice('key_resp_71') is None:
        # initialise key_resp_71
        key_resp_71 = deviceManager.addDevice(
            deviceClass='keyboard',
            deviceName='key_resp_71',
        )
    if deviceManager.getDevice('key_resp_72') is None:
        # initialise key_resp_72
        key_resp_72 = deviceManager.addDevice(
            deviceClass='keyboard',
            deviceName='key_resp_72',
        )
    if deviceManager.getDevice('key_resp_73') is None:
        # initialise key_resp_73
        key_resp_73 = deviceManager.addDevice(
            deviceClass='keyboard',
            deviceName='key_resp_73',
        )
    if deviceManager.getDevice('key_resp_74') is None:
        # initialise key_resp_74
        key_resp_74 = deviceManager.addDevice(
            deviceClass='keyboard',
            deviceName='key_resp_74',
        )
    if deviceManager.getDevice('key_resp_75') is None:
        # initialise key_resp_75
        key_resp_75 = deviceManager.addDevice(
            deviceClass='keyboard',
            deviceName='key_resp_75',
        )
    if deviceManager.getDevice('key_resp_76') is None:
        # initialise key_resp_76
        key_resp_76 = deviceManager.addDevice(
            deviceClass='keyboard',
            deviceName='key_resp_76',
        )
    if deviceManager.getDevice('key_resp_77') is None:
        # initialise key_resp_77
        key_resp_77 = deviceManager.addDevice(
            deviceClass='keyboard',
            deviceName='key_resp_77',
        )
    if deviceManager.getDevice('end_instructions') is None:
        # initialise end_instructions
        end_instructions = deviceManager.addDevice(
            deviceClass='keyboard',
            deviceName='end_instructions',
        )
    if deviceManager.getDevice('key_resp_2') is None:
        # initialise key_resp_2
        key_resp_2 = deviceManager.addDevice(
            deviceClass='keyboard',
            deviceName='key_resp_2',
        )
    if deviceManager.getDevice('responseleft') is None:
        # initialise responseleft
        responseleft = deviceManager.addDevice(
            deviceClass='keyboard',
            deviceName='responseleft',
        )
    if deviceManager.getDevice('key_resp_10') is None:
        # initialise key_resp_10
        key_resp_10 = deviceManager.addDevice(
            deviceClass='keyboard',
            deviceName='key_resp_10',
        )
    if deviceManager.getDevice('practice_answer') is None:
        # initialise practice_answer
        practice_answer = deviceManager.addDevice(
            deviceClass='keyboard',
            deviceName='practice_answer',
        )
    if deviceManager.getDevice('key_resp_23') is None:
        # initialise key_resp_23
        key_resp_23 = deviceManager.addDevice(
            deviceClass='keyboard',
            deviceName='key_resp_23',
        )
    if deviceManager.getDevice('key_resp_17') is None:
        # initialise key_resp_17
        key_resp_17 = deviceManager.addDevice(
            deviceClass='keyboard',
            deviceName='key_resp_17',
        )
    if deviceManager.getDevice('key_resp_18') is None:
        # initialise key_resp_18
        key_resp_18 = deviceManager.addDevice(
            deviceClass='keyboard',
            deviceName='key_resp_18',
        )
    if deviceManager.getDevice('key_resp_19') is None:
        # initialise key_resp_19
        key_resp_19 = deviceManager.addDevice(
            deviceClass='keyboard',
            deviceName='key_resp_19',
        )
    if deviceManager.getDevice('key_resp_20') is None:
        # initialise key_resp_20
        key_resp_20 = deviceManager.addDevice(
            deviceClass='keyboard',
            deviceName='key_resp_20',
        )
    if deviceManager.getDevice('key_resp_7') is None:
        # initialise key_resp_7
        key_resp_7 = deviceManager.addDevice(
            deviceClass='keyboard',
            deviceName='key_resp_7',
        )
    if deviceManager.getDevice('key_resp') is None:
        # initialise key_resp
        key_resp = deviceManager.addDevice(
            deviceClass='keyboard',
            deviceName='key_resp',
        )
    if deviceManager.getDevice('answer_quiz1') is None:
        # initialise answer_quiz1
        answer_quiz1 = deviceManager.addDevice(
            deviceClass='keyboard',
            deviceName='answer_quiz1',
        )
    if deviceManager.getDevice('answer_quiz1_2') is None:
        # initialise answer_quiz1_2
        answer_quiz1_2 = deviceManager.addDevice(
            deviceClass='keyboard',
            deviceName='answer_quiz1_2',
        )
    if deviceManager.getDevice('key_resp_40') is None:
        # initialise key_resp_40
        key_resp_40 = deviceManager.addDevice(
            deviceClass='keyboard',
            deviceName='key_resp_40',
        )
    if deviceManager.getDevice('answer_quiz1_3') is None:
        # initialise answer_quiz1_3
        answer_quiz1_3 = deviceManager.addDevice(
            deviceClass='keyboard',
            deviceName='answer_quiz1_3',
        )
    if deviceManager.getDevice('answer_quiz1_5') is None:
        # initialise answer_quiz1_5
        answer_quiz1_5 = deviceManager.addDevice(
            deviceClass='keyboard',
            deviceName='answer_quiz1_5',
        )
    if deviceManager.getDevice('key_resp_11') is None:
        # initialise key_resp_11
        key_resp_11 = deviceManager.addDevice(
            deviceClass='keyboard',
            deviceName='key_resp_11',
        )
    if deviceManager.getDevice('key_resp_9') is None:
        # initialise key_resp_9
        key_resp_9 = deviceManager.addDevice(
            deviceClass='keyboard',
            deviceName='key_resp_9',
        )
    if deviceManager.getDevice('plan2_response_2') is None:
        # initialise plan2_response_2
        plan2_response_2 = deviceManager.addDevice(
            deviceClass='keyboard',
            deviceName='plan2_response_2',
        )
    if deviceManager.getDevice('key_resp_12') is None:
        # initialise key_resp_12
        key_resp_12 = deviceManager.addDevice(
            deviceClass='keyboard',
            deviceName='key_resp_12',
        )
    if deviceManager.getDevice('key_resp_21') is None:
        # initialise key_resp_21
        key_resp_21 = deviceManager.addDevice(
            deviceClass='keyboard',
            deviceName='key_resp_21',
        )
    if deviceManager.getDevice('key_resp_22') is None:
        # initialise key_resp_22
        key_resp_22 = deviceManager.addDevice(
            deviceClass='keyboard',
            deviceName='key_resp_22',
        )
    if deviceManager.getDevice('key_resp_24') is None:
        # initialise key_resp_24
        key_resp_24 = deviceManager.addDevice(
            deviceClass='keyboard',
            deviceName='key_resp_24',
        )
    if deviceManager.getDevice('key_resp_8') is None:
        # initialise key_resp_8
        key_resp_8 = deviceManager.addDevice(
            deviceClass='keyboard',
            deviceName='key_resp_8',
        )
    if deviceManager.getDevice('plan2_response_3') is None:
        # initialise plan2_response_3
        plan2_response_3 = deviceManager.addDevice(
            deviceClass='keyboard',
            deviceName='plan2_response_3',
        )
    if deviceManager.getDevice('plan2_response_6') is None:
        # initialise plan2_response_6
        plan2_response_6 = deviceManager.addDevice(
            deviceClass='keyboard',
            deviceName='plan2_response_6',
        )
    if deviceManager.getDevice('plan2_response_5') is None:
        # initialise plan2_response_5
        plan2_response_5 = deviceManager.addDevice(
            deviceClass='keyboard',
            deviceName='plan2_response_5',
        )
    if deviceManager.getDevice('key_resp_39') is None:
        # initialise key_resp_39
        key_resp_39 = deviceManager.addDevice(
            deviceClass='keyboard',
            deviceName='key_resp_39',
        )
    if deviceManager.getDevice('key_resp_37') is None:
        # initialise key_resp_37
        key_resp_37 = deviceManager.addDevice(
            deviceClass='keyboard',
            deviceName='key_resp_37',
        )
    if deviceManager.getDevice('key_resp_38') is None:
        # initialise key_resp_38
        key_resp_38 = deviceManager.addDevice(
            deviceClass='keyboard',
            deviceName='key_resp_38',
        )
    if deviceManager.getDevice('key_resp_6') is None:
        # initialise key_resp_6
        key_resp_6 = deviceManager.addDevice(
            deviceClass='keyboard',
            deviceName='key_resp_6',
        )
    if deviceManager.getDevice('plan1_response') is None:
        # initialise plan1_response
        plan1_response = deviceManager.addDevice(
            deviceClass='keyboard',
            deviceName='plan1_response',
        )
    if deviceManager.getDevice('plan2_response') is None:
        # initialise plan2_response
        plan2_response = deviceManager.addDevice(
            deviceClass='keyboard',
            deviceName='plan2_response',
        )
    if deviceManager.getDevice('plan3_response') is None:
        # initialise plan3_response
        plan3_response = deviceManager.addDevice(
            deviceClass='keyboard',
            deviceName='plan3_response',
        )
    # return True if completed successfully
    return True

def pauseExperiment(thisExp, win=None, timers=[], playbackComponents=[]):
    """
    Pause this experiment, preventing the flow from advancing to the next routine until resumed.
    
    Parameters
    ==========
    thisExp : psychopy.data.ExperimentHandler
        Handler object for this experiment, contains the data to save and information about 
        where to save it to.
    win : psychopy.visual.Window
        Window for this experiment.
    timers : list, tuple
        List of timers to reset once pausing is finished.
    playbackComponents : list, tuple
        List of any components with a `pause` method which need to be paused.
    """
    # if we are not paused, do nothing
    if thisExp.status != PAUSED:
        return
    
    # start a timer to figure out how long we're paused for
    pauseTimer = core.Clock()
    # pause any playback components
    for comp in playbackComponents:
        comp.pause()
    # make sure we have a keyboard
    defaultKeyboard = deviceManager.getDevice('defaultKeyboard')
    if defaultKeyboard is None:
        defaultKeyboard = deviceManager.addKeyboard(
            deviceClass='keyboard',
            deviceName='defaultKeyboard',
            backend='ioHub',
        )
    # run a while loop while we wait to unpause
    while thisExp.status == PAUSED:
        # check for quit (typically the Esc key)
        if defaultKeyboard.getKeys(keyList=['escape']):
            endExperiment(thisExp, win=win)
        # sleep 1ms so other threads can execute
        clock.time.sleep(0.001)
    # if stop was requested while paused, quit
    if thisExp.status == FINISHED:
        endExperiment(thisExp, win=win)
    # resume any playback components
    for comp in playbackComponents:
        comp.play()
    # reset any timers
    for timer in timers:
        timer.addTime(-pauseTimer.getTime())


def run(expInfo, thisExp, win, globalClock=None, thisSession=None):
    """
    Run the experiment flow.
    
    Parameters
    ==========
    expInfo : dict
        Information about this experiment, created by the `setupExpInfo` function.
    thisExp : psychopy.data.ExperimentHandler
        Handler object for this experiment, contains the data to save and information about 
        where to save it to.
    psychopy.visual.Window
        Window in which to run this experiment.
    globalClock : psychopy.core.clock.Clock or None
        Clock to get global time from - supply None to make a new one.
    thisSession : psychopy.session.Session or None
        Handle of the Session object this experiment is being run from, if any.
    """
    # mark experiment as started
    thisExp.status = STARTED
    # make sure window is set to foreground to prevent losing focus
    win.winHandle.activate()
    # make sure variables created by exec are available globally
    exec = environmenttools.setExecEnvironment(globals())
    # get device handles from dict of input devices
    ioServer = deviceManager.ioServer
    # get/create a default keyboard (e.g. to check for escape)
    defaultKeyboard = deviceManager.getDevice('defaultKeyboard')
    if defaultKeyboard is None:
        deviceManager.addDevice(
            deviceClass='keyboard', deviceName='defaultKeyboard', backend='ioHub'
        )
    eyetracker = deviceManager.getDevice('eyetracker')
    # make sure we're running in the directory for this experiment
    os.chdir(_thisDir)
    # get filename from ExperimentHandler for convenience
    filename = thisExp.dataFileName
    frameTolerance = 0.001  # how close to onset before 'same' frame
    endExpNow = False  # flag for 'escape' or other condition => quit the exp
    # get frame duration from frame rate in expInfo
    if 'frameRate' in expInfo and expInfo['frameRate'] is not None:
        frameDur = 1.0 / round(expInfo['frameRate'])
    else:
        frameDur = 1.0 / 60.0  # could not measure, so guess
    
    # Start Code - component code to be run after the window creation
    
    # --- Initialize components for Routine "consent" ---
    image_11 = visual.ImageStim(
        win=win,
        name='image_11', 
        image='default.png', mask=None, anchor='center',
        ori=0.0, pos=(0, 0.05), draggable=False, size=(0.65, 0.75),
        color=[1,1,1], colorSpace='rgb', opacity=None,
        flipHoriz=False, flipVert=False,
        texRes=128.0, interpolate=True, depth=0.0)
    consent1_next = keyboard.Keyboard(deviceName='consent1_next')
    text_89 = visual.TextStim(win=win, name='text_89',
        text='Click SPACE to Continue',
        font='Open Sans',
        pos=(0, -0.4), draggable=False, height=0.03, wrapWidth=None, ori=0.0, 
        color='black', colorSpace='rgb', opacity=None, 
        languageStyle='LTR',
        depth=-2.0);
    
    # --- Initialize components for Routine "consent2" ---
    image_13 = visual.ImageStim(
        win=win,
        name='image_13', 
        image='default.png', mask=None, anchor='center',
        ori=0.0, pos=(0, 0.1), draggable=False, size=(0.65, 0.5),
        color=[1,1,1], colorSpace='rgb', opacity=None,
        flipHoriz=False, flipVert=False,
        texRes=128.0, interpolate=True, depth=0.0)
    consent1_next_2 = keyboard.Keyboard(deviceName='consent1_next_2')
    text_90 = visual.TextStim(win=win, name='text_90',
        text='I certify that I have read the informed consent and received the information to contact the investigators if necessary.\n\nClick ‘y’ for YES\nClick ’n’ for NO, and you will EXIT the study',
        font='Open Sans',
        pos=(0, -0.35), draggable=False, height=0.03, wrapWidth=None, ori=0.0, 
        color='black', colorSpace='rgb', opacity=None, 
        languageStyle='LTR',
        depth=-2.0);
    
    # --- Initialize components for Routine "questionnaire_start" ---
    text_33 = visual.TextStim(win=win, name='text_33',
        text='First you’re going to answer a few questions about how much you worry. ',
        font='Open Sans',
        pos=(0, 0), draggable=False, height=0.05, wrapWidth=None, ori=0.0, 
        color='black', colorSpace='rgb', opacity=None, 
        languageStyle='LTR',
        depth=0.0);
    
    # --- Initialize components for Routine "PSWQ15" ---
    text_105 = visual.TextStim(win=win, name='text_105',
        text='Rate each of the following statements on a scale of 1 (“not at all typical of me”) to 5 (“very typical of me”). Please do not leave any items blank.',
        font='Open Sans',
        pos=(0, 0.28), draggable=False, height=0.045, wrapWidth=None, ori=0.0, 
        color='black', colorSpace='rgb', opacity=None, 
        languageStyle='LTR',
        depth=0.0);
    text_106 = visual.TextStim(win=win, name='text_106',
        text='I worry all the time.',
        font='Open Sans',
        pos=(0, 0), draggable=False, height=0.045, wrapWidth=None, ori=0.0, 
        color='black', colorSpace='rgb', opacity=None, 
        languageStyle='LTR',
        depth=-1.0);
    text_107 = visual.TextStim(win=win, name='text_107',
        text='1=Not at all typical - 2 - 3 - 4 - 5=Very typical',
        font='Open Sans',
        pos=(0, -0.2), draggable=False, height=0.045, wrapWidth=None, ori=0.0, 
        color='black', colorSpace='rgb', opacity=None, 
        languageStyle='LTR',
        depth=-2.0);
    key_resp_34 = keyboard.Keyboard(deviceName='key_resp_34')
    
    # --- Initialize components for Routine "PSWQ16" ---
    text_108 = visual.TextStim(win=win, name='text_108',
        text='Rate each of the following statements on a scale of 1 (“not at all typical of me”) to 5 (“very typical of me”). Please do not leave any items blank.',
        font='Open Sans',
        pos=(0, 0.28), draggable=False, height=0.045, wrapWidth=None, ori=0.0, 
        color='black', colorSpace='rgb', opacity=None, 
        languageStyle='LTR',
        depth=0.0);
    text_109 = visual.TextStim(win=win, name='text_109',
        text='I have been a worrier all my life.',
        font='Open Sans',
        pos=(0, 0), draggable=False, height=0.045, wrapWidth=None, ori=0.0, 
        color='black', colorSpace='rgb', opacity=None, 
        languageStyle='LTR',
        depth=-1.0);
    text_110 = visual.TextStim(win=win, name='text_110',
        text='1=Not at all typical - 2 - 3 - 4 - 5=Very typical',
        font='Open Sans',
        pos=(0, -0.2), draggable=False, height=0.045, wrapWidth=None, ori=0.0, 
        color='black', colorSpace='rgb', opacity=None, 
        languageStyle='LTR',
        depth=-2.0);
    key_resp_35 = keyboard.Keyboard(deviceName='key_resp_35')
    
    # --- Initialize components for Routine "q2_instructions" ---
    text_155 = visual.TextStim(win=win, name='text_155',
        text="Now you’re going to answer a few questions about how much you've been feeling. ",
        font='Open Sans',
        pos=(0, 0), draggable=False, height=0.05, wrapWidth=None, ori=0.0, 
        color='black', colorSpace='rgb', opacity=None, 
        languageStyle='LTR',
        depth=0.0);
    
    # --- Initialize components for Routine "AM1" ---
    text_156 = visual.TextStim(win=win, name='text_156',
        text='How much has this happened to you in past two weeks? 1=Not at all, 3=Sometimes, 5=All the time',
        font='Open Sans',
        pos=(0, 0.28), draggable=False, height=0.045, wrapWidth=None, ori=0.0, 
        color='black', colorSpace='rgb', opacity=None, 
        languageStyle='LTR',
        depth=0.0);
    text_157 = visual.TextStim(win=win, name='text_157',
        text='Feel happier or more cheerful than usual.',
        font='Open Sans',
        pos=(0, 0), draggable=False, height=0.045, wrapWidth=None, ori=0.0, 
        color='black', colorSpace='rgb', opacity=None, 
        languageStyle='LTR',
        depth=-1.0);
    text_158 = visual.TextStim(win=win, name='text_158',
        text='1=Not at all - 2 - 3 - 4 - 5=All the time',
        font='Open Sans',
        pos=(0, -0.2), draggable=False, height=0.045, wrapWidth=None, ori=0.0, 
        color='black', colorSpace='rgb', opacity=None, 
        languageStyle='LTR',
        depth=-2.0);
    key_resp_41 = keyboard.Keyboard(deviceName='key_resp_41')
    
    # --- Initialize components for Routine "AM2" ---
    text_159 = visual.TextStim(win=win, name='text_159',
        text='How much has this happened to you in past two weeks? 1=Not at all, 3=Sometimes, 5=All the time',
        font='Open Sans',
        pos=(0, 0.28), draggable=False, height=0.045, wrapWidth=None, ori=0.0, 
        color='black', colorSpace='rgb', opacity=None, 
        languageStyle='LTR',
        depth=0.0);
    text_160 = visual.TextStim(win=win, name='text_160',
        text='Feel more self-confident than usual.',
        font='Open Sans',
        pos=(0, 0), draggable=False, height=0.045, wrapWidth=None, ori=0.0, 
        color='black', colorSpace='rgb', opacity=None, 
        languageStyle='LTR',
        depth=-1.0);
    text_161 = visual.TextStim(win=win, name='text_161',
        text='1=Not at all - 2 - 3 - 4 - 5=All the time',
        font='Open Sans',
        pos=(0, -0.2), draggable=False, height=0.045, wrapWidth=None, ori=0.0, 
        color='black', colorSpace='rgb', opacity=None, 
        languageStyle='LTR',
        depth=-2.0);
    key_resp_42 = keyboard.Keyboard(deviceName='key_resp_42')
    
    # --- Initialize components for Routine "AM3" ---
    text_162 = visual.TextStim(win=win, name='text_162',
        text='How much has this happened to you in past two weeks? 1=Not at all, 3=Sometimes, 5=All the time',
        font='Open Sans',
        pos=(0, 0.28), draggable=False, height=0.045, wrapWidth=None, ori=0.0, 
        color='black', colorSpace='rgb', opacity=None, 
        languageStyle='LTR',
        depth=0.0);
    text_163 = visual.TextStim(win=win, name='text_163',
        text='Need LESS Sleep than usual.',
        font='Open Sans',
        pos=(0, 0), draggable=False, height=0.045, wrapWidth=None, ori=0.0, 
        color='black', colorSpace='rgb', opacity=None, 
        languageStyle='LTR',
        depth=-1.0);
    text_164 = visual.TextStim(win=win, name='text_164',
        text='1=Not at all - 2 - 3 - 4 - 5=All the time',
        font='Open Sans',
        pos=(0, -0.2), draggable=False, height=0.045, wrapWidth=None, ori=0.0, 
        color='black', colorSpace='rgb', opacity=None, 
        languageStyle='LTR',
        depth=-2.0);
    key_resp_43 = keyboard.Keyboard(deviceName='key_resp_43')
    
    # --- Initialize components for Routine "AM4" ---
    text_165 = visual.TextStim(win=win, name='text_165',
        text='How much has this happened to you in past two weeks? 1=Not at all, 3=Sometimes, 5=All the time',
        font='Open Sans',
        pos=(0, 0.28), draggable=False, height=0.045, wrapWidth=None, ori=0.0, 
        color='black', colorSpace='rgb', opacity=None, 
        languageStyle='LTR',
        depth=0.0);
    text_166 = visual.TextStim(win=win, name='text_166',
        text='I talk more than usual.',
        font='Open Sans',
        pos=(0, 0), draggable=False, height=0.045, wrapWidth=None, ori=0.0, 
        color='black', colorSpace='rgb', opacity=None, 
        languageStyle='LTR',
        depth=-1.0);
    text_167 = visual.TextStim(win=win, name='text_167',
        text='1=Not at all - 2 - 3 - 4 - 5=All the time',
        font='Open Sans',
        pos=(0, -0.2), draggable=False, height=0.045, wrapWidth=None, ori=0.0, 
        color='black', colorSpace='rgb', opacity=None, 
        languageStyle='LTR',
        depth=-2.0);
    key_resp_44 = keyboard.Keyboard(deviceName='key_resp_44')
    
    # --- Initialize components for Routine "AM5" ---
    text_168 = visual.TextStim(win=win, name='text_168',
        text='How much has this happened to you in past two weeks? 1=Not at all, 3=Sometimes, 5=All the time',
        font='Open Sans',
        pos=(0, 0.28), draggable=False, height=0.045, wrapWidth=None, ori=0.0, 
        color='black', colorSpace='rgb', opacity=None, 
        languageStyle='LTR',
        depth=0.0);
    text_169 = visual.TextStim(win=win, name='text_169',
        text='I talk more than usual.',
        font='Open Sans',
        pos=(0, 0), draggable=False, height=0.045, wrapWidth=None, ori=0.0, 
        color='black', colorSpace='rgb', opacity=None, 
        languageStyle='LTR',
        depth=-1.0);
    text_170 = visual.TextStim(win=win, name='text_170',
        text='1=Not at all - 2 - 3 - 4 - 5=All the time',
        font='Open Sans',
        pos=(0, -0.2), draggable=False, height=0.045, wrapWidth=None, ori=0.0, 
        color='black', colorSpace='rgb', opacity=None, 
        languageStyle='LTR',
        depth=-2.0);
    key_resp_45 = keyboard.Keyboard(deviceName='key_resp_45')
    
    # --- Initialize components for Routine "q3_instructions" ---
    text_171 = visual.TextStim(win=win, name='text_171',
        text="Answer Yes (with 'y' key) or No (with 'n') key to the following questions",
        font='Open Sans',
        pos=(0, 0), draggable=False, height=0.05, wrapWidth=None, ori=0.0, 
        color='black', colorSpace='rgb', opacity=None, 
        languageStyle='LTR',
        depth=0.0);
    
    # --- Initialize components for Routine "SPQ1" ---
    text_173 = visual.TextStim(win=win, name='text_173',
        text='Have you ever had the sense that some person or force is around you, even though you\ncannot see anyone?',
        font='Open Sans',
        pos=(0, 0), draggable=False, height=0.045, wrapWidth=None, ori=0.0, 
        color='black', colorSpace='rgb', opacity=None, 
        languageStyle='LTR',
        depth=0.0);
    text_174 = visual.TextStim(win=win, name='text_174',
        text='y=YES        n=NO',
        font='Open Sans',
        pos=(0, -0.3), draggable=False, height=0.045, wrapWidth=None, ori=0.0, 
        color='black', colorSpace='rgb', opacity=None, 
        languageStyle='LTR',
        depth=-1.0);
    key_resp_46 = keyboard.Keyboard(deviceName='key_resp_46')
    
    # --- Initialize components for Routine "SPQ2" ---
    text_175 = visual.TextStim(win=win, name='text_175',
        text='Are you sometimes sure that other people can tell what you are thinking?',
        font='Open Sans',
        pos=(0, 0), draggable=False, height=0.045, wrapWidth=None, ori=0.0, 
        color='black', colorSpace='rgb', opacity=None, 
        languageStyle='LTR',
        depth=0.0);
    text_176 = visual.TextStim(win=win, name='text_176',
        text='y=YES        n=NO',
        font='Open Sans',
        pos=(0, -0.3), draggable=False, height=0.045, wrapWidth=None, ori=0.0, 
        color='black', colorSpace='rgb', opacity=None, 
        languageStyle='LTR',
        depth=-1.0);
    key_resp_47 = keyboard.Keyboard(deviceName='key_resp_47')
    
    # --- Initialize components for Routine "SPQ3" ---
    text_177 = visual.TextStim(win=win, name='text_177',
        text='Have you ever noticed a common event or object that seemed to be a special sign for\nyou?',
        font='Open Sans',
        pos=(0, 0), draggable=False, height=0.045, wrapWidth=None, ori=0.0, 
        color='black', colorSpace='rgb', opacity=None, 
        languageStyle='LTR',
        depth=0.0);
    text_178 = visual.TextStim(win=win, name='text_178',
        text='y=YES        n=NO',
        font='Open Sans',
        pos=(0, -0.3), draggable=False, height=0.045, wrapWidth=None, ori=0.0, 
        color='black', colorSpace='rgb', opacity=None, 
        languageStyle='LTR',
        depth=-1.0);
    key_resp_48 = keyboard.Keyboard(deviceName='key_resp_48')
    
    # --- Initialize components for Routine "SPQ4" ---
    text_179 = visual.TextStim(win=win, name='text_179',
        text='Do you often pick up hidden threats or put-downs from what people say or do?',
        font='Open Sans',
        pos=(0, 0), draggable=False, height=0.045, wrapWidth=None, ori=0.0, 
        color='black', colorSpace='rgb', opacity=None, 
        languageStyle='LTR',
        depth=0.0);
    text_180 = visual.TextStim(win=win, name='text_180',
        text='y=YES        n=NO',
        font='Open Sans',
        pos=(0, -0.3), draggable=False, height=0.045, wrapWidth=None, ori=0.0, 
        color='black', colorSpace='rgb', opacity=None, 
        languageStyle='LTR',
        depth=-1.0);
    key_resp_49 = keyboard.Keyboard(deviceName='key_resp_49')
    
    # --- Initialize components for Routine "SPQ5" ---
    text_181 = visual.TextStim(win=win, name='text_181',
        text='Do you often pick up hidden threats or put-downs from what people say or do?',
        font='Open Sans',
        pos=(0, 0), draggable=False, height=0.045, wrapWidth=None, ori=0.0, 
        color='black', colorSpace='rgb', opacity=None, 
        languageStyle='LTR',
        depth=0.0);
    text_182 = visual.TextStim(win=win, name='text_182',
        text='y=YES        n=NO',
        font='Open Sans',
        pos=(0, -0.3), draggable=False, height=0.045, wrapWidth=None, ori=0.0, 
        color='black', colorSpace='rgb', opacity=None, 
        languageStyle='LTR',
        depth=-1.0);
    key_resp_50 = keyboard.Keyboard(deviceName='key_resp_50')
    
    # --- Initialize components for Routine "SPQ6" ---
    text_183 = visual.TextStim(win=win, name='text_183',
        text='Have you had experiences with astrology, seeing the future, UFOs, ESP, or a sixth\nsense?',
        font='Open Sans',
        pos=(0, 0), draggable=False, height=0.045, wrapWidth=None, ori=0.0, 
        color='black', colorSpace='rgb', opacity=None, 
        languageStyle='LTR',
        depth=0.0);
    text_184 = visual.TextStim(win=win, name='text_184',
        text='y=YES        n=NO',
        font='Open Sans',
        pos=(0, -0.3), draggable=False, height=0.045, wrapWidth=None, ori=0.0, 
        color='black', colorSpace='rgb', opacity=None, 
        languageStyle='LTR',
        depth=-1.0);
    key_resp_51 = keyboard.Keyboard(deviceName='key_resp_51')
    
    # --- Initialize components for Routine "SPQ7" ---
    text_185 = visual.TextStim(win=win, name='text_185',
        text='Do you ever suddenly feel distracted by distant sounds that you are not normally aware\nof?',
        font='Open Sans',
        pos=(0, 0), draggable=False, height=0.045, wrapWidth=None, ori=0.0, 
        color='black', colorSpace='rgb', opacity=None, 
        languageStyle='LTR',
        depth=0.0);
    text_186 = visual.TextStim(win=win, name='text_186',
        text='y=YES        n=NO',
        font='Open Sans',
        pos=(0, -0.3), draggable=False, height=0.045, wrapWidth=None, ori=0.0, 
        color='black', colorSpace='rgb', opacity=None, 
        languageStyle='LTR',
        depth=-1.0);
    key_resp_52 = keyboard.Keyboard(deviceName='key_resp_52')
    
    # --- Initialize components for Routine "SPQ8" ---
    text_187 = visual.TextStim(win=win, name='text_187',
        text='Do you often have to keep an eye out to stop people from taking advantage of you?',
        font='Open Sans',
        pos=(0, 0), draggable=False, height=0.045, wrapWidth=None, ori=0.0, 
        color='black', colorSpace='rgb', opacity=None, 
        languageStyle='LTR',
        depth=0.0);
    text_188 = visual.TextStim(win=win, name='text_188',
        text='y=YES        n=NO',
        font='Open Sans',
        pos=(0, -0.3), draggable=False, height=0.045, wrapWidth=None, ori=0.0, 
        color='black', colorSpace='rgb', opacity=None, 
        languageStyle='LTR',
        depth=-1.0);
    key_resp_53 = keyboard.Keyboard(deviceName='key_resp_53')
    
    # --- Initialize components for Routine "SPQ9" ---
    text_189 = visual.TextStim(win=win, name='text_189',
        text='People sometimes find me aloof and distant.',
        font='Open Sans',
        pos=(0, 0), draggable=False, height=0.045, wrapWidth=None, ori=0.0, 
        color='black', colorSpace='rgb', opacity=None, 
        languageStyle='LTR',
        depth=0.0);
    text_190 = visual.TextStim(win=win, name='text_190',
        text='y=YES        n=NO',
        font='Open Sans',
        pos=(0, -0.3), draggable=False, height=0.045, wrapWidth=None, ori=0.0, 
        color='black', colorSpace='rgb', opacity=None, 
        languageStyle='LTR',
        depth=-1.0);
    key_resp_54 = keyboard.Keyboard(deviceName='key_resp_54')
    
    # --- Initialize components for Routine "SPQ10" ---
    text_191 = visual.TextStim(win=win, name='text_191',
        text='1 feel I have to be on my guard even with friends.',
        font='Open Sans',
        pos=(0, 0), draggable=False, height=0.045, wrapWidth=None, ori=0.0, 
        color='black', colorSpace='rgb', opacity=None, 
        languageStyle='LTR',
        depth=0.0);
    text_192 = visual.TextStim(win=win, name='text_192',
        text='y=YES        n=NO',
        font='Open Sans',
        pos=(0, -0.3), draggable=False, height=0.045, wrapWidth=None, ori=0.0, 
        color='black', colorSpace='rgb', opacity=None, 
        languageStyle='LTR',
        depth=-1.0);
    key_resp_55 = keyboard.Keyboard(deviceName='key_resp_55')
    
    # --- Initialize components for Routine "SQP11" ---
    text_193 = visual.TextStim(win=win, name='text_193',
        text='I feel very uncomfortable in social situations involving unfamiliar people.',
        font='Open Sans',
        pos=(0, 0), draggable=False, height=0.045, wrapWidth=None, ori=0.0, 
        color='black', colorSpace='rgb', opacity=None, 
        languageStyle='LTR',
        depth=0.0);
    text_194 = visual.TextStim(win=win, name='text_194',
        text='y=YES        n=NO',
        font='Open Sans',
        pos=(0, -0.3), draggable=False, height=0.045, wrapWidth=None, ori=0.0, 
        color='black', colorSpace='rgb', opacity=None, 
        languageStyle='LTR',
        depth=-1.0);
    key_resp_56 = keyboard.Keyboard(deviceName='key_resp_56')
    
    # --- Initialize components for Routine "SPQ12" ---
    text_195 = visual.TextStim(win=win, name='text_195',
        text='Have you found that it is best not to let other people know too much about you?',
        font='Open Sans',
        pos=(0, 0), draggable=False, height=0.045, wrapWidth=None, ori=0.0, 
        color='black', colorSpace='rgb', opacity=None, 
        languageStyle='LTR',
        depth=0.0);
    text_196 = visual.TextStim(win=win, name='text_196',
        text='y=YES        n=NO',
        font='Open Sans',
        pos=(0, -0.3), draggable=False, height=0.045, wrapWidth=None, ori=0.0, 
        color='black', colorSpace='rgb', opacity=None, 
        languageStyle='LTR',
        depth=-1.0);
    key_resp_57 = keyboard.Keyboard(deviceName='key_resp_57')
    
    # --- Initialize components for Routine "SPQ13" ---
    text_197 = visual.TextStim(win=win, name='text_197',
        text='I tend to keep in the background on social occasions.',
        font='Open Sans',
        pos=(0, 0), draggable=False, height=0.045, wrapWidth=None, ori=0.0, 
        color='black', colorSpace='rgb', opacity=None, 
        languageStyle='LTR',
        depth=0.0);
    text_198 = visual.TextStim(win=win, name='text_198',
        text='y=YES        n=NO',
        font='Open Sans',
        pos=(0, -0.3), draggable=False, height=0.045, wrapWidth=None, ori=0.0, 
        color='black', colorSpace='rgb', opacity=None, 
        languageStyle='LTR',
        depth=-1.0);
    key_resp_58 = keyboard.Keyboard(deviceName='key_resp_58')
    
    # --- Initialize components for Routine "SPQ14" ---
    text_199 = visual.TextStim(win=win, name='text_199',
        text='Do you feel that you are unable to get "close" to people?',
        font='Open Sans',
        pos=(0, 0), draggable=False, height=0.045, wrapWidth=None, ori=0.0, 
        color='black', colorSpace='rgb', opacity=None, 
        languageStyle='LTR',
        depth=0.0);
    text_200 = visual.TextStim(win=win, name='text_200',
        text='y=YES        n=NO',
        font='Open Sans',
        pos=(0, -0.3), draggable=False, height=0.045, wrapWidth=None, ori=0.0, 
        color='black', colorSpace='rgb', opacity=None, 
        languageStyle='LTR',
        depth=-1.0);
    key_resp_59 = keyboard.Keyboard(deviceName='key_resp_59')
    
    # --- Initialize components for Routine "SPQ15" ---
    text_201 = visual.TextStim(win=win, name='text_201',
        text='I feel very uneasy talking to people I do not know well.',
        font='Open Sans',
        pos=(0, 0), draggable=False, height=0.045, wrapWidth=None, ori=0.0, 
        color='black', colorSpace='rgb', opacity=None, 
        languageStyle='LTR',
        depth=0.0);
    text_202 = visual.TextStim(win=win, name='text_202',
        text='y=YES        n=NO',
        font='Open Sans',
        pos=(0, -0.3), draggable=False, height=0.045, wrapWidth=None, ori=0.0, 
        color='black', colorSpace='rgb', opacity=None, 
        languageStyle='LTR',
        depth=-1.0);
    key_resp_60 = keyboard.Keyboard(deviceName='key_resp_60')
    
    # --- Initialize components for Routine "SPQ16" ---
    text_203 = visual.TextStim(win=win, name='text_203',
        text='I tend to keep my feelings to myself.',
        font='Open Sans',
        pos=(0, 0), draggable=False, height=0.045, wrapWidth=None, ori=0.0, 
        color='black', colorSpace='rgb', opacity=None, 
        languageStyle='LTR',
        depth=0.0);
    text_204 = visual.TextStim(win=win, name='text_204',
        text='y=YES        n=NO',
        font='Open Sans',
        pos=(0, -0.3), draggable=False, height=0.045, wrapWidth=None, ori=0.0, 
        color='black', colorSpace='rgb', opacity=None, 
        languageStyle='LTR',
        depth=-1.0);
    key_resp_61 = keyboard.Keyboard(deviceName='key_resp_61')
    
    # --- Initialize components for Routine "SPQ17" ---
    text_205 = visual.TextStim(win=win, name='text_205',
        text='People sometimes comment on my unusual mannerisms and habits.',
        font='Open Sans',
        pos=(0, 0), draggable=False, height=0.045, wrapWidth=None, ori=0.0, 
        color='black', colorSpace='rgb', opacity=None, 
        languageStyle='LTR',
        depth=0.0);
    text_206 = visual.TextStim(win=win, name='text_206',
        text='y=YES        n=NO',
        font='Open Sans',
        pos=(0, -0.3), draggable=False, height=0.045, wrapWidth=None, ori=0.0, 
        color='black', colorSpace='rgb', opacity=None, 
        languageStyle='LTR',
        depth=-1.0);
    key_resp_62 = keyboard.Keyboard(deviceName='key_resp_62')
    
    # --- Initialize components for Routine "SPQ18" ---
    text_207 = visual.TextStim(win=win, name='text_207',
        text='Some people think that I am a very bizarre person.',
        font='Open Sans',
        pos=(0, 0), draggable=False, height=0.045, wrapWidth=None, ori=0.0, 
        color='black', colorSpace='rgb', opacity=None, 
        languageStyle='LTR',
        depth=0.0);
    text_208 = visual.TextStim(win=win, name='text_208',
        text='y=YES        n=NO',
        font='Open Sans',
        pos=(0, -0.3), draggable=False, height=0.045, wrapWidth=None, ori=0.0, 
        color='black', colorSpace='rgb', opacity=None, 
        languageStyle='LTR',
        depth=-1.0);
    key_resp_63 = keyboard.Keyboard(deviceName='key_resp_63')
    
    # --- Initialize components for Routine "SPQ19" ---
    text_209 = visual.TextStim(win=win, name='text_209',
        text='Some people find me a bit vague and elusive during a conversation.',
        font='Open Sans',
        pos=(0, 0), draggable=False, height=0.045, wrapWidth=None, ori=0.0, 
        color='black', colorSpace='rgb', opacity=None, 
        languageStyle='LTR',
        depth=0.0);
    text_210 = visual.TextStim(win=win, name='text_210',
        text='y=YES        n=NO',
        font='Open Sans',
        pos=(0, -0.3), draggable=False, height=0.045, wrapWidth=None, ori=0.0, 
        color='black', colorSpace='rgb', opacity=None, 
        languageStyle='LTR',
        depth=-1.0);
    key_resp_64 = keyboard.Keyboard(deviceName='key_resp_64')
    
    # --- Initialize components for Routine "SPQ20" ---
    text_211 = visual.TextStim(win=win, name='text_211',
        text='I sometimes use words in unusual ways.',
        font='Open Sans',
        pos=(0, 0), draggable=False, height=0.045, wrapWidth=None, ori=0.0, 
        color='black', colorSpace='rgb', opacity=None, 
        languageStyle='LTR',
        depth=0.0);
    text_212 = visual.TextStim(win=win, name='text_212',
        text='y=YES        n=NO',
        font='Open Sans',
        pos=(0, -0.3), draggable=False, height=0.045, wrapWidth=None, ori=0.0, 
        color='black', colorSpace='rgb', opacity=None, 
        languageStyle='LTR',
        depth=-1.0);
    key_resp_65 = keyboard.Keyboard(deviceName='key_resp_65')
    
    # --- Initialize components for Routine "SPQ21" ---
    text_213 = visual.TextStim(win=win, name='text_213',
        text='1 am an odd, unusual person.',
        font='Open Sans',
        pos=(0, 0), draggable=False, height=0.045, wrapWidth=None, ori=0.0, 
        color='black', colorSpace='rgb', opacity=None, 
        languageStyle='LTR',
        depth=0.0);
    text_214 = visual.TextStim(win=win, name='text_214',
        text='y=YES        n=NO',
        font='Open Sans',
        pos=(0, -0.3), draggable=False, height=0.045, wrapWidth=None, ori=0.0, 
        color='black', colorSpace='rgb', opacity=None, 
        languageStyle='LTR',
        depth=-1.0);
    key_resp_66 = keyboard.Keyboard(deviceName='key_resp_66')
    
    # --- Initialize components for Routine "SPQ22" ---
    text_215 = visual.TextStim(win=win, name='text_215',
        text='I find it hard to communicate clearly what I want to say to people.',
        font='Open Sans',
        pos=(0, 0), draggable=False, height=0.045, wrapWidth=None, ori=0.0, 
        color='black', colorSpace='rgb', opacity=None, 
        languageStyle='LTR',
        depth=0.0);
    text_216 = visual.TextStim(win=win, name='text_216',
        text='y=YES        n=NO',
        font='Open Sans',
        pos=(0, -0.3), draggable=False, height=0.045, wrapWidth=None, ori=0.0, 
        color='black', colorSpace='rgb', opacity=None, 
        languageStyle='LTR',
        depth=-1.0);
    key_resp_67 = keyboard.Keyboard(deviceName='key_resp_67')
    
    # --- Initialize components for Routine "q4_instructions" ---
    text_172 = visual.TextStim(win=win, name='text_172',
        text='Now you will rate how much you feel several emotions at this moment',
        font='Open Sans',
        pos=(0, 0), draggable=False, height=0.05, wrapWidth=None, ori=0.0, 
        color='black', colorSpace='rgb', opacity=None, 
        languageStyle='LTR',
        depth=0.0);
    
    # --- Initialize components for Routine "SS1" ---
    text_217 = visual.TextStim(win=win, name='text_217',
        text='How much do you feel this emotion now?',
        font='Open Sans',
        pos=(0, 0.28), draggable=False, height=0.045, wrapWidth=None, ori=0.0, 
        color='black', colorSpace='rgb', opacity=None, 
        languageStyle='LTR',
        depth=0.0);
    text_218 = visual.TextStim(win=win, name='text_218',
        text='Dissatisfied',
        font='Open Sans',
        pos=(0, 0), draggable=False, height=0.045, wrapWidth=None, ori=0.0, 
        color='black', colorSpace='rgb', opacity=None, 
        languageStyle='LTR',
        depth=-1.0);
    text_219 = visual.TextStim(win=win, name='text_219',
        text='1=Not at all - 2 - 3 - 4 - 5=Extremely',
        font='Open Sans',
        pos=(0, -0.2), draggable=False, height=0.045, wrapWidth=None, ori=0.0, 
        color='black', colorSpace='rgb', opacity=None, 
        languageStyle='LTR',
        depth=-2.0);
    key_resp_68 = keyboard.Keyboard(deviceName='key_resp_68')
    
    # --- Initialize components for Routine "SS2" ---
    text_220 = visual.TextStim(win=win, name='text_220',
        text='How much do you feel this emotion now?',
        font='Open Sans',
        pos=(0, 0.28), draggable=False, height=0.045, wrapWidth=None, ori=0.0, 
        color='black', colorSpace='rgb', opacity=None, 
        languageStyle='LTR',
        depth=0.0);
    text_221 = visual.TextStim(win=win, name='text_221',
        text='Alert',
        font='Open Sans',
        pos=(0, 0), draggable=False, height=0.045, wrapWidth=None, ori=0.0, 
        color='black', colorSpace='rgb', opacity=None, 
        languageStyle='LTR',
        depth=-1.0);
    text_222 = visual.TextStim(win=win, name='text_222',
        text='1=Not at all - 2 - 3 - 4 - 5=Extremely',
        font='Open Sans',
        pos=(0, -0.2), draggable=False, height=0.045, wrapWidth=None, ori=0.0, 
        color='black', colorSpace='rgb', opacity=None, 
        languageStyle='LTR',
        depth=-2.0);
    key_resp_69 = keyboard.Keyboard(deviceName='key_resp_69')
    
    # --- Initialize components for Routine "SS3" ---
    text_223 = visual.TextStim(win=win, name='text_223',
        text='How much do you feel this emotion now?',
        font='Open Sans',
        pos=(0, 0.28), draggable=False, height=0.045, wrapWidth=None, ori=0.0, 
        color='black', colorSpace='rgb', opacity=None, 
        languageStyle='LTR',
        depth=0.0);
    text_224 = visual.TextStim(win=win, name='text_224',
        text='Depressed',
        font='Open Sans',
        pos=(0, 0), draggable=False, height=0.045, wrapWidth=None, ori=0.0, 
        color='black', colorSpace='rgb', opacity=None, 
        languageStyle='LTR',
        depth=-1.0);
    text_225 = visual.TextStim(win=win, name='text_225',
        text='1=Not at all - 2 - 3 - 4 - 5=Extremely',
        font='Open Sans',
        pos=(0, -0.2), draggable=False, height=0.045, wrapWidth=None, ori=0.0, 
        color='black', colorSpace='rgb', opacity=None, 
        languageStyle='LTR',
        depth=-2.0);
    key_resp_70 = keyboard.Keyboard(deviceName='key_resp_70')
    
    # --- Initialize components for Routine "SS4" ---
    text_226 = visual.TextStim(win=win, name='text_226',
        text='How much do you feel this emotion now?',
        font='Open Sans',
        pos=(0, 0.28), draggable=False, height=0.045, wrapWidth=None, ori=0.0, 
        color='black', colorSpace='rgb', opacity=None, 
        languageStyle='LTR',
        depth=0.0);
    text_227 = visual.TextStim(win=win, name='text_227',
        text='Sad',
        font='Open Sans',
        pos=(0, 0), draggable=False, height=0.045, wrapWidth=None, ori=0.0, 
        color='black', colorSpace='rgb', opacity=None, 
        languageStyle='LTR',
        depth=-1.0);
    text_228 = visual.TextStim(win=win, name='text_228',
        text='1=Not at all - 2 - 3 - 4 - 5=Extremely',
        font='Open Sans',
        pos=(0, -0.2), draggable=False, height=0.045, wrapWidth=None, ori=0.0, 
        color='black', colorSpace='rgb', opacity=None, 
        languageStyle='LTR',
        depth=-2.0);
    key_resp_71 = keyboard.Keyboard(deviceName='key_resp_71')
    
    # --- Initialize components for Routine "SS5" ---
    text_229 = visual.TextStim(win=win, name='text_229',
        text='How much do you feel this emotion now?',
        font='Open Sans',
        pos=(0, 0.28), draggable=False, height=0.045, wrapWidth=None, ori=0.0, 
        color='black', colorSpace='rgb', opacity=None, 
        languageStyle='LTR',
        depth=0.0);
    text_230 = visual.TextStim(win=win, name='text_230',
        text='Active',
        font='Open Sans',
        pos=(0, 0), draggable=False, height=0.045, wrapWidth=None, ori=0.0, 
        color='black', colorSpace='rgb', opacity=None, 
        languageStyle='LTR',
        depth=-1.0);
    text_231 = visual.TextStim(win=win, name='text_231',
        text='1=Not at all - 2 - 3 - 4 - 5=Extremely',
        font='Open Sans',
        pos=(0, -0.2), draggable=False, height=0.045, wrapWidth=None, ori=0.0, 
        color='black', colorSpace='rgb', opacity=None, 
        languageStyle='LTR',
        depth=-2.0);
    key_resp_72 = keyboard.Keyboard(deviceName='key_resp_72')
    
    # --- Initialize components for Routine "SS6" ---
    text_232 = visual.TextStim(win=win, name='text_232',
        text='How much do you feel this emotion now?',
        font='Open Sans',
        pos=(0, 0.28), draggable=False, height=0.045, wrapWidth=None, ori=0.0, 
        color='black', colorSpace='rgb', opacity=None, 
        languageStyle='LTR',
        depth=0.0);
    text_233 = visual.TextStim(win=win, name='text_233',
        text='Impatient',
        font='Open Sans',
        pos=(0, 0), draggable=False, height=0.045, wrapWidth=None, ori=0.0, 
        color='black', colorSpace='rgb', opacity=None, 
        languageStyle='LTR',
        depth=-1.0);
    text_234 = visual.TextStim(win=win, name='text_234',
        text='1=Not at all - 2 - 3 - 4 - 5=Extremely',
        font='Open Sans',
        pos=(0, -0.2), draggable=False, height=0.045, wrapWidth=None, ori=0.0, 
        color='black', colorSpace='rgb', opacity=None, 
        languageStyle='LTR',
        depth=-2.0);
    key_resp_73 = keyboard.Keyboard(deviceName='key_resp_73')
    
    # --- Initialize components for Routine "SS7" ---
    text_235 = visual.TextStim(win=win, name='text_235',
        text='How much do you feel this emotion now?',
        font='Open Sans',
        pos=(0, 0.28), draggable=False, height=0.045, wrapWidth=None, ori=0.0, 
        color='black', colorSpace='rgb', opacity=None, 
        languageStyle='LTR',
        depth=0.0);
    text_236 = visual.TextStim(win=win, name='text_236',
        text='Annoyed',
        font='Open Sans',
        pos=(0, 0), draggable=False, height=0.045, wrapWidth=None, ori=0.0, 
        color='black', colorSpace='rgb', opacity=None, 
        languageStyle='LTR',
        depth=-1.0);
    text_237 = visual.TextStim(win=win, name='text_237',
        text='1=Not at all - 2 - 3 - 4 - 5=Extremely',
        font='Open Sans',
        pos=(0, -0.2), draggable=False, height=0.045, wrapWidth=None, ori=0.0, 
        color='black', colorSpace='rgb', opacity=None, 
        languageStyle='LTR',
        depth=-2.0);
    key_resp_74 = keyboard.Keyboard(deviceName='key_resp_74')
    
    # --- Initialize components for Routine "SS8" ---
    text_238 = visual.TextStim(win=win, name='text_238',
        text='How much do you feel this emotion now?',
        font='Open Sans',
        pos=(0, 0.28), draggable=False, height=0.045, wrapWidth=None, ori=0.0, 
        color='black', colorSpace='rgb', opacity=None, 
        languageStyle='LTR',
        depth=0.0);
    text_239 = visual.TextStim(win=win, name='text_239',
        text='Angry',
        font='Open Sans',
        pos=(0, 0), draggable=False, height=0.045, wrapWidth=None, ori=0.0, 
        color='black', colorSpace='rgb', opacity=None, 
        languageStyle='LTR',
        depth=-1.0);
    text_240 = visual.TextStim(win=win, name='text_240',
        text='1=Not at all - 2 - 3 - 4 - 5=Extremely',
        font='Open Sans',
        pos=(0, -0.2), draggable=False, height=0.045, wrapWidth=None, ori=0.0, 
        color='black', colorSpace='rgb', opacity=None, 
        languageStyle='LTR',
        depth=-2.0);
    key_resp_75 = keyboard.Keyboard(deviceName='key_resp_75')
    
    # --- Initialize components for Routine "SS9" ---
    text_241 = visual.TextStim(win=win, name='text_241',
        text='How much do you feel this emotion now?',
        font='Open Sans',
        pos=(0, 0.28), draggable=False, height=0.045, wrapWidth=None, ori=0.0, 
        color='black', colorSpace='rgb', opacity=None, 
        languageStyle='LTR',
        depth=0.0);
    text_242 = visual.TextStim(win=win, name='text_242',
        text='Irritated',
        font='Open Sans',
        pos=(0, 0), draggable=False, height=0.045, wrapWidth=None, ori=0.0, 
        color='black', colorSpace='rgb', opacity=None, 
        languageStyle='LTR',
        depth=-1.0);
    text_243 = visual.TextStim(win=win, name='text_243',
        text='1=Not at all - 2 - 3 - 4 - 5=Extremely',
        font='Open Sans',
        pos=(0, -0.2), draggable=False, height=0.045, wrapWidth=None, ori=0.0, 
        color='black', colorSpace='rgb', opacity=None, 
        languageStyle='LTR',
        depth=-2.0);
    key_resp_76 = keyboard.Keyboard(deviceName='key_resp_76')
    
    # --- Initialize components for Routine "SS10" ---
    text_244 = visual.TextStim(win=win, name='text_244',
        text='How much do you feel this emotion now?',
        font='Open Sans',
        pos=(0, 0.28), draggable=False, height=0.045, wrapWidth=None, ori=0.0, 
        color='black', colorSpace='rgb', opacity=None, 
        languageStyle='LTR',
        depth=0.0);
    text_245 = visual.TextStim(win=win, name='text_245',
        text='Grouchy',
        font='Open Sans',
        pos=(0, 0), draggable=False, height=0.045, wrapWidth=None, ori=0.0, 
        color='black', colorSpace='rgb', opacity=None, 
        languageStyle='LTR',
        depth=-1.0);
    text_246 = visual.TextStim(win=win, name='text_246',
        text='1=Not at all - 2 - 3 - 4 - 5=Extremely',
        font='Open Sans',
        pos=(0, -0.2), draggable=False, height=0.045, wrapWidth=None, ori=0.0, 
        color='black', colorSpace='rgb', opacity=None, 
        languageStyle='LTR',
        depth=-2.0);
    key_resp_77 = keyboard.Keyboard(deviceName='key_resp_77')
    
    # --- Initialize components for Routine "instructions" ---
    # Run 'Begin Experiment' code from code_2
    incorrect_actions = 0
    
    cogmap={'baby_left':'backpack',
    'baby_right':'bowtie',
    'toothbrush_left':'car',
    'toothbrush_right':'backpack',
    'backpack_left':'lamp',
    'backpack_right':'zebra',
    'car_left':'cat',
    'car_right':'lamp',
    'bowtie_left':'knight',
    'bowtie_right':'lamp'
    }
    
    cogmap_replanning={'baby_left':'car',
    'baby_right':'backpack',
    'toothbrush_left':'bowtie',
    'toothbrush_right':'backpack',
    'hourglass_left':'bending',
    'hourglass_right':'zebra',
    'backpack_left':'lamp',
    'backpack_right':'hourglass',
    'lamp_left':'zebra',
    'lamp_right':'knight',
    'cat_left':'zebra',
    'cat_right':'hammer',
    'car_left':'cat',
    'car_right':'lamp',
    'bowtie_left':'lamp',
    'bowtie_right':'lamp'
    }
    
    current_image='images/baby.png'
    current_image2='images/backpack.png'
    current_image3='images/lamp.png'
    current_image4='images/zebra.png'
    alternative_image='images/car.png'
    instruction_test = visual.TextStim(win=win, name='instruction_test',
        text='The beginning of the task will involve learning associations between images. You will be told to click left or right at a starting image. You will then see which picture you see next. Your goal is to learn how to get from one picture to the next depending on which direction you go — left or right.\n\nIf you fail to click the correct button 5 times, you will be exited from the game and not win any money. Also, be sure NOT TO CLICK ESC on your keyboard, as that will also exit you from the game. \n\nLAST, if you do not get a high enough score on a simple memory test by the end of training, you are at risk of losing half of your money. So pay attention on memory quizzes!\n\nPress SPACE to continue',
        font='Open Sans',
        pos=(0, 0), draggable=False, height=0.042, wrapWidth=None, ori=0.0, 
        color='black', colorSpace='rgb', opacity=None, 
        languageStyle='LTR',
        depth=-1.0);
    end_instructions = keyboard.Keyboard(deviceName='end_instructions')
    
    # --- Initialize components for Routine "second_instructions" ---
    key_resp_2 = keyboard.Keyboard(deviceName='key_resp_2')
    text_22 = visual.TextStim(win=win, name='text_22',
        text='Your goal is to learn which new picture you will arrive at after selecting a picture by clicking LEFT or RIGHT on your keyboard.\n\nNOTE: There will be a SECOND phase after this first phase, where you can use what you learned to win even more money!\n\nPress SPACE to continue',
        font='Open Sans',
        pos=(0, 0), draggable=False, height=0.04, wrapWidth=None, ori=0.0, 
        color='black', colorSpace='rgb', opacity=None, 
        languageStyle='LTR',
        depth=-1.0);
    
    # --- Initialize components for Routine "third_instructions" ---
    responseleft = keyboard.Keyboard(deviceName='responseleft')
    text_23 = visual.TextStim(win=win, name='text_23',
        text='Remember, your goal is to remember which images come after you choose and the action, LEFT or RIGHT at a starting image. For example, choosing LEFT at a picture of an APPLE may take you to a different image than choosing RIGHT.\n\nTo show you what this looks like, you will do a practice round. You will be tested to see if you remember which images come after the starting image. Good luck! \n\nPress SPACE to continue',
        font='Open Sans',
        pos=(0, 0.0), draggable=False, height=0.04, wrapWidth=None, ori=0.0, 
        color='black', colorSpace='rgb', opacity=None, 
        languageStyle='LTR',
        depth=-1.0);
    
    # --- Initialize components for Routine "instructions4" ---
    text_153 = visual.TextStim(win=win, name='text_153',
        text='If you fail to get 100% on the questions that make sure you understand the ways to get from one picture to the next picture, THE GAME WILL EXIT and you will receive only partial credit for time spent.\n\npay attention during learning so you can win more money! ',
        font='Open Sans',
        pos=(0, 0), draggable=False, height=0.06, wrapWidth=None, ori=0.0, 
        color='black', colorSpace='rgb', opacity=None, 
        languageStyle='LTR',
        depth=0.0);
    
    # --- Initialize components for Routine "practice1" ---
    image_22 = visual.ImageStim(
        win=win,
        name='image_22', 
        image='default.png', mask=None, anchor='center',
        ori=0.0, pos=(0, 0), draggable=False, size=(0.5, 0.5),
        color=[1,1,1], colorSpace='rgb', opacity=None,
        flipHoriz=False, flipVert=False,
        texRes=128.0, interpolate=True, depth=0.0)
    key_resp_10 = keyboard.Keyboard(deviceName='key_resp_10')
    text_40 = visual.TextStim(win=win, name='text_40',
        text='Press left',
        font='Open Sans',
        pos=(0, -0.35), draggable=False, height=0.05, wrapWidth=None, ori=0.0, 
        color='black', colorSpace='rgb', opacity=None, 
        languageStyle='LTR',
        depth=-2.0);
    
    # --- Initialize components for Routine "practice1_result" ---
    image_20 = visual.ImageStim(
        win=win,
        name='image_20', 
        image='default.png', mask=None, anchor='center',
        ori=0.0, pos=(0, 0), draggable=False, size=(0.5, 0.5),
        color=[1,1,1], colorSpace='rgb', opacity=None,
        flipHoriz=False, flipVert=False,
        texRes=128.0, interpolate=True, depth=0.0)
    
    # --- Initialize components for Routine "next_trial" ---
    next_trial_text = visual.TextStim(win=win, name='next_trial_text',
        text='next trial…',
        font='Open Sans',
        pos=(0, 0), draggable=False, height=0.05, wrapWidth=None, ori=0.0, 
        color='black', colorSpace='rgb', opacity=None, 
        languageStyle='LTR',
        depth=0.0);
    
    # --- Initialize components for Routine "practice1_quiz" ---
    basket_2 = visual.ImageStim(
        win=win,
        name='basket_2', 
        image='basket.png', mask=None, anchor='center',
        ori=0.0, pos=(-0.6, -0.05), draggable=False, size=(0.25, 0.25),
        color=[1,1,1], colorSpace='rgb', opacity=None,
        flipHoriz=False, flipVert=False,
        texRes=128.0, interpolate=True, depth=0.0)
    fireworks_2 = visual.ImageStim(
        win=win,
        name='fireworks_2', 
        image='fireworks.png', mask=None, anchor='center',
        ori=0.0, pos=(0, -0.05), draggable=False, size=(0.25, 0.25),
        color=[1,1,1], colorSpace='rgb', opacity=None,
        flipHoriz=False, flipVert=False,
        texRes=128.0, interpolate=True, depth=-1.0)
    tree_2 = visual.ImageStim(
        win=win,
        name='tree_2', 
        image='default.png', mask=None, anchor='center',
        ori=0.0, pos=(0.6, -0.05), draggable=False, size=(0.25, 0.25),
        color=[1,1,1], colorSpace='rgb', opacity=None,
        flipHoriz=False, flipVert=False,
        texRes=128.0, interpolate=True, depth=-2.0)
    text_24 = visual.TextStim(win=win, name='text_24',
        text='A',
        font='Open Sans',
        pos=(-0.6, -0.25), draggable=False, height=0.1, wrapWidth=None, ori=0.0, 
        color='black', colorSpace='rgb', opacity=None, 
        languageStyle='LTR',
        depth=-3.0);
    text_25 = visual.TextStim(win=win, name='text_25',
        text='G',
        font='Open Sans',
        pos=(0, -0.25), draggable=False, height=0.1, wrapWidth=None, ori=0.0, 
        color='black', colorSpace='rgb', opacity=None, 
        languageStyle='LTR',
        depth=-4.0);
    text_27 = visual.TextStim(win=win, name='text_27',
        text='L',
        font='Open Sans',
        pos=(0.6, -0.25), draggable=False, height=0.1, wrapWidth=None, ori=0.0, 
        color='black', colorSpace='rgb', opacity=None, 
        languageStyle='LTR',
        depth=-5.0);
    practice_answer = keyboard.Keyboard(deviceName='practice_answer')
    text_26 = visual.TextStim(win=win, name='text_26',
        text='Which image below did you see after clicking LEFT at the apple image?',
        font='Open Sans',
        pos=(0, 0.2), draggable=False, height=0.05, wrapWidth=None, ori=0.0, 
        color='black', colorSpace='rgb', opacity=None, 
        languageStyle='LTR',
        depth=-8.0);
    
    # --- Initialize components for Routine "practice1_quizfeedback" ---
    text_30 = visual.TextStim(win=win, name='text_30',
        text='',
        font='Open Sans',
        pos=(0, 0), draggable=False, height=0.05, wrapWidth=None, ori=0.0, 
        color='black', colorSpace='rgb', opacity=None, 
        languageStyle='LTR',
        depth=-1.0);
    
    # --- Initialize components for Routine "memory_quiz_instructions" ---
    text_75 = visual.TextStim(win=win, name='text_75',
        text='During your learning about how to get from one picture to another, you will be tested on your learning.\n\nEvery so often (30 trials) you will be asked to use what you’ve learned to try to reach an image where money is hiding. Each of these questions has a correct answer, and we will reward you at the end of the study based on how well you did on these questions. \n\nSpecifically, we will pick a total of 5 rounds at random from these rounds where you can earn reward to determine how much money you win\n\nPress SPACE to continue',
        font='Open Sans',
        pos=(0, 0), draggable=False, height=0.05, wrapWidth=None, ori=0.0, 
        color='black', colorSpace='rgb', opacity=None, 
        languageStyle='LTR',
        depth=0.0);
    key_resp_23 = keyboard.Keyboard(deviceName='key_resp_23')
    
    # --- Initialize components for Routine "quiz1_i" ---
    text_43 = visual.TextStim(win=win, name='text_43',
        text='Instructions Quiz\n\n1. What is the goal of the picture game?\n\na.to learn the type of picture\n\nb.to learn the meaning of pictures\n\nc.to learn which pictures come after taking actions (left or right) certain pictures\n\nd.to learn how actions you take at a picture give you rewards or punishments',
        font='Open Sans',
        pos=(0, 0), draggable=False, height=0.038, wrapWidth=None, ori=0.0, 
        color='black', colorSpace='rgb', opacity=None, 
        languageStyle='LTR',
        depth=0.0);
    key_resp_17 = keyboard.Keyboard(deviceName='key_resp_17')
    
    # --- Initialize components for Routine "quiz2_i" ---
    text_70 = visual.TextStim(win=win, name='text_70',
        text='Instructions Quiz\n\n2. Will you be quizzed during a learning phase about how to get to certain images?\n\na. no\n\nb. yes, every trial you will be quizzed\n\nc. yes, every so oftern (30 trials) you will be quizzed\n\nd. yes, but only at the end of training',
        font='Open Sans',
        pos=(0, 0), draggable=False, height=0.038, wrapWidth=None, ori=0.0, 
        color='black', colorSpace='rgb', opacity=None, 
        languageStyle='LTR',
        depth=0.0);
    key_resp_18 = keyboard.Keyboard(deviceName='key_resp_18')
    
    # --- Initialize components for Routine "quiz3" ---
    text_71 = visual.TextStim(win=win, name='text_71',
        text='Instructions Quiz\n\n3. What happens during the memory quiz?\n\na.you must recall how the pictures look\n\nb. you must REMEMBER the action that will take you a starting image to an upcoming image. 5 of these questions picked at random by the computer will add money to your total\n\nc. you must recall images you most likely DO NOT see after taking an action at a starting image\n\nd. FORGET the action that will take you a starting image to an upcoming image. ',
        font='Open Sans',
        pos=(0, 0), draggable=False, height=0.038, wrapWidth=None, ori=0.0, 
        color='black', colorSpace='rgb', opacity=None, 
        languageStyle='LTR',
        depth=0.0);
    key_resp_19 = keyboard.Keyboard(deviceName='key_resp_19')
    
    # --- Initialize components for Routine "quiz4" ---
    text_72 = visual.TextStim(win=win, name='text_72',
        text='Instructions Quiz\n\n4. After learning you will:\n\na. Be done with the task\n\nb. Use what you learned to plan how to get to certain images\n\nc. Asked to paint an image of what you learned\n\nd. answer many questions about how much you liked the game',
        font='Open Sans',
        pos=(0, 0), draggable=False, height=0.038, wrapWidth=None, ori=0.0, 
        color='black', colorSpace='rgb', opacity=None, 
        languageStyle='LTR',
        depth=0.0);
    key_resp_20 = keyboard.Keyboard(deviceName='key_resp_20')
    
    # --- Initialize components for Routine "quiz_feedback" ---
    result_q_instr = visual.TextStim(win=win, name='result_q_instr',
        text='',
        font='Open Sans',
        pos=(0, 0), draggable=False, height=0.06, wrapWidth=None, ori=0.0, 
        color='black', colorSpace='rgb', opacity=None, 
        languageStyle='LTR',
        depth=0.0);
    
    # --- Initialize components for Routine "start_learning" ---
    text_31 = visual.TextStim(win=win, name='text_31',
        text='Press SPACE to start learning!',
        font='Open Sans',
        pos=(0, 0), draggable=False, height=0.04, wrapWidth=None, ori=0.0, 
        color='black', colorSpace='rgb', opacity=None, 
        languageStyle='LTR',
        depth=0.0);
    key_resp_7 = keyboard.Keyboard(deviceName='key_resp_7')
    
    # --- Initialize components for Routine "learn1" ---
    key_resp = keyboard.Keyboard(deviceName='key_resp')
    image_1 = visual.ImageStim(
        win=win,
        name='image_1', 
        image='default.png', mask=None, anchor='center',
        ori=0.0, pos=(0, 0), draggable=False, size=(0.5, 0.5),
        color=[1,1,1], colorSpace='rgb', opacity=None,
        flipHoriz=False, flipVert=False,
        texRes=128.0, interpolate=True, depth=-1.0)
    text = visual.TextStim(win=win, name='text',
        text='',
        font='Open Sans',
        pos=(0, -0.35), draggable=False, height=0.05, wrapWidth=None, ori=0.0, 
        color='black', colorSpace='rgb', opacity=None, 
        languageStyle='LTR',
        depth=-2.0);
    
    # --- Initialize components for Routine "check_incorrect1" ---
    text_incorrect_2 = visual.TextStim(win=win, name='text_incorrect_2',
        text='',
        font='Open Sans',
        pos=(0, 0), draggable=False, height=0.05, wrapWidth=None, ori=0.0, 
        color='black', colorSpace='rgb', opacity=None, 
        languageStyle='LTR',
        depth=-1.0);
    
    # --- Initialize components for Routine "learn2" ---
    image_2 = visual.ImageStim(
        win=win,
        name='image_2', 
        image='default.png', mask=None, anchor='center',
        ori=0.0, pos=(0, 0), draggable=False, size=(0.5,0.5),
        color=[1,1,1], colorSpace='rgb', opacity=None,
        flipHoriz=False, flipVert=False,
        texRes=128.0, interpolate=True, depth=0.0)
    
    # --- Initialize components for Routine "next_trial" ---
    next_trial_text = visual.TextStim(win=win, name='next_trial_text',
        text='next trial…',
        font='Open Sans',
        pos=(0, 0), draggable=False, height=0.05, wrapWidth=None, ori=0.0, 
        color='black', colorSpace='rgb', opacity=None, 
        languageStyle='LTR',
        depth=0.0);
    
    # --- Initialize components for Routine "counter_quizzes_round" ---
    
    # --- Initialize components for Routine "between" ---
    text_2 = visual.TextStim(win=win, name='text_2',
        text='Time for a memory quiz based on what you learned',
        font='Open Sans',
        pos=(0, 0), draggable=False, height=0.05, wrapWidth=None, ori=0.0, 
        color='black', colorSpace='rgb', opacity=None, 
        languageStyle='LTR',
        depth=0.0);
    
    # --- Initialize components for Routine "quiz" ---
    target_quiz1 = visual.ImageStim(
        win=win,
        name='target_quiz1', 
        image='default.png', mask=None, anchor='center',
        ori=0.0, pos=(0,.15), draggable=False, size=(0.4,0.4),
        color=[1,1,1], colorSpace='rgb', opacity=None,
        flipHoriz=False, flipVert=False,
        texRes=128.0, interpolate=True, depth=0.0)
    question_quiz1 = visual.TextStim(win=win, name='question_quiz1',
        text='',
        font='Open Sans',
        pos=(0, 0.4), draggable=False, height=0.05, wrapWidth=None, ori=0.0, 
        color='black', colorSpace='rgb', opacity=None, 
        languageStyle='LTR',
        depth=-1.0);
    answer_quiz1 = keyboard.Keyboard(deviceName='answer_quiz1')
    answer1 = visual.ImageStim(
        win=win,
        name='answer1', 
        image='default.png', mask=None, anchor='center',
        ori=0.0, pos=(-0.45, -.20), draggable=False, size=(0.2, 0.2),
        color=[1,1,1], colorSpace='rgb', opacity=None,
        flipHoriz=False, flipVert=False,
        texRes=128.0, interpolate=True, depth=-3.0)
    answer2 = visual.ImageStim(
        win=win,
        name='answer2', 
        image='default.png', mask=None, anchor='center',
        ori=0.0, pos=(-0.15, -.20), draggable=False, size=(0.2, 0.2),
        color=[1,1,1], colorSpace='rgb', opacity=None,
        flipHoriz=False, flipVert=False,
        texRes=128.0, interpolate=True, depth=-4.0)
    answer3 = visual.ImageStim(
        win=win,
        name='answer3', 
        image='default.png', mask=None, anchor='center',
        ori=0.0, pos=(0.15, -.20), draggable=False, size=(0.2, 0.2),
        color=[1,1,1], colorSpace='rgb', opacity=None,
        flipHoriz=False, flipVert=False,
        texRes=128.0, interpolate=True, depth=-5.0)
    answer4 = visual.ImageStim(
        win=win,
        name='answer4', 
        image='default.png', mask=None, anchor='center',
        ori=0.0, pos=(0.45, -0.20), draggable=False, size=(0.2, 0.2),
        color=[1,1,1], colorSpace='rgb', opacity=None,
        flipHoriz=False, flipVert=False,
        texRes=128.0, interpolate=True, depth=-6.0)
    a1 = visual.TextStim(win=win, name='a1',
        text='1',
        font='Open Sans',
        pos=(-0.45, -0.35), draggable=False, height=0.05, wrapWidth=None, ori=0.0, 
        color='black', colorSpace='rgb', opacity=None, 
        languageStyle='LTR',
        depth=-7.0);
    a2 = visual.TextStim(win=win, name='a2',
        text='2',
        font='Open Sans',
        pos=(-.15, -0.35), draggable=False, height=0.05, wrapWidth=None, ori=0.0, 
        color='black', colorSpace='rgb', opacity=None, 
        languageStyle='LTR',
        depth=-8.0);
    a3 = visual.TextStim(win=win, name='a3',
        text='3',
        font='Open Sans',
        pos=(.15, -0.35), draggable=False, height=0.05, wrapWidth=None, ori=0.0, 
        color='black', colorSpace='rgb', opacity=None, 
        languageStyle='LTR',
        depth=-9.0);
    a4 = visual.TextStim(win=win, name='a4',
        text='4',
        font='Open Sans',
        pos=(0.45, -0.35), draggable=False, height=0.05, wrapWidth=None, ori=0.0, 
        color='black', colorSpace='rgb', opacity=None, 
        languageStyle='LTR',
        depth=-10.0);
    
    # --- Initialize components for Routine "quiz_feedback" ---
    result_q_instr = visual.TextStim(win=win, name='result_q_instr',
        text='',
        font='Open Sans',
        pos=(0, 0), draggable=False, height=0.06, wrapWidth=None, ori=0.0, 
        color='black', colorSpace='rgb', opacity=None, 
        languageStyle='LTR',
        depth=0.0);
    
    # --- Initialize components for Routine "back_to_learn" ---
    text_8 = visual.TextStim(win=win, name='text_8',
        text='Take a break for 5 seconds before the next round of learning',
        font='Open Sans',
        pos=(0, 0), draggable=False, height=0.05, wrapWidth=None, ori=0.0, 
        color='black', colorSpace='rgb', opacity=None, 
        languageStyle='LTR',
        depth=0.0);
    
    # --- Initialize components for Routine "learn1" ---
    key_resp = keyboard.Keyboard(deviceName='key_resp')
    image_1 = visual.ImageStim(
        win=win,
        name='image_1', 
        image='default.png', mask=None, anchor='center',
        ori=0.0, pos=(0, 0), draggable=False, size=(0.5, 0.5),
        color=[1,1,1], colorSpace='rgb', opacity=None,
        flipHoriz=False, flipVert=False,
        texRes=128.0, interpolate=True, depth=-1.0)
    text = visual.TextStim(win=win, name='text',
        text='',
        font='Open Sans',
        pos=(0, -0.35), draggable=False, height=0.05, wrapWidth=None, ori=0.0, 
        color='black', colorSpace='rgb', opacity=None, 
        languageStyle='LTR',
        depth=-2.0);
    
    # --- Initialize components for Routine "check_incorrect" ---
    text_incorrect = visual.TextStim(win=win, name='text_incorrect',
        text='',
        font='Open Sans',
        pos=(0, 0), draggable=False, height=0.5, wrapWidth=None, ori=0.0, 
        color='black', colorSpace='rgb', opacity=None, 
        languageStyle='LTR',
        depth=-1.0);
    
    # --- Initialize components for Routine "learn2" ---
    image_2 = visual.ImageStim(
        win=win,
        name='image_2', 
        image='default.png', mask=None, anchor='center',
        ori=0.0, pos=(0, 0), draggable=False, size=(0.5,0.5),
        color=[1,1,1], colorSpace='rgb', opacity=None,
        flipHoriz=False, flipVert=False,
        texRes=128.0, interpolate=True, depth=0.0)
    
    # --- Initialize components for Routine "next_trial" ---
    next_trial_text = visual.TextStim(win=win, name='next_trial_text',
        text='next trial…',
        font='Open Sans',
        pos=(0, 0), draggable=False, height=0.05, wrapWidth=None, ori=0.0, 
        color='black', colorSpace='rgb', opacity=None, 
        languageStyle='LTR',
        depth=0.0);
    
    # --- Initialize components for Routine "between" ---
    text_2 = visual.TextStim(win=win, name='text_2',
        text='Time for a memory quiz based on what you learned',
        font='Open Sans',
        pos=(0, 0), draggable=False, height=0.05, wrapWidth=None, ori=0.0, 
        color='black', colorSpace='rgb', opacity=None, 
        languageStyle='LTR',
        depth=0.0);
    
    # --- Initialize components for Routine "quiz2" ---
    target_quiz1_2 = visual.ImageStim(
        win=win,
        name='target_quiz1_2', 
        image='default.png', mask=None, anchor='center',
        ori=0.0, pos=(0,.15), draggable=False, size=(0.4,0.4),
        color=[1,1,1], colorSpace='rgb', opacity=None,
        flipHoriz=False, flipVert=False,
        texRes=128.0, interpolate=True, depth=0.0)
    question_quiz1_2 = visual.TextStim(win=win, name='question_quiz1_2',
        text='',
        font='Open Sans',
        pos=(0, 0.4), draggable=False, height=0.05, wrapWidth=None, ori=0.0, 
        color='black', colorSpace='rgb', opacity=None, 
        languageStyle='LTR',
        depth=-1.0);
    answer_quiz1_2 = keyboard.Keyboard(deviceName='answer_quiz1_2')
    answer1_2 = visual.ImageStim(
        win=win,
        name='answer1_2', 
        image='default.png', mask=None, anchor='center',
        ori=0.0, pos=(-0.45, -.20), draggable=False, size=(0.2, 0.2),
        color=[1,1,1], colorSpace='rgb', opacity=None,
        flipHoriz=False, flipVert=False,
        texRes=128.0, interpolate=True, depth=-3.0)
    answer2_2 = visual.ImageStim(
        win=win,
        name='answer2_2', 
        image='default.png', mask=None, anchor='center',
        ori=0.0, pos=(-0.15, -.20), draggable=False, size=(0.2, 0.2),
        color=[1,1,1], colorSpace='rgb', opacity=None,
        flipHoriz=False, flipVert=False,
        texRes=128.0, interpolate=True, depth=-4.0)
    answer3_2 = visual.ImageStim(
        win=win,
        name='answer3_2', 
        image='default.png', mask=None, anchor='center',
        ori=0.0, pos=(0.15, -.20), draggable=False, size=(0.2, 0.2),
        color=[1,1,1], colorSpace='rgb', opacity=None,
        flipHoriz=False, flipVert=False,
        texRes=128.0, interpolate=True, depth=-5.0)
    answer4_2 = visual.ImageStim(
        win=win,
        name='answer4_2', 
        image='default.png', mask=None, anchor='center',
        ori=0.0, pos=(0.45, -0.20), draggable=False, size=(0.2, 0.2),
        color=[1,1,1], colorSpace='rgb', opacity=None,
        flipHoriz=False, flipVert=False,
        texRes=128.0, interpolate=True, depth=-6.0)
    a1_2 = visual.TextStim(win=win, name='a1_2',
        text='1',
        font='Open Sans',
        pos=(-0.45, -0.35), draggable=False, height=0.05, wrapWidth=None, ori=0.0, 
        color='black', colorSpace='rgb', opacity=None, 
        languageStyle='LTR',
        depth=-7.0);
    a2_2 = visual.TextStim(win=win, name='a2_2',
        text='2',
        font='Open Sans',
        pos=(-.15, -0.35), draggable=False, height=0.05, wrapWidth=None, ori=0.0, 
        color='black', colorSpace='rgb', opacity=None, 
        languageStyle='LTR',
        depth=-8.0);
    a3_2 = visual.TextStim(win=win, name='a3_2',
        text='3',
        font='Open Sans',
        pos=(.15, -0.35), draggable=False, height=0.05, wrapWidth=None, ori=0.0, 
        color='black', colorSpace='rgb', opacity=None, 
        languageStyle='LTR',
        depth=-9.0);
    a4_2 = visual.TextStim(win=win, name='a4_2',
        text='4',
        font='Open Sans',
        pos=(0.45, -0.35), draggable=False, height=0.05, wrapWidth=None, ori=0.0, 
        color='black', colorSpace='rgb', opacity=None, 
        languageStyle='LTR',
        depth=-10.0);
    
    # --- Initialize components for Routine "quiz_feedback" ---
    result_q_instr = visual.TextStim(win=win, name='result_q_instr',
        text='',
        font='Open Sans',
        pos=(0, 0), draggable=False, height=0.06, wrapWidth=None, ori=0.0, 
        color='black', colorSpace='rgb', opacity=None, 
        languageStyle='LTR',
        depth=0.0);
    
    # --- Initialize components for Routine "planning_paths" ---
    text_149 = visual.TextStim(win=win, name='text_149',
        text='Plan how to get from either the BABY or TOOTHBRUSH to new images. \n\nPlan how to get from one image to the next image. \n\nREMEMBER: Nothing has changed since you initially learned about how to navigate between pictures at the beginning of the task.',
        font='Open Sans',
        pos=(0, 0.2), draggable=False, height=0.05, wrapWidth=None, ori=0.0, 
        color='black', colorSpace='rgb', opacity=None, 
        languageStyle='LTR',
        depth=0.0);
    key_resp_40 = keyboard.Keyboard(deviceName='key_resp_40')
    text_49 = visual.TextStim(win=win, name='text_49',
        text='Press space to begin',
        font='Open Sans',
        pos=(0, -0.25), draggable=False, height=0.045, wrapWidth=None, ori=0.0, 
        color='black', colorSpace='rgb', opacity=None, 
        languageStyle='LTR',
        depth=-3.0);
    
    # --- Initialize components for Routine "forgetting_paths1" ---
    question_quiz1_3 = visual.TextStim(win=win, name='question_quiz1_3',
        text='Plan the 2 actions in your head how to get from the left image to the right image. You have two minutes to plan.',
        font='Open Sans',
        pos=(0, 0.3), draggable=False, height=0.05, wrapWidth=None, ori=0.0, 
        color='black', colorSpace='rgb', opacity=None, 
        languageStyle='LTR',
        depth=0.0);
    answer_quiz1_3 = keyboard.Keyboard(deviceName='answer_quiz1_3')
    answer1_3 = visual.ImageStim(
        win=win,
        name='answer1_3', 
        image='default.png', mask=None, anchor='center',
        ori=0.0, pos=(-0.40, 0), draggable=False, size=(0.2, 0.2),
        color=[1,1,1], colorSpace='rgb', opacity=None,
        flipHoriz=False, flipVert=False,
        texRes=128.0, interpolate=True, depth=-2.0)
    answer2_3 = visual.ImageStim(
        win=win,
        name='answer2_3', 
        image='default.png', mask=None, anchor='center',
        ori=0.0, pos=(0, 0), draggable=False, size=(0.2, 0.2),
        color=[1,1,1], colorSpace='rgb', opacity=None,
        flipHoriz=False, flipVert=False,
        texRes=128.0, interpolate=True, depth=-3.0)
    answer3_3 = visual.ImageStim(
        win=win,
        name='answer3_3', 
        image='default.png', mask=None, anchor='center',
        ori=0.0, pos=(0.40, 0), draggable=False, size=(0.2, 0.2),
        color=[1,1,1], colorSpace='rgb', opacity=None,
        flipHoriz=False, flipVert=False,
        texRes=128.0, interpolate=True, depth=-4.0)
    a1_3 = visual.TextStim(win=win, name='a1_3',
        text='>',
        font='Open Sans',
        pos=(-0.20, 0), draggable=False, height=0.1, wrapWidth=None, ori=0.0, 
        color='black', colorSpace='rgb', opacity=None, 
        languageStyle='LTR',
        depth=-5.0);
    a2_3 = visual.TextStim(win=win, name='a2_3',
        text='>',
        font='Open Sans',
        pos=(0.20, 0), draggable=False, height=0.1, wrapWidth=None, ori=0.0, 
        color='black', colorSpace='rgb', opacity=None, 
        languageStyle='LTR',
        depth=-6.0);
    text_146 = visual.TextStim(win=win, name='text_146',
        text='Click the two actions (a sequence of LEFT and RIGHT) on the keyboard that will get you from the image on the far left to the image on the far right.',
        font='Open Sans',
        pos=(0, -0.28), draggable=False, height=0.055, wrapWidth=None, ori=0.0, 
        color='black', colorSpace='rgb', opacity=None, 
        languageStyle='LTR',
        depth=-7.0);
    
    # --- Initialize components for Routine "planningpathstraining2" ---
    question_quiz1_5 = visual.TextStim(win=win, name='question_quiz1_5',
        text='Plan the 2 actions in your head how to get from the left image to the right image. You have two minutes to plan.',
        font='Open Sans',
        pos=(0, 0.3), draggable=False, height=0.05, wrapWidth=None, ori=0.0, 
        color='black', colorSpace='rgb', opacity=None, 
        languageStyle='LTR',
        depth=0.0);
    answer_quiz1_5 = keyboard.Keyboard(deviceName='answer_quiz1_5')
    answer1_5 = visual.ImageStim(
        win=win,
        name='answer1_5', 
        image='default.png', mask=None, anchor='center',
        ori=0.0, pos=(-0.40, 0), draggable=False, size=(0.2, 0.2),
        color=[1,1,1], colorSpace='rgb', opacity=None,
        flipHoriz=False, flipVert=False,
        texRes=128.0, interpolate=True, depth=-2.0)
    answer2_5 = visual.ImageStim(
        win=win,
        name='answer2_5', 
        image='default.png', mask=None, anchor='center',
        ori=0.0, pos=(0, 0), draggable=False, size=(0.2, 0.2),
        color=[1,1,1], colorSpace='rgb', opacity=None,
        flipHoriz=False, flipVert=False,
        texRes=128.0, interpolate=True, depth=-3.0)
    answer3_5 = visual.ImageStim(
        win=win,
        name='answer3_5', 
        image='default.png', mask=None, anchor='center',
        ori=0.0, pos=(0.40, 0), draggable=False, size=(0.2, 0.2),
        color=[1,1,1], colorSpace='rgb', opacity=None,
        flipHoriz=False, flipVert=False,
        texRes=128.0, interpolate=True, depth=-4.0)
    a1_5 = visual.TextStim(win=win, name='a1_5',
        text='>',
        font='Open Sans',
        pos=(-0.20, 0), draggable=False, height=0.1, wrapWidth=None, ori=0.0, 
        color='black', colorSpace='rgb', opacity=None, 
        languageStyle='LTR',
        depth=-5.0);
    a2_5 = visual.TextStim(win=win, name='a2_5',
        text='>',
        font='Open Sans',
        pos=(0.20, 0), draggable=False, height=0.1, wrapWidth=None, ori=0.0, 
        color='black', colorSpace='rgb', opacity=None, 
        languageStyle='LTR',
        depth=-6.0);
    text_152 = visual.TextStim(win=win, name='text_152',
        text='Click the two actions (a sequence of LEFT and RIGHT) on the keyboard that will get you from the image on the far left to the image on the far right.',
        font='Open Sans',
        pos=(0, -0.28), draggable=False, height=0.055, wrapWidth=None, ori=0.0, 
        color='black', colorSpace='rgb', opacity=None, 
        languageStyle='LTR',
        depth=-8.0);
    
    # --- Initialize components for Routine "correct_forget_paths" ---
    next_trial_text_2 = visual.TextStim(win=win, name='next_trial_text_2',
        text='',
        font='Open Sans',
        pos=(0, 0), draggable=False, height=0.05, wrapWidth=None, ori=0.0, 
        color='black', colorSpace='rgb', opacity=None, 
        languageStyle='LTR',
        depth=0.0);
    text_151 = visual.TextStim(win=win, name='text_151',
        text='',
        font='Open Sans',
        pos=(0, -0.25), draggable=False, height=0.1, wrapWidth=None, ori=0.0, 
        color='black', colorSpace='rgb', opacity=None, 
        languageStyle='LTR',
        depth=-1.0);
    
    # --- Initialize components for Routine "total_score_planning" ---
    next_trial_text_3 = visual.TextStim(win=win, name='next_trial_text_3',
        text='',
        font='Open Sans',
        pos=(0, -0.2), draggable=False, height=0.05, wrapWidth=None, ori=0.0, 
        color='black', colorSpace='rgb', opacity=None, 
        languageStyle='LTR',
        depth=-1.0);
    text_150 = visual.TextStim(win=win, name='text_150',
        text='Percent correct:',
        font='Open Sans',
        pos=(0, 0.05), draggable=False, height=0.06, wrapWidth=None, ori=0.0, 
        color='black', colorSpace='rgb', opacity=None, 
        languageStyle='LTR',
        depth=-2.0);
    
    # --- Initialize components for Routine "break_routine" ---
    text_9 = visual.TextStim(win=win, name='text_9',
        text='Next stage: Planning phase!',
        font='Open Sans',
        pos=(0, 0), draggable=False, height=0.05, wrapWidth=None, ori=0.0, 
        color='black', colorSpace='rgb', opacity=None, 
        languageStyle='LTR',
        depth=0.0);
    
    # --- Initialize components for Routine "instructions_reward" ---
    instructions_rewardstage = visual.TextStim(win=win, name='instructions_rewardstage',
        text='Now it’s time to use what you learned to get rewards. You will play a series of trials that each have 3 decisions. Each decision, you will be shown a long-term BIG reward that you can get to at the 3rd decision. You can plan how to get there based off of what you learned.\n\nThe first choice will always involve choosing whether you start at the picture of the BABY or the picture of the TOOTHBRUSH. After that, you will click either LEFT or RIGHT to try to get to new pictures. \n\nIMPORTANT: You will always have the option to click SPACE to win 100 points. By choosing this option, the computer will take take you to a new image by choosing left or right for you. For example, on the first trial, if you click SPACE, the computer will randomly select either BABY or TOOTHBRUSH for you.',
        font='Open Sans',
        pos=(0, 0), draggable=False, height=0.032, wrapWidth=None, ori=0.0, 
        color='black', colorSpace='rgb', opacity=None, 
        languageStyle='LTR',
        depth=0.0);
    key_resp_11 = keyboard.Keyboard(deviceName='key_resp_11')
    text_46 = visual.TextStim(win=win, name='text_46',
        text='Press SPACE to continue ',
        font='Open Sans',
        pos=(0, -0.32), draggable=False, height=0.045, wrapWidth=None, ori=0.0, 
        color='black', colorSpace='rgb', opacity=None, 
        languageStyle='LTR',
        depth=-2.0);
    
    # --- Initialize components for Routine "instructions_planning_2" ---
    text_50 = visual.TextStim(win=win, name='text_50',
        text='VERY RARELY, the computer will take you to a location you didn’t want to go.\n\nTry your best to get the most points possible! You can win the most points both by collecting immediate rewards by clicking SPACE and by reaching and winning the long-term goals.\n\nYou will always see your WINNING TOTAL on each screen and your goal is to win the most points to win th most money!\n\nPress SPACE to continue',
        font='Open Sans',
        pos=(0, 0), draggable=False, height=0.04, wrapWidth=None, ori=0.0, 
        color='black', colorSpace='rgb', opacity=None, 
        languageStyle='LTR',
        depth=0.0);
    key_resp_9 = keyboard.Keyboard(deviceName='key_resp_9')
    # Run 'Begin Experiment' code from code_20
    
    
    directions_dict={'baby_left':'images/backpack.png',
    'baby_right':'images/bowtie.png',
    'toothbrush_left':'images/car.png',
    'toothbrush_right':'images/backpack.png',
    'hourglass_right':'images/hammer.png',
    'hourglass_left':'images/knight.png',
    'backpack_left':'images/lamp.png',
    'backpack_right':'images/hourglass.png',
    'lamp_left':'images/hammer.png',
    'lamp_right':'images/bending.png',
    'cat_left':'images/hammer.png',
    'cat_right':'images/zebra.png',
    'car_left':'images/cat.png',
    'car_right':'images/lamp.png',
    'bowtie_left':'images/lamp.png',
    'bowtie_right':'images/lamp.png'}
    
    
    
    incorrect_actions=0
    action='left.png'
    
    
    
    correct_quiz='p'
    percent_correct=''
    text_correct=''
    
    
    
    # --- Initialize components for Routine "instructions_example_trial" ---
    text_13 = visual.TextStim(win=win, name='text_13',
        text='EXAMPLE TRIAL: You are now at the image below. Choose left or right based off of what you learned to get the most points in images listed below!',
        font='Open Sans',
        pos=(0, 0.35), draggable=False, height=0.04, wrapWidth=None, ori=0.0, 
        color='black', colorSpace='rgb', opacity=None, 
        languageStyle='LTR',
        depth=-1.0);
    R1_5 = visual.ImageStim(
        win=win,
        name='R1_5', 
        image='images/knight.png', mask=None, anchor='center',
        ori=0.0, pos=(-0.15,-0.1), draggable=False, size=(0.15, 0.15),
        color=[1,1,1], colorSpace='rgb', opacity=None,
        flipHoriz=False, flipVert=False,
        texRes=128.0, interpolate=True, depth=-2.0)
    R2_5 = visual.ImageStim(
        win=win,
        name='R2_5', 
        image='images/computer.png', mask=None, anchor='center',
        ori=0.0, pos=(0.15, -0.1), draggable=False, size=(0.15, 0.15),
        color=[1,1,1], colorSpace='rgb', opacity=None,
        flipHoriz=False, flipVert=False,
        texRes=128.0, interpolate=True, depth=-3.0)
    rew1_5 = visual.TextStim(win=win, name='rew1_5',
        text='',
        font='Open Sans',
        pos=(-0.15, -0.22), draggable=False, height=0.05, wrapWidth=None, ori=0.0, 
        color='green', colorSpace='rgb', opacity=None, 
        languageStyle='LTR',
        depth=-4.0);
    rew2_5 = visual.TextStim(win=win, name='rew2_5',
        text='',
        font='Open Sans',
        pos=(0.15, -0.25), draggable=False, height=0.05, wrapWidth=None, ori=0.0, 
        color='green', colorSpace='rgb', opacity=None, 
        languageStyle='LTR',
        depth=-5.0);
    text_21 = visual.TextStim(win=win, name='text_21',
        text='Choose LEFT or RIGHT to try to win points!',
        font='Open Sans',
        pos=(0, -0.38), draggable=False, height=0.025, wrapWidth=None, ori=0.0, 
        color='black', colorSpace='rgb', opacity=None, 
        languageStyle='LTR',
        depth=-6.0);
    plan2_response_2 = keyboard.Keyboard(deviceName='plan2_response_2')
    current_image_decision2_2 = visual.ImageStim(
        win=win,
        name='current_image_decision2_2', 
        image='images/baby.png', mask=None, anchor='center',
        ori=0.0, pos=(0, 0.17), draggable=False, size=(0.2, 0.2),
        color=[1,1,1], colorSpace='rgb', opacity=None,
        flipHoriz=False, flipVert=False,
        texRes=128.0, interpolate=True, depth=-8.0)
    
    # --- Initialize components for Routine "long_term_reward_instructions" ---
    instructions_rewardstage_2 = visual.TextStim(win=win, name='instructions_rewardstage_2',
        text='Each planning trial has 3 decisions. You have the chance to win 400 points if you successfully make it to that destination at the 3rd decision. It is always presented on the bottom RIGHT of the 3 decisions, and will NEVER CHANGE across the 3 decisions.\n\nBy contrast, on the bottom LEFT, you can choose to have the computer select which state to go to next, and win 100 points instantly! You will see your total score.\n\nIMPORTANT: MANY TIMES YOU CAN WIN BOTH THE IMMEDIATE REWARD AND THE LONG TERM REWARD!\n',
        font='Open Sans',
        pos=(0, 0), draggable=False, height=0.032, wrapWidth=None, ori=0.0, 
        color='black', colorSpace='rgb', opacity=None, 
        languageStyle='LTR',
        depth=0.0);
    key_resp_12 = keyboard.Keyboard(deviceName='key_resp_12')
    text_45 = visual.TextStim(win=win, name='text_45',
        text='press SPACE to continue',
        font='Open Sans',
        pos=(0, -0.32), draggable=False, height=0.05, wrapWidth=None, ori=0.0, 
        color='black', colorSpace='rgb', opacity=None, 
        languageStyle='LTR',
        depth=-2.0);
    
    # --- Initialize components for Routine "quiz_planning_1" ---
    text_47 = visual.TextStim(win=win, name='text_47',
        text='Planning Quiz\n\n1. What is always the first decision out of the 3 decisions for EVERY planning trial?\n\na. between CAT and TOOTHBRUSH\n\nb. between CAR and TOOTHBRUSH\n\nc. between BABY and TOOTHBRUSH\n\nd. You start at a different point each planning trial',
        font='Open Sans',
        pos=(0, 0), draggable=False, height=0.038, wrapWidth=None, ori=0.0, 
        color='black', colorSpace='rgb', opacity=None, 
        languageStyle='LTR',
        depth=0.0);
    key_resp_21 = keyboard.Keyboard(deviceName='key_resp_21')
    
    # --- Initialize components for Routine "quiz_planning_2" ---
    text_73 = visual.TextStim(win=win, name='text_73',
        text='Instructions Quiz\n\n2. What is the long term reward depicted on bottom right?\n\na. It is a reward you can obtain every decision out of the 3 decisions.\n\nb. It is a big reward you can get only at the 3rd decision. Its location will not change across all 3 decisions to allow you to plan how to get there!\n\nc. It is always a reward that you can ONLY get by AVOIDING going for short-term rewards.\n\nd. It is your total amount of winnings in the game.',
        font='Open Sans',
        pos=(0, 0), draggable=False, height=0.038, wrapWidth=None, ori=0.0, 
        color='black', colorSpace='rgb', opacity=None, 
        languageStyle='LTR',
        depth=0.0);
    key_resp_22 = keyboard.Keyboard(deviceName='key_resp_22')
    
    # --- Initialize components for Routine "quiz_planning_3" ---
    text_74 = visual.TextStim(win=win, name='text_74',
        text='Planning Quiz\n\n3. What happens when you press SPACE ?\n\na. It is the reward you get from memory quizzes during learning\n\nb. You instantly get 100 points but the computer randomly selects LEFT or RIGHT for you, so you don’t know the image you’ll end up at next.\n\nc. It gives you 60 points but PREVENTS you from getting the LONG-term reward. \n\nd. It is the rewards you already got during what you previously learned.',
        font='Open Sans',
        pos=(0, 0), draggable=False, height=0.038, wrapWidth=None, ori=0.0, 
        color='black', colorSpace='rgb', opacity=None, 
        languageStyle='LTR',
        depth=0.0);
    key_resp_24 = keyboard.Keyboard(deviceName='key_resp_24')
    
    # --- Initialize components for Routine "quiz_feedback" ---
    result_q_instr = visual.TextStim(win=win, name='result_q_instr',
        text='',
        font='Open Sans',
        pos=(0, 0), draggable=False, height=0.06, wrapWidth=None, ori=0.0, 
        color='black', colorSpace='rgb', opacity=None, 
        languageStyle='LTR',
        depth=0.0);
    
    # --- Initialize components for Routine "see_planning_trials" ---
    text_48 = visual.TextStim(win=win, name='text_48',
        text='Now you will see how planning trials look in the real game. These trials will not include the same images you just learned about. However, the same things you learn now in practice will apply to the real planning phase. \n\nPress SPACE to continue.',
        font='Open Sans',
        pos=(0, 0), draggable=False, height=0.05, wrapWidth=None, ori=0.0, 
        color='black', colorSpace='rgb', opacity=None, 
        languageStyle='LTR',
        depth=0.0);
    key_resp_8 = keyboard.Keyboard(deviceName='key_resp_8')
    
    # --- Initialize components for Routine "instructions_planning_new" ---
    text_32 = visual.TextStim(win=win, name='text_32',
        text='EXAMPLE Decision 1: Choose SPACE and the computer randomly selects which state you get to.',
        font='Open Sans',
        pos=(0, 0.35), draggable=False, height=0.04, wrapWidth=None, ori=0.0, 
        color='black', colorSpace='rgb', opacity=None, 
        languageStyle='LTR',
        depth=-1.0);
    R1_6 = visual.ImageStim(
        win=win,
        name='R1_6', 
        image='images/computer.png', mask=None, anchor='center',
        ori=0.0, pos=(-0.15,-0.1), draggable=False, size=(0.15, 0.15),
        color=[1,1,1], colorSpace='rgb', opacity=None,
        flipHoriz=False, flipVert=False,
        texRes=128.0, interpolate=True, depth=-2.0)
    R2_6 = visual.ImageStim(
        win=win,
        name='R2_6', 
        image='images/knight.png', mask=None, anchor='center',
        ori=0.0, pos=(0.15, -0.1), draggable=False, size=(0.15, 0.15),
        color=[1,1,1], colorSpace='rgb', opacity=None,
        flipHoriz=False, flipVert=False,
        texRes=128.0, interpolate=True, depth=-3.0)
    rew1_6 = visual.TextStim(win=win, name='rew1_6',
        text='',
        font='Open Sans',
        pos=(-0.15, -0.22), draggable=False, height=0.05, wrapWidth=None, ori=0.0, 
        color='green', colorSpace='rgb', opacity=None, 
        languageStyle='LTR',
        depth=-4.0);
    rew2_6 = visual.TextStim(win=win, name='rew2_6',
        text='',
        font='Open Sans',
        pos=(0.15, -0.22), draggable=False, height=0.05, wrapWidth=None, ori=0.0, 
        color='green', colorSpace='rgb', opacity=None, 
        languageStyle='LTR',
        depth=-5.0);
    plan2_response_3 = keyboard.Keyboard(deviceName='plan2_response_3')
    text_34 = visual.TextStim(win=win, name='text_34',
        text='Long-Term Reward',
        font='Open Sans',
        pos=(0.20, -0.32), draggable=False, height=0.04, wrapWidth=None, ori=0.0, 
        color='black', colorSpace='rgb', opacity=None, 
        languageStyle='LTR',
        depth=-7.0);
    text_41 = visual.TextStim(win=win, name='text_41',
        text='Computer Chooses',
        font='Open Sans',
        pos=(-0.20, -0.32), draggable=False, height=0.04, wrapWidth=None, ori=0.0, 
        color='black', colorSpace='rgb', opacity=None, 
        languageStyle='LTR',
        depth=-8.0);
    text_114 = visual.TextStim(win=win, name='text_114',
        text='',
        font='Open Sans',
        pos=(0.1, -0.41), draggable=False, height=0.04, wrapWidth=None, ori=0.0, 
        color='red', colorSpace='rgb', opacity=None, 
        languageStyle='LTR',
        depth=-9.0);
    text_128 = visual.TextStim(win=win, name='text_128',
        text='Total=',
        font='Open Sans',
        pos=(-0.10, -0.41), draggable=False, height=0.04, wrapWidth=None, ori=0.0, 
        color='red', colorSpace='rgb', opacity=None, 
        languageStyle='LTR',
        depth=-10.0);
    
    # --- Initialize components for Routine "planning_2_instructions" ---
    text_52 = visual.TextStim(win=win, name='text_52',
        text='The COMPUTER chose LEFT and now you’re at the PLANET. \nDecision 2: Choose the computer again by clicking SPACE. ',
        font='Open Sans',
        pos=(0, 0.38), draggable=False, height=0.04, wrapWidth=None, ori=0.0, 
        color='black', colorSpace='rgb', opacity=None, 
        languageStyle='LTR',
        depth=-1.0);
    R1_9 = visual.ImageStim(
        win=win,
        name='R1_9', 
        image='images/computer.png', mask=None, anchor='center',
        ori=0.0, pos=(-0.15,-0.1), draggable=False, size=(0.15, 0.15),
        color=[1,1,1], colorSpace='rgb', opacity=None,
        flipHoriz=False, flipVert=False,
        texRes=128.0, interpolate=True, depth=-2.0)
    R2_9 = visual.ImageStim(
        win=win,
        name='R2_9', 
        image='images/knight.png', mask=None, anchor='center',
        ori=0.0, pos=(0.15, -0.1), draggable=False, size=(0.15, 0.15),
        color=[1,1,1], colorSpace='rgb', opacity=None,
        flipHoriz=False, flipVert=False,
        texRes=128.0, interpolate=True, depth=-3.0)
    rew1_9 = visual.TextStim(win=win, name='rew1_9',
        text='',
        font='Open Sans',
        pos=(-0.15, -0.22), draggable=False, height=0.05, wrapWidth=None, ori=0.0, 
        color='green', colorSpace='rgb', opacity=None, 
        languageStyle='LTR',
        depth=-4.0);
    rew2_9 = visual.TextStim(win=win, name='rew2_9',
        text='',
        font='Open Sans',
        pos=(0.15, -0.22), draggable=False, height=0.05, wrapWidth=None, ori=0.0, 
        color='green', colorSpace='rgb', opacity=None, 
        languageStyle='LTR',
        depth=-5.0);
    text_53 = visual.TextStim(win=win, name='text_53',
        text='Choose LEFT or RIGHT',
        font='Open Sans',
        pos=(0.15, -0.30), draggable=False, height=0.025, wrapWidth=None, ori=0.0, 
        color='black', colorSpace='rgb', opacity=None, 
        languageStyle='LTR',
        depth=-6.0);
    plan2_response_6 = keyboard.Keyboard(deviceName='plan2_response_6')
    current_image_decision2_5 = visual.ImageStim(
        win=win,
        name='current_image_decision2_5', 
        image='planet.png', mask=None, anchor='center',
        ori=0.0, pos=(0, 0.17), draggable=False, size=(0.2, 0.2),
        color=[1,1,1], colorSpace='rgb', opacity=None,
        flipHoriz=False, flipVert=False,
        texRes=128.0, interpolate=True, depth=-8.0)
    text_115 = visual.TextStim(win=win, name='text_115',
        text='',
        font='Open Sans',
        pos=(0.1, -0.41), draggable=False, height=0.04, wrapWidth=None, ori=0.0, 
        color='red', colorSpace='rgb', opacity=None, 
        languageStyle='LTR',
        depth=-9.0);
    text_129 = visual.TextStim(win=win, name='text_129',
        text='Total=',
        font='Open Sans',
        pos=(-0.15, -0.41), draggable=False, height=0.04, wrapWidth=None, ori=0.0, 
        color='red', colorSpace='rgb', opacity=None, 
        languageStyle='LTR',
        depth=-10.0);
    
    # --- Initialize components for Routine "instructions_planning_new3" ---
    text_136 = visual.TextStim(win=win, name='text_136',
        text='Decision 3: You are at the BASKET. Choose right to get the BIG REWARD at the KNIGHT. ',
        font='Open Sans',
        pos=(0, 0.35), draggable=False, height=0.04, wrapWidth=None, ori=0.0, 
        color='black', colorSpace='rgb', opacity=None, 
        languageStyle='LTR',
        depth=-1.0);
    R1_11 = visual.ImageStim(
        win=win,
        name='R1_11', 
        image='images/computer.png', mask=None, anchor='center',
        ori=0.0, pos=(-0.15,-0.1), draggable=False, size=(0.10, 0.10),
        color=[1,1,1], colorSpace='rgb', opacity=None,
        flipHoriz=False, flipVert=False,
        texRes=128.0, interpolate=True, depth=-2.0)
    R2_11 = visual.ImageStim(
        win=win,
        name='R2_11', 
        image='images/knight.png', mask=None, anchor='center',
        ori=0.0, pos=(0.15, -0.1), draggable=False, size=(0.10, 0.10),
        color=[1,1,1], colorSpace='rgb', opacity=None,
        flipHoriz=False, flipVert=False,
        texRes=128.0, interpolate=True, depth=-3.0)
    rew1_11 = visual.TextStim(win=win, name='rew1_11',
        text='',
        font='Open Sans',
        pos=(-0.15, -0.22), draggable=False, height=0.05, wrapWidth=None, ori=0.0, 
        color='green', colorSpace='rgb', opacity=None, 
        languageStyle='LTR',
        depth=-4.0);
    rew2_11 = visual.TextStim(win=win, name='rew2_11',
        text='',
        font='Open Sans',
        pos=(0.15, -0.22), draggable=False, height=0.05, wrapWidth=None, ori=0.0, 
        color='green', colorSpace='rgb', opacity=None, 
        languageStyle='LTR',
        depth=-5.0);
    plan2_response_5 = keyboard.Keyboard(deviceName='plan2_response_5')
    current_image_decision2_6 = visual.ImageStim(
        win=win,
        name='current_image_decision2_6', 
        image='basket.png', mask=None, anchor='center',
        ori=0.0, pos=(0, 0.17), draggable=False, size=(0.15, 0.15),
        color=[1,1,1], colorSpace='rgb', opacity=None,
        flipHoriz=False, flipVert=False,
        texRes=128.0, interpolate=True, depth=-7.0)
    text_137 = visual.TextStim(win=win, name='text_137',
        text='Long-Term Reward',
        font='Open Sans',
        pos=(0.20, -0.32), draggable=False, height=0.04, wrapWidth=None, ori=0.0, 
        color='black', colorSpace='rgb', opacity=None, 
        languageStyle='LTR',
        depth=-8.0);
    text_138 = visual.TextStim(win=win, name='text_138',
        text='Short-Term Reward',
        font='Open Sans',
        pos=(-0.20, -0.32), draggable=False, height=0.04, wrapWidth=None, ori=0.0, 
        color='black', colorSpace='rgb', opacity=None, 
        languageStyle='LTR',
        depth=-9.0);
    text_139 = visual.TextStim(win=win, name='text_139',
        text='',
        font='Open Sans',
        pos=(0.1, -0.41), draggable=False, height=0.04, wrapWidth=None, ori=0.0, 
        color='red', colorSpace='rgb', opacity=None, 
        languageStyle='LTR',
        depth=-10.0);
    text_140 = visual.TextStim(win=win, name='text_140',
        text='Total=',
        font='Open Sans',
        pos=(-0.15, -0.41), draggable=False, height=0.04, wrapWidth=None, ori=0.0, 
        color='red', colorSpace='rgb', opacity=None, 
        languageStyle='LTR',
        depth=-11.0);
    
    # --- Initialize components for Routine "practice_planning_outcomes" ---
    image_6 = visual.ImageStim(
        win=win,
        name='image_6', 
        image='images/knight.png', mask=None, anchor='center',
        ori=0.0, pos=(0, 0), draggable=False, size=(0.5, 0.5),
        color=[1,1,1], colorSpace='rgb', opacity=None,
        flipHoriz=False, flipVert=False,
        texRes=128.0, interpolate=True, depth=-1.0)
    text_141 = visual.TextStim(win=win, name='text_141',
        text='You arrived here! ',
        font='Open Sans',
        pos=(0, 0.35), draggable=False, height=0.05, wrapWidth=None, ori=0.0, 
        color='black', colorSpace='rgb', opacity=None, 
        languageStyle='LTR',
        depth=-2.0);
    text_142 = visual.TextStim(win=win, name='text_142',
        text='',
        font='Open Sans',
        pos=(0, -0.41), draggable=False, height=0.04, wrapWidth=None, ori=0.0, 
        color='red', colorSpace='rgb', opacity=None, 
        languageStyle='LTR',
        depth=-3.0);
    text_143 = visual.TextStim(win=win, name='text_143',
        text='Total=',
        font='Open Sans',
        pos=(-0.12, -0.41), draggable=False, height=0.04, wrapWidth=None, ori=0.0, 
        color='red', colorSpace='rgb', opacity=None, 
        languageStyle='LTR',
        depth=-4.0);
    
    # --- Initialize components for Routine "immediate_rewar_lesson" ---
    text_148 = visual.TextStim(win=win, name='text_148',
        text='NOTICE: You were able to avoid planning twice by clicking SPACE to win 200 more points and STILL arrive at the long-term goal of KNIGHT. In the upcoming planning phase, use what you know about how to get to long term goals to determine when it is best to choose yourself or let the COMPUTER choose for you to win more points. Press SPACE to continue.',
        font='Open Sans',
        pos=(0, 0), draggable=False, height=0.05, wrapWidth=None, ori=0.0, 
        color='black', colorSpace='rgb', opacity=None, 
        languageStyle='LTR',
        depth=0.0);
    key_resp_39 = keyboard.Keyboard(deviceName='key_resp_39')
    
    # --- Initialize components for Routine "lesson_practice" ---
    text_144 = visual.TextStim(win=win, name='text_144',
        text='If you do well in upcoming planning trials, you can WIN even more bonus MONEY!\n\nIMPORTANT: when you press SPACE to have the computer choose for you, it will always take you to a new image the way you learned about in the learning phase. After this random choice, you will then be able to try to reach the long term goal image from where the random choice led you to.\n\nPress SPACE to continue',
        font='Open Sans',
        pos=(0, 0), draggable=False, height=0.045, wrapWidth=None, ori=0.0, 
        color='black', colorSpace='rgb', opacity=None, 
        languageStyle='LTR',
        depth=0.0);
    key_resp_37 = keyboard.Keyboard(deviceName='key_resp_37')
    
    # --- Initialize components for Routine "lesson_practice_2" ---
    text_145 = visual.TextStim(win=win, name='text_145',
        text='IMPORTANT: Each big long-term image you can plan to reach has a different amount of ROUTES to get there. For example, one long-term image may have only one route, while another may have many! Use this to choose well and win the most points you can! \n\n\nPress SPACE to continue',
        font='Open Sans',
        pos=(0, 0), draggable=False, height=0.045, wrapWidth=None, ori=0.0, 
        color='black', colorSpace='rgb', opacity=None, 
        languageStyle='LTR',
        depth=0.0);
    key_resp_38 = keyboard.Keyboard(deviceName='key_resp_38')
    
    # --- Initialize components for Routine "start_real_planning" ---
    text_42 = visual.TextStim(win=win, name='text_42',
        text='Starting the actual planning phase. \n\nREMEMBER: You have UNLIMITED time to plan. Try to figure out when it makes sense press SPACE and have the computer choose for you in a way that still makes sure you can get to the BIG REWARD. \n\npress SPACE to start and good luck!',
        font='Open Sans',
        pos=(0, 0), draggable=False, height=0.05, wrapWidth=None, ori=0.0, 
        color='black', colorSpace='rgb', opacity=None, 
        languageStyle='LTR',
        depth=0.0);
    key_resp_6 = keyboard.Keyboard(deviceName='key_resp_6')
    
    # --- Initialize components for Routine "plan1_info_2" ---
    text_5 = visual.TextStim(win=win, name='text_5',
        text='Choose LEFT for BABY or RIGHT for TOOTHBRUSH or SPACE. Make this choice by considering how to get the most points at the images shown below.',
        font='Open Sans',
        pos=(0, 0.35), draggable=False, height=0.03, wrapWidth=None, ori=0.0, 
        color='black', colorSpace='rgb', opacity=None, 
        languageStyle='LTR',
        depth=-1.0);
    R1 = visual.ImageStim(
        win=win,
        name='R1', 
        image='images/computer.png', mask=None, anchor='center',
        ori=0.0, pos=(-0.15,-0.12), draggable=False, size=(0.15, 0.15),
        color=[1,1,1], colorSpace='rgb', opacity=None,
        flipHoriz=False, flipVert=False,
        texRes=128.0, interpolate=True, depth=-2.0)
    R2 = visual.ImageStim(
        win=win,
        name='R2', 
        image='default.png', mask=None, anchor='center',
        ori=0.0, pos=(0.15, -.12), draggable=False, size=(0.15, 0.15),
        color=[1,1,1], colorSpace='rgb', opacity=None,
        flipHoriz=False, flipVert=False,
        texRes=128.0, interpolate=True, depth=-3.0)
    rew1 = visual.TextStim(win=win, name='rew1',
        text='SPACE for 100',
        font='Open Sans',
        pos=(-0.15, -0.27), draggable=False, height=0.05, wrapWidth=None, ori=0.0, 
        color='green', colorSpace='rgb', opacity=None, 
        languageStyle='LTR',
        depth=-4.0);
    rew2 = visual.TextStim(win=win, name='rew2',
        text='',
        font='Open Sans',
        pos=(0.15, -0.27), draggable=False, height=0.05, wrapWidth=None, ori=0.0, 
        color='green', colorSpace='rgb', opacity=None, 
        languageStyle='LTR',
        depth=-5.0);
    text_6 = visual.TextStim(win=win, name='text_6',
        text='Left or Right',
        font='Open Sans',
        pos=(0.15, -0.32), draggable=False, height=0.025, wrapWidth=None, ori=0.0, 
        color='black', colorSpace='rgb', opacity=None, 
        languageStyle='LTR',
        depth=-6.0);
    plan1_response = keyboard.Keyboard(deviceName='plan1_response')
    babyleft = visual.ImageStim(
        win=win,
        name='babyleft', 
        image='images/baby.png', mask=None, anchor='center',
        ori=0.0, pos=(-0.2, 0.2), draggable=False, size=(0.15, 0.15),
        color=[1,1,1], colorSpace='rgb', opacity=None,
        flipHoriz=False, flipVert=False,
        texRes=128.0, interpolate=True, depth=-8.0)
    toothbrushright = visual.ImageStim(
        win=win,
        name='toothbrushright', 
        image='images/toothbrush.png', mask=None, anchor='center',
        ori=0.0, pos=(0.2, 0.2), draggable=False, size=(0.15, 0.15),
        color=[1,1,1], colorSpace='rgb', opacity=None,
        flipHoriz=False, flipVert=False,
        texRes=128.0, interpolate=True, depth=-9.0)
    text_117 = visual.TextStim(win=win, name='text_117',
        text='',
        font='Open Sans',
        pos=(0, -0.41), draggable=False, height=0.04, wrapWidth=None, ori=0.0, 
        color='red', colorSpace='rgb', opacity=None, 
        languageStyle='LTR',
        depth=-10.0);
    text_120 = visual.TextStim(win=win, name='text_120',
        text='Total=',
        font='Open Sans',
        pos=(-0.1, -0.41), draggable=False, height=0.04, wrapWidth=None, ori=0.0, 
        color='red', colorSpace='rgb', opacity=None, 
        languageStyle='LTR',
        depth=-11.0);
    
    # --- Initialize components for Routine "plan2_info" ---
    text_7 = visual.TextStim(win=win, name='text_7',
        text='You are now at the image below. Choose left or right or SPACE based off of what you learned to get the most points in images listed below!',
        font='Open Sans',
        pos=(0, 0.4), draggable=False, height=0.04, wrapWidth=None, ori=0.0, 
        color='black', colorSpace='rgb', opacity=None, 
        languageStyle='LTR',
        depth=-1.0);
    R1_2 = visual.ImageStim(
        win=win,
        name='R1_2', 
        image='default.png', mask=None, anchor='center',
        ori=0.0, pos=(-0.15,-0.1), draggable=False, size=(0.15, 0.15),
        color=[1,1,1], colorSpace='rgb', opacity=None,
        flipHoriz=False, flipVert=False,
        texRes=128.0, interpolate=True, depth=-2.0)
    R2_2 = visual.ImageStim(
        win=win,
        name='R2_2', 
        image='default.png', mask=None, anchor='center',
        ori=0.0, pos=(0.15, -0.1), draggable=False, size=(0.15, 0.15),
        color=[1,1,1], colorSpace='rgb', opacity=None,
        flipHoriz=False, flipVert=False,
        texRes=128.0, interpolate=True, depth=-3.0)
    rew1_2 = visual.TextStim(win=win, name='rew1_2',
        text='SPACE for 100',
        font='Open Sans',
        pos=(-0.15, -0.22), draggable=False, height=0.05, wrapWidth=None, ori=0.0, 
        color='green', colorSpace='rgb', opacity=None, 
        languageStyle='LTR',
        depth=-4.0);
    rew2_2 = visual.TextStim(win=win, name='rew2_2',
        text='',
        font='Open Sans',
        pos=(0.15, -0.22), draggable=False, height=0.05, wrapWidth=None, ori=0.0, 
        color='green', colorSpace='rgb', opacity=None, 
        languageStyle='LTR',
        depth=-5.0);
    text_10 = visual.TextStim(win=win, name='text_10',
        text='Left or Right',
        font='Open Sans',
        pos=(0.15, -0.32), draggable=False, height=0.025, wrapWidth=None, ori=0.0, 
        color='black', colorSpace='rgb', opacity=None, 
        languageStyle='LTR',
        depth=-6.0);
    plan2_response = keyboard.Keyboard(deviceName='plan2_response')
    current_image_decision2 = visual.ImageStim(
        win=win,
        name='current_image_decision2', 
        image='default.png', mask=None, anchor='center',
        ori=0.0, pos=(0, 0.17), draggable=False, size=(0.2, 0.2),
        color=[1,1,1], colorSpace='rgb', opacity=None,
        flipHoriz=False, flipVert=False,
        texRes=128.0, interpolate=True, depth=-8.0)
    text_118 = visual.TextStim(win=win, name='text_118',
        text='',
        font='Open Sans',
        pos=(0, -0.41), draggable=False, height=0.04, wrapWidth=None, ori=0.0, 
        color='red', colorSpace='rgb', opacity=None, 
        languageStyle='LTR',
        depth=-9.0);
    text_121 = visual.TextStim(win=win, name='text_121',
        text='Total=',
        font='Open Sans',
        pos=(-0.1, -0.41), draggable=False, height=0.04, wrapWidth=None, ori=0.0, 
        color='red', colorSpace='rgb', opacity=None, 
        languageStyle='LTR',
        depth=-10.0);
    
    # --- Initialize components for Routine "plan3_info" ---
    text_14 = visual.TextStim(win=win, name='text_14',
        text='You are now at the image below. Choose left or right or SPACE based off of what you learned to get the most points in images listed below!',
        font='Open Sans',
        pos=(0, 0.4), draggable=False, height=0.04, wrapWidth=None, ori=0.0, 
        color='black', colorSpace='rgb', opacity=None, 
        languageStyle='LTR',
        depth=-1.0);
    R1_3 = visual.ImageStim(
        win=win,
        name='R1_3', 
        image='images/computer.png', mask=None, anchor='center',
        ori=0.0, pos=(-0.15,-0.1), draggable=False, size=(0.15, 0.15),
        color=[1,1,1], colorSpace='rgb', opacity=None,
        flipHoriz=False, flipVert=False,
        texRes=128.0, interpolate=True, depth=-2.0)
    R2_3 = visual.ImageStim(
        win=win,
        name='R2_3', 
        image='default.png', mask=None, anchor='center',
        ori=0.0, pos=(0.15, -0.1), draggable=False, size=(0.15, 0.15),
        color=[1,1,1], colorSpace='rgb', opacity=None,
        flipHoriz=False, flipVert=False,
        texRes=128.0, interpolate=True, depth=-3.0)
    rew1_3 = visual.TextStim(win=win, name='rew1_3',
        text='SPACE for 100',
        font='Open Sans',
        pos=(-0.15, -0.22), draggable=False, height=0.05, wrapWidth=None, ori=0.0, 
        color='green', colorSpace='rgb', opacity=None, 
        languageStyle='LTR',
        depth=-4.0);
    rew2_3 = visual.TextStim(win=win, name='rew2_3',
        text='',
        font='Open Sans',
        pos=(0.15, -0.22), draggable=False, height=0.05, wrapWidth=None, ori=0.0, 
        color='green', colorSpace='rgb', opacity=None, 
        languageStyle='LTR',
        depth=-5.0);
    text_15 = visual.TextStim(win=win, name='text_15',
        text='Left or Right',
        font='Open Sans',
        pos=(0.15, -0.32), draggable=False, height=0.025, wrapWidth=None, ori=0.0, 
        color='black', colorSpace='rgb', opacity=None, 
        languageStyle='LTR',
        depth=-6.0);
    plan3_response = keyboard.Keyboard(deviceName='plan3_response')
    current_image_decision3 = visual.ImageStim(
        win=win,
        name='current_image_decision3', 
        image='default.png', mask=None, anchor='center',
        ori=0.0, pos=(0, 0.17), draggable=False, size=(0.2, 0.2),
        color=[1,1,1], colorSpace='rgb', opacity=None,
        flipHoriz=False, flipVert=False,
        texRes=128.0, interpolate=True, depth=-8.0)
    text_122 = visual.TextStim(win=win, name='text_122',
        text='',
        font='Open Sans',
        pos=(0, -0.41), draggable=False, height=0.04, wrapWidth=None, ori=0.0, 
        color='red', colorSpace='rgb', opacity=None, 
        languageStyle='LTR',
        depth=-9.0);
    text_123 = visual.TextStim(win=win, name='text_123',
        text='Total=',
        font='Open Sans',
        pos=(-0.1, -0.41), draggable=False, height=0.04, wrapWidth=None, ori=0.0, 
        color='red', colorSpace='rgb', opacity=None, 
        languageStyle='LTR',
        depth=-10.0);
    
    # --- Initialize components for Routine "planning4" ---
    image_4 = visual.ImageStim(
        win=win,
        name='image_4', 
        image='default.png', mask=None, anchor='center',
        ori=0.0, pos=(0, 0), draggable=False, size=(0.5, 0.5),
        color=[1,1,1], colorSpace='rgb', opacity=None,
        flipHoriz=False, flipVert=False,
        texRes=128.0, interpolate=True, depth=-1.0)
    text_19 = visual.TextStim(win=win, name='text_19',
        text='You arrived here! ',
        font='Open Sans',
        pos=(0, 0.35), draggable=False, height=0.05, wrapWidth=None, ori=0.0, 
        color='black', colorSpace='rgb', opacity=None, 
        languageStyle='LTR',
        depth=-2.0);
    text_119 = visual.TextStim(win=win, name='text_119',
        text='',
        font='Open Sans',
        pos=(0, -0.41), draggable=False, height=0.04, wrapWidth=None, ori=0.0, 
        color='red', colorSpace='rgb', opacity=None, 
        languageStyle='LTR',
        depth=-3.0);
    text_131 = visual.TextStim(win=win, name='text_131',
        text='Total=',
        font='Open Sans',
        pos=(-0.12, -0.41), draggable=False, height=0.04, wrapWidth=None, ori=0.0, 
        color='red', colorSpace='rgb', opacity=None, 
        languageStyle='LTR',
        depth=-4.0);
    
    # --- Initialize components for Routine "next_trial" ---
    next_trial_text = visual.TextStim(win=win, name='next_trial_text',
        text='next trial…',
        font='Open Sans',
        pos=(0, 0), draggable=False, height=0.05, wrapWidth=None, ori=0.0, 
        color='black', colorSpace='rgb', opacity=None, 
        languageStyle='LTR',
        depth=0.0);
    
    # --- Initialize components for Routine "planning_paths" ---
    text_149 = visual.TextStim(win=win, name='text_149',
        text='Plan how to get from either the BABY or TOOTHBRUSH to new images. \n\nPlan how to get from one image to the next image. \n\nREMEMBER: Nothing has changed since you initially learned about how to navigate between pictures at the beginning of the task.',
        font='Open Sans',
        pos=(0, 0.2), draggable=False, height=0.05, wrapWidth=None, ori=0.0, 
        color='black', colorSpace='rgb', opacity=None, 
        languageStyle='LTR',
        depth=0.0);
    key_resp_40 = keyboard.Keyboard(deviceName='key_resp_40')
    text_49 = visual.TextStim(win=win, name='text_49',
        text='Press space to begin',
        font='Open Sans',
        pos=(0, -0.25), draggable=False, height=0.045, wrapWidth=None, ori=0.0, 
        color='black', colorSpace='rgb', opacity=None, 
        languageStyle='LTR',
        depth=-3.0);
    
    # --- Initialize components for Routine "forgetting_paths1" ---
    question_quiz1_3 = visual.TextStim(win=win, name='question_quiz1_3',
        text='Plan the 2 actions in your head how to get from the left image to the right image. You have two minutes to plan.',
        font='Open Sans',
        pos=(0, 0.3), draggable=False, height=0.05, wrapWidth=None, ori=0.0, 
        color='black', colorSpace='rgb', opacity=None, 
        languageStyle='LTR',
        depth=0.0);
    answer_quiz1_3 = keyboard.Keyboard(deviceName='answer_quiz1_3')
    answer1_3 = visual.ImageStim(
        win=win,
        name='answer1_3', 
        image='default.png', mask=None, anchor='center',
        ori=0.0, pos=(-0.40, 0), draggable=False, size=(0.2, 0.2),
        color=[1,1,1], colorSpace='rgb', opacity=None,
        flipHoriz=False, flipVert=False,
        texRes=128.0, interpolate=True, depth=-2.0)
    answer2_3 = visual.ImageStim(
        win=win,
        name='answer2_3', 
        image='default.png', mask=None, anchor='center',
        ori=0.0, pos=(0, 0), draggable=False, size=(0.2, 0.2),
        color=[1,1,1], colorSpace='rgb', opacity=None,
        flipHoriz=False, flipVert=False,
        texRes=128.0, interpolate=True, depth=-3.0)
    answer3_3 = visual.ImageStim(
        win=win,
        name='answer3_3', 
        image='default.png', mask=None, anchor='center',
        ori=0.0, pos=(0.40, 0), draggable=False, size=(0.2, 0.2),
        color=[1,1,1], colorSpace='rgb', opacity=None,
        flipHoriz=False, flipVert=False,
        texRes=128.0, interpolate=True, depth=-4.0)
    a1_3 = visual.TextStim(win=win, name='a1_3',
        text='>',
        font='Open Sans',
        pos=(-0.20, 0), draggable=False, height=0.1, wrapWidth=None, ori=0.0, 
        color='black', colorSpace='rgb', opacity=None, 
        languageStyle='LTR',
        depth=-5.0);
    a2_3 = visual.TextStim(win=win, name='a2_3',
        text='>',
        font='Open Sans',
        pos=(0.20, 0), draggable=False, height=0.1, wrapWidth=None, ori=0.0, 
        color='black', colorSpace='rgb', opacity=None, 
        languageStyle='LTR',
        depth=-6.0);
    text_146 = visual.TextStim(win=win, name='text_146',
        text='Click the two actions (a sequence of LEFT and RIGHT) on the keyboard that will get you from the image on the far left to the image on the far right.',
        font='Open Sans',
        pos=(0, -0.28), draggable=False, height=0.055, wrapWidth=None, ori=0.0, 
        color='black', colorSpace='rgb', opacity=None, 
        languageStyle='LTR',
        depth=-7.0);
    
    # --- Initialize components for Routine "planningpathstraining2" ---
    question_quiz1_5 = visual.TextStim(win=win, name='question_quiz1_5',
        text='Plan the 2 actions in your head how to get from the left image to the right image. You have two minutes to plan.',
        font='Open Sans',
        pos=(0, 0.3), draggable=False, height=0.05, wrapWidth=None, ori=0.0, 
        color='black', colorSpace='rgb', opacity=None, 
        languageStyle='LTR',
        depth=0.0);
    answer_quiz1_5 = keyboard.Keyboard(deviceName='answer_quiz1_5')
    answer1_5 = visual.ImageStim(
        win=win,
        name='answer1_5', 
        image='default.png', mask=None, anchor='center',
        ori=0.0, pos=(-0.40, 0), draggable=False, size=(0.2, 0.2),
        color=[1,1,1], colorSpace='rgb', opacity=None,
        flipHoriz=False, flipVert=False,
        texRes=128.0, interpolate=True, depth=-2.0)
    answer2_5 = visual.ImageStim(
        win=win,
        name='answer2_5', 
        image='default.png', mask=None, anchor='center',
        ori=0.0, pos=(0, 0), draggable=False, size=(0.2, 0.2),
        color=[1,1,1], colorSpace='rgb', opacity=None,
        flipHoriz=False, flipVert=False,
        texRes=128.0, interpolate=True, depth=-3.0)
    answer3_5 = visual.ImageStim(
        win=win,
        name='answer3_5', 
        image='default.png', mask=None, anchor='center',
        ori=0.0, pos=(0.40, 0), draggable=False, size=(0.2, 0.2),
        color=[1,1,1], colorSpace='rgb', opacity=None,
        flipHoriz=False, flipVert=False,
        texRes=128.0, interpolate=True, depth=-4.0)
    a1_5 = visual.TextStim(win=win, name='a1_5',
        text='>',
        font='Open Sans',
        pos=(-0.20, 0), draggable=False, height=0.1, wrapWidth=None, ori=0.0, 
        color='black', colorSpace='rgb', opacity=None, 
        languageStyle='LTR',
        depth=-5.0);
    a2_5 = visual.TextStim(win=win, name='a2_5',
        text='>',
        font='Open Sans',
        pos=(0.20, 0), draggable=False, height=0.1, wrapWidth=None, ori=0.0, 
        color='black', colorSpace='rgb', opacity=None, 
        languageStyle='LTR',
        depth=-6.0);
    text_152 = visual.TextStim(win=win, name='text_152',
        text='Click the two actions (a sequence of LEFT and RIGHT) on the keyboard that will get you from the image on the far left to the image on the far right.',
        font='Open Sans',
        pos=(0, -0.28), draggable=False, height=0.055, wrapWidth=None, ori=0.0, 
        color='black', colorSpace='rgb', opacity=None, 
        languageStyle='LTR',
        depth=-8.0);
    
    # --- Initialize components for Routine "correct_forget_paths" ---
    next_trial_text_2 = visual.TextStim(win=win, name='next_trial_text_2',
        text='',
        font='Open Sans',
        pos=(0, 0), draggable=False, height=0.05, wrapWidth=None, ori=0.0, 
        color='black', colorSpace='rgb', opacity=None, 
        languageStyle='LTR',
        depth=0.0);
    text_151 = visual.TextStim(win=win, name='text_151',
        text='',
        font='Open Sans',
        pos=(0, -0.25), draggable=False, height=0.1, wrapWidth=None, ori=0.0, 
        color='black', colorSpace='rgb', opacity=None, 
        languageStyle='LTR',
        depth=-1.0);
    
    # --- Initialize components for Routine "total_score_planning" ---
    next_trial_text_3 = visual.TextStim(win=win, name='next_trial_text_3',
        text='',
        font='Open Sans',
        pos=(0, -0.2), draggable=False, height=0.05, wrapWidth=None, ori=0.0, 
        color='black', colorSpace='rgb', opacity=None, 
        languageStyle='LTR',
        depth=-1.0);
    text_150 = visual.TextStim(win=win, name='text_150',
        text='Percent correct:',
        font='Open Sans',
        pos=(0, 0.05), draggable=False, height=0.06, wrapWidth=None, ori=0.0, 
        color='black', colorSpace='rgb', opacity=None, 
        languageStyle='LTR',
        depth=-2.0);
    
    # --- Initialize components for Routine "end" ---
    text_20 = visual.TextStim(win=win, name='text_20',
        text='Thanks for your participation! you will have your Prolific credit and bonuses updated in the next couple of weeks.',
        font='Open Sans',
        pos=(0, 0), draggable=False, height=0.04, wrapWidth=None, ori=0.0, 
        color='black', colorSpace='rgb', opacity=None, 
        languageStyle='LTR',
        depth=0.0);
    
    # create some handy timers
    
    # global clock to track the time since experiment started
    if globalClock is None:
        # create a clock if not given one
        globalClock = core.Clock()
    if isinstance(globalClock, str):
        # if given a string, make a clock accoridng to it
        if globalClock == 'float':
            # get timestamps as a simple value
            globalClock = core.Clock(format='float')
        elif globalClock == 'iso':
            # get timestamps in ISO format
            globalClock = core.Clock(format='%Y-%m-%d_%H:%M:%S.%f%z')
        else:
            # get timestamps in a custom format
            globalClock = core.Clock(format=globalClock)
    if ioServer is not None:
        ioServer.syncClock(globalClock)
    logging.setDefaultClock(globalClock)
    # routine timer to track time remaining of each (possibly non-slip) routine
    routineTimer = core.Clock()
    win.flip()  # flip window to reset last flip timer
    # store the exact time the global clock started
    expInfo['expStart'] = data.getDateStr(
        format='%Y-%m-%d %Hh%M.%S.%f %z', fractionalSecondDigits=6
    )
    
    # --- Prepare to start Routine "consent" ---
    # create an object to store info about Routine consent
    consent = data.Routine(
        name='consent',
        components=[image_11, consent1_next, text_89],
    )
    consent.status = NOT_STARTED
    continueRoutine = True
    # update component parameters for each repeat
    image_11.setImage('consent1.png')
    # create starting attributes for consent1_next
    consent1_next.keys = []
    consent1_next.rt = []
    _consent1_next_allKeys = []
    # store start times for consent
    consent.tStartRefresh = win.getFutureFlipTime(clock=globalClock)
    consent.tStart = globalClock.getTime(format='float')
    consent.status = STARTED
    thisExp.addData('consent.started', consent.tStart)
    consent.maxDuration = None
    # keep track of which components have finished
    consentComponents = consent.components
    for thisComponent in consent.components:
        thisComponent.tStart = None
        thisComponent.tStop = None
        thisComponent.tStartRefresh = None
        thisComponent.tStopRefresh = None
        if hasattr(thisComponent, 'status'):
            thisComponent.status = NOT_STARTED
    # reset timers
    t = 0
    _timeToFirstFrame = win.getFutureFlipTime(clock="now")
    frameN = -1
    
    # --- Run Routine "consent" ---
    consent.forceEnded = routineForceEnded = not continueRoutine
    while continueRoutine:
        # get current time
        t = routineTimer.getTime()
        tThisFlip = win.getFutureFlipTime(clock=routineTimer)
        tThisFlipGlobal = win.getFutureFlipTime(clock=None)
        frameN = frameN + 1  # number of completed frames (so 0 is the first frame)
        # update/draw components on each frame
        
        # *image_11* updates
        
        # if image_11 is starting this frame...
        if image_11.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
            # keep track of start time/frame for later
            image_11.frameNStart = frameN  # exact frame index
            image_11.tStart = t  # local t and not account for scr refresh
            image_11.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(image_11, 'tStartRefresh')  # time at next scr refresh
            # add timestamp to datafile
            thisExp.timestampOnFlip(win, 'image_11.started')
            # update status
            image_11.status = STARTED
            image_11.setAutoDraw(True)
        
        # if image_11 is active this frame...
        if image_11.status == STARTED:
            # update params
            pass
        
        # *consent1_next* updates
        waitOnFlip = False
        
        # if consent1_next is starting this frame...
        if consent1_next.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
            # keep track of start time/frame for later
            consent1_next.frameNStart = frameN  # exact frame index
            consent1_next.tStart = t  # local t and not account for scr refresh
            consent1_next.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(consent1_next, 'tStartRefresh')  # time at next scr refresh
            # add timestamp to datafile
            thisExp.timestampOnFlip(win, 'consent1_next.started')
            # update status
            consent1_next.status = STARTED
            # keyboard checking is just starting
            waitOnFlip = True
            win.callOnFlip(consent1_next.clock.reset)  # t=0 on next screen flip
            win.callOnFlip(consent1_next.clearEvents, eventType='keyboard')  # clear events on next screen flip
        if consent1_next.status == STARTED and not waitOnFlip:
            theseKeys = consent1_next.getKeys(keyList=['space'], ignoreKeys=["escape"], waitRelease=False)
            _consent1_next_allKeys.extend(theseKeys)
            if len(_consent1_next_allKeys):
                consent1_next.keys = _consent1_next_allKeys[-1].name  # just the last key pressed
                consent1_next.rt = _consent1_next_allKeys[-1].rt
                consent1_next.duration = _consent1_next_allKeys[-1].duration
                # a response ends the routine
                continueRoutine = False
        
        # *text_89* updates
        
        # if text_89 is starting this frame...
        if text_89.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
            # keep track of start time/frame for later
            text_89.frameNStart = frameN  # exact frame index
            text_89.tStart = t  # local t and not account for scr refresh
            text_89.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(text_89, 'tStartRefresh')  # time at next scr refresh
            # add timestamp to datafile
            thisExp.timestampOnFlip(win, 'text_89.started')
            # update status
            text_89.status = STARTED
            text_89.setAutoDraw(True)
        
        # if text_89 is active this frame...
        if text_89.status == STARTED:
            # update params
            pass
        
        # check for quit (typically the Esc key)
        if defaultKeyboard.getKeys(keyList=["escape"]):
            thisExp.status = FINISHED
        if thisExp.status == FINISHED or endExpNow:
            endExperiment(thisExp, win=win)
            return
        # pause experiment here if requested
        if thisExp.status == PAUSED:
            pauseExperiment(
                thisExp=thisExp, 
                win=win, 
                timers=[routineTimer], 
                playbackComponents=[]
            )
            # skip the frame we paused on
            continue
        
        # check if all components have finished
        if not continueRoutine:  # a component has requested a forced-end of Routine
            consent.forceEnded = routineForceEnded = True
            break
        continueRoutine = False  # will revert to True if at least one component still running
        for thisComponent in consent.components:
            if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:
                continueRoutine = True
                break  # at least one component has not yet finished
        
        # refresh the screen
        if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen
            win.flip()
    
    # --- Ending Routine "consent" ---
    for thisComponent in consent.components:
        if hasattr(thisComponent, "setAutoDraw"):
            thisComponent.setAutoDraw(False)
    # store stop times for consent
    consent.tStop = globalClock.getTime(format='float')
    consent.tStopRefresh = tThisFlipGlobal
    thisExp.addData('consent.stopped', consent.tStop)
    # check responses
    if consent1_next.keys in ['', [], None]:  # No response was made
        consent1_next.keys = None
    thisExp.addData('consent1_next.keys',consent1_next.keys)
    if consent1_next.keys != None:  # we had a response
        thisExp.addData('consent1_next.rt', consent1_next.rt)
        thisExp.addData('consent1_next.duration', consent1_next.duration)
    thisExp.nextEntry()
    # the Routine "consent" was not non-slip safe, so reset the non-slip timer
    routineTimer.reset()
    
    # --- Prepare to start Routine "consent2" ---
    # create an object to store info about Routine consent2
    consent2 = data.Routine(
        name='consent2',
        components=[image_13, consent1_next_2, text_90],
    )
    consent2.status = NOT_STARTED
    continueRoutine = True
    # update component parameters for each repeat
    image_13.setImage('consent2.png')
    # create starting attributes for consent1_next_2
    consent1_next_2.keys = []
    consent1_next_2.rt = []
    _consent1_next_2_allKeys = []
    # store start times for consent2
    consent2.tStartRefresh = win.getFutureFlipTime(clock=globalClock)
    consent2.tStart = globalClock.getTime(format='float')
    consent2.status = STARTED
    thisExp.addData('consent2.started', consent2.tStart)
    consent2.maxDuration = None
    # keep track of which components have finished
    consent2Components = consent2.components
    for thisComponent in consent2.components:
        thisComponent.tStart = None
        thisComponent.tStop = None
        thisComponent.tStartRefresh = None
        thisComponent.tStopRefresh = None
        if hasattr(thisComponent, 'status'):
            thisComponent.status = NOT_STARTED
    # reset timers
    t = 0
    _timeToFirstFrame = win.getFutureFlipTime(clock="now")
    frameN = -1
    
    # --- Run Routine "consent2" ---
    consent2.forceEnded = routineForceEnded = not continueRoutine
    while continueRoutine:
        # get current time
        t = routineTimer.getTime()
        tThisFlip = win.getFutureFlipTime(clock=routineTimer)
        tThisFlipGlobal = win.getFutureFlipTime(clock=None)
        frameN = frameN + 1  # number of completed frames (so 0 is the first frame)
        # update/draw components on each frame
        
        # *image_13* updates
        
        # if image_13 is starting this frame...
        if image_13.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
            # keep track of start time/frame for later
            image_13.frameNStart = frameN  # exact frame index
            image_13.tStart = t  # local t and not account for scr refresh
            image_13.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(image_13, 'tStartRefresh')  # time at next scr refresh
            # add timestamp to datafile
            thisExp.timestampOnFlip(win, 'image_13.started')
            # update status
            image_13.status = STARTED
            image_13.setAutoDraw(True)
        
        # if image_13 is active this frame...
        if image_13.status == STARTED:
            # update params
            pass
        
        # *consent1_next_2* updates
        waitOnFlip = False
        
        # if consent1_next_2 is starting this frame...
        if consent1_next_2.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
            # keep track of start time/frame for later
            consent1_next_2.frameNStart = frameN  # exact frame index
            consent1_next_2.tStart = t  # local t and not account for scr refresh
            consent1_next_2.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(consent1_next_2, 'tStartRefresh')  # time at next scr refresh
            # add timestamp to datafile
            thisExp.timestampOnFlip(win, 'consent1_next_2.started')
            # update status
            consent1_next_2.status = STARTED
            # keyboard checking is just starting
            waitOnFlip = True
            win.callOnFlip(consent1_next_2.clock.reset)  # t=0 on next screen flip
            win.callOnFlip(consent1_next_2.clearEvents, eventType='keyboard')  # clear events on next screen flip
        if consent1_next_2.status == STARTED and not waitOnFlip:
            theseKeys = consent1_next_2.getKeys(keyList=['y','n'], ignoreKeys=["escape"], waitRelease=False)
            _consent1_next_2_allKeys.extend(theseKeys)
            if len(_consent1_next_2_allKeys):
                consent1_next_2.keys = _consent1_next_2_allKeys[-1].name  # just the last key pressed
                consent1_next_2.rt = _consent1_next_2_allKeys[-1].rt
                consent1_next_2.duration = _consent1_next_2_allKeys[-1].duration
                # a response ends the routine
                continueRoutine = False
        
        # *text_90* updates
        
        # if text_90 is starting this frame...
        if text_90.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
            # keep track of start time/frame for later
            text_90.frameNStart = frameN  # exact frame index
            text_90.tStart = t  # local t and not account for scr refresh
            text_90.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(text_90, 'tStartRefresh')  # time at next scr refresh
            # add timestamp to datafile
            thisExp.timestampOnFlip(win, 'text_90.started')
            # update status
            text_90.status = STARTED
            text_90.setAutoDraw(True)
        
        # if text_90 is active this frame...
        if text_90.status == STARTED:
            # update params
            pass
        
        # check for quit (typically the Esc key)
        if defaultKeyboard.getKeys(keyList=["escape"]):
            thisExp.status = FINISHED
        if thisExp.status == FINISHED or endExpNow:
            endExperiment(thisExp, win=win)
            return
        # pause experiment here if requested
        if thisExp.status == PAUSED:
            pauseExperiment(
                thisExp=thisExp, 
                win=win, 
                timers=[routineTimer], 
                playbackComponents=[]
            )
            # skip the frame we paused on
            continue
        
        # check if all components have finished
        if not continueRoutine:  # a component has requested a forced-end of Routine
            consent2.forceEnded = routineForceEnded = True
            break
        continueRoutine = False  # will revert to True if at least one component still running
        for thisComponent in consent2.components:
            if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:
                continueRoutine = True
                break  # at least one component has not yet finished
        
        # refresh the screen
        if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen
            win.flip()
    
    # --- Ending Routine "consent2" ---
    for thisComponent in consent2.components:
        if hasattr(thisComponent, "setAutoDraw"):
            thisComponent.setAutoDraw(False)
    # store stop times for consent2
    consent2.tStop = globalClock.getTime(format='float')
    consent2.tStopRefresh = tThisFlipGlobal
    thisExp.addData('consent2.stopped', consent2.tStop)
    # check responses
    if consent1_next_2.keys in ['', [], None]:  # No response was made
        consent1_next_2.keys = None
    thisExp.addData('consent1_next_2.keys',consent1_next_2.keys)
    if consent1_next_2.keys != None:  # we had a response
        thisExp.addData('consent1_next_2.rt', consent1_next_2.rt)
        thisExp.addData('consent1_next_2.duration', consent1_next_2.duration)
    # Run 'End Routine' code from code_19
    if consent1_next_2.keys=='n':
        psychoJS.quit()
    thisExp.nextEntry()
    # the Routine "consent2" was not non-slip safe, so reset the non-slip timer
    routineTimer.reset()
    
    # --- Prepare to start Routine "questionnaire_start" ---
    # create an object to store info about Routine questionnaire_start
    questionnaire_start = data.Routine(
        name='questionnaire_start',
        components=[text_33],
    )
    questionnaire_start.status = NOT_STARTED
    continueRoutine = True
    # update component parameters for each repeat
    # store start times for questionnaire_start
    questionnaire_start.tStartRefresh = win.getFutureFlipTime(clock=globalClock)
    questionnaire_start.tStart = globalClock.getTime(format='float')
    questionnaire_start.status = STARTED
    thisExp.addData('questionnaire_start.started', questionnaire_start.tStart)
    questionnaire_start.maxDuration = None
    # keep track of which components have finished
    questionnaire_startComponents = questionnaire_start.components
    for thisComponent in questionnaire_start.components:
        thisComponent.tStart = None
        thisComponent.tStop = None
        thisComponent.tStartRefresh = None
        thisComponent.tStopRefresh = None
        if hasattr(thisComponent, 'status'):
            thisComponent.status = NOT_STARTED
    # reset timers
    t = 0
    _timeToFirstFrame = win.getFutureFlipTime(clock="now")
    frameN = -1
    
    # --- Run Routine "questionnaire_start" ---
    questionnaire_start.forceEnded = routineForceEnded = not continueRoutine
    while continueRoutine and routineTimer.getTime() < 5.0:
        # get current time
        t = routineTimer.getTime()
        tThisFlip = win.getFutureFlipTime(clock=routineTimer)
        tThisFlipGlobal = win.getFutureFlipTime(clock=None)
        frameN = frameN + 1  # number of completed frames (so 0 is the first frame)
        # update/draw components on each frame
        
        # *text_33* updates
        
        # if text_33 is starting this frame...
        if text_33.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
            # keep track of start time/frame for later
            text_33.frameNStart = frameN  # exact frame index
            text_33.tStart = t  # local t and not account for scr refresh
            text_33.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(text_33, 'tStartRefresh')  # time at next scr refresh
            # add timestamp to datafile
            thisExp.timestampOnFlip(win, 'text_33.started')
            # update status
            text_33.status = STARTED
            text_33.setAutoDraw(True)
        
        # if text_33 is active this frame...
        if text_33.status == STARTED:
            # update params
            pass
        
        # if text_33 is stopping this frame...
        if text_33.status == STARTED:
            # is it time to stop? (based on global clock, using actual start)
            if tThisFlipGlobal > text_33.tStartRefresh + 5.0-frameTolerance:
                # keep track of stop time/frame for later
                text_33.tStop = t  # not accounting for scr refresh
                text_33.tStopRefresh = tThisFlipGlobal  # on global time
                text_33.frameNStop = frameN  # exact frame index
                # add timestamp to datafile
                thisExp.timestampOnFlip(win, 'text_33.stopped')
                # update status
                text_33.status = FINISHED
                text_33.setAutoDraw(False)
        
        # check for quit (typically the Esc key)
        if defaultKeyboard.getKeys(keyList=["escape"]):
            thisExp.status = FINISHED
        if thisExp.status == FINISHED or endExpNow:
            endExperiment(thisExp, win=win)
            return
        # pause experiment here if requested
        if thisExp.status == PAUSED:
            pauseExperiment(
                thisExp=thisExp, 
                win=win, 
                timers=[routineTimer], 
                playbackComponents=[]
            )
            # skip the frame we paused on
            continue
        
        # check if all components have finished
        if not continueRoutine:  # a component has requested a forced-end of Routine
            questionnaire_start.forceEnded = routineForceEnded = True
            break
        continueRoutine = False  # will revert to True if at least one component still running
        for thisComponent in questionnaire_start.components:
            if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:
                continueRoutine = True
                break  # at least one component has not yet finished
        
        # refresh the screen
        if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen
            win.flip()
    
    # --- Ending Routine "questionnaire_start" ---
    for thisComponent in questionnaire_start.components:
        if hasattr(thisComponent, "setAutoDraw"):
            thisComponent.setAutoDraw(False)
    # store stop times for questionnaire_start
    questionnaire_start.tStop = globalClock.getTime(format='float')
    questionnaire_start.tStopRefresh = tThisFlipGlobal
    thisExp.addData('questionnaire_start.stopped', questionnaire_start.tStop)
    # using non-slip timing so subtract the expected duration of this Routine (unless ended on request)
    if questionnaire_start.maxDurationReached:
        routineTimer.addTime(-questionnaire_start.maxDuration)
    elif questionnaire_start.forceEnded:
        routineTimer.reset()
    else:
        routineTimer.addTime(-5.000000)
    thisExp.nextEntry()
    
    # --- Prepare to start Routine "PSWQ15" ---
    # create an object to store info about Routine PSWQ15
    PSWQ15 = data.Routine(
        name='PSWQ15',
        components=[text_105, text_106, text_107, key_resp_34],
    )
    PSWQ15.status = NOT_STARTED
    continueRoutine = True
    # update component parameters for each repeat
    # create starting attributes for key_resp_34
    key_resp_34.keys = []
    key_resp_34.rt = []
    _key_resp_34_allKeys = []
    # store start times for PSWQ15
    PSWQ15.tStartRefresh = win.getFutureFlipTime(clock=globalClock)
    PSWQ15.tStart = globalClock.getTime(format='float')
    PSWQ15.status = STARTED
    thisExp.addData('PSWQ15.started', PSWQ15.tStart)
    PSWQ15.maxDuration = None
    # keep track of which components have finished
    PSWQ15Components = PSWQ15.components
    for thisComponent in PSWQ15.components:
        thisComponent.tStart = None
        thisComponent.tStop = None
        thisComponent.tStartRefresh = None
        thisComponent.tStopRefresh = None
        if hasattr(thisComponent, 'status'):
            thisComponent.status = NOT_STARTED
    # reset timers
    t = 0
    _timeToFirstFrame = win.getFutureFlipTime(clock="now")
    frameN = -1
    
    # --- Run Routine "PSWQ15" ---
    PSWQ15.forceEnded = routineForceEnded = not continueRoutine
    while continueRoutine:
        # get current time
        t = routineTimer.getTime()
        tThisFlip = win.getFutureFlipTime(clock=routineTimer)
        tThisFlipGlobal = win.getFutureFlipTime(clock=None)
        frameN = frameN + 1  # number of completed frames (so 0 is the first frame)
        # update/draw components on each frame
        
        # *text_105* updates
        
        # if text_105 is starting this frame...
        if text_105.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
            # keep track of start time/frame for later
            text_105.frameNStart = frameN  # exact frame index
            text_105.tStart = t  # local t and not account for scr refresh
            text_105.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(text_105, 'tStartRefresh')  # time at next scr refresh
            # add timestamp to datafile
            thisExp.timestampOnFlip(win, 'text_105.started')
            # update status
            text_105.status = STARTED
            text_105.setAutoDraw(True)
        
        # if text_105 is active this frame...
        if text_105.status == STARTED:
            # update params
            pass
        
        # *text_106* updates
        
        # if text_106 is starting this frame...
        if text_106.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
            # keep track of start time/frame for later
            text_106.frameNStart = frameN  # exact frame index
            text_106.tStart = t  # local t and not account for scr refresh
            text_106.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(text_106, 'tStartRefresh')  # time at next scr refresh
            # add timestamp to datafile
            thisExp.timestampOnFlip(win, 'text_106.started')
            # update status
            text_106.status = STARTED
            text_106.setAutoDraw(True)
        
        # if text_106 is active this frame...
        if text_106.status == STARTED:
            # update params
            pass
        
        # *text_107* updates
        
        # if text_107 is starting this frame...
        if text_107.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
            # keep track of start time/frame for later
            text_107.frameNStart = frameN  # exact frame index
            text_107.tStart = t  # local t and not account for scr refresh
            text_107.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(text_107, 'tStartRefresh')  # time at next scr refresh
            # add timestamp to datafile
            thisExp.timestampOnFlip(win, 'text_107.started')
            # update status
            text_107.status = STARTED
            text_107.setAutoDraw(True)
        
        # if text_107 is active this frame...
        if text_107.status == STARTED:
            # update params
            pass
        
        # *key_resp_34* updates
        waitOnFlip = False
        
        # if key_resp_34 is starting this frame...
        if key_resp_34.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
            # keep track of start time/frame for later
            key_resp_34.frameNStart = frameN  # exact frame index
            key_resp_34.tStart = t  # local t and not account for scr refresh
            key_resp_34.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(key_resp_34, 'tStartRefresh')  # time at next scr refresh
            # add timestamp to datafile
            thisExp.timestampOnFlip(win, 'key_resp_34.started')
            # update status
            key_resp_34.status = STARTED
            # keyboard checking is just starting
            waitOnFlip = True
            win.callOnFlip(key_resp_34.clock.reset)  # t=0 on next screen flip
            win.callOnFlip(key_resp_34.clearEvents, eventType='keyboard')  # clear events on next screen flip
        if key_resp_34.status == STARTED and not waitOnFlip:
            theseKeys = key_resp_34.getKeys(keyList=[1,2,3,4,5,'1','2','3','4','5'], ignoreKeys=["escape"], waitRelease=False)
            _key_resp_34_allKeys.extend(theseKeys)
            if len(_key_resp_34_allKeys):
                key_resp_34.keys = _key_resp_34_allKeys[-1].name  # just the last key pressed
                key_resp_34.rt = _key_resp_34_allKeys[-1].rt
                key_resp_34.duration = _key_resp_34_allKeys[-1].duration
                # a response ends the routine
                continueRoutine = False
        
        # check for quit (typically the Esc key)
        if defaultKeyboard.getKeys(keyList=["escape"]):
            thisExp.status = FINISHED
        if thisExp.status == FINISHED or endExpNow:
            endExperiment(thisExp, win=win)
            return
        # pause experiment here if requested
        if thisExp.status == PAUSED:
            pauseExperiment(
                thisExp=thisExp, 
                win=win, 
                timers=[routineTimer], 
                playbackComponents=[]
            )
            # skip the frame we paused on
            continue
        
        # check if all components have finished
        if not continueRoutine:  # a component has requested a forced-end of Routine
            PSWQ15.forceEnded = routineForceEnded = True
            break
        continueRoutine = False  # will revert to True if at least one component still running
        for thisComponent in PSWQ15.components:
            if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:
                continueRoutine = True
                break  # at least one component has not yet finished
        
        # refresh the screen
        if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen
            win.flip()
    
    # --- Ending Routine "PSWQ15" ---
    for thisComponent in PSWQ15.components:
        if hasattr(thisComponent, "setAutoDraw"):
            thisComponent.setAutoDraw(False)
    # store stop times for PSWQ15
    PSWQ15.tStop = globalClock.getTime(format='float')
    PSWQ15.tStopRefresh = tThisFlipGlobal
    thisExp.addData('PSWQ15.stopped', PSWQ15.tStop)
    # check responses
    if key_resp_34.keys in ['', [], None]:  # No response was made
        key_resp_34.keys = None
    thisExp.addData('key_resp_34.keys',key_resp_34.keys)
    if key_resp_34.keys != None:  # we had a response
        thisExp.addData('key_resp_34.rt', key_resp_34.rt)
        thisExp.addData('key_resp_34.duration', key_resp_34.duration)
    thisExp.nextEntry()
    # the Routine "PSWQ15" was not non-slip safe, so reset the non-slip timer
    routineTimer.reset()
    
    # --- Prepare to start Routine "PSWQ16" ---
    # create an object to store info about Routine PSWQ16
    PSWQ16 = data.Routine(
        name='PSWQ16',
        components=[text_108, text_109, text_110, key_resp_35],
    )
    PSWQ16.status = NOT_STARTED
    continueRoutine = True
    # update component parameters for each repeat
    # create starting attributes for key_resp_35
    key_resp_35.keys = []
    key_resp_35.rt = []
    _key_resp_35_allKeys = []
    # store start times for PSWQ16
    PSWQ16.tStartRefresh = win.getFutureFlipTime(clock=globalClock)
    PSWQ16.tStart = globalClock.getTime(format='float')
    PSWQ16.status = STARTED
    thisExp.addData('PSWQ16.started', PSWQ16.tStart)
    PSWQ16.maxDuration = None
    # keep track of which components have finished
    PSWQ16Components = PSWQ16.components
    for thisComponent in PSWQ16.components:
        thisComponent.tStart = None
        thisComponent.tStop = None
        thisComponent.tStartRefresh = None
        thisComponent.tStopRefresh = None
        if hasattr(thisComponent, 'status'):
            thisComponent.status = NOT_STARTED
    # reset timers
    t = 0
    _timeToFirstFrame = win.getFutureFlipTime(clock="now")
    frameN = -1
    
    # --- Run Routine "PSWQ16" ---
    PSWQ16.forceEnded = routineForceEnded = not continueRoutine
    while continueRoutine:
        # get current time
        t = routineTimer.getTime()
        tThisFlip = win.getFutureFlipTime(clock=routineTimer)
        tThisFlipGlobal = win.getFutureFlipTime(clock=None)
        frameN = frameN + 1  # number of completed frames (so 0 is the first frame)
        # update/draw components on each frame
        
        # *text_108* updates
        
        # if text_108 is starting this frame...
        if text_108.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
            # keep track of start time/frame for later
            text_108.frameNStart = frameN  # exact frame index
            text_108.tStart = t  # local t and not account for scr refresh
            text_108.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(text_108, 'tStartRefresh')  # time at next scr refresh
            # add timestamp to datafile
            thisExp.timestampOnFlip(win, 'text_108.started')
            # update status
            text_108.status = STARTED
            text_108.setAutoDraw(True)
        
        # if text_108 is active this frame...
        if text_108.status == STARTED:
            # update params
            pass
        
        # *text_109* updates
        
        # if text_109 is starting this frame...
        if text_109.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
            # keep track of start time/frame for later
            text_109.frameNStart = frameN  # exact frame index
            text_109.tStart = t  # local t and not account for scr refresh
            text_109.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(text_109, 'tStartRefresh')  # time at next scr refresh
            # add timestamp to datafile
            thisExp.timestampOnFlip(win, 'text_109.started')
            # update status
            text_109.status = STARTED
            text_109.setAutoDraw(True)
        
        # if text_109 is active this frame...
        if text_109.status == STARTED:
            # update params
            pass
        
        # *text_110* updates
        
        # if text_110 is starting this frame...
        if text_110.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
            # keep track of start time/frame for later
            text_110.frameNStart = frameN  # exact frame index
            text_110.tStart = t  # local t and not account for scr refresh
            text_110.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(text_110, 'tStartRefresh')  # time at next scr refresh
            # add timestamp to datafile
            thisExp.timestampOnFlip(win, 'text_110.started')
            # update status
            text_110.status = STARTED
            text_110.setAutoDraw(True)
        
        # if text_110 is active this frame...
        if text_110.status == STARTED:
            # update params
            pass
        
        # *key_resp_35* updates
        waitOnFlip = False
        
        # if key_resp_35 is starting this frame...
        if key_resp_35.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
            # keep track of start time/frame for later
            key_resp_35.frameNStart = frameN  # exact frame index
            key_resp_35.tStart = t  # local t and not account for scr refresh
            key_resp_35.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(key_resp_35, 'tStartRefresh')  # time at next scr refresh
            # add timestamp to datafile
            thisExp.timestampOnFlip(win, 'key_resp_35.started')
            # update status
            key_resp_35.status = STARTED
            # keyboard checking is just starting
            waitOnFlip = True
            win.callOnFlip(key_resp_35.clock.reset)  # t=0 on next screen flip
            win.callOnFlip(key_resp_35.clearEvents, eventType='keyboard')  # clear events on next screen flip
        if key_resp_35.status == STARTED and not waitOnFlip:
            theseKeys = key_resp_35.getKeys(keyList=[1,2,3,4,5,'1','2','3','4','5'], ignoreKeys=["escape"], waitRelease=False)
            _key_resp_35_allKeys.extend(theseKeys)
            if len(_key_resp_35_allKeys):
                key_resp_35.keys = _key_resp_35_allKeys[-1].name  # just the last key pressed
                key_resp_35.rt = _key_resp_35_allKeys[-1].rt
                key_resp_35.duration = _key_resp_35_allKeys[-1].duration
                # a response ends the routine
                continueRoutine = False
        
        # check for quit (typically the Esc key)
        if defaultKeyboard.getKeys(keyList=["escape"]):
            thisExp.status = FINISHED
        if thisExp.status == FINISHED or endExpNow:
            endExperiment(thisExp, win=win)
            return
        # pause experiment here if requested
        if thisExp.status == PAUSED:
            pauseExperiment(
                thisExp=thisExp, 
                win=win, 
                timers=[routineTimer], 
                playbackComponents=[]
            )
            # skip the frame we paused on
            continue
        
        # check if all components have finished
        if not continueRoutine:  # a component has requested a forced-end of Routine
            PSWQ16.forceEnded = routineForceEnded = True
            break
        continueRoutine = False  # will revert to True if at least one component still running
        for thisComponent in PSWQ16.components:
            if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:
                continueRoutine = True
                break  # at least one component has not yet finished
        
        # refresh the screen
        if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen
            win.flip()
    
    # --- Ending Routine "PSWQ16" ---
    for thisComponent in PSWQ16.components:
        if hasattr(thisComponent, "setAutoDraw"):
            thisComponent.setAutoDraw(False)
    # store stop times for PSWQ16
    PSWQ16.tStop = globalClock.getTime(format='float')
    PSWQ16.tStopRefresh = tThisFlipGlobal
    thisExp.addData('PSWQ16.stopped', PSWQ16.tStop)
    # check responses
    if key_resp_35.keys in ['', [], None]:  # No response was made
        key_resp_35.keys = None
    thisExp.addData('key_resp_35.keys',key_resp_35.keys)
    if key_resp_35.keys != None:  # we had a response
        thisExp.addData('key_resp_35.rt', key_resp_35.rt)
        thisExp.addData('key_resp_35.duration', key_resp_35.duration)
    thisExp.nextEntry()
    # the Routine "PSWQ16" was not non-slip safe, so reset the non-slip timer
    routineTimer.reset()
    
    # --- Prepare to start Routine "q2_instructions" ---
    # create an object to store info about Routine q2_instructions
    q2_instructions = data.Routine(
        name='q2_instructions',
        components=[text_155],
    )
    q2_instructions.status = NOT_STARTED
    continueRoutine = True
    # update component parameters for each repeat
    # store start times for q2_instructions
    q2_instructions.tStartRefresh = win.getFutureFlipTime(clock=globalClock)
    q2_instructions.tStart = globalClock.getTime(format='float')
    q2_instructions.status = STARTED
    thisExp.addData('q2_instructions.started', q2_instructions.tStart)
    q2_instructions.maxDuration = None
    # keep track of which components have finished
    q2_instructionsComponents = q2_instructions.components
    for thisComponent in q2_instructions.components:
        thisComponent.tStart = None
        thisComponent.tStop = None
        thisComponent.tStartRefresh = None
        thisComponent.tStopRefresh = None
        if hasattr(thisComponent, 'status'):
            thisComponent.status = NOT_STARTED
    # reset timers
    t = 0
    _timeToFirstFrame = win.getFutureFlipTime(clock="now")
    frameN = -1
    
    # --- Run Routine "q2_instructions" ---
    q2_instructions.forceEnded = routineForceEnded = not continueRoutine
    while continueRoutine and routineTimer.getTime() < 5.0:
        # get current time
        t = routineTimer.getTime()
        tThisFlip = win.getFutureFlipTime(clock=routineTimer)
        tThisFlipGlobal = win.getFutureFlipTime(clock=None)
        frameN = frameN + 1  # number of completed frames (so 0 is the first frame)
        # update/draw components on each frame
        
        # *text_155* updates
        
        # if text_155 is starting this frame...
        if text_155.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
            # keep track of start time/frame for later
            text_155.frameNStart = frameN  # exact frame index
            text_155.tStart = t  # local t and not account for scr refresh
            text_155.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(text_155, 'tStartRefresh')  # time at next scr refresh
            # add timestamp to datafile
            thisExp.timestampOnFlip(win, 'text_155.started')
            # update status
            text_155.status = STARTED
            text_155.setAutoDraw(True)
        
        # if text_155 is active this frame...
        if text_155.status == STARTED:
            # update params
            pass
        
        # if text_155 is stopping this frame...
        if text_155.status == STARTED:
            # is it time to stop? (based on global clock, using actual start)
            if tThisFlipGlobal > text_155.tStartRefresh + 5.0-frameTolerance:
                # keep track of stop time/frame for later
                text_155.tStop = t  # not accounting for scr refresh
                text_155.tStopRefresh = tThisFlipGlobal  # on global time
                text_155.frameNStop = frameN  # exact frame index
                # add timestamp to datafile
                thisExp.timestampOnFlip(win, 'text_155.stopped')
                # update status
                text_155.status = FINISHED
                text_155.setAutoDraw(False)
        
        # check for quit (typically the Esc key)
        if defaultKeyboard.getKeys(keyList=["escape"]):
            thisExp.status = FINISHED
        if thisExp.status == FINISHED or endExpNow:
            endExperiment(thisExp, win=win)
            return
        # pause experiment here if requested
        if thisExp.status == PAUSED:
            pauseExperiment(
                thisExp=thisExp, 
                win=win, 
                timers=[routineTimer], 
                playbackComponents=[]
            )
            # skip the frame we paused on
            continue
        
        # check if all components have finished
        if not continueRoutine:  # a component has requested a forced-end of Routine
            q2_instructions.forceEnded = routineForceEnded = True
            break
        continueRoutine = False  # will revert to True if at least one component still running
        for thisComponent in q2_instructions.components:
            if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:
                continueRoutine = True
                break  # at least one component has not yet finished
        
        # refresh the screen
        if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen
            win.flip()
    
    # --- Ending Routine "q2_instructions" ---
    for thisComponent in q2_instructions.components:
        if hasattr(thisComponent, "setAutoDraw"):
            thisComponent.setAutoDraw(False)
    # store stop times for q2_instructions
    q2_instructions.tStop = globalClock.getTime(format='float')
    q2_instructions.tStopRefresh = tThisFlipGlobal
    thisExp.addData('q2_instructions.stopped', q2_instructions.tStop)
    # using non-slip timing so subtract the expected duration of this Routine (unless ended on request)
    if q2_instructions.maxDurationReached:
        routineTimer.addTime(-q2_instructions.maxDuration)
    elif q2_instructions.forceEnded:
        routineTimer.reset()
    else:
        routineTimer.addTime(-5.000000)
    thisExp.nextEntry()
    
    # --- Prepare to start Routine "AM1" ---
    # create an object to store info about Routine AM1
    AM1 = data.Routine(
        name='AM1',
        components=[text_156, text_157, text_158, key_resp_41],
    )
    AM1.status = NOT_STARTED
    continueRoutine = True
    # update component parameters for each repeat
    # create starting attributes for key_resp_41
    key_resp_41.keys = []
    key_resp_41.rt = []
    _key_resp_41_allKeys = []
    # store start times for AM1
    AM1.tStartRefresh = win.getFutureFlipTime(clock=globalClock)
    AM1.tStart = globalClock.getTime(format='float')
    AM1.status = STARTED
    thisExp.addData('AM1.started', AM1.tStart)
    AM1.maxDuration = None
    # keep track of which components have finished
    AM1Components = AM1.components
    for thisComponent in AM1.components:
        thisComponent.tStart = None
        thisComponent.tStop = None
        thisComponent.tStartRefresh = None
        thisComponent.tStopRefresh = None
        if hasattr(thisComponent, 'status'):
            thisComponent.status = NOT_STARTED
    # reset timers
    t = 0
    _timeToFirstFrame = win.getFutureFlipTime(clock="now")
    frameN = -1
    
    # --- Run Routine "AM1" ---
    AM1.forceEnded = routineForceEnded = not continueRoutine
    while continueRoutine:
        # get current time
        t = routineTimer.getTime()
        tThisFlip = win.getFutureFlipTime(clock=routineTimer)
        tThisFlipGlobal = win.getFutureFlipTime(clock=None)
        frameN = frameN + 1  # number of completed frames (so 0 is the first frame)
        # update/draw components on each frame
        
        # *text_156* updates
        
        # if text_156 is starting this frame...
        if text_156.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
            # keep track of start time/frame for later
            text_156.frameNStart = frameN  # exact frame index
            text_156.tStart = t  # local t and not account for scr refresh
            text_156.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(text_156, 'tStartRefresh')  # time at next scr refresh
            # add timestamp to datafile
            thisExp.timestampOnFlip(win, 'text_156.started')
            # update status
            text_156.status = STARTED
            text_156.setAutoDraw(True)
        
        # if text_156 is active this frame...
        if text_156.status == STARTED:
            # update params
            pass
        
        # *text_157* updates
        
        # if text_157 is starting this frame...
        if text_157.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
            # keep track of start time/frame for later
            text_157.frameNStart = frameN  # exact frame index
            text_157.tStart = t  # local t and not account for scr refresh
            text_157.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(text_157, 'tStartRefresh')  # time at next scr refresh
            # add timestamp to datafile
            thisExp.timestampOnFlip(win, 'text_157.started')
            # update status
            text_157.status = STARTED
            text_157.setAutoDraw(True)
        
        # if text_157 is active this frame...
        if text_157.status == STARTED:
            # update params
            pass
        
        # *text_158* updates
        
        # if text_158 is starting this frame...
        if text_158.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
            # keep track of start time/frame for later
            text_158.frameNStart = frameN  # exact frame index
            text_158.tStart = t  # local t and not account for scr refresh
            text_158.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(text_158, 'tStartRefresh')  # time at next scr refresh
            # add timestamp to datafile
            thisExp.timestampOnFlip(win, 'text_158.started')
            # update status
            text_158.status = STARTED
            text_158.setAutoDraw(True)
        
        # if text_158 is active this frame...
        if text_158.status == STARTED:
            # update params
            pass
        
        # *key_resp_41* updates
        waitOnFlip = False
        
        # if key_resp_41 is starting this frame...
        if key_resp_41.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
            # keep track of start time/frame for later
            key_resp_41.frameNStart = frameN  # exact frame index
            key_resp_41.tStart = t  # local t and not account for scr refresh
            key_resp_41.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(key_resp_41, 'tStartRefresh')  # time at next scr refresh
            # add timestamp to datafile
            thisExp.timestampOnFlip(win, 'key_resp_41.started')
            # update status
            key_resp_41.status = STARTED
            # keyboard checking is just starting
            waitOnFlip = True
            win.callOnFlip(key_resp_41.clock.reset)  # t=0 on next screen flip
            win.callOnFlip(key_resp_41.clearEvents, eventType='keyboard')  # clear events on next screen flip
        if key_resp_41.status == STARTED and not waitOnFlip:
            theseKeys = key_resp_41.getKeys(keyList=[1,2,3,4,5,'1','2','3','4','5'], ignoreKeys=["escape"], waitRelease=False)
            _key_resp_41_allKeys.extend(theseKeys)
            if len(_key_resp_41_allKeys):
                key_resp_41.keys = _key_resp_41_allKeys[-1].name  # just the last key pressed
                key_resp_41.rt = _key_resp_41_allKeys[-1].rt
                key_resp_41.duration = _key_resp_41_allKeys[-1].duration
                # a response ends the routine
                continueRoutine = False
        
        # check for quit (typically the Esc key)
        if defaultKeyboard.getKeys(keyList=["escape"]):
            thisExp.status = FINISHED
        if thisExp.status == FINISHED or endExpNow:
            endExperiment(thisExp, win=win)
            return
        # pause experiment here if requested
        if thisExp.status == PAUSED:
            pauseExperiment(
                thisExp=thisExp, 
                win=win, 
                timers=[routineTimer], 
                playbackComponents=[]
            )
            # skip the frame we paused on
            continue
        
        # check if all components have finished
        if not continueRoutine:  # a component has requested a forced-end of Routine
            AM1.forceEnded = routineForceEnded = True
            break
        continueRoutine = False  # will revert to True if at least one component still running
        for thisComponent in AM1.components:
            if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:
                continueRoutine = True
                break  # at least one component has not yet finished
        
        # refresh the screen
        if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen
            win.flip()
    
    # --- Ending Routine "AM1" ---
    for thisComponent in AM1.components:
        if hasattr(thisComponent, "setAutoDraw"):
            thisComponent.setAutoDraw(False)
    # store stop times for AM1
    AM1.tStop = globalClock.getTime(format='float')
    AM1.tStopRefresh = tThisFlipGlobal
    thisExp.addData('AM1.stopped', AM1.tStop)
    # check responses
    if key_resp_41.keys in ['', [], None]:  # No response was made
        key_resp_41.keys = None
    thisExp.addData('key_resp_41.keys',key_resp_41.keys)
    if key_resp_41.keys != None:  # we had a response
        thisExp.addData('key_resp_41.rt', key_resp_41.rt)
        thisExp.addData('key_resp_41.duration', key_resp_41.duration)
    thisExp.nextEntry()
    # the Routine "AM1" was not non-slip safe, so reset the non-slip timer
    routineTimer.reset()
    
    # --- Prepare to start Routine "AM2" ---
    # create an object to store info about Routine AM2
    AM2 = data.Routine(
        name='AM2',
        components=[text_159, text_160, text_161, key_resp_42],
    )
    AM2.status = NOT_STARTED
    continueRoutine = True
    # update component parameters for each repeat
    # create starting attributes for key_resp_42
    key_resp_42.keys = []
    key_resp_42.rt = []
    _key_resp_42_allKeys = []
    # store start times for AM2
    AM2.tStartRefresh = win.getFutureFlipTime(clock=globalClock)
    AM2.tStart = globalClock.getTime(format='float')
    AM2.status = STARTED
    thisExp.addData('AM2.started', AM2.tStart)
    AM2.maxDuration = None
    # keep track of which components have finished
    AM2Components = AM2.components
    for thisComponent in AM2.components:
        thisComponent.tStart = None
        thisComponent.tStop = None
        thisComponent.tStartRefresh = None
        thisComponent.tStopRefresh = None
        if hasattr(thisComponent, 'status'):
            thisComponent.status = NOT_STARTED
    # reset timers
    t = 0
    _timeToFirstFrame = win.getFutureFlipTime(clock="now")
    frameN = -1
    
    # --- Run Routine "AM2" ---
    AM2.forceEnded = routineForceEnded = not continueRoutine
    while continueRoutine:
        # get current time
        t = routineTimer.getTime()
        tThisFlip = win.getFutureFlipTime(clock=routineTimer)
        tThisFlipGlobal = win.getFutureFlipTime(clock=None)
        frameN = frameN + 1  # number of completed frames (so 0 is the first frame)
        # update/draw components on each frame
        
        # *text_159* updates
        
        # if text_159 is starting this frame...
        if text_159.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
            # keep track of start time/frame for later
            text_159.frameNStart = frameN  # exact frame index
            text_159.tStart = t  # local t and not account for scr refresh
            text_159.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(text_159, 'tStartRefresh')  # time at next scr refresh
            # add timestamp to datafile
            thisExp.timestampOnFlip(win, 'text_159.started')
            # update status
            text_159.status = STARTED
            text_159.setAutoDraw(True)
        
        # if text_159 is active this frame...
        if text_159.status == STARTED:
            # update params
            pass
        
        # *text_160* updates
        
        # if text_160 is starting this frame...
        if text_160.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
            # keep track of start time/frame for later
            text_160.frameNStart = frameN  # exact frame index
            text_160.tStart = t  # local t and not account for scr refresh
            text_160.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(text_160, 'tStartRefresh')  # time at next scr refresh
            # add timestamp to datafile
            thisExp.timestampOnFlip(win, 'text_160.started')
            # update status
            text_160.status = STARTED
            text_160.setAutoDraw(True)
        
        # if text_160 is active this frame...
        if text_160.status == STARTED:
            # update params
            pass
        
        # *text_161* updates
        
        # if text_161 is starting this frame...
        if text_161.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
            # keep track of start time/frame for later
            text_161.frameNStart = frameN  # exact frame index
            text_161.tStart = t  # local t and not account for scr refresh
            text_161.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(text_161, 'tStartRefresh')  # time at next scr refresh
            # add timestamp to datafile
            thisExp.timestampOnFlip(win, 'text_161.started')
            # update status
            text_161.status = STARTED
            text_161.setAutoDraw(True)
        
        # if text_161 is active this frame...
        if text_161.status == STARTED:
            # update params
            pass
        
        # *key_resp_42* updates
        waitOnFlip = False
        
        # if key_resp_42 is starting this frame...
        if key_resp_42.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
            # keep track of start time/frame for later
            key_resp_42.frameNStart = frameN  # exact frame index
            key_resp_42.tStart = t  # local t and not account for scr refresh
            key_resp_42.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(key_resp_42, 'tStartRefresh')  # time at next scr refresh
            # add timestamp to datafile
            thisExp.timestampOnFlip(win, 'key_resp_42.started')
            # update status
            key_resp_42.status = STARTED
            # keyboard checking is just starting
            waitOnFlip = True
            win.callOnFlip(key_resp_42.clock.reset)  # t=0 on next screen flip
            win.callOnFlip(key_resp_42.clearEvents, eventType='keyboard')  # clear events on next screen flip
        if key_resp_42.status == STARTED and not waitOnFlip:
            theseKeys = key_resp_42.getKeys(keyList=[1,2,3,4,5,'1','2','3','4','5'], ignoreKeys=["escape"], waitRelease=False)
            _key_resp_42_allKeys.extend(theseKeys)
            if len(_key_resp_42_allKeys):
                key_resp_42.keys = _key_resp_42_allKeys[-1].name  # just the last key pressed
                key_resp_42.rt = _key_resp_42_allKeys[-1].rt
                key_resp_42.duration = _key_resp_42_allKeys[-1].duration
                # a response ends the routine
                continueRoutine = False
        
        # check for quit (typically the Esc key)
        if defaultKeyboard.getKeys(keyList=["escape"]):
            thisExp.status = FINISHED
        if thisExp.status == FINISHED or endExpNow:
            endExperiment(thisExp, win=win)
            return
        # pause experiment here if requested
        if thisExp.status == PAUSED:
            pauseExperiment(
                thisExp=thisExp, 
                win=win, 
                timers=[routineTimer], 
                playbackComponents=[]
            )
            # skip the frame we paused on
            continue
        
        # check if all components have finished
        if not continueRoutine:  # a component has requested a forced-end of Routine
            AM2.forceEnded = routineForceEnded = True
            break
        continueRoutine = False  # will revert to True if at least one component still running
        for thisComponent in AM2.components:
            if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:
                continueRoutine = True
                break  # at least one component has not yet finished
        
        # refresh the screen
        if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen
            win.flip()
    
    # --- Ending Routine "AM2" ---
    for thisComponent in AM2.components:
        if hasattr(thisComponent, "setAutoDraw"):
            thisComponent.setAutoDraw(False)
    # store stop times for AM2
    AM2.tStop = globalClock.getTime(format='float')
    AM2.tStopRefresh = tThisFlipGlobal
    thisExp.addData('AM2.stopped', AM2.tStop)
    # check responses
    if key_resp_42.keys in ['', [], None]:  # No response was made
        key_resp_42.keys = None
    thisExp.addData('key_resp_42.keys',key_resp_42.keys)
    if key_resp_42.keys != None:  # we had a response
        thisExp.addData('key_resp_42.rt', key_resp_42.rt)
        thisExp.addData('key_resp_42.duration', key_resp_42.duration)
    thisExp.nextEntry()
    # the Routine "AM2" was not non-slip safe, so reset the non-slip timer
    routineTimer.reset()
    
    # --- Prepare to start Routine "AM3" ---
    # create an object to store info about Routine AM3
    AM3 = data.Routine(
        name='AM3',
        components=[text_162, text_163, text_164, key_resp_43],
    )
    AM3.status = NOT_STARTED
    continueRoutine = True
    # update component parameters for each repeat
    # create starting attributes for key_resp_43
    key_resp_43.keys = []
    key_resp_43.rt = []
    _key_resp_43_allKeys = []
    # store start times for AM3
    AM3.tStartRefresh = win.getFutureFlipTime(clock=globalClock)
    AM3.tStart = globalClock.getTime(format='float')
    AM3.status = STARTED
    thisExp.addData('AM3.started', AM3.tStart)
    AM3.maxDuration = None
    # keep track of which components have finished
    AM3Components = AM3.components
    for thisComponent in AM3.components:
        thisComponent.tStart = None
        thisComponent.tStop = None
        thisComponent.tStartRefresh = None
        thisComponent.tStopRefresh = None
        if hasattr(thisComponent, 'status'):
            thisComponent.status = NOT_STARTED
    # reset timers
    t = 0
    _timeToFirstFrame = win.getFutureFlipTime(clock="now")
    frameN = -1
    
    # --- Run Routine "AM3" ---
    AM3.forceEnded = routineForceEnded = not continueRoutine
    while continueRoutine:
        # get current time
        t = routineTimer.getTime()
        tThisFlip = win.getFutureFlipTime(clock=routineTimer)
        tThisFlipGlobal = win.getFutureFlipTime(clock=None)
        frameN = frameN + 1  # number of completed frames (so 0 is the first frame)
        # update/draw components on each frame
        
        # *text_162* updates
        
        # if text_162 is starting this frame...
        if text_162.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
            # keep track of start time/frame for later
            text_162.frameNStart = frameN  # exact frame index
            text_162.tStart = t  # local t and not account for scr refresh
            text_162.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(text_162, 'tStartRefresh')  # time at next scr refresh
            # add timestamp to datafile
            thisExp.timestampOnFlip(win, 'text_162.started')
            # update status
            text_162.status = STARTED
            text_162.setAutoDraw(True)
        
        # if text_162 is active this frame...
        if text_162.status == STARTED:
            # update params
            pass
        
        # *text_163* updates
        
        # if text_163 is starting this frame...
        if text_163.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
            # keep track of start time/frame for later
            text_163.frameNStart = frameN  # exact frame index
            text_163.tStart = t  # local t and not account for scr refresh
            text_163.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(text_163, 'tStartRefresh')  # time at next scr refresh
            # add timestamp to datafile
            thisExp.timestampOnFlip(win, 'text_163.started')
            # update status
            text_163.status = STARTED
            text_163.setAutoDraw(True)
        
        # if text_163 is active this frame...
        if text_163.status == STARTED:
            # update params
            pass
        
        # *text_164* updates
        
        # if text_164 is starting this frame...
        if text_164.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
            # keep track of start time/frame for later
            text_164.frameNStart = frameN  # exact frame index
            text_164.tStart = t  # local t and not account for scr refresh
            text_164.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(text_164, 'tStartRefresh')  # time at next scr refresh
            # add timestamp to datafile
            thisExp.timestampOnFlip(win, 'text_164.started')
            # update status
            text_164.status = STARTED
            text_164.setAutoDraw(True)
        
        # if text_164 is active this frame...
        if text_164.status == STARTED:
            # update params
            pass
        
        # *key_resp_43* updates
        waitOnFlip = False
        
        # if key_resp_43 is starting this frame...
        if key_resp_43.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
            # keep track of start time/frame for later
            key_resp_43.frameNStart = frameN  # exact frame index
            key_resp_43.tStart = t  # local t and not account for scr refresh
            key_resp_43.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(key_resp_43, 'tStartRefresh')  # time at next scr refresh
            # add timestamp to datafile
            thisExp.timestampOnFlip(win, 'key_resp_43.started')
            # update status
            key_resp_43.status = STARTED
            # keyboard checking is just starting
            waitOnFlip = True
            win.callOnFlip(key_resp_43.clock.reset)  # t=0 on next screen flip
            win.callOnFlip(key_resp_43.clearEvents, eventType='keyboard')  # clear events on next screen flip
        if key_resp_43.status == STARTED and not waitOnFlip:
            theseKeys = key_resp_43.getKeys(keyList=[1,2,3,4,5,'1','2','3','4','5'], ignoreKeys=["escape"], waitRelease=False)
            _key_resp_43_allKeys.extend(theseKeys)
            if len(_key_resp_43_allKeys):
                key_resp_43.keys = _key_resp_43_allKeys[-1].name  # just the last key pressed
                key_resp_43.rt = _key_resp_43_allKeys[-1].rt
                key_resp_43.duration = _key_resp_43_allKeys[-1].duration
                # a response ends the routine
                continueRoutine = False
        
        # check for quit (typically the Esc key)
        if defaultKeyboard.getKeys(keyList=["escape"]):
            thisExp.status = FINISHED
        if thisExp.status == FINISHED or endExpNow:
            endExperiment(thisExp, win=win)
            return
        # pause experiment here if requested
        if thisExp.status == PAUSED:
            pauseExperiment(
                thisExp=thisExp, 
                win=win, 
                timers=[routineTimer], 
                playbackComponents=[]
            )
            # skip the frame we paused on
            continue
        
        # check if all components have finished
        if not continueRoutine:  # a component has requested a forced-end of Routine
            AM3.forceEnded = routineForceEnded = True
            break
        continueRoutine = False  # will revert to True if at least one component still running
        for thisComponent in AM3.components:
            if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:
                continueRoutine = True
                break  # at least one component has not yet finished
        
        # refresh the screen
        if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen
            win.flip()
    
    # --- Ending Routine "AM3" ---
    for thisComponent in AM3.components:
        if hasattr(thisComponent, "setAutoDraw"):
            thisComponent.setAutoDraw(False)
    # store stop times for AM3
    AM3.tStop = globalClock.getTime(format='float')
    AM3.tStopRefresh = tThisFlipGlobal
    thisExp.addData('AM3.stopped', AM3.tStop)
    # check responses
    if key_resp_43.keys in ['', [], None]:  # No response was made
        key_resp_43.keys = None
    thisExp.addData('key_resp_43.keys',key_resp_43.keys)
    if key_resp_43.keys != None:  # we had a response
        thisExp.addData('key_resp_43.rt', key_resp_43.rt)
        thisExp.addData('key_resp_43.duration', key_resp_43.duration)
    thisExp.nextEntry()
    # the Routine "AM3" was not non-slip safe, so reset the non-slip timer
    routineTimer.reset()
    
    # --- Prepare to start Routine "AM4" ---
    # create an object to store info about Routine AM4
    AM4 = data.Routine(
        name='AM4',
        components=[text_165, text_166, text_167, key_resp_44],
    )
    AM4.status = NOT_STARTED
    continueRoutine = True
    # update component parameters for each repeat
    # create starting attributes for key_resp_44
    key_resp_44.keys = []
    key_resp_44.rt = []
    _key_resp_44_allKeys = []
    # store start times for AM4
    AM4.tStartRefresh = win.getFutureFlipTime(clock=globalClock)
    AM4.tStart = globalClock.getTime(format='float')
    AM4.status = STARTED
    thisExp.addData('AM4.started', AM4.tStart)
    AM4.maxDuration = None
    # keep track of which components have finished
    AM4Components = AM4.components
    for thisComponent in AM4.components:
        thisComponent.tStart = None
        thisComponent.tStop = None
        thisComponent.tStartRefresh = None
        thisComponent.tStopRefresh = None
        if hasattr(thisComponent, 'status'):
            thisComponent.status = NOT_STARTED
    # reset timers
    t = 0
    _timeToFirstFrame = win.getFutureFlipTime(clock="now")
    frameN = -1
    
    # --- Run Routine "AM4" ---
    AM4.forceEnded = routineForceEnded = not continueRoutine
    while continueRoutine:
        # get current time
        t = routineTimer.getTime()
        tThisFlip = win.getFutureFlipTime(clock=routineTimer)
        tThisFlipGlobal = win.getFutureFlipTime(clock=None)
        frameN = frameN + 1  # number of completed frames (so 0 is the first frame)
        # update/draw components on each frame
        
        # *text_165* updates
        
        # if text_165 is starting this frame...
        if text_165.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
            # keep track of start time/frame for later
            text_165.frameNStart = frameN  # exact frame index
            text_165.tStart = t  # local t and not account for scr refresh
            text_165.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(text_165, 'tStartRefresh')  # time at next scr refresh
            # add timestamp to datafile
            thisExp.timestampOnFlip(win, 'text_165.started')
            # update status
            text_165.status = STARTED
            text_165.setAutoDraw(True)
        
        # if text_165 is active this frame...
        if text_165.status == STARTED:
            # update params
            pass
        
        # *text_166* updates
        
        # if text_166 is starting this frame...
        if text_166.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
            # keep track of start time/frame for later
            text_166.frameNStart = frameN  # exact frame index
            text_166.tStart = t  # local t and not account for scr refresh
            text_166.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(text_166, 'tStartRefresh')  # time at next scr refresh
            # add timestamp to datafile
            thisExp.timestampOnFlip(win, 'text_166.started')
            # update status
            text_166.status = STARTED
            text_166.setAutoDraw(True)
        
        # if text_166 is active this frame...
        if text_166.status == STARTED:
            # update params
            pass
        
        # *text_167* updates
        
        # if text_167 is starting this frame...
        if text_167.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
            # keep track of start time/frame for later
            text_167.frameNStart = frameN  # exact frame index
            text_167.tStart = t  # local t and not account for scr refresh
            text_167.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(text_167, 'tStartRefresh')  # time at next scr refresh
            # add timestamp to datafile
            thisExp.timestampOnFlip(win, 'text_167.started')
            # update status
            text_167.status = STARTED
            text_167.setAutoDraw(True)
        
        # if text_167 is active this frame...
        if text_167.status == STARTED:
            # update params
            pass
        
        # *key_resp_44* updates
        waitOnFlip = False
        
        # if key_resp_44 is starting this frame...
        if key_resp_44.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
            # keep track of start time/frame for later
            key_resp_44.frameNStart = frameN  # exact frame index
            key_resp_44.tStart = t  # local t and not account for scr refresh
            key_resp_44.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(key_resp_44, 'tStartRefresh')  # time at next scr refresh
            # add timestamp to datafile
            thisExp.timestampOnFlip(win, 'key_resp_44.started')
            # update status
            key_resp_44.status = STARTED
            # keyboard checking is just starting
            waitOnFlip = True
            win.callOnFlip(key_resp_44.clock.reset)  # t=0 on next screen flip
            win.callOnFlip(key_resp_44.clearEvents, eventType='keyboard')  # clear events on next screen flip
        if key_resp_44.status == STARTED and not waitOnFlip:
            theseKeys = key_resp_44.getKeys(keyList=[1,2,3,4,5,'1','2','3','4','5'], ignoreKeys=["escape"], waitRelease=False)
            _key_resp_44_allKeys.extend(theseKeys)
            if len(_key_resp_44_allKeys):
                key_resp_44.keys = _key_resp_44_allKeys[-1].name  # just the last key pressed
                key_resp_44.rt = _key_resp_44_allKeys[-1].rt
                key_resp_44.duration = _key_resp_44_allKeys[-1].duration
                # a response ends the routine
                continueRoutine = False
        
        # check for quit (typically the Esc key)
        if defaultKeyboard.getKeys(keyList=["escape"]):
            thisExp.status = FINISHED
        if thisExp.status == FINISHED or endExpNow:
            endExperiment(thisExp, win=win)
            return
        # pause experiment here if requested
        if thisExp.status == PAUSED:
            pauseExperiment(
                thisExp=thisExp, 
                win=win, 
                timers=[routineTimer], 
                playbackComponents=[]
            )
            # skip the frame we paused on
            continue
        
        # check if all components have finished
        if not continueRoutine:  # a component has requested a forced-end of Routine
            AM4.forceEnded = routineForceEnded = True
            break
        continueRoutine = False  # will revert to True if at least one component still running
        for thisComponent in AM4.components:
            if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:
                continueRoutine = True
                break  # at least one component has not yet finished
        
        # refresh the screen
        if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen
            win.flip()
    
    # --- Ending Routine "AM4" ---
    for thisComponent in AM4.components:
        if hasattr(thisComponent, "setAutoDraw"):
            thisComponent.setAutoDraw(False)
    # store stop times for AM4
    AM4.tStop = globalClock.getTime(format='float')
    AM4.tStopRefresh = tThisFlipGlobal
    thisExp.addData('AM4.stopped', AM4.tStop)
    # check responses
    if key_resp_44.keys in ['', [], None]:  # No response was made
        key_resp_44.keys = None
    thisExp.addData('key_resp_44.keys',key_resp_44.keys)
    if key_resp_44.keys != None:  # we had a response
        thisExp.addData('key_resp_44.rt', key_resp_44.rt)
        thisExp.addData('key_resp_44.duration', key_resp_44.duration)
    thisExp.nextEntry()
    # the Routine "AM4" was not non-slip safe, so reset the non-slip timer
    routineTimer.reset()
    
    # --- Prepare to start Routine "AM5" ---
    # create an object to store info about Routine AM5
    AM5 = data.Routine(
        name='AM5',
        components=[text_168, text_169, text_170, key_resp_45],
    )
    AM5.status = NOT_STARTED
    continueRoutine = True
    # update component parameters for each repeat
    # create starting attributes for key_resp_45
    key_resp_45.keys = []
    key_resp_45.rt = []
    _key_resp_45_allKeys = []
    # store start times for AM5
    AM5.tStartRefresh = win.getFutureFlipTime(clock=globalClock)
    AM5.tStart = globalClock.getTime(format='float')
    AM5.status = STARTED
    thisExp.addData('AM5.started', AM5.tStart)
    AM5.maxDuration = None
    # keep track of which components have finished
    AM5Components = AM5.components
    for thisComponent in AM5.components:
        thisComponent.tStart = None
        thisComponent.tStop = None
        thisComponent.tStartRefresh = None
        thisComponent.tStopRefresh = None
        if hasattr(thisComponent, 'status'):
            thisComponent.status = NOT_STARTED
    # reset timers
    t = 0
    _timeToFirstFrame = win.getFutureFlipTime(clock="now")
    frameN = -1
    
    # --- Run Routine "AM5" ---
    AM5.forceEnded = routineForceEnded = not continueRoutine
    while continueRoutine:
        # get current time
        t = routineTimer.getTime()
        tThisFlip = win.getFutureFlipTime(clock=routineTimer)
        tThisFlipGlobal = win.getFutureFlipTime(clock=None)
        frameN = frameN + 1  # number of completed frames (so 0 is the first frame)
        # update/draw components on each frame
        
        # *text_168* updates
        
        # if text_168 is starting this frame...
        if text_168.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
            # keep track of start time/frame for later
            text_168.frameNStart = frameN  # exact frame index
            text_168.tStart = t  # local t and not account for scr refresh
            text_168.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(text_168, 'tStartRefresh')  # time at next scr refresh
            # add timestamp to datafile
            thisExp.timestampOnFlip(win, 'text_168.started')
            # update status
            text_168.status = STARTED
            text_168.setAutoDraw(True)
        
        # if text_168 is active this frame...
        if text_168.status == STARTED:
            # update params
            pass
        
        # *text_169* updates
        
        # if text_169 is starting this frame...
        if text_169.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
            # keep track of start time/frame for later
            text_169.frameNStart = frameN  # exact frame index
            text_169.tStart = t  # local t and not account for scr refresh
            text_169.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(text_169, 'tStartRefresh')  # time at next scr refresh
            # add timestamp to datafile
            thisExp.timestampOnFlip(win, 'text_169.started')
            # update status
            text_169.status = STARTED
            text_169.setAutoDraw(True)
        
        # if text_169 is active this frame...
        if text_169.status == STARTED:
            # update params
            pass
        
        # *text_170* updates
        
        # if text_170 is starting this frame...
        if text_170.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
            # keep track of start time/frame for later
            text_170.frameNStart = frameN  # exact frame index
            text_170.tStart = t  # local t and not account for scr refresh
            text_170.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(text_170, 'tStartRefresh')  # time at next scr refresh
            # add timestamp to datafile
            thisExp.timestampOnFlip(win, 'text_170.started')
            # update status
            text_170.status = STARTED
            text_170.setAutoDraw(True)
        
        # if text_170 is active this frame...
        if text_170.status == STARTED:
            # update params
            pass
        
        # *key_resp_45* updates
        waitOnFlip = False
        
        # if key_resp_45 is starting this frame...
        if key_resp_45.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
            # keep track of start time/frame for later
            key_resp_45.frameNStart = frameN  # exact frame index
            key_resp_45.tStart = t  # local t and not account for scr refresh
            key_resp_45.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(key_resp_45, 'tStartRefresh')  # time at next scr refresh
            # add timestamp to datafile
            thisExp.timestampOnFlip(win, 'key_resp_45.started')
            # update status
            key_resp_45.status = STARTED
            # keyboard checking is just starting
            waitOnFlip = True
            win.callOnFlip(key_resp_45.clock.reset)  # t=0 on next screen flip
            win.callOnFlip(key_resp_45.clearEvents, eventType='keyboard')  # clear events on next screen flip
        if key_resp_45.status == STARTED and not waitOnFlip:
            theseKeys = key_resp_45.getKeys(keyList=[1,2,3,4,5,'1','2','3','4','5'], ignoreKeys=["escape"], waitRelease=False)
            _key_resp_45_allKeys.extend(theseKeys)
            if len(_key_resp_45_allKeys):
                key_resp_45.keys = _key_resp_45_allKeys[-1].name  # just the last key pressed
                key_resp_45.rt = _key_resp_45_allKeys[-1].rt
                key_resp_45.duration = _key_resp_45_allKeys[-1].duration
                # a response ends the routine
                continueRoutine = False
        
        # check for quit (typically the Esc key)
        if defaultKeyboard.getKeys(keyList=["escape"]):
            thisExp.status = FINISHED
        if thisExp.status == FINISHED or endExpNow:
            endExperiment(thisExp, win=win)
            return
        # pause experiment here if requested
        if thisExp.status == PAUSED:
            pauseExperiment(
                thisExp=thisExp, 
                win=win, 
                timers=[routineTimer], 
                playbackComponents=[]
            )
            # skip the frame we paused on
            continue
        
        # check if all components have finished
        if not continueRoutine:  # a component has requested a forced-end of Routine
            AM5.forceEnded = routineForceEnded = True
            break
        continueRoutine = False  # will revert to True if at least one component still running
        for thisComponent in AM5.components:
            if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:
                continueRoutine = True
                break  # at least one component has not yet finished
        
        # refresh the screen
        if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen
            win.flip()
    
    # --- Ending Routine "AM5" ---
    for thisComponent in AM5.components:
        if hasattr(thisComponent, "setAutoDraw"):
            thisComponent.setAutoDraw(False)
    # store stop times for AM5
    AM5.tStop = globalClock.getTime(format='float')
    AM5.tStopRefresh = tThisFlipGlobal
    thisExp.addData('AM5.stopped', AM5.tStop)
    # check responses
    if key_resp_45.keys in ['', [], None]:  # No response was made
        key_resp_45.keys = None
    thisExp.addData('key_resp_45.keys',key_resp_45.keys)
    if key_resp_45.keys != None:  # we had a response
        thisExp.addData('key_resp_45.rt', key_resp_45.rt)
        thisExp.addData('key_resp_45.duration', key_resp_45.duration)
    thisExp.nextEntry()
    # the Routine "AM5" was not non-slip safe, so reset the non-slip timer
    routineTimer.reset()
    
    # --- Prepare to start Routine "q3_instructions" ---
    # create an object to store info about Routine q3_instructions
    q3_instructions = data.Routine(
        name='q3_instructions',
        components=[text_171],
    )
    q3_instructions.status = NOT_STARTED
    continueRoutine = True
    # update component parameters for each repeat
    # store start times for q3_instructions
    q3_instructions.tStartRefresh = win.getFutureFlipTime(clock=globalClock)
    q3_instructions.tStart = globalClock.getTime(format='float')
    q3_instructions.status = STARTED
    thisExp.addData('q3_instructions.started', q3_instructions.tStart)
    q3_instructions.maxDuration = None
    # keep track of which components have finished
    q3_instructionsComponents = q3_instructions.components
    for thisComponent in q3_instructions.components:
        thisComponent.tStart = None
        thisComponent.tStop = None
        thisComponent.tStartRefresh = None
        thisComponent.tStopRefresh = None
        if hasattr(thisComponent, 'status'):
            thisComponent.status = NOT_STARTED
    # reset timers
    t = 0
    _timeToFirstFrame = win.getFutureFlipTime(clock="now")
    frameN = -1
    
    # --- Run Routine "q3_instructions" ---
    q3_instructions.forceEnded = routineForceEnded = not continueRoutine
    while continueRoutine and routineTimer.getTime() < 5.0:
        # get current time
        t = routineTimer.getTime()
        tThisFlip = win.getFutureFlipTime(clock=routineTimer)
        tThisFlipGlobal = win.getFutureFlipTime(clock=None)
        frameN = frameN + 1  # number of completed frames (so 0 is the first frame)
        # update/draw components on each frame
        
        # *text_171* updates
        
        # if text_171 is starting this frame...
        if text_171.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
            # keep track of start time/frame for later
            text_171.frameNStart = frameN  # exact frame index
            text_171.tStart = t  # local t and not account for scr refresh
            text_171.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(text_171, 'tStartRefresh')  # time at next scr refresh
            # add timestamp to datafile
            thisExp.timestampOnFlip(win, 'text_171.started')
            # update status
            text_171.status = STARTED
            text_171.setAutoDraw(True)
        
        # if text_171 is active this frame...
        if text_171.status == STARTED:
            # update params
            pass
        
        # if text_171 is stopping this frame...
        if text_171.status == STARTED:
            # is it time to stop? (based on global clock, using actual start)
            if tThisFlipGlobal > text_171.tStartRefresh + 5.0-frameTolerance:
                # keep track of stop time/frame for later
                text_171.tStop = t  # not accounting for scr refresh
                text_171.tStopRefresh = tThisFlipGlobal  # on global time
                text_171.frameNStop = frameN  # exact frame index
                # add timestamp to datafile
                thisExp.timestampOnFlip(win, 'text_171.stopped')
                # update status
                text_171.status = FINISHED
                text_171.setAutoDraw(False)
        
        # check for quit (typically the Esc key)
        if defaultKeyboard.getKeys(keyList=["escape"]):
            thisExp.status = FINISHED
        if thisExp.status == FINISHED or endExpNow:
            endExperiment(thisExp, win=win)
            return
        # pause experiment here if requested
        if thisExp.status == PAUSED:
            pauseExperiment(
                thisExp=thisExp, 
                win=win, 
                timers=[routineTimer], 
                playbackComponents=[]
            )
            # skip the frame we paused on
            continue
        
        # check if all components have finished
        if not continueRoutine:  # a component has requested a forced-end of Routine
            q3_instructions.forceEnded = routineForceEnded = True
            break
        continueRoutine = False  # will revert to True if at least one component still running
        for thisComponent in q3_instructions.components:
            if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:
                continueRoutine = True
                break  # at least one component has not yet finished
        
        # refresh the screen
        if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen
            win.flip()
    
    # --- Ending Routine "q3_instructions" ---
    for thisComponent in q3_instructions.components:
        if hasattr(thisComponent, "setAutoDraw"):
            thisComponent.setAutoDraw(False)
    # store stop times for q3_instructions
    q3_instructions.tStop = globalClock.getTime(format='float')
    q3_instructions.tStopRefresh = tThisFlipGlobal
    thisExp.addData('q3_instructions.stopped', q3_instructions.tStop)
    # using non-slip timing so subtract the expected duration of this Routine (unless ended on request)
    if q3_instructions.maxDurationReached:
        routineTimer.addTime(-q3_instructions.maxDuration)
    elif q3_instructions.forceEnded:
        routineTimer.reset()
    else:
        routineTimer.addTime(-5.000000)
    thisExp.nextEntry()
    
    # --- Prepare to start Routine "SPQ1" ---
    # create an object to store info about Routine SPQ1
    SPQ1 = data.Routine(
        name='SPQ1',
        components=[text_173, text_174, key_resp_46],
    )
    SPQ1.status = NOT_STARTED
    continueRoutine = True
    # update component parameters for each repeat
    # create starting attributes for key_resp_46
    key_resp_46.keys = []
    key_resp_46.rt = []
    _key_resp_46_allKeys = []
    # store start times for SPQ1
    SPQ1.tStartRefresh = win.getFutureFlipTime(clock=globalClock)
    SPQ1.tStart = globalClock.getTime(format='float')
    SPQ1.status = STARTED
    thisExp.addData('SPQ1.started', SPQ1.tStart)
    SPQ1.maxDuration = None
    # keep track of which components have finished
    SPQ1Components = SPQ1.components
    for thisComponent in SPQ1.components:
        thisComponent.tStart = None
        thisComponent.tStop = None
        thisComponent.tStartRefresh = None
        thisComponent.tStopRefresh = None
        if hasattr(thisComponent, 'status'):
            thisComponent.status = NOT_STARTED
    # reset timers
    t = 0
    _timeToFirstFrame = win.getFutureFlipTime(clock="now")
    frameN = -1
    
    # --- Run Routine "SPQ1" ---
    SPQ1.forceEnded = routineForceEnded = not continueRoutine
    while continueRoutine:
        # get current time
        t = routineTimer.getTime()
        tThisFlip = win.getFutureFlipTime(clock=routineTimer)
        tThisFlipGlobal = win.getFutureFlipTime(clock=None)
        frameN = frameN + 1  # number of completed frames (so 0 is the first frame)
        # update/draw components on each frame
        
        # *text_173* updates
        
        # if text_173 is starting this frame...
        if text_173.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
            # keep track of start time/frame for later
            text_173.frameNStart = frameN  # exact frame index
            text_173.tStart = t  # local t and not account for scr refresh
            text_173.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(text_173, 'tStartRefresh')  # time at next scr refresh
            # add timestamp to datafile
            thisExp.timestampOnFlip(win, 'text_173.started')
            # update status
            text_173.status = STARTED
            text_173.setAutoDraw(True)
        
        # if text_173 is active this frame...
        if text_173.status == STARTED:
            # update params
            pass
        
        # *text_174* updates
        
        # if text_174 is starting this frame...
        if text_174.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
            # keep track of start time/frame for later
            text_174.frameNStart = frameN  # exact frame index
            text_174.tStart = t  # local t and not account for scr refresh
            text_174.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(text_174, 'tStartRefresh')  # time at next scr refresh
            # add timestamp to datafile
            thisExp.timestampOnFlip(win, 'text_174.started')
            # update status
            text_174.status = STARTED
            text_174.setAutoDraw(True)
        
        # if text_174 is active this frame...
        if text_174.status == STARTED:
            # update params
            pass
        
        # *key_resp_46* updates
        waitOnFlip = False
        
        # if key_resp_46 is starting this frame...
        if key_resp_46.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
            # keep track of start time/frame for later
            key_resp_46.frameNStart = frameN  # exact frame index
            key_resp_46.tStart = t  # local t and not account for scr refresh
            key_resp_46.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(key_resp_46, 'tStartRefresh')  # time at next scr refresh
            # add timestamp to datafile
            thisExp.timestampOnFlip(win, 'key_resp_46.started')
            # update status
            key_resp_46.status = STARTED
            # keyboard checking is just starting
            waitOnFlip = True
            win.callOnFlip(key_resp_46.clock.reset)  # t=0 on next screen flip
            win.callOnFlip(key_resp_46.clearEvents, eventType='keyboard')  # clear events on next screen flip
        if key_resp_46.status == STARTED and not waitOnFlip:
            theseKeys = key_resp_46.getKeys(keyList=['y','n'], ignoreKeys=["escape"], waitRelease=False)
            _key_resp_46_allKeys.extend(theseKeys)
            if len(_key_resp_46_allKeys):
                key_resp_46.keys = _key_resp_46_allKeys[-1].name  # just the last key pressed
                key_resp_46.rt = _key_resp_46_allKeys[-1].rt
                key_resp_46.duration = _key_resp_46_allKeys[-1].duration
                # a response ends the routine
                continueRoutine = False
        
        # check for quit (typically the Esc key)
        if defaultKeyboard.getKeys(keyList=["escape"]):
            thisExp.status = FINISHED
        if thisExp.status == FINISHED or endExpNow:
            endExperiment(thisExp, win=win)
            return
        # pause experiment here if requested
        if thisExp.status == PAUSED:
            pauseExperiment(
                thisExp=thisExp, 
                win=win, 
                timers=[routineTimer], 
                playbackComponents=[]
            )
            # skip the frame we paused on
            continue
        
        # check if all components have finished
        if not continueRoutine:  # a component has requested a forced-end of Routine
            SPQ1.forceEnded = routineForceEnded = True
            break
        continueRoutine = False  # will revert to True if at least one component still running
        for thisComponent in SPQ1.components:
            if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:
                continueRoutine = True
                break  # at least one component has not yet finished
        
        # refresh the screen
        if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen
            win.flip()
    
    # --- Ending Routine "SPQ1" ---
    for thisComponent in SPQ1.components:
        if hasattr(thisComponent, "setAutoDraw"):
            thisComponent.setAutoDraw(False)
    # store stop times for SPQ1
    SPQ1.tStop = globalClock.getTime(format='float')
    SPQ1.tStopRefresh = tThisFlipGlobal
    thisExp.addData('SPQ1.stopped', SPQ1.tStop)
    # check responses
    if key_resp_46.keys in ['', [], None]:  # No response was made
        key_resp_46.keys = None
    thisExp.addData('key_resp_46.keys',key_resp_46.keys)
    if key_resp_46.keys != None:  # we had a response
        thisExp.addData('key_resp_46.rt', key_resp_46.rt)
        thisExp.addData('key_resp_46.duration', key_resp_46.duration)
    thisExp.nextEntry()
    # the Routine "SPQ1" was not non-slip safe, so reset the non-slip timer
    routineTimer.reset()
    
    # --- Prepare to start Routine "SPQ2" ---
    # create an object to store info about Routine SPQ2
    SPQ2 = data.Routine(
        name='SPQ2',
        components=[text_175, text_176, key_resp_47],
    )
    SPQ2.status = NOT_STARTED
    continueRoutine = True
    # update component parameters for each repeat
    # create starting attributes for key_resp_47
    key_resp_47.keys = []
    key_resp_47.rt = []
    _key_resp_47_allKeys = []
    # store start times for SPQ2
    SPQ2.tStartRefresh = win.getFutureFlipTime(clock=globalClock)
    SPQ2.tStart = globalClock.getTime(format='float')
    SPQ2.status = STARTED
    thisExp.addData('SPQ2.started', SPQ2.tStart)
    SPQ2.maxDuration = None
    # keep track of which components have finished
    SPQ2Components = SPQ2.components
    for thisComponent in SPQ2.components:
        thisComponent.tStart = None
        thisComponent.tStop = None
        thisComponent.tStartRefresh = None
        thisComponent.tStopRefresh = None
        if hasattr(thisComponent, 'status'):
            thisComponent.status = NOT_STARTED
    # reset timers
    t = 0
    _timeToFirstFrame = win.getFutureFlipTime(clock="now")
    frameN = -1
    
    # --- Run Routine "SPQ2" ---
    SPQ2.forceEnded = routineForceEnded = not continueRoutine
    while continueRoutine:
        # get current time
        t = routineTimer.getTime()
        tThisFlip = win.getFutureFlipTime(clock=routineTimer)
        tThisFlipGlobal = win.getFutureFlipTime(clock=None)
        frameN = frameN + 1  # number of completed frames (so 0 is the first frame)
        # update/draw components on each frame
        
        # *text_175* updates
        
        # if text_175 is starting this frame...
        if text_175.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
            # keep track of start time/frame for later
            text_175.frameNStart = frameN  # exact frame index
            text_175.tStart = t  # local t and not account for scr refresh
            text_175.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(text_175, 'tStartRefresh')  # time at next scr refresh
            # add timestamp to datafile
            thisExp.timestampOnFlip(win, 'text_175.started')
            # update status
            text_175.status = STARTED
            text_175.setAutoDraw(True)
        
        # if text_175 is active this frame...
        if text_175.status == STARTED:
            # update params
            pass
        
        # *text_176* updates
        
        # if text_176 is starting this frame...
        if text_176.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
            # keep track of start time/frame for later
            text_176.frameNStart = frameN  # exact frame index
            text_176.tStart = t  # local t and not account for scr refresh
            text_176.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(text_176, 'tStartRefresh')  # time at next scr refresh
            # add timestamp to datafile
            thisExp.timestampOnFlip(win, 'text_176.started')
            # update status
            text_176.status = STARTED
            text_176.setAutoDraw(True)
        
        # if text_176 is active this frame...
        if text_176.status == STARTED:
            # update params
            pass
        
        # *key_resp_47* updates
        waitOnFlip = False
        
        # if key_resp_47 is starting this frame...
        if key_resp_47.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
            # keep track of start time/frame for later
            key_resp_47.frameNStart = frameN  # exact frame index
            key_resp_47.tStart = t  # local t and not account for scr refresh
            key_resp_47.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(key_resp_47, 'tStartRefresh')  # time at next scr refresh
            # add timestamp to datafile
            thisExp.timestampOnFlip(win, 'key_resp_47.started')
            # update status
            key_resp_47.status = STARTED
            # keyboard checking is just starting
            waitOnFlip = True
            win.callOnFlip(key_resp_47.clock.reset)  # t=0 on next screen flip
            win.callOnFlip(key_resp_47.clearEvents, eventType='keyboard')  # clear events on next screen flip
        if key_resp_47.status == STARTED and not waitOnFlip:
            theseKeys = key_resp_47.getKeys(keyList=['y','n'], ignoreKeys=["escape"], waitRelease=False)
            _key_resp_47_allKeys.extend(theseKeys)
            if len(_key_resp_47_allKeys):
                key_resp_47.keys = _key_resp_47_allKeys[-1].name  # just the last key pressed
                key_resp_47.rt = _key_resp_47_allKeys[-1].rt
                key_resp_47.duration = _key_resp_47_allKeys[-1].duration
                # a response ends the routine
                continueRoutine = False
        
        # check for quit (typically the Esc key)
        if defaultKeyboard.getKeys(keyList=["escape"]):
            thisExp.status = FINISHED
        if thisExp.status == FINISHED or endExpNow:
            endExperiment(thisExp, win=win)
            return
        # pause experiment here if requested
        if thisExp.status == PAUSED:
            pauseExperiment(
                thisExp=thisExp, 
                win=win, 
                timers=[routineTimer], 
                playbackComponents=[]
            )
            # skip the frame we paused on
            continue
        
        # check if all components have finished
        if not continueRoutine:  # a component has requested a forced-end of Routine
            SPQ2.forceEnded = routineForceEnded = True
            break
        continueRoutine = False  # will revert to True if at least one component still running
        for thisComponent in SPQ2.components:
            if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:
                continueRoutine = True
                break  # at least one component has not yet finished
        
        # refresh the screen
        if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen
            win.flip()
    
    # --- Ending Routine "SPQ2" ---
    for thisComponent in SPQ2.components:
        if hasattr(thisComponent, "setAutoDraw"):
            thisComponent.setAutoDraw(False)
    # store stop times for SPQ2
    SPQ2.tStop = globalClock.getTime(format='float')
    SPQ2.tStopRefresh = tThisFlipGlobal
    thisExp.addData('SPQ2.stopped', SPQ2.tStop)
    # check responses
    if key_resp_47.keys in ['', [], None]:  # No response was made
        key_resp_47.keys = None
    thisExp.addData('key_resp_47.keys',key_resp_47.keys)
    if key_resp_47.keys != None:  # we had a response
        thisExp.addData('key_resp_47.rt', key_resp_47.rt)
        thisExp.addData('key_resp_47.duration', key_resp_47.duration)
    thisExp.nextEntry()
    # the Routine "SPQ2" was not non-slip safe, so reset the non-slip timer
    routineTimer.reset()
    
    # --- Prepare to start Routine "SPQ3" ---
    # create an object to store info about Routine SPQ3
    SPQ3 = data.Routine(
        name='SPQ3',
        components=[text_177, text_178, key_resp_48],
    )
    SPQ3.status = NOT_STARTED
    continueRoutine = True
    # update component parameters for each repeat
    # create starting attributes for key_resp_48
    key_resp_48.keys = []
    key_resp_48.rt = []
    _key_resp_48_allKeys = []
    # store start times for SPQ3
    SPQ3.tStartRefresh = win.getFutureFlipTime(clock=globalClock)
    SPQ3.tStart = globalClock.getTime(format='float')
    SPQ3.status = STARTED
    thisExp.addData('SPQ3.started', SPQ3.tStart)
    SPQ3.maxDuration = None
    # keep track of which components have finished
    SPQ3Components = SPQ3.components
    for thisComponent in SPQ3.components:
        thisComponent.tStart = None
        thisComponent.tStop = None
        thisComponent.tStartRefresh = None
        thisComponent.tStopRefresh = None
        if hasattr(thisComponent, 'status'):
            thisComponent.status = NOT_STARTED
    # reset timers
    t = 0
    _timeToFirstFrame = win.getFutureFlipTime(clock="now")
    frameN = -1
    
    # --- Run Routine "SPQ3" ---
    SPQ3.forceEnded = routineForceEnded = not continueRoutine
    while continueRoutine:
        # get current time
        t = routineTimer.getTime()
        tThisFlip = win.getFutureFlipTime(clock=routineTimer)
        tThisFlipGlobal = win.getFutureFlipTime(clock=None)
        frameN = frameN + 1  # number of completed frames (so 0 is the first frame)
        # update/draw components on each frame
        
        # *text_177* updates
        
        # if text_177 is starting this frame...
        if text_177.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
            # keep track of start time/frame for later
            text_177.frameNStart = frameN  # exact frame index
            text_177.tStart = t  # local t and not account for scr refresh
            text_177.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(text_177, 'tStartRefresh')  # time at next scr refresh
            # add timestamp to datafile
            thisExp.timestampOnFlip(win, 'text_177.started')
            # update status
            text_177.status = STARTED
            text_177.setAutoDraw(True)
        
        # if text_177 is active this frame...
        if text_177.status == STARTED:
            # update params
            pass
        
        # *text_178* updates
        
        # if text_178 is starting this frame...
        if text_178.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
            # keep track of start time/frame for later
            text_178.frameNStart = frameN  # exact frame index
            text_178.tStart = t  # local t and not account for scr refresh
            text_178.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(text_178, 'tStartRefresh')  # time at next scr refresh
            # add timestamp to datafile
            thisExp.timestampOnFlip(win, 'text_178.started')
            # update status
            text_178.status = STARTED
            text_178.setAutoDraw(True)
        
        # if text_178 is active this frame...
        if text_178.status == STARTED:
            # update params
            pass
        
        # *key_resp_48* updates
        waitOnFlip = False
        
        # if key_resp_48 is starting this frame...
        if key_resp_48.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
            # keep track of start time/frame for later
            key_resp_48.frameNStart = frameN  # exact frame index
            key_resp_48.tStart = t  # local t and not account for scr refresh
            key_resp_48.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(key_resp_48, 'tStartRefresh')  # time at next scr refresh
            # add timestamp to datafile
            thisExp.timestampOnFlip(win, 'key_resp_48.started')
            # update status
            key_resp_48.status = STARTED
            # keyboard checking is just starting
            waitOnFlip = True
            win.callOnFlip(key_resp_48.clock.reset)  # t=0 on next screen flip
            win.callOnFlip(key_resp_48.clearEvents, eventType='keyboard')  # clear events on next screen flip
        if key_resp_48.status == STARTED and not waitOnFlip:
            theseKeys = key_resp_48.getKeys(keyList=['y','n'], ignoreKeys=["escape"], waitRelease=False)
            _key_resp_48_allKeys.extend(theseKeys)
            if len(_key_resp_48_allKeys):
                key_resp_48.keys = _key_resp_48_allKeys[-1].name  # just the last key pressed
                key_resp_48.rt = _key_resp_48_allKeys[-1].rt
                key_resp_48.duration = _key_resp_48_allKeys[-1].duration
                # a response ends the routine
                continueRoutine = False
        
        # check for quit (typically the Esc key)
        if defaultKeyboard.getKeys(keyList=["escape"]):
            thisExp.status = FINISHED
        if thisExp.status == FINISHED or endExpNow:
            endExperiment(thisExp, win=win)
            return
        # pause experiment here if requested
        if thisExp.status == PAUSED:
            pauseExperiment(
                thisExp=thisExp, 
                win=win, 
                timers=[routineTimer], 
                playbackComponents=[]
            )
            # skip the frame we paused on
            continue
        
        # check if all components have finished
        if not continueRoutine:  # a component has requested a forced-end of Routine
            SPQ3.forceEnded = routineForceEnded = True
            break
        continueRoutine = False  # will revert to True if at least one component still running
        for thisComponent in SPQ3.components:
            if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:
                continueRoutine = True
                break  # at least one component has not yet finished
        
        # refresh the screen
        if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen
            win.flip()
    
    # --- Ending Routine "SPQ3" ---
    for thisComponent in SPQ3.components:
        if hasattr(thisComponent, "setAutoDraw"):
            thisComponent.setAutoDraw(False)
    # store stop times for SPQ3
    SPQ3.tStop = globalClock.getTime(format='float')
    SPQ3.tStopRefresh = tThisFlipGlobal
    thisExp.addData('SPQ3.stopped', SPQ3.tStop)
    # check responses
    if key_resp_48.keys in ['', [], None]:  # No response was made
        key_resp_48.keys = None
    thisExp.addData('key_resp_48.keys',key_resp_48.keys)
    if key_resp_48.keys != None:  # we had a response
        thisExp.addData('key_resp_48.rt', key_resp_48.rt)
        thisExp.addData('key_resp_48.duration', key_resp_48.duration)
    thisExp.nextEntry()
    # the Routine "SPQ3" was not non-slip safe, so reset the non-slip timer
    routineTimer.reset()
    
    # --- Prepare to start Routine "SPQ4" ---
    # create an object to store info about Routine SPQ4
    SPQ4 = data.Routine(
        name='SPQ4',
        components=[text_179, text_180, key_resp_49],
    )
    SPQ4.status = NOT_STARTED
    continueRoutine = True
    # update component parameters for each repeat
    # create starting attributes for key_resp_49
    key_resp_49.keys = []
    key_resp_49.rt = []
    _key_resp_49_allKeys = []
    # store start times for SPQ4
    SPQ4.tStartRefresh = win.getFutureFlipTime(clock=globalClock)
    SPQ4.tStart = globalClock.getTime(format='float')
    SPQ4.status = STARTED
    thisExp.addData('SPQ4.started', SPQ4.tStart)
    SPQ4.maxDuration = None
    # keep track of which components have finished
    SPQ4Components = SPQ4.components
    for thisComponent in SPQ4.components:
        thisComponent.tStart = None
        thisComponent.tStop = None
        thisComponent.tStartRefresh = None
        thisComponent.tStopRefresh = None
        if hasattr(thisComponent, 'status'):
            thisComponent.status = NOT_STARTED
    # reset timers
    t = 0
    _timeToFirstFrame = win.getFutureFlipTime(clock="now")
    frameN = -1
    
    # --- Run Routine "SPQ4" ---
    SPQ4.forceEnded = routineForceEnded = not continueRoutine
    while continueRoutine:
        # get current time
        t = routineTimer.getTime()
        tThisFlip = win.getFutureFlipTime(clock=routineTimer)
        tThisFlipGlobal = win.getFutureFlipTime(clock=None)
        frameN = frameN + 1  # number of completed frames (so 0 is the first frame)
        # update/draw components on each frame
        
        # *text_179* updates
        
        # if text_179 is starting this frame...
        if text_179.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
            # keep track of start time/frame for later
            text_179.frameNStart = frameN  # exact frame index
            text_179.tStart = t  # local t and not account for scr refresh
            text_179.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(text_179, 'tStartRefresh')  # time at next scr refresh
            # add timestamp to datafile
            thisExp.timestampOnFlip(win, 'text_179.started')
            # update status
            text_179.status = STARTED
            text_179.setAutoDraw(True)
        
        # if text_179 is active this frame...
        if text_179.status == STARTED:
            # update params
            pass
        
        # *text_180* updates
        
        # if text_180 is starting this frame...
        if text_180.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
            # keep track of start time/frame for later
            text_180.frameNStart = frameN  # exact frame index
            text_180.tStart = t  # local t and not account for scr refresh
            text_180.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(text_180, 'tStartRefresh')  # time at next scr refresh
            # add timestamp to datafile
            thisExp.timestampOnFlip(win, 'text_180.started')
            # update status
            text_180.status = STARTED
            text_180.setAutoDraw(True)
        
        # if text_180 is active this frame...
        if text_180.status == STARTED:
            # update params
            pass
        
        # *key_resp_49* updates
        waitOnFlip = False
        
        # if key_resp_49 is starting this frame...
        if key_resp_49.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
            # keep track of start time/frame for later
            key_resp_49.frameNStart = frameN  # exact frame index
            key_resp_49.tStart = t  # local t and not account for scr refresh
            key_resp_49.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(key_resp_49, 'tStartRefresh')  # time at next scr refresh
            # add timestamp to datafile
            thisExp.timestampOnFlip(win, 'key_resp_49.started')
            # update status
            key_resp_49.status = STARTED
            # keyboard checking is just starting
            waitOnFlip = True
            win.callOnFlip(key_resp_49.clock.reset)  # t=0 on next screen flip
            win.callOnFlip(key_resp_49.clearEvents, eventType='keyboard')  # clear events on next screen flip
        if key_resp_49.status == STARTED and not waitOnFlip:
            theseKeys = key_resp_49.getKeys(keyList=['y','n'], ignoreKeys=["escape"], waitRelease=False)
            _key_resp_49_allKeys.extend(theseKeys)
            if len(_key_resp_49_allKeys):
                key_resp_49.keys = _key_resp_49_allKeys[-1].name  # just the last key pressed
                key_resp_49.rt = _key_resp_49_allKeys[-1].rt
                key_resp_49.duration = _key_resp_49_allKeys[-1].duration
                # a response ends the routine
                continueRoutine = False
        
        # check for quit (typically the Esc key)
        if defaultKeyboard.getKeys(keyList=["escape"]):
            thisExp.status = FINISHED
        if thisExp.status == FINISHED or endExpNow:
            endExperiment(thisExp, win=win)
            return
        # pause experiment here if requested
        if thisExp.status == PAUSED:
            pauseExperiment(
                thisExp=thisExp, 
                win=win, 
                timers=[routineTimer], 
                playbackComponents=[]
            )
            # skip the frame we paused on
            continue
        
        # check if all components have finished
        if not continueRoutine:  # a component has requested a forced-end of Routine
            SPQ4.forceEnded = routineForceEnded = True
            break
        continueRoutine = False  # will revert to True if at least one component still running
        for thisComponent in SPQ4.components:
            if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:
                continueRoutine = True
                break  # at least one component has not yet finished
        
        # refresh the screen
        if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen
            win.flip()
    
    # --- Ending Routine "SPQ4" ---
    for thisComponent in SPQ4.components:
        if hasattr(thisComponent, "setAutoDraw"):
            thisComponent.setAutoDraw(False)
    # store stop times for SPQ4
    SPQ4.tStop = globalClock.getTime(format='float')
    SPQ4.tStopRefresh = tThisFlipGlobal
    thisExp.addData('SPQ4.stopped', SPQ4.tStop)
    # check responses
    if key_resp_49.keys in ['', [], None]:  # No response was made
        key_resp_49.keys = None
    thisExp.addData('key_resp_49.keys',key_resp_49.keys)
    if key_resp_49.keys != None:  # we had a response
        thisExp.addData('key_resp_49.rt', key_resp_49.rt)
        thisExp.addData('key_resp_49.duration', key_resp_49.duration)
    thisExp.nextEntry()
    # the Routine "SPQ4" was not non-slip safe, so reset the non-slip timer
    routineTimer.reset()
    
    # --- Prepare to start Routine "SPQ5" ---
    # create an object to store info about Routine SPQ5
    SPQ5 = data.Routine(
        name='SPQ5',
        components=[text_181, text_182, key_resp_50],
    )
    SPQ5.status = NOT_STARTED
    continueRoutine = True
    # update component parameters for each repeat
    # create starting attributes for key_resp_50
    key_resp_50.keys = []
    key_resp_50.rt = []
    _key_resp_50_allKeys = []
    # store start times for SPQ5
    SPQ5.tStartRefresh = win.getFutureFlipTime(clock=globalClock)
    SPQ5.tStart = globalClock.getTime(format='float')
    SPQ5.status = STARTED
    thisExp.addData('SPQ5.started', SPQ5.tStart)
    SPQ5.maxDuration = None
    # keep track of which components have finished
    SPQ5Components = SPQ5.components
    for thisComponent in SPQ5.components:
        thisComponent.tStart = None
        thisComponent.tStop = None
        thisComponent.tStartRefresh = None
        thisComponent.tStopRefresh = None
        if hasattr(thisComponent, 'status'):
            thisComponent.status = NOT_STARTED
    # reset timers
    t = 0
    _timeToFirstFrame = win.getFutureFlipTime(clock="now")
    frameN = -1
    
    # --- Run Routine "SPQ5" ---
    SPQ5.forceEnded = routineForceEnded = not continueRoutine
    while continueRoutine:
        # get current time
        t = routineTimer.getTime()
        tThisFlip = win.getFutureFlipTime(clock=routineTimer)
        tThisFlipGlobal = win.getFutureFlipTime(clock=None)
        frameN = frameN + 1  # number of completed frames (so 0 is the first frame)
        # update/draw components on each frame
        
        # *text_181* updates
        
        # if text_181 is starting this frame...
        if text_181.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
            # keep track of start time/frame for later
            text_181.frameNStart = frameN  # exact frame index
            text_181.tStart = t  # local t and not account for scr refresh
            text_181.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(text_181, 'tStartRefresh')  # time at next scr refresh
            # add timestamp to datafile
            thisExp.timestampOnFlip(win, 'text_181.started')
            # update status
            text_181.status = STARTED
            text_181.setAutoDraw(True)
        
        # if text_181 is active this frame...
        if text_181.status == STARTED:
            # update params
            pass
        
        # *text_182* updates
        
        # if text_182 is starting this frame...
        if text_182.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
            # keep track of start time/frame for later
            text_182.frameNStart = frameN  # exact frame index
            text_182.tStart = t  # local t and not account for scr refresh
            text_182.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(text_182, 'tStartRefresh')  # time at next scr refresh
            # add timestamp to datafile
            thisExp.timestampOnFlip(win, 'text_182.started')
            # update status
            text_182.status = STARTED
            text_182.setAutoDraw(True)
        
        # if text_182 is active this frame...
        if text_182.status == STARTED:
            # update params
            pass
        
        # *key_resp_50* updates
        waitOnFlip = False
        
        # if key_resp_50 is starting this frame...
        if key_resp_50.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
            # keep track of start time/frame for later
            key_resp_50.frameNStart = frameN  # exact frame index
            key_resp_50.tStart = t  # local t and not account for scr refresh
            key_resp_50.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(key_resp_50, 'tStartRefresh')  # time at next scr refresh
            # add timestamp to datafile
            thisExp.timestampOnFlip(win, 'key_resp_50.started')
            # update status
            key_resp_50.status = STARTED
            # keyboard checking is just starting
            waitOnFlip = True
            win.callOnFlip(key_resp_50.clock.reset)  # t=0 on next screen flip
            win.callOnFlip(key_resp_50.clearEvents, eventType='keyboard')  # clear events on next screen flip
        if key_resp_50.status == STARTED and not waitOnFlip:
            theseKeys = key_resp_50.getKeys(keyList=['y','n'], ignoreKeys=["escape"], waitRelease=False)
            _key_resp_50_allKeys.extend(theseKeys)
            if len(_key_resp_50_allKeys):
                key_resp_50.keys = _key_resp_50_allKeys[-1].name  # just the last key pressed
                key_resp_50.rt = _key_resp_50_allKeys[-1].rt
                key_resp_50.duration = _key_resp_50_allKeys[-1].duration
                # a response ends the routine
                continueRoutine = False
        
        # check for quit (typically the Esc key)
        if defaultKeyboard.getKeys(keyList=["escape"]):
            thisExp.status = FINISHED
        if thisExp.status == FINISHED or endExpNow:
            endExperiment(thisExp, win=win)
            return
        # pause experiment here if requested
        if thisExp.status == PAUSED:
            pauseExperiment(
                thisExp=thisExp, 
                win=win, 
                timers=[routineTimer], 
                playbackComponents=[]
            )
            # skip the frame we paused on
            continue
        
        # check if all components have finished
        if not continueRoutine:  # a component has requested a forced-end of Routine
            SPQ5.forceEnded = routineForceEnded = True
            break
        continueRoutine = False  # will revert to True if at least one component still running
        for thisComponent in SPQ5.components:
            if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:
                continueRoutine = True
                break  # at least one component has not yet finished
        
        # refresh the screen
        if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen
            win.flip()
    
    # --- Ending Routine "SPQ5" ---
    for thisComponent in SPQ5.components:
        if hasattr(thisComponent, "setAutoDraw"):
            thisComponent.setAutoDraw(False)
    # store stop times for SPQ5
    SPQ5.tStop = globalClock.getTime(format='float')
    SPQ5.tStopRefresh = tThisFlipGlobal
    thisExp.addData('SPQ5.stopped', SPQ5.tStop)
    # check responses
    if key_resp_50.keys in ['', [], None]:  # No response was made
        key_resp_50.keys = None
    thisExp.addData('key_resp_50.keys',key_resp_50.keys)
    if key_resp_50.keys != None:  # we had a response
        thisExp.addData('key_resp_50.rt', key_resp_50.rt)
        thisExp.addData('key_resp_50.duration', key_resp_50.duration)
    thisExp.nextEntry()
    # the Routine "SPQ5" was not non-slip safe, so reset the non-slip timer
    routineTimer.reset()
    
    # --- Prepare to start Routine "SPQ6" ---
    # create an object to store info about Routine SPQ6
    SPQ6 = data.Routine(
        name='SPQ6',
        components=[text_183, text_184, key_resp_51],
    )
    SPQ6.status = NOT_STARTED
    continueRoutine = True
    # update component parameters for each repeat
    # create starting attributes for key_resp_51
    key_resp_51.keys = []
    key_resp_51.rt = []
    _key_resp_51_allKeys = []
    # store start times for SPQ6
    SPQ6.tStartRefresh = win.getFutureFlipTime(clock=globalClock)
    SPQ6.tStart = globalClock.getTime(format='float')
    SPQ6.status = STARTED
    thisExp.addData('SPQ6.started', SPQ6.tStart)
    SPQ6.maxDuration = None
    # keep track of which components have finished
    SPQ6Components = SPQ6.components
    for thisComponent in SPQ6.components:
        thisComponent.tStart = None
        thisComponent.tStop = None
        thisComponent.tStartRefresh = None
        thisComponent.tStopRefresh = None
        if hasattr(thisComponent, 'status'):
            thisComponent.status = NOT_STARTED
    # reset timers
    t = 0
    _timeToFirstFrame = win.getFutureFlipTime(clock="now")
    frameN = -1
    
    # --- Run Routine "SPQ6" ---
    SPQ6.forceEnded = routineForceEnded = not continueRoutine
    while continueRoutine:
        # get current time
        t = routineTimer.getTime()
        tThisFlip = win.getFutureFlipTime(clock=routineTimer)
        tThisFlipGlobal = win.getFutureFlipTime(clock=None)
        frameN = frameN + 1  # number of completed frames (so 0 is the first frame)
        # update/draw components on each frame
        
        # *text_183* updates
        
        # if text_183 is starting this frame...
        if text_183.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
            # keep track of start time/frame for later
            text_183.frameNStart = frameN  # exact frame index
            text_183.tStart = t  # local t and not account for scr refresh
            text_183.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(text_183, 'tStartRefresh')  # time at next scr refresh
            # add timestamp to datafile
            thisExp.timestampOnFlip(win, 'text_183.started')
            # update status
            text_183.status = STARTED
            text_183.setAutoDraw(True)
        
        # if text_183 is active this frame...
        if text_183.status == STARTED:
            # update params
            pass
        
        # *text_184* updates
        
        # if text_184 is starting this frame...
        if text_184.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
            # keep track of start time/frame for later
            text_184.frameNStart = frameN  # exact frame index
            text_184.tStart = t  # local t and not account for scr refresh
            text_184.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(text_184, 'tStartRefresh')  # time at next scr refresh
            # add timestamp to datafile
            thisExp.timestampOnFlip(win, 'text_184.started')
            # update status
            text_184.status = STARTED
            text_184.setAutoDraw(True)
        
        # if text_184 is active this frame...
        if text_184.status == STARTED:
            # update params
            pass
        
        # *key_resp_51* updates
        waitOnFlip = False
        
        # if key_resp_51 is starting this frame...
        if key_resp_51.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
            # keep track of start time/frame for later
            key_resp_51.frameNStart = frameN  # exact frame index
            key_resp_51.tStart = t  # local t and not account for scr refresh
            key_resp_51.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(key_resp_51, 'tStartRefresh')  # time at next scr refresh
            # add timestamp to datafile
            thisExp.timestampOnFlip(win, 'key_resp_51.started')
            # update status
            key_resp_51.status = STARTED
            # keyboard checking is just starting
            waitOnFlip = True
            win.callOnFlip(key_resp_51.clock.reset)  # t=0 on next screen flip
            win.callOnFlip(key_resp_51.clearEvents, eventType='keyboard')  # clear events on next screen flip
        if key_resp_51.status == STARTED and not waitOnFlip:
            theseKeys = key_resp_51.getKeys(keyList=['y','n'], ignoreKeys=["escape"], waitRelease=False)
            _key_resp_51_allKeys.extend(theseKeys)
            if len(_key_resp_51_allKeys):
                key_resp_51.keys = _key_resp_51_allKeys[-1].name  # just the last key pressed
                key_resp_51.rt = _key_resp_51_allKeys[-1].rt
                key_resp_51.duration = _key_resp_51_allKeys[-1].duration
                # a response ends the routine
                continueRoutine = False
        
        # check for quit (typically the Esc key)
        if defaultKeyboard.getKeys(keyList=["escape"]):
            thisExp.status = FINISHED
        if thisExp.status == FINISHED or endExpNow:
            endExperiment(thisExp, win=win)
            return
        # pause experiment here if requested
        if thisExp.status == PAUSED:
            pauseExperiment(
                thisExp=thisExp, 
                win=win, 
                timers=[routineTimer], 
                playbackComponents=[]
            )
            # skip the frame we paused on
            continue
        
        # check if all components have finished
        if not continueRoutine:  # a component has requested a forced-end of Routine
            SPQ6.forceEnded = routineForceEnded = True
            break
        continueRoutine = False  # will revert to True if at least one component still running
        for thisComponent in SPQ6.components:
            if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:
                continueRoutine = True
                break  # at least one component has not yet finished
        
        # refresh the screen
        if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen
            win.flip()
    
    # --- Ending Routine "SPQ6" ---
    for thisComponent in SPQ6.components:
        if hasattr(thisComponent, "setAutoDraw"):
            thisComponent.setAutoDraw(False)
    # store stop times for SPQ6
    SPQ6.tStop = globalClock.getTime(format='float')
    SPQ6.tStopRefresh = tThisFlipGlobal
    thisExp.addData('SPQ6.stopped', SPQ6.tStop)
    # check responses
    if key_resp_51.keys in ['', [], None]:  # No response was made
        key_resp_51.keys = None
    thisExp.addData('key_resp_51.keys',key_resp_51.keys)
    if key_resp_51.keys != None:  # we had a response
        thisExp.addData('key_resp_51.rt', key_resp_51.rt)
        thisExp.addData('key_resp_51.duration', key_resp_51.duration)
    thisExp.nextEntry()
    # the Routine "SPQ6" was not non-slip safe, so reset the non-slip timer
    routineTimer.reset()
    
    # --- Prepare to start Routine "SPQ7" ---
    # create an object to store info about Routine SPQ7
    SPQ7 = data.Routine(
        name='SPQ7',
        components=[text_185, text_186, key_resp_52],
    )
    SPQ7.status = NOT_STARTED
    continueRoutine = True
    # update component parameters for each repeat
    # create starting attributes for key_resp_52
    key_resp_52.keys = []
    key_resp_52.rt = []
    _key_resp_52_allKeys = []
    # store start times for SPQ7
    SPQ7.tStartRefresh = win.getFutureFlipTime(clock=globalClock)
    SPQ7.tStart = globalClock.getTime(format='float')
    SPQ7.status = STARTED
    thisExp.addData('SPQ7.started', SPQ7.tStart)
    SPQ7.maxDuration = None
    # keep track of which components have finished
    SPQ7Components = SPQ7.components
    for thisComponent in SPQ7.components:
        thisComponent.tStart = None
        thisComponent.tStop = None
        thisComponent.tStartRefresh = None
        thisComponent.tStopRefresh = None
        if hasattr(thisComponent, 'status'):
            thisComponent.status = NOT_STARTED
    # reset timers
    t = 0
    _timeToFirstFrame = win.getFutureFlipTime(clock="now")
    frameN = -1
    
    # --- Run Routine "SPQ7" ---
    SPQ7.forceEnded = routineForceEnded = not continueRoutine
    while continueRoutine:
        # get current time
        t = routineTimer.getTime()
        tThisFlip = win.getFutureFlipTime(clock=routineTimer)
        tThisFlipGlobal = win.getFutureFlipTime(clock=None)
        frameN = frameN + 1  # number of completed frames (so 0 is the first frame)
        # update/draw components on each frame
        
        # *text_185* updates
        
        # if text_185 is starting this frame...
        if text_185.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
            # keep track of start time/frame for later
            text_185.frameNStart = frameN  # exact frame index
            text_185.tStart = t  # local t and not account for scr refresh
            text_185.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(text_185, 'tStartRefresh')  # time at next scr refresh
            # add timestamp to datafile
            thisExp.timestampOnFlip(win, 'text_185.started')
            # update status
            text_185.status = STARTED
            text_185.setAutoDraw(True)
        
        # if text_185 is active this frame...
        if text_185.status == STARTED:
            # update params
            pass
        
        # *text_186* updates
        
        # if text_186 is starting this frame...
        if text_186.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
            # keep track of start time/frame for later
            text_186.frameNStart = frameN  # exact frame index
            text_186.tStart = t  # local t and not account for scr refresh
            text_186.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(text_186, 'tStartRefresh')  # time at next scr refresh
            # add timestamp to datafile
            thisExp.timestampOnFlip(win, 'text_186.started')
            # update status
            text_186.status = STARTED
            text_186.setAutoDraw(True)
        
        # if text_186 is active this frame...
        if text_186.status == STARTED:
            # update params
            pass
        
        # *key_resp_52* updates
        waitOnFlip = False
        
        # if key_resp_52 is starting this frame...
        if key_resp_52.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
            # keep track of start time/frame for later
            key_resp_52.frameNStart = frameN  # exact frame index
            key_resp_52.tStart = t  # local t and not account for scr refresh
            key_resp_52.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(key_resp_52, 'tStartRefresh')  # time at next scr refresh
            # add timestamp to datafile
            thisExp.timestampOnFlip(win, 'key_resp_52.started')
            # update status
            key_resp_52.status = STARTED
            # keyboard checking is just starting
            waitOnFlip = True
            win.callOnFlip(key_resp_52.clock.reset)  # t=0 on next screen flip
            win.callOnFlip(key_resp_52.clearEvents, eventType='keyboard')  # clear events on next screen flip
        if key_resp_52.status == STARTED and not waitOnFlip:
            theseKeys = key_resp_52.getKeys(keyList=['y','n'], ignoreKeys=["escape"], waitRelease=False)
            _key_resp_52_allKeys.extend(theseKeys)
            if len(_key_resp_52_allKeys):
                key_resp_52.keys = _key_resp_52_allKeys[-1].name  # just the last key pressed
                key_resp_52.rt = _key_resp_52_allKeys[-1].rt
                key_resp_52.duration = _key_resp_52_allKeys[-1].duration
                # a response ends the routine
                continueRoutine = False
        
        # check for quit (typically the Esc key)
        if defaultKeyboard.getKeys(keyList=["escape"]):
            thisExp.status = FINISHED
        if thisExp.status == FINISHED or endExpNow:
            endExperiment(thisExp, win=win)
            return
        # pause experiment here if requested
        if thisExp.status == PAUSED:
            pauseExperiment(
                thisExp=thisExp, 
                win=win, 
                timers=[routineTimer], 
                playbackComponents=[]
            )
            # skip the frame we paused on
            continue
        
        # check if all components have finished
        if not continueRoutine:  # a component has requested a forced-end of Routine
            SPQ7.forceEnded = routineForceEnded = True
            break
        continueRoutine = False  # will revert to True if at least one component still running
        for thisComponent in SPQ7.components:
            if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:
                continueRoutine = True
                break  # at least one component has not yet finished
        
        # refresh the screen
        if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen
            win.flip()
    
    # --- Ending Routine "SPQ7" ---
    for thisComponent in SPQ7.components:
        if hasattr(thisComponent, "setAutoDraw"):
            thisComponent.setAutoDraw(False)
    # store stop times for SPQ7
    SPQ7.tStop = globalClock.getTime(format='float')
    SPQ7.tStopRefresh = tThisFlipGlobal
    thisExp.addData('SPQ7.stopped', SPQ7.tStop)
    # check responses
    if key_resp_52.keys in ['', [], None]:  # No response was made
        key_resp_52.keys = None
    thisExp.addData('key_resp_52.keys',key_resp_52.keys)
    if key_resp_52.keys != None:  # we had a response
        thisExp.addData('key_resp_52.rt', key_resp_52.rt)
        thisExp.addData('key_resp_52.duration', key_resp_52.duration)
    thisExp.nextEntry()
    # the Routine "SPQ7" was not non-slip safe, so reset the non-slip timer
    routineTimer.reset()
    
    # --- Prepare to start Routine "SPQ8" ---
    # create an object to store info about Routine SPQ8
    SPQ8 = data.Routine(
        name='SPQ8',
        components=[text_187, text_188, key_resp_53],
    )
    SPQ8.status = NOT_STARTED
    continueRoutine = True
    # update component parameters for each repeat
    # create starting attributes for key_resp_53
    key_resp_53.keys = []
    key_resp_53.rt = []
    _key_resp_53_allKeys = []
    # store start times for SPQ8
    SPQ8.tStartRefresh = win.getFutureFlipTime(clock=globalClock)
    SPQ8.tStart = globalClock.getTime(format='float')
    SPQ8.status = STARTED
    thisExp.addData('SPQ8.started', SPQ8.tStart)
    SPQ8.maxDuration = None
    # keep track of which components have finished
    SPQ8Components = SPQ8.components
    for thisComponent in SPQ8.components:
        thisComponent.tStart = None
        thisComponent.tStop = None
        thisComponent.tStartRefresh = None
        thisComponent.tStopRefresh = None
        if hasattr(thisComponent, 'status'):
            thisComponent.status = NOT_STARTED
    # reset timers
    t = 0
    _timeToFirstFrame = win.getFutureFlipTime(clock="now")
    frameN = -1
    
    # --- Run Routine "SPQ8" ---
    SPQ8.forceEnded = routineForceEnded = not continueRoutine
    while continueRoutine:
        # get current time
        t = routineTimer.getTime()
        tThisFlip = win.getFutureFlipTime(clock=routineTimer)
        tThisFlipGlobal = win.getFutureFlipTime(clock=None)
        frameN = frameN + 1  # number of completed frames (so 0 is the first frame)
        # update/draw components on each frame
        
        # *text_187* updates
        
        # if text_187 is starting this frame...
        if text_187.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
            # keep track of start time/frame for later
            text_187.frameNStart = frameN  # exact frame index
            text_187.tStart = t  # local t and not account for scr refresh
            text_187.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(text_187, 'tStartRefresh')  # time at next scr refresh
            # add timestamp to datafile
            thisExp.timestampOnFlip(win, 'text_187.started')
            # update status
            text_187.status = STARTED
            text_187.setAutoDraw(True)
        
        # if text_187 is active this frame...
        if text_187.status == STARTED:
            # update params
            pass
        
        # *text_188* updates
        
        # if text_188 is starting this frame...
        if text_188.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
            # keep track of start time/frame for later
            text_188.frameNStart = frameN  # exact frame index
            text_188.tStart = t  # local t and not account for scr refresh
            text_188.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(text_188, 'tStartRefresh')  # time at next scr refresh
            # add timestamp to datafile
            thisExp.timestampOnFlip(win, 'text_188.started')
            # update status
            text_188.status = STARTED
            text_188.setAutoDraw(True)
        
        # if text_188 is active this frame...
        if text_188.status == STARTED:
            # update params
            pass
        
        # *key_resp_53* updates
        waitOnFlip = False
        
        # if key_resp_53 is starting this frame...
        if key_resp_53.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
            # keep track of start time/frame for later
            key_resp_53.frameNStart = frameN  # exact frame index
            key_resp_53.tStart = t  # local t and not account for scr refresh
            key_resp_53.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(key_resp_53, 'tStartRefresh')  # time at next scr refresh
            # add timestamp to datafile
            thisExp.timestampOnFlip(win, 'key_resp_53.started')
            # update status
            key_resp_53.status = STARTED
            # keyboard checking is just starting
            waitOnFlip = True
            win.callOnFlip(key_resp_53.clock.reset)  # t=0 on next screen flip
            win.callOnFlip(key_resp_53.clearEvents, eventType='keyboard')  # clear events on next screen flip
        if key_resp_53.status == STARTED and not waitOnFlip:
            theseKeys = key_resp_53.getKeys(keyList=['y','n'], ignoreKeys=["escape"], waitRelease=False)
            _key_resp_53_allKeys.extend(theseKeys)
            if len(_key_resp_53_allKeys):
                key_resp_53.keys = _key_resp_53_allKeys[-1].name  # just the last key pressed
                key_resp_53.rt = _key_resp_53_allKeys[-1].rt
                key_resp_53.duration = _key_resp_53_allKeys[-1].duration
                # a response ends the routine
                continueRoutine = False
        
        # check for quit (typically the Esc key)
        if defaultKeyboard.getKeys(keyList=["escape"]):
            thisExp.status = FINISHED
        if thisExp.status == FINISHED or endExpNow:
            endExperiment(thisExp, win=win)
            return
        # pause experiment here if requested
        if thisExp.status == PAUSED:
            pauseExperiment(
                thisExp=thisExp, 
                win=win, 
                timers=[routineTimer], 
                playbackComponents=[]
            )
            # skip the frame we paused on
            continue
        
        # check if all components have finished
        if not continueRoutine:  # a component has requested a forced-end of Routine
            SPQ8.forceEnded = routineForceEnded = True
            break
        continueRoutine = False  # will revert to True if at least one component still running
        for thisComponent in SPQ8.components:
            if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:
                continueRoutine = True
                break  # at least one component has not yet finished
        
        # refresh the screen
        if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen
            win.flip()
    
    # --- Ending Routine "SPQ8" ---
    for thisComponent in SPQ8.components:
        if hasattr(thisComponent, "setAutoDraw"):
            thisComponent.setAutoDraw(False)
    # store stop times for SPQ8
    SPQ8.tStop = globalClock.getTime(format='float')
    SPQ8.tStopRefresh = tThisFlipGlobal
    thisExp.addData('SPQ8.stopped', SPQ8.tStop)
    # check responses
    if key_resp_53.keys in ['', [], None]:  # No response was made
        key_resp_53.keys = None
    thisExp.addData('key_resp_53.keys',key_resp_53.keys)
    if key_resp_53.keys != None:  # we had a response
        thisExp.addData('key_resp_53.rt', key_resp_53.rt)
        thisExp.addData('key_resp_53.duration', key_resp_53.duration)
    thisExp.nextEntry()
    # the Routine "SPQ8" was not non-slip safe, so reset the non-slip timer
    routineTimer.reset()
    
    # --- Prepare to start Routine "SPQ9" ---
    # create an object to store info about Routine SPQ9
    SPQ9 = data.Routine(
        name='SPQ9',
        components=[text_189, text_190, key_resp_54],
    )
    SPQ9.status = NOT_STARTED
    continueRoutine = True
    # update component parameters for each repeat
    # create starting attributes for key_resp_54
    key_resp_54.keys = []
    key_resp_54.rt = []
    _key_resp_54_allKeys = []
    # store start times for SPQ9
    SPQ9.tStartRefresh = win.getFutureFlipTime(clock=globalClock)
    SPQ9.tStart = globalClock.getTime(format='float')
    SPQ9.status = STARTED
    thisExp.addData('SPQ9.started', SPQ9.tStart)
    SPQ9.maxDuration = None
    # keep track of which components have finished
    SPQ9Components = SPQ9.components
    for thisComponent in SPQ9.components:
        thisComponent.tStart = None
        thisComponent.tStop = None
        thisComponent.tStartRefresh = None
        thisComponent.tStopRefresh = None
        if hasattr(thisComponent, 'status'):
            thisComponent.status = NOT_STARTED
    # reset timers
    t = 0
    _timeToFirstFrame = win.getFutureFlipTime(clock="now")
    frameN = -1
    
    # --- Run Routine "SPQ9" ---
    SPQ9.forceEnded = routineForceEnded = not continueRoutine
    while continueRoutine:
        # get current time
        t = routineTimer.getTime()
        tThisFlip = win.getFutureFlipTime(clock=routineTimer)
        tThisFlipGlobal = win.getFutureFlipTime(clock=None)
        frameN = frameN + 1  # number of completed frames (so 0 is the first frame)
        # update/draw components on each frame
        
        # *text_189* updates
        
        # if text_189 is starting this frame...
        if text_189.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
            # keep track of start time/frame for later
            text_189.frameNStart = frameN  # exact frame index
            text_189.tStart = t  # local t and not account for scr refresh
            text_189.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(text_189, 'tStartRefresh')  # time at next scr refresh
            # add timestamp to datafile
            thisExp.timestampOnFlip(win, 'text_189.started')
            # update status
            text_189.status = STARTED
            text_189.setAutoDraw(True)
        
        # if text_189 is active this frame...
        if text_189.status == STARTED:
            # update params
            pass
        
        # *text_190* updates
        
        # if text_190 is starting this frame...
        if text_190.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
            # keep track of start time/frame for later
            text_190.frameNStart = frameN  # exact frame index
            text_190.tStart = t  # local t and not account for scr refresh
            text_190.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(text_190, 'tStartRefresh')  # time at next scr refresh
            # add timestamp to datafile
            thisExp.timestampOnFlip(win, 'text_190.started')
            # update status
            text_190.status = STARTED
            text_190.setAutoDraw(True)
        
        # if text_190 is active this frame...
        if text_190.status == STARTED:
            # update params
            pass
        
        # *key_resp_54* updates
        waitOnFlip = False
        
        # if key_resp_54 is starting this frame...
        if key_resp_54.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
            # keep track of start time/frame for later
            key_resp_54.frameNStart = frameN  # exact frame index
            key_resp_54.tStart = t  # local t and not account for scr refresh
            key_resp_54.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(key_resp_54, 'tStartRefresh')  # time at next scr refresh
            # add timestamp to datafile
            thisExp.timestampOnFlip(win, 'key_resp_54.started')
            # update status
            key_resp_54.status = STARTED
            # keyboard checking is just starting
            waitOnFlip = True
            win.callOnFlip(key_resp_54.clock.reset)  # t=0 on next screen flip
            win.callOnFlip(key_resp_54.clearEvents, eventType='keyboard')  # clear events on next screen flip
        if key_resp_54.status == STARTED and not waitOnFlip:
            theseKeys = key_resp_54.getKeys(keyList=['y','n'], ignoreKeys=["escape"], waitRelease=False)
            _key_resp_54_allKeys.extend(theseKeys)
            if len(_key_resp_54_allKeys):
                key_resp_54.keys = _key_resp_54_allKeys[-1].name  # just the last key pressed
                key_resp_54.rt = _key_resp_54_allKeys[-1].rt
                key_resp_54.duration = _key_resp_54_allKeys[-1].duration
                # a response ends the routine
                continueRoutine = False
        
        # check for quit (typically the Esc key)
        if defaultKeyboard.getKeys(keyList=["escape"]):
            thisExp.status = FINISHED
        if thisExp.status == FINISHED or endExpNow:
            endExperiment(thisExp, win=win)
            return
        # pause experiment here if requested
        if thisExp.status == PAUSED:
            pauseExperiment(
                thisExp=thisExp, 
                win=win, 
                timers=[routineTimer], 
                playbackComponents=[]
            )
            # skip the frame we paused on
            continue
        
        # check if all components have finished
        if not continueRoutine:  # a component has requested a forced-end of Routine
            SPQ9.forceEnded = routineForceEnded = True
            break
        continueRoutine = False  # will revert to True if at least one component still running
        for thisComponent in SPQ9.components:
            if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:
                continueRoutine = True
                break  # at least one component has not yet finished
        
        # refresh the screen
        if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen
            win.flip()
    
    # --- Ending Routine "SPQ9" ---
    for thisComponent in SPQ9.components:
        if hasattr(thisComponent, "setAutoDraw"):
            thisComponent.setAutoDraw(False)
    # store stop times for SPQ9
    SPQ9.tStop = globalClock.getTime(format='float')
    SPQ9.tStopRefresh = tThisFlipGlobal
    thisExp.addData('SPQ9.stopped', SPQ9.tStop)
    # check responses
    if key_resp_54.keys in ['', [], None]:  # No response was made
        key_resp_54.keys = None
    thisExp.addData('key_resp_54.keys',key_resp_54.keys)
    if key_resp_54.keys != None:  # we had a response
        thisExp.addData('key_resp_54.rt', key_resp_54.rt)
        thisExp.addData('key_resp_54.duration', key_resp_54.duration)
    thisExp.nextEntry()
    # the Routine "SPQ9" was not non-slip safe, so reset the non-slip timer
    routineTimer.reset()
    
    # --- Prepare to start Routine "SPQ10" ---
    # create an object to store info about Routine SPQ10
    SPQ10 = data.Routine(
        name='SPQ10',
        components=[text_191, text_192, key_resp_55],
    )
    SPQ10.status = NOT_STARTED
    continueRoutine = True
    # update component parameters for each repeat
    # create starting attributes for key_resp_55
    key_resp_55.keys = []
    key_resp_55.rt = []
    _key_resp_55_allKeys = []
    # store start times for SPQ10
    SPQ10.tStartRefresh = win.getFutureFlipTime(clock=globalClock)
    SPQ10.tStart = globalClock.getTime(format='float')
    SPQ10.status = STARTED
    thisExp.addData('SPQ10.started', SPQ10.tStart)
    SPQ10.maxDuration = None
    # keep track of which components have finished
    SPQ10Components = SPQ10.components
    for thisComponent in SPQ10.components:
        thisComponent.tStart = None
        thisComponent.tStop = None
        thisComponent.tStartRefresh = None
        thisComponent.tStopRefresh = None
        if hasattr(thisComponent, 'status'):
            thisComponent.status = NOT_STARTED
    # reset timers
    t = 0
    _timeToFirstFrame = win.getFutureFlipTime(clock="now")
    frameN = -1
    
    # --- Run Routine "SPQ10" ---
    SPQ10.forceEnded = routineForceEnded = not continueRoutine
    while continueRoutine:
        # get current time
        t = routineTimer.getTime()
        tThisFlip = win.getFutureFlipTime(clock=routineTimer)
        tThisFlipGlobal = win.getFutureFlipTime(clock=None)
        frameN = frameN + 1  # number of completed frames (so 0 is the first frame)
        # update/draw components on each frame
        
        # *text_191* updates
        
        # if text_191 is starting this frame...
        if text_191.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
            # keep track of start time/frame for later
            text_191.frameNStart = frameN  # exact frame index
            text_191.tStart = t  # local t and not account for scr refresh
            text_191.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(text_191, 'tStartRefresh')  # time at next scr refresh
            # add timestamp to datafile
            thisExp.timestampOnFlip(win, 'text_191.started')
            # update status
            text_191.status = STARTED
            text_191.setAutoDraw(True)
        
        # if text_191 is active this frame...
        if text_191.status == STARTED:
            # update params
            pass
        
        # *text_192* updates
        
        # if text_192 is starting this frame...
        if text_192.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
            # keep track of start time/frame for later
            text_192.frameNStart = frameN  # exact frame index
            text_192.tStart = t  # local t and not account for scr refresh
            text_192.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(text_192, 'tStartRefresh')  # time at next scr refresh
            # add timestamp to datafile
            thisExp.timestampOnFlip(win, 'text_192.started')
            # update status
            text_192.status = STARTED
            text_192.setAutoDraw(True)
        
        # if text_192 is active this frame...
        if text_192.status == STARTED:
            # update params
            pass
        
        # *key_resp_55* updates
        waitOnFlip = False
        
        # if key_resp_55 is starting this frame...
        if key_resp_55.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
            # keep track of start time/frame for later
            key_resp_55.frameNStart = frameN  # exact frame index
            key_resp_55.tStart = t  # local t and not account for scr refresh
            key_resp_55.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(key_resp_55, 'tStartRefresh')  # time at next scr refresh
            # add timestamp to datafile
            thisExp.timestampOnFlip(win, 'key_resp_55.started')
            # update status
            key_resp_55.status = STARTED
            # keyboard checking is just starting
            waitOnFlip = True
            win.callOnFlip(key_resp_55.clock.reset)  # t=0 on next screen flip
            win.callOnFlip(key_resp_55.clearEvents, eventType='keyboard')  # clear events on next screen flip
        if key_resp_55.status == STARTED and not waitOnFlip:
            theseKeys = key_resp_55.getKeys(keyList=['y','n'], ignoreKeys=["escape"], waitRelease=False)
            _key_resp_55_allKeys.extend(theseKeys)
            if len(_key_resp_55_allKeys):
                key_resp_55.keys = _key_resp_55_allKeys[-1].name  # just the last key pressed
                key_resp_55.rt = _key_resp_55_allKeys[-1].rt
                key_resp_55.duration = _key_resp_55_allKeys[-1].duration
                # a response ends the routine
                continueRoutine = False
        
        # check for quit (typically the Esc key)
        if defaultKeyboard.getKeys(keyList=["escape"]):
            thisExp.status = FINISHED
        if thisExp.status == FINISHED or endExpNow:
            endExperiment(thisExp, win=win)
            return
        # pause experiment here if requested
        if thisExp.status == PAUSED:
            pauseExperiment(
                thisExp=thisExp, 
                win=win, 
                timers=[routineTimer], 
                playbackComponents=[]
            )
            # skip the frame we paused on
            continue
        
        # check if all components have finished
        if not continueRoutine:  # a component has requested a forced-end of Routine
            SPQ10.forceEnded = routineForceEnded = True
            break
        continueRoutine = False  # will revert to True if at least one component still running
        for thisComponent in SPQ10.components:
            if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:
                continueRoutine = True
                break  # at least one component has not yet finished
        
        # refresh the screen
        if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen
            win.flip()
    
    # --- Ending Routine "SPQ10" ---
    for thisComponent in SPQ10.components:
        if hasattr(thisComponent, "setAutoDraw"):
            thisComponent.setAutoDraw(False)
    # store stop times for SPQ10
    SPQ10.tStop = globalClock.getTime(format='float')
    SPQ10.tStopRefresh = tThisFlipGlobal
    thisExp.addData('SPQ10.stopped', SPQ10.tStop)
    # check responses
    if key_resp_55.keys in ['', [], None]:  # No response was made
        key_resp_55.keys = None
    thisExp.addData('key_resp_55.keys',key_resp_55.keys)
    if key_resp_55.keys != None:  # we had a response
        thisExp.addData('key_resp_55.rt', key_resp_55.rt)
        thisExp.addData('key_resp_55.duration', key_resp_55.duration)
    thisExp.nextEntry()
    # the Routine "SPQ10" was not non-slip safe, so reset the non-slip timer
    routineTimer.reset()
    
    # --- Prepare to start Routine "SQP11" ---
    # create an object to store info about Routine SQP11
    SQP11 = data.Routine(
        name='SQP11',
        components=[text_193, text_194, key_resp_56],
    )
    SQP11.status = NOT_STARTED
    continueRoutine = True
    # update component parameters for each repeat
    # create starting attributes for key_resp_56
    key_resp_56.keys = []
    key_resp_56.rt = []
    _key_resp_56_allKeys = []
    # store start times for SQP11
    SQP11.tStartRefresh = win.getFutureFlipTime(clock=globalClock)
    SQP11.tStart = globalClock.getTime(format='float')
    SQP11.status = STARTED
    thisExp.addData('SQP11.started', SQP11.tStart)
    SQP11.maxDuration = None
    # keep track of which components have finished
    SQP11Components = SQP11.components
    for thisComponent in SQP11.components:
        thisComponent.tStart = None
        thisComponent.tStop = None
        thisComponent.tStartRefresh = None
        thisComponent.tStopRefresh = None
        if hasattr(thisComponent, 'status'):
            thisComponent.status = NOT_STARTED
    # reset timers
    t = 0
    _timeToFirstFrame = win.getFutureFlipTime(clock="now")
    frameN = -1
    
    # --- Run Routine "SQP11" ---
    SQP11.forceEnded = routineForceEnded = not continueRoutine
    while continueRoutine:
        # get current time
        t = routineTimer.getTime()
        tThisFlip = win.getFutureFlipTime(clock=routineTimer)
        tThisFlipGlobal = win.getFutureFlipTime(clock=None)
        frameN = frameN + 1  # number of completed frames (so 0 is the first frame)
        # update/draw components on each frame
        
        # *text_193* updates
        
        # if text_193 is starting this frame...
        if text_193.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
            # keep track of start time/frame for later
            text_193.frameNStart = frameN  # exact frame index
            text_193.tStart = t  # local t and not account for scr refresh
            text_193.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(text_193, 'tStartRefresh')  # time at next scr refresh
            # add timestamp to datafile
            thisExp.timestampOnFlip(win, 'text_193.started')
            # update status
            text_193.status = STARTED
            text_193.setAutoDraw(True)
        
        # if text_193 is active this frame...
        if text_193.status == STARTED:
            # update params
            pass
        
        # *text_194* updates
        
        # if text_194 is starting this frame...
        if text_194.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
            # keep track of start time/frame for later
            text_194.frameNStart = frameN  # exact frame index
            text_194.tStart = t  # local t and not account for scr refresh
            text_194.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(text_194, 'tStartRefresh')  # time at next scr refresh
            # add timestamp to datafile
            thisExp.timestampOnFlip(win, 'text_194.started')
            # update status
            text_194.status = STARTED
            text_194.setAutoDraw(True)
        
        # if text_194 is active this frame...
        if text_194.status == STARTED:
            # update params
            pass
        
        # *key_resp_56* updates
        waitOnFlip = False
        
        # if key_resp_56 is starting this frame...
        if key_resp_56.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
            # keep track of start time/frame for later
            key_resp_56.frameNStart = frameN  # exact frame index
            key_resp_56.tStart = t  # local t and not account for scr refresh
            key_resp_56.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(key_resp_56, 'tStartRefresh')  # time at next scr refresh
            # add timestamp to datafile
            thisExp.timestampOnFlip(win, 'key_resp_56.started')
            # update status
            key_resp_56.status = STARTED
            # keyboard checking is just starting
            waitOnFlip = True
            win.callOnFlip(key_resp_56.clock.reset)  # t=0 on next screen flip
            win.callOnFlip(key_resp_56.clearEvents, eventType='keyboard')  # clear events on next screen flip
        if key_resp_56.status == STARTED and not waitOnFlip:
            theseKeys = key_resp_56.getKeys(keyList=['y','n'], ignoreKeys=["escape"], waitRelease=False)
            _key_resp_56_allKeys.extend(theseKeys)
            if len(_key_resp_56_allKeys):
                key_resp_56.keys = _key_resp_56_allKeys[-1].name  # just the last key pressed
                key_resp_56.rt = _key_resp_56_allKeys[-1].rt
                key_resp_56.duration = _key_resp_56_allKeys[-1].duration
                # a response ends the routine
                continueRoutine = False
        
        # check for quit (typically the Esc key)
        if defaultKeyboard.getKeys(keyList=["escape"]):
            thisExp.status = FINISHED
        if thisExp.status == FINISHED or endExpNow:
            endExperiment(thisExp, win=win)
            return
        # pause experiment here if requested
        if thisExp.status == PAUSED:
            pauseExperiment(
                thisExp=thisExp, 
                win=win, 
                timers=[routineTimer], 
                playbackComponents=[]
            )
            # skip the frame we paused on
            continue
        
        # check if all components have finished
        if not continueRoutine:  # a component has requested a forced-end of Routine
            SQP11.forceEnded = routineForceEnded = True
            break
        continueRoutine = False  # will revert to True if at least one component still running
        for thisComponent in SQP11.components:
            if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:
                continueRoutine = True
                break  # at least one component has not yet finished
        
        # refresh the screen
        if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen
            win.flip()
    
    # --- Ending Routine "SQP11" ---
    for thisComponent in SQP11.components:
        if hasattr(thisComponent, "setAutoDraw"):
            thisComponent.setAutoDraw(False)
    # store stop times for SQP11
    SQP11.tStop = globalClock.getTime(format='float')
    SQP11.tStopRefresh = tThisFlipGlobal
    thisExp.addData('SQP11.stopped', SQP11.tStop)
    # check responses
    if key_resp_56.keys in ['', [], None]:  # No response was made
        key_resp_56.keys = None
    thisExp.addData('key_resp_56.keys',key_resp_56.keys)
    if key_resp_56.keys != None:  # we had a response
        thisExp.addData('key_resp_56.rt', key_resp_56.rt)
        thisExp.addData('key_resp_56.duration', key_resp_56.duration)
    thisExp.nextEntry()
    # the Routine "SQP11" was not non-slip safe, so reset the non-slip timer
    routineTimer.reset()
    
    # --- Prepare to start Routine "SPQ12" ---
    # create an object to store info about Routine SPQ12
    SPQ12 = data.Routine(
        name='SPQ12',
        components=[text_195, text_196, key_resp_57],
    )
    SPQ12.status = NOT_STARTED
    continueRoutine = True
    # update component parameters for each repeat
    # create starting attributes for key_resp_57
    key_resp_57.keys = []
    key_resp_57.rt = []
    _key_resp_57_allKeys = []
    # store start times for SPQ12
    SPQ12.tStartRefresh = win.getFutureFlipTime(clock=globalClock)
    SPQ12.tStart = globalClock.getTime(format='float')
    SPQ12.status = STARTED
    thisExp.addData('SPQ12.started', SPQ12.tStart)
    SPQ12.maxDuration = None
    # keep track of which components have finished
    SPQ12Components = SPQ12.components
    for thisComponent in SPQ12.components:
        thisComponent.tStart = None
        thisComponent.tStop = None
        thisComponent.tStartRefresh = None
        thisComponent.tStopRefresh = None
        if hasattr(thisComponent, 'status'):
            thisComponent.status = NOT_STARTED
    # reset timers
    t = 0
    _timeToFirstFrame = win.getFutureFlipTime(clock="now")
    frameN = -1
    
    # --- Run Routine "SPQ12" ---
    SPQ12.forceEnded = routineForceEnded = not continueRoutine
    while continueRoutine:
        # get current time
        t = routineTimer.getTime()
        tThisFlip = win.getFutureFlipTime(clock=routineTimer)
        tThisFlipGlobal = win.getFutureFlipTime(clock=None)
        frameN = frameN + 1  # number of completed frames (so 0 is the first frame)
        # update/draw components on each frame
        
        # *text_195* updates
        
        # if text_195 is starting this frame...
        if text_195.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
            # keep track of start time/frame for later
            text_195.frameNStart = frameN  # exact frame index
            text_195.tStart = t  # local t and not account for scr refresh
            text_195.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(text_195, 'tStartRefresh')  # time at next scr refresh
            # add timestamp to datafile
            thisExp.timestampOnFlip(win, 'text_195.started')
            # update status
            text_195.status = STARTED
            text_195.setAutoDraw(True)
        
        # if text_195 is active this frame...
        if text_195.status == STARTED:
            # update params
            pass
        
        # *text_196* updates
        
        # if text_196 is starting this frame...
        if text_196.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
            # keep track of start time/frame for later
            text_196.frameNStart = frameN  # exact frame index
            text_196.tStart = t  # local t and not account for scr refresh
            text_196.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(text_196, 'tStartRefresh')  # time at next scr refresh
            # add timestamp to datafile
            thisExp.timestampOnFlip(win, 'text_196.started')
            # update status
            text_196.status = STARTED
            text_196.setAutoDraw(True)
        
        # if text_196 is active this frame...
        if text_196.status == STARTED:
            # update params
            pass
        
        # *key_resp_57* updates
        waitOnFlip = False
        
        # if key_resp_57 is starting this frame...
        if key_resp_57.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
            # keep track of start time/frame for later
            key_resp_57.frameNStart = frameN  # exact frame index
            key_resp_57.tStart = t  # local t and not account for scr refresh
            key_resp_57.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(key_resp_57, 'tStartRefresh')  # time at next scr refresh
            # add timestamp to datafile
            thisExp.timestampOnFlip(win, 'key_resp_57.started')
            # update status
            key_resp_57.status = STARTED
            # keyboard checking is just starting
            waitOnFlip = True
            win.callOnFlip(key_resp_57.clock.reset)  # t=0 on next screen flip
            win.callOnFlip(key_resp_57.clearEvents, eventType='keyboard')  # clear events on next screen flip
        if key_resp_57.status == STARTED and not waitOnFlip:
            theseKeys = key_resp_57.getKeys(keyList=['y','n'], ignoreKeys=["escape"], waitRelease=False)
            _key_resp_57_allKeys.extend(theseKeys)
            if len(_key_resp_57_allKeys):
                key_resp_57.keys = _key_resp_57_allKeys[-1].name  # just the last key pressed
                key_resp_57.rt = _key_resp_57_allKeys[-1].rt
                key_resp_57.duration = _key_resp_57_allKeys[-1].duration
                # a response ends the routine
                continueRoutine = False
        
        # check for quit (typically the Esc key)
        if defaultKeyboard.getKeys(keyList=["escape"]):
            thisExp.status = FINISHED
        if thisExp.status == FINISHED or endExpNow:
            endExperiment(thisExp, win=win)
            return
        # pause experiment here if requested
        if thisExp.status == PAUSED:
            pauseExperiment(
                thisExp=thisExp, 
                win=win, 
                timers=[routineTimer], 
                playbackComponents=[]
            )
            # skip the frame we paused on
            continue
        
        # check if all components have finished
        if not continueRoutine:  # a component has requested a forced-end of Routine
            SPQ12.forceEnded = routineForceEnded = True
            break
        continueRoutine = False  # will revert to True if at least one component still running
        for thisComponent in SPQ12.components:
            if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:
                continueRoutine = True
                break  # at least one component has not yet finished
        
        # refresh the screen
        if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen
            win.flip()
    
    # --- Ending Routine "SPQ12" ---
    for thisComponent in SPQ12.components:
        if hasattr(thisComponent, "setAutoDraw"):
            thisComponent.setAutoDraw(False)
    # store stop times for SPQ12
    SPQ12.tStop = globalClock.getTime(format='float')
    SPQ12.tStopRefresh = tThisFlipGlobal
    thisExp.addData('SPQ12.stopped', SPQ12.tStop)
    # check responses
    if key_resp_57.keys in ['', [], None]:  # No response was made
        key_resp_57.keys = None
    thisExp.addData('key_resp_57.keys',key_resp_57.keys)
    if key_resp_57.keys != None:  # we had a response
        thisExp.addData('key_resp_57.rt', key_resp_57.rt)
        thisExp.addData('key_resp_57.duration', key_resp_57.duration)
    thisExp.nextEntry()
    # the Routine "SPQ12" was not non-slip safe, so reset the non-slip timer
    routineTimer.reset()
    
    # --- Prepare to start Routine "SPQ13" ---
    # create an object to store info about Routine SPQ13
    SPQ13 = data.Routine(
        name='SPQ13',
        components=[text_197, text_198, key_resp_58],
    )
    SPQ13.status = NOT_STARTED
    continueRoutine = True
    # update component parameters for each repeat
    # create starting attributes for key_resp_58
    key_resp_58.keys = []
    key_resp_58.rt = []
    _key_resp_58_allKeys = []
    # store start times for SPQ13
    SPQ13.tStartRefresh = win.getFutureFlipTime(clock=globalClock)
    SPQ13.tStart = globalClock.getTime(format='float')
    SPQ13.status = STARTED
    thisExp.addData('SPQ13.started', SPQ13.tStart)
    SPQ13.maxDuration = None
    # keep track of which components have finished
    SPQ13Components = SPQ13.components
    for thisComponent in SPQ13.components:
        thisComponent.tStart = None
        thisComponent.tStop = None
        thisComponent.tStartRefresh = None
        thisComponent.tStopRefresh = None
        if hasattr(thisComponent, 'status'):
            thisComponent.status = NOT_STARTED
    # reset timers
    t = 0
    _timeToFirstFrame = win.getFutureFlipTime(clock="now")
    frameN = -1
    
    # --- Run Routine "SPQ13" ---
    SPQ13.forceEnded = routineForceEnded = not continueRoutine
    while continueRoutine:
        # get current time
        t = routineTimer.getTime()
        tThisFlip = win.getFutureFlipTime(clock=routineTimer)
        tThisFlipGlobal = win.getFutureFlipTime(clock=None)
        frameN = frameN + 1  # number of completed frames (so 0 is the first frame)
        # update/draw components on each frame
        
        # *text_197* updates
        
        # if text_197 is starting this frame...
        if text_197.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
            # keep track of start time/frame for later
            text_197.frameNStart = frameN  # exact frame index
            text_197.tStart = t  # local t and not account for scr refresh
            text_197.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(text_197, 'tStartRefresh')  # time at next scr refresh
            # add timestamp to datafile
            thisExp.timestampOnFlip(win, 'text_197.started')
            # update status
            text_197.status = STARTED
            text_197.setAutoDraw(True)
        
        # if text_197 is active this frame...
        if text_197.status == STARTED:
            # update params
            pass
        
        # *text_198* updates
        
        # if text_198 is starting this frame...
        if text_198.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
            # keep track of start time/frame for later
            text_198.frameNStart = frameN  # exact frame index
            text_198.tStart = t  # local t and not account for scr refresh
            text_198.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(text_198, 'tStartRefresh')  # time at next scr refresh
            # add timestamp to datafile
            thisExp.timestampOnFlip(win, 'text_198.started')
            # update status
            text_198.status = STARTED
            text_198.setAutoDraw(True)
        
        # if text_198 is active this frame...
        if text_198.status == STARTED:
            # update params
            pass
        
        # *key_resp_58* updates
        waitOnFlip = False
        
        # if key_resp_58 is starting this frame...
        if key_resp_58.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
            # keep track of start time/frame for later
            key_resp_58.frameNStart = frameN  # exact frame index
            key_resp_58.tStart = t  # local t and not account for scr refresh
            key_resp_58.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(key_resp_58, 'tStartRefresh')  # time at next scr refresh
            # add timestamp to datafile
            thisExp.timestampOnFlip(win, 'key_resp_58.started')
            # update status
            key_resp_58.status = STARTED
            # keyboard checking is just starting
            waitOnFlip = True
            win.callOnFlip(key_resp_58.clock.reset)  # t=0 on next screen flip
            win.callOnFlip(key_resp_58.clearEvents, eventType='keyboard')  # clear events on next screen flip
        if key_resp_58.status == STARTED and not waitOnFlip:
            theseKeys = key_resp_58.getKeys(keyList=['y','n'], ignoreKeys=["escape"], waitRelease=False)
            _key_resp_58_allKeys.extend(theseKeys)
            if len(_key_resp_58_allKeys):
                key_resp_58.keys = _key_resp_58_allKeys[-1].name  # just the last key pressed
                key_resp_58.rt = _key_resp_58_allKeys[-1].rt
                key_resp_58.duration = _key_resp_58_allKeys[-1].duration
                # a response ends the routine
                continueRoutine = False
        
        # check for quit (typically the Esc key)
        if defaultKeyboard.getKeys(keyList=["escape"]):
            thisExp.status = FINISHED
        if thisExp.status == FINISHED or endExpNow:
            endExperiment(thisExp, win=win)
            return
        # pause experiment here if requested
        if thisExp.status == PAUSED:
            pauseExperiment(
                thisExp=thisExp, 
                win=win, 
                timers=[routineTimer], 
                playbackComponents=[]
            )
            # skip the frame we paused on
            continue
        
        # check if all components have finished
        if not continueRoutine:  # a component has requested a forced-end of Routine
            SPQ13.forceEnded = routineForceEnded = True
            break
        continueRoutine = False  # will revert to True if at least one component still running
        for thisComponent in SPQ13.components:
            if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:
                continueRoutine = True
                break  # at least one component has not yet finished
        
        # refresh the screen
        if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen
            win.flip()
    
    # --- Ending Routine "SPQ13" ---
    for thisComponent in SPQ13.components:
        if hasattr(thisComponent, "setAutoDraw"):
            thisComponent.setAutoDraw(False)
    # store stop times for SPQ13
    SPQ13.tStop = globalClock.getTime(format='float')
    SPQ13.tStopRefresh = tThisFlipGlobal
    thisExp.addData('SPQ13.stopped', SPQ13.tStop)
    # check responses
    if key_resp_58.keys in ['', [], None]:  # No response was made
        key_resp_58.keys = None
    thisExp.addData('key_resp_58.keys',key_resp_58.keys)
    if key_resp_58.keys != None:  # we had a response
        thisExp.addData('key_resp_58.rt', key_resp_58.rt)
        thisExp.addData('key_resp_58.duration', key_resp_58.duration)
    thisExp.nextEntry()
    # the Routine "SPQ13" was not non-slip safe, so reset the non-slip timer
    routineTimer.reset()
    
    # --- Prepare to start Routine "SPQ14" ---
    # create an object to store info about Routine SPQ14
    SPQ14 = data.Routine(
        name='SPQ14',
        components=[text_199, text_200, key_resp_59],
    )
    SPQ14.status = NOT_STARTED
    continueRoutine = True
    # update component parameters for each repeat
    # create starting attributes for key_resp_59
    key_resp_59.keys = []
    key_resp_59.rt = []
    _key_resp_59_allKeys = []
    # store start times for SPQ14
    SPQ14.tStartRefresh = win.getFutureFlipTime(clock=globalClock)
    SPQ14.tStart = globalClock.getTime(format='float')
    SPQ14.status = STARTED
    thisExp.addData('SPQ14.started', SPQ14.tStart)
    SPQ14.maxDuration = None
    # keep track of which components have finished
    SPQ14Components = SPQ14.components
    for thisComponent in SPQ14.components:
        thisComponent.tStart = None
        thisComponent.tStop = None
        thisComponent.tStartRefresh = None
        thisComponent.tStopRefresh = None
        if hasattr(thisComponent, 'status'):
            thisComponent.status = NOT_STARTED
    # reset timers
    t = 0
    _timeToFirstFrame = win.getFutureFlipTime(clock="now")
    frameN = -1
    
    # --- Run Routine "SPQ14" ---
    SPQ14.forceEnded = routineForceEnded = not continueRoutine
    while continueRoutine:
        # get current time
        t = routineTimer.getTime()
        tThisFlip = win.getFutureFlipTime(clock=routineTimer)
        tThisFlipGlobal = win.getFutureFlipTime(clock=None)
        frameN = frameN + 1  # number of completed frames (so 0 is the first frame)
        # update/draw components on each frame
        
        # *text_199* updates
        
        # if text_199 is starting this frame...
        if text_199.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
            # keep track of start time/frame for later
            text_199.frameNStart = frameN  # exact frame index
            text_199.tStart = t  # local t and not account for scr refresh
            text_199.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(text_199, 'tStartRefresh')  # time at next scr refresh
            # add timestamp to datafile
            thisExp.timestampOnFlip(win, 'text_199.started')
            # update status
            text_199.status = STARTED
            text_199.setAutoDraw(True)
        
        # if text_199 is active this frame...
        if text_199.status == STARTED:
            # update params
            pass
        
        # *text_200* updates
        
        # if text_200 is starting this frame...
        if text_200.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
            # keep track of start time/frame for later
            text_200.frameNStart = frameN  # exact frame index
            text_200.tStart = t  # local t and not account for scr refresh
            text_200.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(text_200, 'tStartRefresh')  # time at next scr refresh
            # add timestamp to datafile
            thisExp.timestampOnFlip(win, 'text_200.started')
            # update status
            text_200.status = STARTED
            text_200.setAutoDraw(True)
        
        # if text_200 is active this frame...
        if text_200.status == STARTED:
            # update params
            pass
        
        # *key_resp_59* updates
        waitOnFlip = False
        
        # if key_resp_59 is starting this frame...
        if key_resp_59.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
            # keep track of start time/frame for later
            key_resp_59.frameNStart = frameN  # exact frame index
            key_resp_59.tStart = t  # local t and not account for scr refresh
            key_resp_59.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(key_resp_59, 'tStartRefresh')  # time at next scr refresh
            # add timestamp to datafile
            thisExp.timestampOnFlip(win, 'key_resp_59.started')
            # update status
            key_resp_59.status = STARTED
            # keyboard checking is just starting
            waitOnFlip = True
            win.callOnFlip(key_resp_59.clock.reset)  # t=0 on next screen flip
            win.callOnFlip(key_resp_59.clearEvents, eventType='keyboard')  # clear events on next screen flip
        if key_resp_59.status == STARTED and not waitOnFlip:
            theseKeys = key_resp_59.getKeys(keyList=['y','n'], ignoreKeys=["escape"], waitRelease=False)
            _key_resp_59_allKeys.extend(theseKeys)
            if len(_key_resp_59_allKeys):
                key_resp_59.keys = _key_resp_59_allKeys[-1].name  # just the last key pressed
                key_resp_59.rt = _key_resp_59_allKeys[-1].rt
                key_resp_59.duration = _key_resp_59_allKeys[-1].duration
                # a response ends the routine
                continueRoutine = False
        
        # check for quit (typically the Esc key)
        if defaultKeyboard.getKeys(keyList=["escape"]):
            thisExp.status = FINISHED
        if thisExp.status == FINISHED or endExpNow:
            endExperiment(thisExp, win=win)
            return
        # pause experiment here if requested
        if thisExp.status == PAUSED:
            pauseExperiment(
                thisExp=thisExp, 
                win=win, 
                timers=[routineTimer], 
                playbackComponents=[]
            )
            # skip the frame we paused on
            continue
        
        # check if all components have finished
        if not continueRoutine:  # a component has requested a forced-end of Routine
            SPQ14.forceEnded = routineForceEnded = True
            break
        continueRoutine = False  # will revert to True if at least one component still running
        for thisComponent in SPQ14.components:
            if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:
                continueRoutine = True
                break  # at least one component has not yet finished
        
        # refresh the screen
        if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen
            win.flip()
    
    # --- Ending Routine "SPQ14" ---
    for thisComponent in SPQ14.components:
        if hasattr(thisComponent, "setAutoDraw"):
            thisComponent.setAutoDraw(False)
    # store stop times for SPQ14
    SPQ14.tStop = globalClock.getTime(format='float')
    SPQ14.tStopRefresh = tThisFlipGlobal
    thisExp.addData('SPQ14.stopped', SPQ14.tStop)
    # check responses
    if key_resp_59.keys in ['', [], None]:  # No response was made
        key_resp_59.keys = None
    thisExp.addData('key_resp_59.keys',key_resp_59.keys)
    if key_resp_59.keys != None:  # we had a response
        thisExp.addData('key_resp_59.rt', key_resp_59.rt)
        thisExp.addData('key_resp_59.duration', key_resp_59.duration)
    thisExp.nextEntry()
    # the Routine "SPQ14" was not non-slip safe, so reset the non-slip timer
    routineTimer.reset()
    
    # --- Prepare to start Routine "SPQ15" ---
    # create an object to store info about Routine SPQ15
    SPQ15 = data.Routine(
        name='SPQ15',
        components=[text_201, text_202, key_resp_60],
    )
    SPQ15.status = NOT_STARTED
    continueRoutine = True
    # update component parameters for each repeat
    # create starting attributes for key_resp_60
    key_resp_60.keys = []
    key_resp_60.rt = []
    _key_resp_60_allKeys = []
    # store start times for SPQ15
    SPQ15.tStartRefresh = win.getFutureFlipTime(clock=globalClock)
    SPQ15.tStart = globalClock.getTime(format='float')
    SPQ15.status = STARTED
    thisExp.addData('SPQ15.started', SPQ15.tStart)
    SPQ15.maxDuration = None
    # keep track of which components have finished
    SPQ15Components = SPQ15.components
    for thisComponent in SPQ15.components:
        thisComponent.tStart = None
        thisComponent.tStop = None
        thisComponent.tStartRefresh = None
        thisComponent.tStopRefresh = None
        if hasattr(thisComponent, 'status'):
            thisComponent.status = NOT_STARTED
    # reset timers
    t = 0
    _timeToFirstFrame = win.getFutureFlipTime(clock="now")
    frameN = -1
    
    # --- Run Routine "SPQ15" ---
    SPQ15.forceEnded = routineForceEnded = not continueRoutine
    while continueRoutine:
        # get current time
        t = routineTimer.getTime()
        tThisFlip = win.getFutureFlipTime(clock=routineTimer)
        tThisFlipGlobal = win.getFutureFlipTime(clock=None)
        frameN = frameN + 1  # number of completed frames (so 0 is the first frame)
        # update/draw components on each frame
        
        # *text_201* updates
        
        # if text_201 is starting this frame...
        if text_201.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
            # keep track of start time/frame for later
            text_201.frameNStart = frameN  # exact frame index
            text_201.tStart = t  # local t and not account for scr refresh
            text_201.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(text_201, 'tStartRefresh')  # time at next scr refresh
            # add timestamp to datafile
            thisExp.timestampOnFlip(win, 'text_201.started')
            # update status
            text_201.status = STARTED
            text_201.setAutoDraw(True)
        
        # if text_201 is active this frame...
        if text_201.status == STARTED:
            # update params
            pass
        
        # *text_202* updates
        
        # if text_202 is starting this frame...
        if text_202.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
            # keep track of start time/frame for later
            text_202.frameNStart = frameN  # exact frame index
            text_202.tStart = t  # local t and not account for scr refresh
            text_202.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(text_202, 'tStartRefresh')  # time at next scr refresh
            # add timestamp to datafile
            thisExp.timestampOnFlip(win, 'text_202.started')
            # update status
            text_202.status = STARTED
            text_202.setAutoDraw(True)
        
        # if text_202 is active this frame...
        if text_202.status == STARTED:
            # update params
            pass
        
        # *key_resp_60* updates
        waitOnFlip = False
        
        # if key_resp_60 is starting this frame...
        if key_resp_60.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
            # keep track of start time/frame for later
            key_resp_60.frameNStart = frameN  # exact frame index
            key_resp_60.tStart = t  # local t and not account for scr refresh
            key_resp_60.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(key_resp_60, 'tStartRefresh')  # time at next scr refresh
            # add timestamp to datafile
            thisExp.timestampOnFlip(win, 'key_resp_60.started')
            # update status
            key_resp_60.status = STARTED
            # keyboard checking is just starting
            waitOnFlip = True
            win.callOnFlip(key_resp_60.clock.reset)  # t=0 on next screen flip
            win.callOnFlip(key_resp_60.clearEvents, eventType='keyboard')  # clear events on next screen flip
        if key_resp_60.status == STARTED and not waitOnFlip:
            theseKeys = key_resp_60.getKeys(keyList=['y','n'], ignoreKeys=["escape"], waitRelease=False)
            _key_resp_60_allKeys.extend(theseKeys)
            if len(_key_resp_60_allKeys):
                key_resp_60.keys = _key_resp_60_allKeys[-1].name  # just the last key pressed
                key_resp_60.rt = _key_resp_60_allKeys[-1].rt
                key_resp_60.duration = _key_resp_60_allKeys[-1].duration
                # a response ends the routine
                continueRoutine = False
        
        # check for quit (typically the Esc key)
        if defaultKeyboard.getKeys(keyList=["escape"]):
            thisExp.status = FINISHED
        if thisExp.status == FINISHED or endExpNow:
            endExperiment(thisExp, win=win)
            return
        # pause experiment here if requested
        if thisExp.status == PAUSED:
            pauseExperiment(
                thisExp=thisExp, 
                win=win, 
                timers=[routineTimer], 
                playbackComponents=[]
            )
            # skip the frame we paused on
            continue
        
        # check if all components have finished
        if not continueRoutine:  # a component has requested a forced-end of Routine
            SPQ15.forceEnded = routineForceEnded = True
            break
        continueRoutine = False  # will revert to True if at least one component still running
        for thisComponent in SPQ15.components:
            if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:
                continueRoutine = True
                break  # at least one component has not yet finished
        
        # refresh the screen
        if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen
            win.flip()
    
    # --- Ending Routine "SPQ15" ---
    for thisComponent in SPQ15.components:
        if hasattr(thisComponent, "setAutoDraw"):
            thisComponent.setAutoDraw(False)
    # store stop times for SPQ15
    SPQ15.tStop = globalClock.getTime(format='float')
    SPQ15.tStopRefresh = tThisFlipGlobal
    thisExp.addData('SPQ15.stopped', SPQ15.tStop)
    # check responses
    if key_resp_60.keys in ['', [], None]:  # No response was made
        key_resp_60.keys = None
    thisExp.addData('key_resp_60.keys',key_resp_60.keys)
    if key_resp_60.keys != None:  # we had a response
        thisExp.addData('key_resp_60.rt', key_resp_60.rt)
        thisExp.addData('key_resp_60.duration', key_resp_60.duration)
    thisExp.nextEntry()
    # the Routine "SPQ15" was not non-slip safe, so reset the non-slip timer
    routineTimer.reset()
    
    # --- Prepare to start Routine "SPQ16" ---
    # create an object to store info about Routine SPQ16
    SPQ16 = data.Routine(
        name='SPQ16',
        components=[text_203, text_204, key_resp_61],
    )
    SPQ16.status = NOT_STARTED
    continueRoutine = True
    # update component parameters for each repeat
    # create starting attributes for key_resp_61
    key_resp_61.keys = []
    key_resp_61.rt = []
    _key_resp_61_allKeys = []
    # store start times for SPQ16
    SPQ16.tStartRefresh = win.getFutureFlipTime(clock=globalClock)
    SPQ16.tStart = globalClock.getTime(format='float')
    SPQ16.status = STARTED
    thisExp.addData('SPQ16.started', SPQ16.tStart)
    SPQ16.maxDuration = None
    # keep track of which components have finished
    SPQ16Components = SPQ16.components
    for thisComponent in SPQ16.components:
        thisComponent.tStart = None
        thisComponent.tStop = None
        thisComponent.tStartRefresh = None
        thisComponent.tStopRefresh = None
        if hasattr(thisComponent, 'status'):
            thisComponent.status = NOT_STARTED
    # reset timers
    t = 0
    _timeToFirstFrame = win.getFutureFlipTime(clock="now")
    frameN = -1
    
    # --- Run Routine "SPQ16" ---
    SPQ16.forceEnded = routineForceEnded = not continueRoutine
    while continueRoutine:
        # get current time
        t = routineTimer.getTime()
        tThisFlip = win.getFutureFlipTime(clock=routineTimer)
        tThisFlipGlobal = win.getFutureFlipTime(clock=None)
        frameN = frameN + 1  # number of completed frames (so 0 is the first frame)
        # update/draw components on each frame
        
        # *text_203* updates
        
        # if text_203 is starting this frame...
        if text_203.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
            # keep track of start time/frame for later
            text_203.frameNStart = frameN  # exact frame index
            text_203.tStart = t  # local t and not account for scr refresh
            text_203.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(text_203, 'tStartRefresh')  # time at next scr refresh
            # add timestamp to datafile
            thisExp.timestampOnFlip(win, 'text_203.started')
            # update status
            text_203.status = STARTED
            text_203.setAutoDraw(True)
        
        # if text_203 is active this frame...
        if text_203.status == STARTED:
            # update params
            pass
        
        # *text_204* updates
        
        # if text_204 is starting this frame...
        if text_204.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
            # keep track of start time/frame for later
            text_204.frameNStart = frameN  # exact frame index
            text_204.tStart = t  # local t and not account for scr refresh
            text_204.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(text_204, 'tStartRefresh')  # time at next scr refresh
            # add timestamp to datafile
            thisExp.timestampOnFlip(win, 'text_204.started')
            # update status
            text_204.status = STARTED
            text_204.setAutoDraw(True)
        
        # if text_204 is active this frame...
        if text_204.status == STARTED:
            # update params
            pass
        
        # *key_resp_61* updates
        waitOnFlip = False
        
        # if key_resp_61 is starting this frame...
        if key_resp_61.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
            # keep track of start time/frame for later
            key_resp_61.frameNStart = frameN  # exact frame index
            key_resp_61.tStart = t  # local t and not account for scr refresh
            key_resp_61.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(key_resp_61, 'tStartRefresh')  # time at next scr refresh
            # add timestamp to datafile
            thisExp.timestampOnFlip(win, 'key_resp_61.started')
            # update status
            key_resp_61.status = STARTED
            # keyboard checking is just starting
            waitOnFlip = True
            win.callOnFlip(key_resp_61.clock.reset)  # t=0 on next screen flip
            win.callOnFlip(key_resp_61.clearEvents, eventType='keyboard')  # clear events on next screen flip
        if key_resp_61.status == STARTED and not waitOnFlip:
            theseKeys = key_resp_61.getKeys(keyList=['y','n'], ignoreKeys=["escape"], waitRelease=False)
            _key_resp_61_allKeys.extend(theseKeys)
            if len(_key_resp_61_allKeys):
                key_resp_61.keys = _key_resp_61_allKeys[-1].name  # just the last key pressed
                key_resp_61.rt = _key_resp_61_allKeys[-1].rt
                key_resp_61.duration = _key_resp_61_allKeys[-1].duration
                # a response ends the routine
                continueRoutine = False
        
        # check for quit (typically the Esc key)
        if defaultKeyboard.getKeys(keyList=["escape"]):
            thisExp.status = FINISHED
        if thisExp.status == FINISHED or endExpNow:
            endExperiment(thisExp, win=win)
            return
        # pause experiment here if requested
        if thisExp.status == PAUSED:
            pauseExperiment(
                thisExp=thisExp, 
                win=win, 
                timers=[routineTimer], 
                playbackComponents=[]
            )
            # skip the frame we paused on
            continue
        
        # check if all components have finished
        if not continueRoutine:  # a component has requested a forced-end of Routine
            SPQ16.forceEnded = routineForceEnded = True
            break
        continueRoutine = False  # will revert to True if at least one component still running
        for thisComponent in SPQ16.components:
            if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:
                continueRoutine = True
                break  # at least one component has not yet finished
        
        # refresh the screen
        if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen
            win.flip()
    
    # --- Ending Routine "SPQ16" ---
    for thisComponent in SPQ16.components:
        if hasattr(thisComponent, "setAutoDraw"):
            thisComponent.setAutoDraw(False)
    # store stop times for SPQ16
    SPQ16.tStop = globalClock.getTime(format='float')
    SPQ16.tStopRefresh = tThisFlipGlobal
    thisExp.addData('SPQ16.stopped', SPQ16.tStop)
    # check responses
    if key_resp_61.keys in ['', [], None]:  # No response was made
        key_resp_61.keys = None
    thisExp.addData('key_resp_61.keys',key_resp_61.keys)
    if key_resp_61.keys != None:  # we had a response
        thisExp.addData('key_resp_61.rt', key_resp_61.rt)
        thisExp.addData('key_resp_61.duration', key_resp_61.duration)
    thisExp.nextEntry()
    # the Routine "SPQ16" was not non-slip safe, so reset the non-slip timer
    routineTimer.reset()
    
    # --- Prepare to start Routine "SPQ17" ---
    # create an object to store info about Routine SPQ17
    SPQ17 = data.Routine(
        name='SPQ17',
        components=[text_205, text_206, key_resp_62],
    )
    SPQ17.status = NOT_STARTED
    continueRoutine = True
    # update component parameters for each repeat
    # create starting attributes for key_resp_62
    key_resp_62.keys = []
    key_resp_62.rt = []
    _key_resp_62_allKeys = []
    # store start times for SPQ17
    SPQ17.tStartRefresh = win.getFutureFlipTime(clock=globalClock)
    SPQ17.tStart = globalClock.getTime(format='float')
    SPQ17.status = STARTED
    thisExp.addData('SPQ17.started', SPQ17.tStart)
    SPQ17.maxDuration = None
    # keep track of which components have finished
    SPQ17Components = SPQ17.components
    for thisComponent in SPQ17.components:
        thisComponent.tStart = None
        thisComponent.tStop = None
        thisComponent.tStartRefresh = None
        thisComponent.tStopRefresh = None
        if hasattr(thisComponent, 'status'):
            thisComponent.status = NOT_STARTED
    # reset timers
    t = 0
    _timeToFirstFrame = win.getFutureFlipTime(clock="now")
    frameN = -1
    
    # --- Run Routine "SPQ17" ---
    SPQ17.forceEnded = routineForceEnded = not continueRoutine
    while continueRoutine:
        # get current time
        t = routineTimer.getTime()
        tThisFlip = win.getFutureFlipTime(clock=routineTimer)
        tThisFlipGlobal = win.getFutureFlipTime(clock=None)
        frameN = frameN + 1  # number of completed frames (so 0 is the first frame)
        # update/draw components on each frame
        
        # *text_205* updates
        
        # if text_205 is starting this frame...
        if text_205.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
            # keep track of start time/frame for later
            text_205.frameNStart = frameN  # exact frame index
            text_205.tStart = t  # local t and not account for scr refresh
            text_205.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(text_205, 'tStartRefresh')  # time at next scr refresh
            # add timestamp to datafile
            thisExp.timestampOnFlip(win, 'text_205.started')
            # update status
            text_205.status = STARTED
            text_205.setAutoDraw(True)
        
        # if text_205 is active this frame...
        if text_205.status == STARTED:
            # update params
            pass
        
        # *text_206* updates
        
        # if text_206 is starting this frame...
        if text_206.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
            # keep track of start time/frame for later
            text_206.frameNStart = frameN  # exact frame index
            text_206.tStart = t  # local t and not account for scr refresh
            text_206.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(text_206, 'tStartRefresh')  # time at next scr refresh
            # add timestamp to datafile
            thisExp.timestampOnFlip(win, 'text_206.started')
            # update status
            text_206.status = STARTED
            text_206.setAutoDraw(True)
        
        # if text_206 is active this frame...
        if text_206.status == STARTED:
            # update params
            pass
        
        # *key_resp_62* updates
        waitOnFlip = False
        
        # if key_resp_62 is starting this frame...
        if key_resp_62.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
            # keep track of start time/frame for later
            key_resp_62.frameNStart = frameN  # exact frame index
            key_resp_62.tStart = t  # local t and not account for scr refresh
            key_resp_62.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(key_resp_62, 'tStartRefresh')  # time at next scr refresh
            # add timestamp to datafile
            thisExp.timestampOnFlip(win, 'key_resp_62.started')
            # update status
            key_resp_62.status = STARTED
            # keyboard checking is just starting
            waitOnFlip = True
            win.callOnFlip(key_resp_62.clock.reset)  # t=0 on next screen flip
            win.callOnFlip(key_resp_62.clearEvents, eventType='keyboard')  # clear events on next screen flip
        if key_resp_62.status == STARTED and not waitOnFlip:
            theseKeys = key_resp_62.getKeys(keyList=['y','n'], ignoreKeys=["escape"], waitRelease=False)
            _key_resp_62_allKeys.extend(theseKeys)
            if len(_key_resp_62_allKeys):
                key_resp_62.keys = _key_resp_62_allKeys[-1].name  # just the last key pressed
                key_resp_62.rt = _key_resp_62_allKeys[-1].rt
                key_resp_62.duration = _key_resp_62_allKeys[-1].duration
                # a response ends the routine
                continueRoutine = False
        
        # check for quit (typically the Esc key)
        if defaultKeyboard.getKeys(keyList=["escape"]):
            thisExp.status = FINISHED
        if thisExp.status == FINISHED or endExpNow:
            endExperiment(thisExp, win=win)
            return
        # pause experiment here if requested
        if thisExp.status == PAUSED:
            pauseExperiment(
                thisExp=thisExp, 
                win=win, 
                timers=[routineTimer], 
                playbackComponents=[]
            )
            # skip the frame we paused on
            continue
        
        # check if all components have finished
        if not continueRoutine:  # a component has requested a forced-end of Routine
            SPQ17.forceEnded = routineForceEnded = True
            break
        continueRoutine = False  # will revert to True if at least one component still running
        for thisComponent in SPQ17.components:
            if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:
                continueRoutine = True
                break  # at least one component has not yet finished
        
        # refresh the screen
        if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen
            win.flip()
    
    # --- Ending Routine "SPQ17" ---
    for thisComponent in SPQ17.components:
        if hasattr(thisComponent, "setAutoDraw"):
            thisComponent.setAutoDraw(False)
    # store stop times for SPQ17
    SPQ17.tStop = globalClock.getTime(format='float')
    SPQ17.tStopRefresh = tThisFlipGlobal
    thisExp.addData('SPQ17.stopped', SPQ17.tStop)
    # check responses
    if key_resp_62.keys in ['', [], None]:  # No response was made
        key_resp_62.keys = None
    thisExp.addData('key_resp_62.keys',key_resp_62.keys)
    if key_resp_62.keys != None:  # we had a response
        thisExp.addData('key_resp_62.rt', key_resp_62.rt)
        thisExp.addData('key_resp_62.duration', key_resp_62.duration)
    thisExp.nextEntry()
    # the Routine "SPQ17" was not non-slip safe, so reset the non-slip timer
    routineTimer.reset()
    
    # --- Prepare to start Routine "SPQ18" ---
    # create an object to store info about Routine SPQ18
    SPQ18 = data.Routine(
        name='SPQ18',
        components=[text_207, text_208, key_resp_63],
    )
    SPQ18.status = NOT_STARTED
    continueRoutine = True
    # update component parameters for each repeat
    # create starting attributes for key_resp_63
    key_resp_63.keys = []
    key_resp_63.rt = []
    _key_resp_63_allKeys = []
    # store start times for SPQ18
    SPQ18.tStartRefresh = win.getFutureFlipTime(clock=globalClock)
    SPQ18.tStart = globalClock.getTime(format='float')
    SPQ18.status = STARTED
    thisExp.addData('SPQ18.started', SPQ18.tStart)
    SPQ18.maxDuration = None
    # keep track of which components have finished
    SPQ18Components = SPQ18.components
    for thisComponent in SPQ18.components:
        thisComponent.tStart = None
        thisComponent.tStop = None
        thisComponent.tStartRefresh = None
        thisComponent.tStopRefresh = None
        if hasattr(thisComponent, 'status'):
            thisComponent.status = NOT_STARTED
    # reset timers
    t = 0
    _timeToFirstFrame = win.getFutureFlipTime(clock="now")
    frameN = -1
    
    # --- Run Routine "SPQ18" ---
    SPQ18.forceEnded = routineForceEnded = not continueRoutine
    while continueRoutine:
        # get current time
        t = routineTimer.getTime()
        tThisFlip = win.getFutureFlipTime(clock=routineTimer)
        tThisFlipGlobal = win.getFutureFlipTime(clock=None)
        frameN = frameN + 1  # number of completed frames (so 0 is the first frame)
        # update/draw components on each frame
        
        # *text_207* updates
        
        # if text_207 is starting this frame...
        if text_207.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
            # keep track of start time/frame for later
            text_207.frameNStart = frameN  # exact frame index
            text_207.tStart = t  # local t and not account for scr refresh
            text_207.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(text_207, 'tStartRefresh')  # time at next scr refresh
            # add timestamp to datafile
            thisExp.timestampOnFlip(win, 'text_207.started')
            # update status
            text_207.status = STARTED
            text_207.setAutoDraw(True)
        
        # if text_207 is active this frame...
        if text_207.status == STARTED:
            # update params
            pass
        
        # *text_208* updates
        
        # if text_208 is starting this frame...
        if text_208.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
            # keep track of start time/frame for later
            text_208.frameNStart = frameN  # exact frame index
            text_208.tStart = t  # local t and not account for scr refresh
            text_208.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(text_208, 'tStartRefresh')  # time at next scr refresh
            # add timestamp to datafile
            thisExp.timestampOnFlip(win, 'text_208.started')
            # update status
            text_208.status = STARTED
            text_208.setAutoDraw(True)
        
        # if text_208 is active this frame...
        if text_208.status == STARTED:
            # update params
            pass
        
        # *key_resp_63* updates
        waitOnFlip = False
        
        # if key_resp_63 is starting this frame...
        if key_resp_63.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
            # keep track of start time/frame for later
            key_resp_63.frameNStart = frameN  # exact frame index
            key_resp_63.tStart = t  # local t and not account for scr refresh
            key_resp_63.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(key_resp_63, 'tStartRefresh')  # time at next scr refresh
            # add timestamp to datafile
            thisExp.timestampOnFlip(win, 'key_resp_63.started')
            # update status
            key_resp_63.status = STARTED
            # keyboard checking is just starting
            waitOnFlip = True
            win.callOnFlip(key_resp_63.clock.reset)  # t=0 on next screen flip
            win.callOnFlip(key_resp_63.clearEvents, eventType='keyboard')  # clear events on next screen flip
        if key_resp_63.status == STARTED and not waitOnFlip:
            theseKeys = key_resp_63.getKeys(keyList=['y','n'], ignoreKeys=["escape"], waitRelease=False)
            _key_resp_63_allKeys.extend(theseKeys)
            if len(_key_resp_63_allKeys):
                key_resp_63.keys = _key_resp_63_allKeys[-1].name  # just the last key pressed
                key_resp_63.rt = _key_resp_63_allKeys[-1].rt
                key_resp_63.duration = _key_resp_63_allKeys[-1].duration
                # a response ends the routine
                continueRoutine = False
        
        # check for quit (typically the Esc key)
        if defaultKeyboard.getKeys(keyList=["escape"]):
            thisExp.status = FINISHED
        if thisExp.status == FINISHED or endExpNow:
            endExperiment(thisExp, win=win)
            return
        # pause experiment here if requested
        if thisExp.status == PAUSED:
            pauseExperiment(
                thisExp=thisExp, 
                win=win, 
                timers=[routineTimer], 
                playbackComponents=[]
            )
            # skip the frame we paused on
            continue
        
        # check if all components have finished
        if not continueRoutine:  # a component has requested a forced-end of Routine
            SPQ18.forceEnded = routineForceEnded = True
            break
        continueRoutine = False  # will revert to True if at least one component still running
        for thisComponent in SPQ18.components:
            if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:
                continueRoutine = True
                break  # at least one component has not yet finished
        
        # refresh the screen
        if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen
            win.flip()
    
    # --- Ending Routine "SPQ18" ---
    for thisComponent in SPQ18.components:
        if hasattr(thisComponent, "setAutoDraw"):
            thisComponent.setAutoDraw(False)
    # store stop times for SPQ18
    SPQ18.tStop = globalClock.getTime(format='float')
    SPQ18.tStopRefresh = tThisFlipGlobal
    thisExp.addData('SPQ18.stopped', SPQ18.tStop)
    # check responses
    if key_resp_63.keys in ['', [], None]:  # No response was made
        key_resp_63.keys = None
    thisExp.addData('key_resp_63.keys',key_resp_63.keys)
    if key_resp_63.keys != None:  # we had a response
        thisExp.addData('key_resp_63.rt', key_resp_63.rt)
        thisExp.addData('key_resp_63.duration', key_resp_63.duration)
    thisExp.nextEntry()
    # the Routine "SPQ18" was not non-slip safe, so reset the non-slip timer
    routineTimer.reset()
    
    # --- Prepare to start Routine "SPQ19" ---
    # create an object to store info about Routine SPQ19
    SPQ19 = data.Routine(
        name='SPQ19',
        components=[text_209, text_210, key_resp_64],
    )
    SPQ19.status = NOT_STARTED
    continueRoutine = True
    # update component parameters for each repeat
    # create starting attributes for key_resp_64
    key_resp_64.keys = []
    key_resp_64.rt = []
    _key_resp_64_allKeys = []
    # store start times for SPQ19
    SPQ19.tStartRefresh = win.getFutureFlipTime(clock=globalClock)
    SPQ19.tStart = globalClock.getTime(format='float')
    SPQ19.status = STARTED
    thisExp.addData('SPQ19.started', SPQ19.tStart)
    SPQ19.maxDuration = None
    # keep track of which components have finished
    SPQ19Components = SPQ19.components
    for thisComponent in SPQ19.components:
        thisComponent.tStart = None
        thisComponent.tStop = None
        thisComponent.tStartRefresh = None
        thisComponent.tStopRefresh = None
        if hasattr(thisComponent, 'status'):
            thisComponent.status = NOT_STARTED
    # reset timers
    t = 0
    _timeToFirstFrame = win.getFutureFlipTime(clock="now")
    frameN = -1
    
    # --- Run Routine "SPQ19" ---
    SPQ19.forceEnded = routineForceEnded = not continueRoutine
    while continueRoutine:
        # get current time
        t = routineTimer.getTime()
        tThisFlip = win.getFutureFlipTime(clock=routineTimer)
        tThisFlipGlobal = win.getFutureFlipTime(clock=None)
        frameN = frameN + 1  # number of completed frames (so 0 is the first frame)
        # update/draw components on each frame
        
        # *text_209* updates
        
        # if text_209 is starting this frame...
        if text_209.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
            # keep track of start time/frame for later
            text_209.frameNStart = frameN  # exact frame index
            text_209.tStart = t  # local t and not account for scr refresh
            text_209.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(text_209, 'tStartRefresh')  # time at next scr refresh
            # add timestamp to datafile
            thisExp.timestampOnFlip(win, 'text_209.started')
            # update status
            text_209.status = STARTED
            text_209.setAutoDraw(True)
        
        # if text_209 is active this frame...
        if text_209.status == STARTED:
            # update params
            pass
        
        # *text_210* updates
        
        # if text_210 is starting this frame...
        if text_210.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
            # keep track of start time/frame for later
            text_210.frameNStart = frameN  # exact frame index
            text_210.tStart = t  # local t and not account for scr refresh
            text_210.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(text_210, 'tStartRefresh')  # time at next scr refresh
            # add timestamp to datafile
            thisExp.timestampOnFlip(win, 'text_210.started')
            # update status
            text_210.status = STARTED
            text_210.setAutoDraw(True)
        
        # if text_210 is active this frame...
        if text_210.status == STARTED:
            # update params
            pass
        
        # *key_resp_64* updates
        waitOnFlip = False
        
        # if key_resp_64 is starting this frame...
        if key_resp_64.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
            # keep track of start time/frame for later
            key_resp_64.frameNStart = frameN  # exact frame index
            key_resp_64.tStart = t  # local t and not account for scr refresh
            key_resp_64.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(key_resp_64, 'tStartRefresh')  # time at next scr refresh
            # add timestamp to datafile
            thisExp.timestampOnFlip(win, 'key_resp_64.started')
            # update status
            key_resp_64.status = STARTED
            # keyboard checking is just starting
            waitOnFlip = True
            win.callOnFlip(key_resp_64.clock.reset)  # t=0 on next screen flip
            win.callOnFlip(key_resp_64.clearEvents, eventType='keyboard')  # clear events on next screen flip
        if key_resp_64.status == STARTED and not waitOnFlip:
            theseKeys = key_resp_64.getKeys(keyList=['y','n'], ignoreKeys=["escape"], waitRelease=False)
            _key_resp_64_allKeys.extend(theseKeys)
            if len(_key_resp_64_allKeys):
                key_resp_64.keys = _key_resp_64_allKeys[-1].name  # just the last key pressed
                key_resp_64.rt = _key_resp_64_allKeys[-1].rt
                key_resp_64.duration = _key_resp_64_allKeys[-1].duration
                # a response ends the routine
                continueRoutine = False
        
        # check for quit (typically the Esc key)
        if defaultKeyboard.getKeys(keyList=["escape"]):
            thisExp.status = FINISHED
        if thisExp.status == FINISHED or endExpNow:
            endExperiment(thisExp, win=win)
            return
        # pause experiment here if requested
        if thisExp.status == PAUSED:
            pauseExperiment(
                thisExp=thisExp, 
                win=win, 
                timers=[routineTimer], 
                playbackComponents=[]
            )
            # skip the frame we paused on
            continue
        
        # check if all components have finished
        if not continueRoutine:  # a component has requested a forced-end of Routine
            SPQ19.forceEnded = routineForceEnded = True
            break
        continueRoutine = False  # will revert to True if at least one component still running
        for thisComponent in SPQ19.components:
            if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:
                continueRoutine = True
                break  # at least one component has not yet finished
        
        # refresh the screen
        if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen
            win.flip()
    
    # --- Ending Routine "SPQ19" ---
    for thisComponent in SPQ19.components:
        if hasattr(thisComponent, "setAutoDraw"):
            thisComponent.setAutoDraw(False)
    # store stop times for SPQ19
    SPQ19.tStop = globalClock.getTime(format='float')
    SPQ19.tStopRefresh = tThisFlipGlobal
    thisExp.addData('SPQ19.stopped', SPQ19.tStop)
    # check responses
    if key_resp_64.keys in ['', [], None]:  # No response was made
        key_resp_64.keys = None
    thisExp.addData('key_resp_64.keys',key_resp_64.keys)
    if key_resp_64.keys != None:  # we had a response
        thisExp.addData('key_resp_64.rt', key_resp_64.rt)
        thisExp.addData('key_resp_64.duration', key_resp_64.duration)
    thisExp.nextEntry()
    # the Routine "SPQ19" was not non-slip safe, so reset the non-slip timer
    routineTimer.reset()
    
    # --- Prepare to start Routine "SPQ20" ---
    # create an object to store info about Routine SPQ20
    SPQ20 = data.Routine(
        name='SPQ20',
        components=[text_211, text_212, key_resp_65],
    )
    SPQ20.status = NOT_STARTED
    continueRoutine = True
    # update component parameters for each repeat
    # create starting attributes for key_resp_65
    key_resp_65.keys = []
    key_resp_65.rt = []
    _key_resp_65_allKeys = []
    # store start times for SPQ20
    SPQ20.tStartRefresh = win.getFutureFlipTime(clock=globalClock)
    SPQ20.tStart = globalClock.getTime(format='float')
    SPQ20.status = STARTED
    thisExp.addData('SPQ20.started', SPQ20.tStart)
    SPQ20.maxDuration = None
    # keep track of which components have finished
    SPQ20Components = SPQ20.components
    for thisComponent in SPQ20.components:
        thisComponent.tStart = None
        thisComponent.tStop = None
        thisComponent.tStartRefresh = None
        thisComponent.tStopRefresh = None
        if hasattr(thisComponent, 'status'):
            thisComponent.status = NOT_STARTED
    # reset timers
    t = 0
    _timeToFirstFrame = win.getFutureFlipTime(clock="now")
    frameN = -1
    
    # --- Run Routine "SPQ20" ---
    SPQ20.forceEnded = routineForceEnded = not continueRoutine
    while continueRoutine:
        # get current time
        t = routineTimer.getTime()
        tThisFlip = win.getFutureFlipTime(clock=routineTimer)
        tThisFlipGlobal = win.getFutureFlipTime(clock=None)
        frameN = frameN + 1  # number of completed frames (so 0 is the first frame)
        # update/draw components on each frame
        
        # *text_211* updates
        
        # if text_211 is starting this frame...
        if text_211.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
            # keep track of start time/frame for later
            text_211.frameNStart = frameN  # exact frame index
            text_211.tStart = t  # local t and not account for scr refresh
            text_211.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(text_211, 'tStartRefresh')  # time at next scr refresh
            # add timestamp to datafile
            thisExp.timestampOnFlip(win, 'text_211.started')
            # update status
            text_211.status = STARTED
            text_211.setAutoDraw(True)
        
        # if text_211 is active this frame...
        if text_211.status == STARTED:
            # update params
            pass
        
        # *text_212* updates
        
        # if text_212 is starting this frame...
        if text_212.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
            # keep track of start time/frame for later
            text_212.frameNStart = frameN  # exact frame index
            text_212.tStart = t  # local t and not account for scr refresh
            text_212.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(text_212, 'tStartRefresh')  # time at next scr refresh
            # add timestamp to datafile
            thisExp.timestampOnFlip(win, 'text_212.started')
            # update status
            text_212.status = STARTED
            text_212.setAutoDraw(True)
        
        # if text_212 is active this frame...
        if text_212.status == STARTED:
            # update params
            pass
        
        # *key_resp_65* updates
        waitOnFlip = False
        
        # if key_resp_65 is starting this frame...
        if key_resp_65.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
            # keep track of start time/frame for later
            key_resp_65.frameNStart = frameN  # exact frame index
            key_resp_65.tStart = t  # local t and not account for scr refresh
            key_resp_65.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(key_resp_65, 'tStartRefresh')  # time at next scr refresh
            # add timestamp to datafile
            thisExp.timestampOnFlip(win, 'key_resp_65.started')
            # update status
            key_resp_65.status = STARTED
            # keyboard checking is just starting
            waitOnFlip = True
            win.callOnFlip(key_resp_65.clock.reset)  # t=0 on next screen flip
            win.callOnFlip(key_resp_65.clearEvents, eventType='keyboard')  # clear events on next screen flip
        if key_resp_65.status == STARTED and not waitOnFlip:
            theseKeys = key_resp_65.getKeys(keyList=['y','n'], ignoreKeys=["escape"], waitRelease=False)
            _key_resp_65_allKeys.extend(theseKeys)
            if len(_key_resp_65_allKeys):
                key_resp_65.keys = _key_resp_65_allKeys[-1].name  # just the last key pressed
                key_resp_65.rt = _key_resp_65_allKeys[-1].rt
                key_resp_65.duration = _key_resp_65_allKeys[-1].duration
                # a response ends the routine
                continueRoutine = False
        
        # check for quit (typically the Esc key)
        if defaultKeyboard.getKeys(keyList=["escape"]):
            thisExp.status = FINISHED
        if thisExp.status == FINISHED or endExpNow:
            endExperiment(thisExp, win=win)
            return
        # pause experiment here if requested
        if thisExp.status == PAUSED:
            pauseExperiment(
                thisExp=thisExp, 
                win=win, 
                timers=[routineTimer], 
                playbackComponents=[]
            )
            # skip the frame we paused on
            continue
        
        # check if all components have finished
        if not continueRoutine:  # a component has requested a forced-end of Routine
            SPQ20.forceEnded = routineForceEnded = True
            break
        continueRoutine = False  # will revert to True if at least one component still running
        for thisComponent in SPQ20.components:
            if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:
                continueRoutine = True
                break  # at least one component has not yet finished
        
        # refresh the screen
        if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen
            win.flip()
    
    # --- Ending Routine "SPQ20" ---
    for thisComponent in SPQ20.components:
        if hasattr(thisComponent, "setAutoDraw"):
            thisComponent.setAutoDraw(False)
    # store stop times for SPQ20
    SPQ20.tStop = globalClock.getTime(format='float')
    SPQ20.tStopRefresh = tThisFlipGlobal
    thisExp.addData('SPQ20.stopped', SPQ20.tStop)
    # check responses
    if key_resp_65.keys in ['', [], None]:  # No response was made
        key_resp_65.keys = None
    thisExp.addData('key_resp_65.keys',key_resp_65.keys)
    if key_resp_65.keys != None:  # we had a response
        thisExp.addData('key_resp_65.rt', key_resp_65.rt)
        thisExp.addData('key_resp_65.duration', key_resp_65.duration)
    thisExp.nextEntry()
    # the Routine "SPQ20" was not non-slip safe, so reset the non-slip timer
    routineTimer.reset()
    
    # --- Prepare to start Routine "SPQ21" ---
    # create an object to store info about Routine SPQ21
    SPQ21 = data.Routine(
        name='SPQ21',
        components=[text_213, text_214, key_resp_66],
    )
    SPQ21.status = NOT_STARTED
    continueRoutine = True
    # update component parameters for each repeat
    # create starting attributes for key_resp_66
    key_resp_66.keys = []
    key_resp_66.rt = []
    _key_resp_66_allKeys = []
    # store start times for SPQ21
    SPQ21.tStartRefresh = win.getFutureFlipTime(clock=globalClock)
    SPQ21.tStart = globalClock.getTime(format='float')
    SPQ21.status = STARTED
    thisExp.addData('SPQ21.started', SPQ21.tStart)
    SPQ21.maxDuration = None
    # keep track of which components have finished
    SPQ21Components = SPQ21.components
    for thisComponent in SPQ21.components:
        thisComponent.tStart = None
        thisComponent.tStop = None
        thisComponent.tStartRefresh = None
        thisComponent.tStopRefresh = None
        if hasattr(thisComponent, 'status'):
            thisComponent.status = NOT_STARTED
    # reset timers
    t = 0
    _timeToFirstFrame = win.getFutureFlipTime(clock="now")
    frameN = -1
    
    # --- Run Routine "SPQ21" ---
    SPQ21.forceEnded = routineForceEnded = not continueRoutine
    while continueRoutine:
        # get current time
        t = routineTimer.getTime()
        tThisFlip = win.getFutureFlipTime(clock=routineTimer)
        tThisFlipGlobal = win.getFutureFlipTime(clock=None)
        frameN = frameN + 1  # number of completed frames (so 0 is the first frame)
        # update/draw components on each frame
        
        # *text_213* updates
        
        # if text_213 is starting this frame...
        if text_213.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
            # keep track of start time/frame for later
            text_213.frameNStart = frameN  # exact frame index
            text_213.tStart = t  # local t and not account for scr refresh
            text_213.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(text_213, 'tStartRefresh')  # time at next scr refresh
            # add timestamp to datafile
            thisExp.timestampOnFlip(win, 'text_213.started')
            # update status
            text_213.status = STARTED
            text_213.setAutoDraw(True)
        
        # if text_213 is active this frame...
        if text_213.status == STARTED:
            # update params
            pass
        
        # *text_214* updates
        
        # if text_214 is starting this frame...
        if text_214.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
            # keep track of start time/frame for later
            text_214.frameNStart = frameN  # exact frame index
            text_214.tStart = t  # local t and not account for scr refresh
            text_214.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(text_214, 'tStartRefresh')  # time at next scr refresh
            # add timestamp to datafile
            thisExp.timestampOnFlip(win, 'text_214.started')
            # update status
            text_214.status = STARTED
            text_214.setAutoDraw(True)
        
        # if text_214 is active this frame...
        if text_214.status == STARTED:
            # update params
            pass
        
        # *key_resp_66* updates
        waitOnFlip = False
        
        # if key_resp_66 is starting this frame...
        if key_resp_66.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
            # keep track of start time/frame for later
            key_resp_66.frameNStart = frameN  # exact frame index
            key_resp_66.tStart = t  # local t and not account for scr refresh
            key_resp_66.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(key_resp_66, 'tStartRefresh')  # time at next scr refresh
            # add timestamp to datafile
            thisExp.timestampOnFlip(win, 'key_resp_66.started')
            # update status
            key_resp_66.status = STARTED
            # keyboard checking is just starting
            waitOnFlip = True
            win.callOnFlip(key_resp_66.clock.reset)  # t=0 on next screen flip
            win.callOnFlip(key_resp_66.clearEvents, eventType='keyboard')  # clear events on next screen flip
        if key_resp_66.status == STARTED and not waitOnFlip:
            theseKeys = key_resp_66.getKeys(keyList=['y','n'], ignoreKeys=["escape"], waitRelease=False)
            _key_resp_66_allKeys.extend(theseKeys)
            if len(_key_resp_66_allKeys):
                key_resp_66.keys = _key_resp_66_allKeys[-1].name  # just the last key pressed
                key_resp_66.rt = _key_resp_66_allKeys[-1].rt
                key_resp_66.duration = _key_resp_66_allKeys[-1].duration
                # a response ends the routine
                continueRoutine = False
        
        # check for quit (typically the Esc key)
        if defaultKeyboard.getKeys(keyList=["escape"]):
            thisExp.status = FINISHED
        if thisExp.status == FINISHED or endExpNow:
            endExperiment(thisExp, win=win)
            return
        # pause experiment here if requested
        if thisExp.status == PAUSED:
            pauseExperiment(
                thisExp=thisExp, 
                win=win, 
                timers=[routineTimer], 
                playbackComponents=[]
            )
            # skip the frame we paused on
            continue
        
        # check if all components have finished
        if not continueRoutine:  # a component has requested a forced-end of Routine
            SPQ21.forceEnded = routineForceEnded = True
            break
        continueRoutine = False  # will revert to True if at least one component still running
        for thisComponent in SPQ21.components:
            if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:
                continueRoutine = True
                break  # at least one component has not yet finished
        
        # refresh the screen
        if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen
            win.flip()
    
    # --- Ending Routine "SPQ21" ---
    for thisComponent in SPQ21.components:
        if hasattr(thisComponent, "setAutoDraw"):
            thisComponent.setAutoDraw(False)
    # store stop times for SPQ21
    SPQ21.tStop = globalClock.getTime(format='float')
    SPQ21.tStopRefresh = tThisFlipGlobal
    thisExp.addData('SPQ21.stopped', SPQ21.tStop)
    # check responses
    if key_resp_66.keys in ['', [], None]:  # No response was made
        key_resp_66.keys = None
    thisExp.addData('key_resp_66.keys',key_resp_66.keys)
    if key_resp_66.keys != None:  # we had a response
        thisExp.addData('key_resp_66.rt', key_resp_66.rt)
        thisExp.addData('key_resp_66.duration', key_resp_66.duration)
    thisExp.nextEntry()
    # the Routine "SPQ21" was not non-slip safe, so reset the non-slip timer
    routineTimer.reset()
    
    # --- Prepare to start Routine "SPQ22" ---
    # create an object to store info about Routine SPQ22
    SPQ22 = data.Routine(
        name='SPQ22',
        components=[text_215, text_216, key_resp_67],
    )
    SPQ22.status = NOT_STARTED
    continueRoutine = True
    # update component parameters for each repeat
    # create starting attributes for key_resp_67
    key_resp_67.keys = []
    key_resp_67.rt = []
    _key_resp_67_allKeys = []
    # store start times for SPQ22
    SPQ22.tStartRefresh = win.getFutureFlipTime(clock=globalClock)
    SPQ22.tStart = globalClock.getTime(format='float')
    SPQ22.status = STARTED
    thisExp.addData('SPQ22.started', SPQ22.tStart)
    SPQ22.maxDuration = None
    # keep track of which components have finished
    SPQ22Components = SPQ22.components
    for thisComponent in SPQ22.components:
        thisComponent.tStart = None
        thisComponent.tStop = None
        thisComponent.tStartRefresh = None
        thisComponent.tStopRefresh = None
        if hasattr(thisComponent, 'status'):
            thisComponent.status = NOT_STARTED
    # reset timers
    t = 0
    _timeToFirstFrame = win.getFutureFlipTime(clock="now")
    frameN = -1
    
    # --- Run Routine "SPQ22" ---
    SPQ22.forceEnded = routineForceEnded = not continueRoutine
    while continueRoutine:
        # get current time
        t = routineTimer.getTime()
        tThisFlip = win.getFutureFlipTime(clock=routineTimer)
        tThisFlipGlobal = win.getFutureFlipTime(clock=None)
        frameN = frameN + 1  # number of completed frames (so 0 is the first frame)
        # update/draw components on each frame
        
        # *text_215* updates
        
        # if text_215 is starting this frame...
        if text_215.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
            # keep track of start time/frame for later
            text_215.frameNStart = frameN  # exact frame index
            text_215.tStart = t  # local t and not account for scr refresh
            text_215.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(text_215, 'tStartRefresh')  # time at next scr refresh
            # add timestamp to datafile
            thisExp.timestampOnFlip(win, 'text_215.started')
            # update status
            text_215.status = STARTED
            text_215.setAutoDraw(True)
        
        # if text_215 is active this frame...
        if text_215.status == STARTED:
            # update params
            pass
        
        # *text_216* updates
        
        # if text_216 is starting this frame...
        if text_216.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
            # keep track of start time/frame for later
            text_216.frameNStart = frameN  # exact frame index
            text_216.tStart = t  # local t and not account for scr refresh
            text_216.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(text_216, 'tStartRefresh')  # time at next scr refresh
            # add timestamp to datafile
            thisExp.timestampOnFlip(win, 'text_216.started')
            # update status
            text_216.status = STARTED
            text_216.setAutoDraw(True)
        
        # if text_216 is active this frame...
        if text_216.status == STARTED:
            # update params
            pass
        
        # *key_resp_67* updates
        waitOnFlip = False
        
        # if key_resp_67 is starting this frame...
        if key_resp_67.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
            # keep track of start time/frame for later
            key_resp_67.frameNStart = frameN  # exact frame index
            key_resp_67.tStart = t  # local t and not account for scr refresh
            key_resp_67.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(key_resp_67, 'tStartRefresh')  # time at next scr refresh
            # add timestamp to datafile
            thisExp.timestampOnFlip(win, 'key_resp_67.started')
            # update status
            key_resp_67.status = STARTED
            # keyboard checking is just starting
            waitOnFlip = True
            win.callOnFlip(key_resp_67.clock.reset)  # t=0 on next screen flip
            win.callOnFlip(key_resp_67.clearEvents, eventType='keyboard')  # clear events on next screen flip
        if key_resp_67.status == STARTED and not waitOnFlip:
            theseKeys = key_resp_67.getKeys(keyList=['y','n'], ignoreKeys=["escape"], waitRelease=False)
            _key_resp_67_allKeys.extend(theseKeys)
            if len(_key_resp_67_allKeys):
                key_resp_67.keys = _key_resp_67_allKeys[-1].name  # just the last key pressed
                key_resp_67.rt = _key_resp_67_allKeys[-1].rt
                key_resp_67.duration = _key_resp_67_allKeys[-1].duration
                # a response ends the routine
                continueRoutine = False
        
        # check for quit (typically the Esc key)
        if defaultKeyboard.getKeys(keyList=["escape"]):
            thisExp.status = FINISHED
        if thisExp.status == FINISHED or endExpNow:
            endExperiment(thisExp, win=win)
            return
        # pause experiment here if requested
        if thisExp.status == PAUSED:
            pauseExperiment(
                thisExp=thisExp, 
                win=win, 
                timers=[routineTimer], 
                playbackComponents=[]
            )
            # skip the frame we paused on
            continue
        
        # check if all components have finished
        if not continueRoutine:  # a component has requested a forced-end of Routine
            SPQ22.forceEnded = routineForceEnded = True
            break
        continueRoutine = False  # will revert to True if at least one component still running
        for thisComponent in SPQ22.components:
            if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:
                continueRoutine = True
                break  # at least one component has not yet finished
        
        # refresh the screen
        if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen
            win.flip()
    
    # --- Ending Routine "SPQ22" ---
    for thisComponent in SPQ22.components:
        if hasattr(thisComponent, "setAutoDraw"):
            thisComponent.setAutoDraw(False)
    # store stop times for SPQ22
    SPQ22.tStop = globalClock.getTime(format='float')
    SPQ22.tStopRefresh = tThisFlipGlobal
    thisExp.addData('SPQ22.stopped', SPQ22.tStop)
    # check responses
    if key_resp_67.keys in ['', [], None]:  # No response was made
        key_resp_67.keys = None
    thisExp.addData('key_resp_67.keys',key_resp_67.keys)
    if key_resp_67.keys != None:  # we had a response
        thisExp.addData('key_resp_67.rt', key_resp_67.rt)
        thisExp.addData('key_resp_67.duration', key_resp_67.duration)
    thisExp.nextEntry()
    # the Routine "SPQ22" was not non-slip safe, so reset the non-slip timer
    routineTimer.reset()
    
    # --- Prepare to start Routine "q4_instructions" ---
    # create an object to store info about Routine q4_instructions
    q4_instructions = data.Routine(
        name='q4_instructions',
        components=[text_172],
    )
    q4_instructions.status = NOT_STARTED
    continueRoutine = True
    # update component parameters for each repeat
    # store start times for q4_instructions
    q4_instructions.tStartRefresh = win.getFutureFlipTime(clock=globalClock)
    q4_instructions.tStart = globalClock.getTime(format='float')
    q4_instructions.status = STARTED
    thisExp.addData('q4_instructions.started', q4_instructions.tStart)
    q4_instructions.maxDuration = None
    # keep track of which components have finished
    q4_instructionsComponents = q4_instructions.components
    for thisComponent in q4_instructions.components:
        thisComponent.tStart = None
        thisComponent.tStop = None
        thisComponent.tStartRefresh = None
        thisComponent.tStopRefresh = None
        if hasattr(thisComponent, 'status'):
            thisComponent.status = NOT_STARTED
    # reset timers
    t = 0
    _timeToFirstFrame = win.getFutureFlipTime(clock="now")
    frameN = -1
    
    # --- Run Routine "q4_instructions" ---
    q4_instructions.forceEnded = routineForceEnded = not continueRoutine
    while continueRoutine and routineTimer.getTime() < 5.0:
        # get current time
        t = routineTimer.getTime()
        tThisFlip = win.getFutureFlipTime(clock=routineTimer)
        tThisFlipGlobal = win.getFutureFlipTime(clock=None)
        frameN = frameN + 1  # number of completed frames (so 0 is the first frame)
        # update/draw components on each frame
        
        # *text_172* updates
        
        # if text_172 is starting this frame...
        if text_172.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
            # keep track of start time/frame for later
            text_172.frameNStart = frameN  # exact frame index
            text_172.tStart = t  # local t and not account for scr refresh
            text_172.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(text_172, 'tStartRefresh')  # time at next scr refresh
            # add timestamp to datafile
            thisExp.timestampOnFlip(win, 'text_172.started')
            # update status
            text_172.status = STARTED
            text_172.setAutoDraw(True)
        
        # if text_172 is active this frame...
        if text_172.status == STARTED:
            # update params
            pass
        
        # if text_172 is stopping this frame...
        if text_172.status == STARTED:
            # is it time to stop? (based on global clock, using actual start)
            if tThisFlipGlobal > text_172.tStartRefresh + 5.0-frameTolerance:
                # keep track of stop time/frame for later
                text_172.tStop = t  # not accounting for scr refresh
                text_172.tStopRefresh = tThisFlipGlobal  # on global time
                text_172.frameNStop = frameN  # exact frame index
                # add timestamp to datafile
                thisExp.timestampOnFlip(win, 'text_172.stopped')
                # update status
                text_172.status = FINISHED
                text_172.setAutoDraw(False)
        
        # check for quit (typically the Esc key)
        if defaultKeyboard.getKeys(keyList=["escape"]):
            thisExp.status = FINISHED
        if thisExp.status == FINISHED or endExpNow:
            endExperiment(thisExp, win=win)
            return
        # pause experiment here if requested
        if thisExp.status == PAUSED:
            pauseExperiment(
                thisExp=thisExp, 
                win=win, 
                timers=[routineTimer], 
                playbackComponents=[]
            )
            # skip the frame we paused on
            continue
        
        # check if all components have finished
        if not continueRoutine:  # a component has requested a forced-end of Routine
            q4_instructions.forceEnded = routineForceEnded = True
            break
        continueRoutine = False  # will revert to True if at least one component still running
        for thisComponent in q4_instructions.components:
            if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:
                continueRoutine = True
                break  # at least one component has not yet finished
        
        # refresh the screen
        if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen
            win.flip()
    
    # --- Ending Routine "q4_instructions" ---
    for thisComponent in q4_instructions.components:
        if hasattr(thisComponent, "setAutoDraw"):
            thisComponent.setAutoDraw(False)
    # store stop times for q4_instructions
    q4_instructions.tStop = globalClock.getTime(format='float')
    q4_instructions.tStopRefresh = tThisFlipGlobal
    thisExp.addData('q4_instructions.stopped', q4_instructions.tStop)
    # using non-slip timing so subtract the expected duration of this Routine (unless ended on request)
    if q4_instructions.maxDurationReached:
        routineTimer.addTime(-q4_instructions.maxDuration)
    elif q4_instructions.forceEnded:
        routineTimer.reset()
    else:
        routineTimer.addTime(-5.000000)
    thisExp.nextEntry()
    
    # --- Prepare to start Routine "SS1" ---
    # create an object to store info about Routine SS1
    SS1 = data.Routine(
        name='SS1',
        components=[text_217, text_218, text_219, key_resp_68],
    )
    SS1.status = NOT_STARTED
    continueRoutine = True
    # update component parameters for each repeat
    # create starting attributes for key_resp_68
    key_resp_68.keys = []
    key_resp_68.rt = []
    _key_resp_68_allKeys = []
    # store start times for SS1
    SS1.tStartRefresh = win.getFutureFlipTime(clock=globalClock)
    SS1.tStart = globalClock.getTime(format='float')
    SS1.status = STARTED
    thisExp.addData('SS1.started', SS1.tStart)
    SS1.maxDuration = None
    # keep track of which components have finished
    SS1Components = SS1.components
    for thisComponent in SS1.components:
        thisComponent.tStart = None
        thisComponent.tStop = None
        thisComponent.tStartRefresh = None
        thisComponent.tStopRefresh = None
        if hasattr(thisComponent, 'status'):
            thisComponent.status = NOT_STARTED
    # reset timers
    t = 0
    _timeToFirstFrame = win.getFutureFlipTime(clock="now")
    frameN = -1
    
    # --- Run Routine "SS1" ---
    SS1.forceEnded = routineForceEnded = not continueRoutine
    while continueRoutine:
        # get current time
        t = routineTimer.getTime()
        tThisFlip = win.getFutureFlipTime(clock=routineTimer)
        tThisFlipGlobal = win.getFutureFlipTime(clock=None)
        frameN = frameN + 1  # number of completed frames (so 0 is the first frame)
        # update/draw components on each frame
        
        # *text_217* updates
        
        # if text_217 is starting this frame...
        if text_217.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
            # keep track of start time/frame for later
            text_217.frameNStart = frameN  # exact frame index
            text_217.tStart = t  # local t and not account for scr refresh
            text_217.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(text_217, 'tStartRefresh')  # time at next scr refresh
            # add timestamp to datafile
            thisExp.timestampOnFlip(win, 'text_217.started')
            # update status
            text_217.status = STARTED
            text_217.setAutoDraw(True)
        
        # if text_217 is active this frame...
        if text_217.status == STARTED:
            # update params
            pass
        
        # *text_218* updates
        
        # if text_218 is starting this frame...
        if text_218.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
            # keep track of start time/frame for later
            text_218.frameNStart = frameN  # exact frame index
            text_218.tStart = t  # local t and not account for scr refresh
            text_218.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(text_218, 'tStartRefresh')  # time at next scr refresh
            # add timestamp to datafile
            thisExp.timestampOnFlip(win, 'text_218.started')
            # update status
            text_218.status = STARTED
            text_218.setAutoDraw(True)
        
        # if text_218 is active this frame...
        if text_218.status == STARTED:
            # update params
            pass
        
        # *text_219* updates
        
        # if text_219 is starting this frame...
        if text_219.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
            # keep track of start time/frame for later
            text_219.frameNStart = frameN  # exact frame index
            text_219.tStart = t  # local t and not account for scr refresh
            text_219.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(text_219, 'tStartRefresh')  # time at next scr refresh
            # add timestamp to datafile
            thisExp.timestampOnFlip(win, 'text_219.started')
            # update status
            text_219.status = STARTED
            text_219.setAutoDraw(True)
        
        # if text_219 is active this frame...
        if text_219.status == STARTED:
            # update params
            pass
        
        # *key_resp_68* updates
        waitOnFlip = False
        
        # if key_resp_68 is starting this frame...
        if key_resp_68.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
            # keep track of start time/frame for later
            key_resp_68.frameNStart = frameN  # exact frame index
            key_resp_68.tStart = t  # local t and not account for scr refresh
            key_resp_68.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(key_resp_68, 'tStartRefresh')  # time at next scr refresh
            # add timestamp to datafile
            thisExp.timestampOnFlip(win, 'key_resp_68.started')
            # update status
            key_resp_68.status = STARTED
            # keyboard checking is just starting
            waitOnFlip = True
            win.callOnFlip(key_resp_68.clock.reset)  # t=0 on next screen flip
            win.callOnFlip(key_resp_68.clearEvents, eventType='keyboard')  # clear events on next screen flip
        if key_resp_68.status == STARTED and not waitOnFlip:
            theseKeys = key_resp_68.getKeys(keyList=[1,2,3,4,5,'1','2','3','4','5'], ignoreKeys=["escape"], waitRelease=False)
            _key_resp_68_allKeys.extend(theseKeys)
            if len(_key_resp_68_allKeys):
                key_resp_68.keys = _key_resp_68_allKeys[-1].name  # just the last key pressed
                key_resp_68.rt = _key_resp_68_allKeys[-1].rt
                key_resp_68.duration = _key_resp_68_allKeys[-1].duration
                # a response ends the routine
                continueRoutine = False
        
        # check for quit (typically the Esc key)
        if defaultKeyboard.getKeys(keyList=["escape"]):
            thisExp.status = FINISHED
        if thisExp.status == FINISHED or endExpNow:
            endExperiment(thisExp, win=win)
            return
        # pause experiment here if requested
        if thisExp.status == PAUSED:
            pauseExperiment(
                thisExp=thisExp, 
                win=win, 
                timers=[routineTimer], 
                playbackComponents=[]
            )
            # skip the frame we paused on
            continue
        
        # check if all components have finished
        if not continueRoutine:  # a component has requested a forced-end of Routine
            SS1.forceEnded = routineForceEnded = True
            break
        continueRoutine = False  # will revert to True if at least one component still running
        for thisComponent in SS1.components:
            if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:
                continueRoutine = True
                break  # at least one component has not yet finished
        
        # refresh the screen
        if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen
            win.flip()
    
    # --- Ending Routine "SS1" ---
    for thisComponent in SS1.components:
        if hasattr(thisComponent, "setAutoDraw"):
            thisComponent.setAutoDraw(False)
    # store stop times for SS1
    SS1.tStop = globalClock.getTime(format='float')
    SS1.tStopRefresh = tThisFlipGlobal
    thisExp.addData('SS1.stopped', SS1.tStop)
    # check responses
    if key_resp_68.keys in ['', [], None]:  # No response was made
        key_resp_68.keys = None
    thisExp.addData('key_resp_68.keys',key_resp_68.keys)
    if key_resp_68.keys != None:  # we had a response
        thisExp.addData('key_resp_68.rt', key_resp_68.rt)
        thisExp.addData('key_resp_68.duration', key_resp_68.duration)
    thisExp.nextEntry()
    # the Routine "SS1" was not non-slip safe, so reset the non-slip timer
    routineTimer.reset()
    
    # --- Prepare to start Routine "SS2" ---
    # create an object to store info about Routine SS2
    SS2 = data.Routine(
        name='SS2',
        components=[text_220, text_221, text_222, key_resp_69],
    )
    SS2.status = NOT_STARTED
    continueRoutine = True
    # update component parameters for each repeat
    # create starting attributes for key_resp_69
    key_resp_69.keys = []
    key_resp_69.rt = []
    _key_resp_69_allKeys = []
    # store start times for SS2
    SS2.tStartRefresh = win.getFutureFlipTime(clock=globalClock)
    SS2.tStart = globalClock.getTime(format='float')
    SS2.status = STARTED
    thisExp.addData('SS2.started', SS2.tStart)
    SS2.maxDuration = None
    # keep track of which components have finished
    SS2Components = SS2.components
    for thisComponent in SS2.components:
        thisComponent.tStart = None
        thisComponent.tStop = None
        thisComponent.tStartRefresh = None
        thisComponent.tStopRefresh = None
        if hasattr(thisComponent, 'status'):
            thisComponent.status = NOT_STARTED
    # reset timers
    t = 0
    _timeToFirstFrame = win.getFutureFlipTime(clock="now")
    frameN = -1
    
    # --- Run Routine "SS2" ---
    SS2.forceEnded = routineForceEnded = not continueRoutine
    while continueRoutine:
        # get current time
        t = routineTimer.getTime()
        tThisFlip = win.getFutureFlipTime(clock=routineTimer)
        tThisFlipGlobal = win.getFutureFlipTime(clock=None)
        frameN = frameN + 1  # number of completed frames (so 0 is the first frame)
        # update/draw components on each frame
        
        # *text_220* updates
        
        # if text_220 is starting this frame...
        if text_220.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
            # keep track of start time/frame for later
            text_220.frameNStart = frameN  # exact frame index
            text_220.tStart = t  # local t and not account for scr refresh
            text_220.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(text_220, 'tStartRefresh')  # time at next scr refresh
            # add timestamp to datafile
            thisExp.timestampOnFlip(win, 'text_220.started')
            # update status
            text_220.status = STARTED
            text_220.setAutoDraw(True)
        
        # if text_220 is active this frame...
        if text_220.status == STARTED:
            # update params
            pass
        
        # *text_221* updates
        
        # if text_221 is starting this frame...
        if text_221.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
            # keep track of start time/frame for later
            text_221.frameNStart = frameN  # exact frame index
            text_221.tStart = t  # local t and not account for scr refresh
            text_221.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(text_221, 'tStartRefresh')  # time at next scr refresh
            # add timestamp to datafile
            thisExp.timestampOnFlip(win, 'text_221.started')
            # update status
            text_221.status = STARTED
            text_221.setAutoDraw(True)
        
        # if text_221 is active this frame...
        if text_221.status == STARTED:
            # update params
            pass
        
        # *text_222* updates
        
        # if text_222 is starting this frame...
        if text_222.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
            # keep track of start time/frame for later
            text_222.frameNStart = frameN  # exact frame index
            text_222.tStart = t  # local t and not account for scr refresh
            text_222.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(text_222, 'tStartRefresh')  # time at next scr refresh
            # add timestamp to datafile
            thisExp.timestampOnFlip(win, 'text_222.started')
            # update status
            text_222.status = STARTED
            text_222.setAutoDraw(True)
        
        # if text_222 is active this frame...
        if text_222.status == STARTED:
            # update params
            pass
        
        # *key_resp_69* updates
        waitOnFlip = False
        
        # if key_resp_69 is starting this frame...
        if key_resp_69.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
            # keep track of start time/frame for later
            key_resp_69.frameNStart = frameN  # exact frame index
            key_resp_69.tStart = t  # local t and not account for scr refresh
            key_resp_69.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(key_resp_69, 'tStartRefresh')  # time at next scr refresh
            # add timestamp to datafile
            thisExp.timestampOnFlip(win, 'key_resp_69.started')
            # update status
            key_resp_69.status = STARTED
            # keyboard checking is just starting
            waitOnFlip = True
            win.callOnFlip(key_resp_69.clock.reset)  # t=0 on next screen flip
            win.callOnFlip(key_resp_69.clearEvents, eventType='keyboard')  # clear events on next screen flip
        if key_resp_69.status == STARTED and not waitOnFlip:
            theseKeys = key_resp_69.getKeys(keyList=[1,2,3,4,5,'1','2','3','4','5'], ignoreKeys=["escape"], waitRelease=False)
            _key_resp_69_allKeys.extend(theseKeys)
            if len(_key_resp_69_allKeys):
                key_resp_69.keys = _key_resp_69_allKeys[-1].name  # just the last key pressed
                key_resp_69.rt = _key_resp_69_allKeys[-1].rt
                key_resp_69.duration = _key_resp_69_allKeys[-1].duration
                # a response ends the routine
                continueRoutine = False
        
        # check for quit (typically the Esc key)
        if defaultKeyboard.getKeys(keyList=["escape"]):
            thisExp.status = FINISHED
        if thisExp.status == FINISHED or endExpNow:
            endExperiment(thisExp, win=win)
            return
        # pause experiment here if requested
        if thisExp.status == PAUSED:
            pauseExperiment(
                thisExp=thisExp, 
                win=win, 
                timers=[routineTimer], 
                playbackComponents=[]
            )
            # skip the frame we paused on
            continue
        
        # check if all components have finished
        if not continueRoutine:  # a component has requested a forced-end of Routine
            SS2.forceEnded = routineForceEnded = True
            break
        continueRoutine = False  # will revert to True if at least one component still running
        for thisComponent in SS2.components:
            if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:
                continueRoutine = True
                break  # at least one component has not yet finished
        
        # refresh the screen
        if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen
            win.flip()
    
    # --- Ending Routine "SS2" ---
    for thisComponent in SS2.components:
        if hasattr(thisComponent, "setAutoDraw"):
            thisComponent.setAutoDraw(False)
    # store stop times for SS2
    SS2.tStop = globalClock.getTime(format='float')
    SS2.tStopRefresh = tThisFlipGlobal
    thisExp.addData('SS2.stopped', SS2.tStop)
    # check responses
    if key_resp_69.keys in ['', [], None]:  # No response was made
        key_resp_69.keys = None
    thisExp.addData('key_resp_69.keys',key_resp_69.keys)
    if key_resp_69.keys != None:  # we had a response
        thisExp.addData('key_resp_69.rt', key_resp_69.rt)
        thisExp.addData('key_resp_69.duration', key_resp_69.duration)
    thisExp.nextEntry()
    # the Routine "SS2" was not non-slip safe, so reset the non-slip timer
    routineTimer.reset()
    
    # --- Prepare to start Routine "SS3" ---
    # create an object to store info about Routine SS3
    SS3 = data.Routine(
        name='SS3',
        components=[text_223, text_224, text_225, key_resp_70],
    )
    SS3.status = NOT_STARTED
    continueRoutine = True
    # update component parameters for each repeat
    # create starting attributes for key_resp_70
    key_resp_70.keys = []
    key_resp_70.rt = []
    _key_resp_70_allKeys = []
    # store start times for SS3
    SS3.tStartRefresh = win.getFutureFlipTime(clock=globalClock)
    SS3.tStart = globalClock.getTime(format='float')
    SS3.status = STARTED
    thisExp.addData('SS3.started', SS3.tStart)
    SS3.maxDuration = None
    # keep track of which components have finished
    SS3Components = SS3.components
    for thisComponent in SS3.components:
        thisComponent.tStart = None
        thisComponent.tStop = None
        thisComponent.tStartRefresh = None
        thisComponent.tStopRefresh = None
        if hasattr(thisComponent, 'status'):
            thisComponent.status = NOT_STARTED
    # reset timers
    t = 0
    _timeToFirstFrame = win.getFutureFlipTime(clock="now")
    frameN = -1
    
    # --- Run Routine "SS3" ---
    SS3.forceEnded = routineForceEnded = not continueRoutine
    while continueRoutine:
        # get current time
        t = routineTimer.getTime()
        tThisFlip = win.getFutureFlipTime(clock=routineTimer)
        tThisFlipGlobal = win.getFutureFlipTime(clock=None)
        frameN = frameN + 1  # number of completed frames (so 0 is the first frame)
        # update/draw components on each frame
        
        # *text_223* updates
        
        # if text_223 is starting this frame...
        if text_223.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
            # keep track of start time/frame for later
            text_223.frameNStart = frameN  # exact frame index
            text_223.tStart = t  # local t and not account for scr refresh
            text_223.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(text_223, 'tStartRefresh')  # time at next scr refresh
            # add timestamp to datafile
            thisExp.timestampOnFlip(win, 'text_223.started')
            # update status
            text_223.status = STARTED
            text_223.setAutoDraw(True)
        
        # if text_223 is active this frame...
        if text_223.status == STARTED:
            # update params
            pass
        
        # *text_224* updates
        
        # if text_224 is starting this frame...
        if text_224.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
            # keep track of start time/frame for later
            text_224.frameNStart = frameN  # exact frame index
            text_224.tStart = t  # local t and not account for scr refresh
            text_224.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(text_224, 'tStartRefresh')  # time at next scr refresh
            # add timestamp to datafile
            thisExp.timestampOnFlip(win, 'text_224.started')
            # update status
            text_224.status = STARTED
            text_224.setAutoDraw(True)
        
        # if text_224 is active this frame...
        if text_224.status == STARTED:
            # update params
            pass
        
        # *text_225* updates
        
        # if text_225 is starting this frame...
        if text_225.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
            # keep track of start time/frame for later
            text_225.frameNStart = frameN  # exact frame index
            text_225.tStart = t  # local t and not account for scr refresh
            text_225.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(text_225, 'tStartRefresh')  # time at next scr refresh
            # add timestamp to datafile
            thisExp.timestampOnFlip(win, 'text_225.started')
            # update status
            text_225.status = STARTED
            text_225.setAutoDraw(True)
        
        # if text_225 is active this frame...
        if text_225.status == STARTED:
            # update params
            pass
        
        # *key_resp_70* updates
        waitOnFlip = False
        
        # if key_resp_70 is starting this frame...
        if key_resp_70.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
            # keep track of start time/frame for later
            key_resp_70.frameNStart = frameN  # exact frame index
            key_resp_70.tStart = t  # local t and not account for scr refresh
            key_resp_70.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(key_resp_70, 'tStartRefresh')  # time at next scr refresh
            # add timestamp to datafile
            thisExp.timestampOnFlip(win, 'key_resp_70.started')
            # update status
            key_resp_70.status = STARTED
            # keyboard checking is just starting
            waitOnFlip = True
            win.callOnFlip(key_resp_70.clock.reset)  # t=0 on next screen flip
            win.callOnFlip(key_resp_70.clearEvents, eventType='keyboard')  # clear events on next screen flip
        if key_resp_70.status == STARTED and not waitOnFlip:
            theseKeys = key_resp_70.getKeys(keyList=[1,2,3,4,5,'1','2','3','4','5'], ignoreKeys=["escape"], waitRelease=False)
            _key_resp_70_allKeys.extend(theseKeys)
            if len(_key_resp_70_allKeys):
                key_resp_70.keys = _key_resp_70_allKeys[-1].name  # just the last key pressed
                key_resp_70.rt = _key_resp_70_allKeys[-1].rt
                key_resp_70.duration = _key_resp_70_allKeys[-1].duration
                # a response ends the routine
                continueRoutine = False
        
        # check for quit (typically the Esc key)
        if defaultKeyboard.getKeys(keyList=["escape"]):
            thisExp.status = FINISHED
        if thisExp.status == FINISHED or endExpNow:
            endExperiment(thisExp, win=win)
            return
        # pause experiment here if requested
        if thisExp.status == PAUSED:
            pauseExperiment(
                thisExp=thisExp, 
                win=win, 
                timers=[routineTimer], 
                playbackComponents=[]
            )
            # skip the frame we paused on
            continue
        
        # check if all components have finished
        if not continueRoutine:  # a component has requested a forced-end of Routine
            SS3.forceEnded = routineForceEnded = True
            break
        continueRoutine = False  # will revert to True if at least one component still running
        for thisComponent in SS3.components:
            if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:
                continueRoutine = True
                break  # at least one component has not yet finished
        
        # refresh the screen
        if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen
            win.flip()
    
    # --- Ending Routine "SS3" ---
    for thisComponent in SS3.components:
        if hasattr(thisComponent, "setAutoDraw"):
            thisComponent.setAutoDraw(False)
    # store stop times for SS3
    SS3.tStop = globalClock.getTime(format='float')
    SS3.tStopRefresh = tThisFlipGlobal
    thisExp.addData('SS3.stopped', SS3.tStop)
    # check responses
    if key_resp_70.keys in ['', [], None]:  # No response was made
        key_resp_70.keys = None
    thisExp.addData('key_resp_70.keys',key_resp_70.keys)
    if key_resp_70.keys != None:  # we had a response
        thisExp.addData('key_resp_70.rt', key_resp_70.rt)
        thisExp.addData('key_resp_70.duration', key_resp_70.duration)
    thisExp.nextEntry()
    # the Routine "SS3" was not non-slip safe, so reset the non-slip timer
    routineTimer.reset()
    
    # --- Prepare to start Routine "SS4" ---
    # create an object to store info about Routine SS4
    SS4 = data.Routine(
        name='SS4',
        components=[text_226, text_227, text_228, key_resp_71],
    )
    SS4.status = NOT_STARTED
    continueRoutine = True
    # update component parameters for each repeat
    # create starting attributes for key_resp_71
    key_resp_71.keys = []
    key_resp_71.rt = []
    _key_resp_71_allKeys = []
    # store start times for SS4
    SS4.tStartRefresh = win.getFutureFlipTime(clock=globalClock)
    SS4.tStart = globalClock.getTime(format='float')
    SS4.status = STARTED
    thisExp.addData('SS4.started', SS4.tStart)
    SS4.maxDuration = None
    # keep track of which components have finished
    SS4Components = SS4.components
    for thisComponent in SS4.components:
        thisComponent.tStart = None
        thisComponent.tStop = None
        thisComponent.tStartRefresh = None
        thisComponent.tStopRefresh = None
        if hasattr(thisComponent, 'status'):
            thisComponent.status = NOT_STARTED
    # reset timers
    t = 0
    _timeToFirstFrame = win.getFutureFlipTime(clock="now")
    frameN = -1
    
    # --- Run Routine "SS4" ---
    SS4.forceEnded = routineForceEnded = not continueRoutine
    while continueRoutine:
        # get current time
        t = routineTimer.getTime()
        tThisFlip = win.getFutureFlipTime(clock=routineTimer)
        tThisFlipGlobal = win.getFutureFlipTime(clock=None)
        frameN = frameN + 1  # number of completed frames (so 0 is the first frame)
        # update/draw components on each frame
        
        # *text_226* updates
        
        # if text_226 is starting this frame...
        if text_226.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
            # keep track of start time/frame for later
            text_226.frameNStart = frameN  # exact frame index
            text_226.tStart = t  # local t and not account for scr refresh
            text_226.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(text_226, 'tStartRefresh')  # time at next scr refresh
            # add timestamp to datafile
            thisExp.timestampOnFlip(win, 'text_226.started')
            # update status
            text_226.status = STARTED
            text_226.setAutoDraw(True)
        
        # if text_226 is active this frame...
        if text_226.status == STARTED:
            # update params
            pass
        
        # *text_227* updates
        
        # if text_227 is starting this frame...
        if text_227.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
            # keep track of start time/frame for later
            text_227.frameNStart = frameN  # exact frame index
            text_227.tStart = t  # local t and not account for scr refresh
            text_227.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(text_227, 'tStartRefresh')  # time at next scr refresh
            # add timestamp to datafile
            thisExp.timestampOnFlip(win, 'text_227.started')
            # update status
            text_227.status = STARTED
            text_227.setAutoDraw(True)
        
        # if text_227 is active this frame...
        if text_227.status == STARTED:
            # update params
            pass
        
        # *text_228* updates
        
        # if text_228 is starting this frame...
        if text_228.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
            # keep track of start time/frame for later
            text_228.frameNStart = frameN  # exact frame index
            text_228.tStart = t  # local t and not account for scr refresh
            text_228.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(text_228, 'tStartRefresh')  # time at next scr refresh
            # add timestamp to datafile
            thisExp.timestampOnFlip(win, 'text_228.started')
            # update status
            text_228.status = STARTED
            text_228.setAutoDraw(True)
        
        # if text_228 is active this frame...
        if text_228.status == STARTED:
            # update params
            pass
        
        # *key_resp_71* updates
        waitOnFlip = False
        
        # if key_resp_71 is starting this frame...
        if key_resp_71.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
            # keep track of start time/frame for later
            key_resp_71.frameNStart = frameN  # exact frame index
            key_resp_71.tStart = t  # local t and not account for scr refresh
            key_resp_71.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(key_resp_71, 'tStartRefresh')  # time at next scr refresh
            # add timestamp to datafile
            thisExp.timestampOnFlip(win, 'key_resp_71.started')
            # update status
            key_resp_71.status = STARTED
            # keyboard checking is just starting
            waitOnFlip = True
            win.callOnFlip(key_resp_71.clock.reset)  # t=0 on next screen flip
            win.callOnFlip(key_resp_71.clearEvents, eventType='keyboard')  # clear events on next screen flip
        if key_resp_71.status == STARTED and not waitOnFlip:
            theseKeys = key_resp_71.getKeys(keyList=[1,2,3,4,5,'1','2','3','4','5'], ignoreKeys=["escape"], waitRelease=False)
            _key_resp_71_allKeys.extend(theseKeys)
            if len(_key_resp_71_allKeys):
                key_resp_71.keys = _key_resp_71_allKeys[-1].name  # just the last key pressed
                key_resp_71.rt = _key_resp_71_allKeys[-1].rt
                key_resp_71.duration = _key_resp_71_allKeys[-1].duration
                # a response ends the routine
                continueRoutine = False
        
        # check for quit (typically the Esc key)
        if defaultKeyboard.getKeys(keyList=["escape"]):
            thisExp.status = FINISHED
        if thisExp.status == FINISHED or endExpNow:
            endExperiment(thisExp, win=win)
            return
        # pause experiment here if requested
        if thisExp.status == PAUSED:
            pauseExperiment(
                thisExp=thisExp, 
                win=win, 
                timers=[routineTimer], 
                playbackComponents=[]
            )
            # skip the frame we paused on
            continue
        
        # check if all components have finished
        if not continueRoutine:  # a component has requested a forced-end of Routine
            SS4.forceEnded = routineForceEnded = True
            break
        continueRoutine = False  # will revert to True if at least one component still running
        for thisComponent in SS4.components:
            if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:
                continueRoutine = True
                break  # at least one component has not yet finished
        
        # refresh the screen
        if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen
            win.flip()
    
    # --- Ending Routine "SS4" ---
    for thisComponent in SS4.components:
        if hasattr(thisComponent, "setAutoDraw"):
            thisComponent.setAutoDraw(False)
    # store stop times for SS4
    SS4.tStop = globalClock.getTime(format='float')
    SS4.tStopRefresh = tThisFlipGlobal
    thisExp.addData('SS4.stopped', SS4.tStop)
    # check responses
    if key_resp_71.keys in ['', [], None]:  # No response was made
        key_resp_71.keys = None
    thisExp.addData('key_resp_71.keys',key_resp_71.keys)
    if key_resp_71.keys != None:  # we had a response
        thisExp.addData('key_resp_71.rt', key_resp_71.rt)
        thisExp.addData('key_resp_71.duration', key_resp_71.duration)
    thisExp.nextEntry()
    # the Routine "SS4" was not non-slip safe, so reset the non-slip timer
    routineTimer.reset()
    
    # --- Prepare to start Routine "SS5" ---
    # create an object to store info about Routine SS5
    SS5 = data.Routine(
        name='SS5',
        components=[text_229, text_230, text_231, key_resp_72],
    )
    SS5.status = NOT_STARTED
    continueRoutine = True
    # update component parameters for each repeat
    # create starting attributes for key_resp_72
    key_resp_72.keys = []
    key_resp_72.rt = []
    _key_resp_72_allKeys = []
    # store start times for SS5
    SS5.tStartRefresh = win.getFutureFlipTime(clock=globalClock)
    SS5.tStart = globalClock.getTime(format='float')
    SS5.status = STARTED
    thisExp.addData('SS5.started', SS5.tStart)
    SS5.maxDuration = None
    # keep track of which components have finished
    SS5Components = SS5.components
    for thisComponent in SS5.components:
        thisComponent.tStart = None
        thisComponent.tStop = None
        thisComponent.tStartRefresh = None
        thisComponent.tStopRefresh = None
        if hasattr(thisComponent, 'status'):
            thisComponent.status = NOT_STARTED
    # reset timers
    t = 0
    _timeToFirstFrame = win.getFutureFlipTime(clock="now")
    frameN = -1
    
    # --- Run Routine "SS5" ---
    SS5.forceEnded = routineForceEnded = not continueRoutine
    while continueRoutine:
        # get current time
        t = routineTimer.getTime()
        tThisFlip = win.getFutureFlipTime(clock=routineTimer)
        tThisFlipGlobal = win.getFutureFlipTime(clock=None)
        frameN = frameN + 1  # number of completed frames (so 0 is the first frame)
        # update/draw components on each frame
        
        # *text_229* updates
        
        # if text_229 is starting this frame...
        if text_229.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
            # keep track of start time/frame for later
            text_229.frameNStart = frameN  # exact frame index
            text_229.tStart = t  # local t and not account for scr refresh
            text_229.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(text_229, 'tStartRefresh')  # time at next scr refresh
            # add timestamp to datafile
            thisExp.timestampOnFlip(win, 'text_229.started')
            # update status
            text_229.status = STARTED
            text_229.setAutoDraw(True)
        
        # if text_229 is active this frame...
        if text_229.status == STARTED:
            # update params
            pass
        
        # *text_230* updates
        
        # if text_230 is starting this frame...
        if text_230.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
            # keep track of start time/frame for later
            text_230.frameNStart = frameN  # exact frame index
            text_230.tStart = t  # local t and not account for scr refresh
            text_230.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(text_230, 'tStartRefresh')  # time at next scr refresh
            # add timestamp to datafile
            thisExp.timestampOnFlip(win, 'text_230.started')
            # update status
            text_230.status = STARTED
            text_230.setAutoDraw(True)
        
        # if text_230 is active this frame...
        if text_230.status == STARTED:
            # update params
            pass
        
        # *text_231* updates
        
        # if text_231 is starting this frame...
        if text_231.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
            # keep track of start time/frame for later
            text_231.frameNStart = frameN  # exact frame index
            text_231.tStart = t  # local t and not account for scr refresh
            text_231.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(text_231, 'tStartRefresh')  # time at next scr refresh
            # add timestamp to datafile
            thisExp.timestampOnFlip(win, 'text_231.started')
            # update status
            text_231.status = STARTED
            text_231.setAutoDraw(True)
        
        # if text_231 is active this frame...
        if text_231.status == STARTED:
            # update params
            pass
        
        # *key_resp_72* updates
        waitOnFlip = False
        
        # if key_resp_72 is starting this frame...
        if key_resp_72.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
            # keep track of start time/frame for later
            key_resp_72.frameNStart = frameN  # exact frame index
            key_resp_72.tStart = t  # local t and not account for scr refresh
            key_resp_72.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(key_resp_72, 'tStartRefresh')  # time at next scr refresh
            # add timestamp to datafile
            thisExp.timestampOnFlip(win, 'key_resp_72.started')
            # update status
            key_resp_72.status = STARTED
            # keyboard checking is just starting
            waitOnFlip = True
            win.callOnFlip(key_resp_72.clock.reset)  # t=0 on next screen flip
            win.callOnFlip(key_resp_72.clearEvents, eventType='keyboard')  # clear events on next screen flip
        if key_resp_72.status == STARTED and not waitOnFlip:
            theseKeys = key_resp_72.getKeys(keyList=[1,2,3,4,5,'1','2','3','4','5'], ignoreKeys=["escape"], waitRelease=False)
            _key_resp_72_allKeys.extend(theseKeys)
            if len(_key_resp_72_allKeys):
                key_resp_72.keys = _key_resp_72_allKeys[-1].name  # just the last key pressed
                key_resp_72.rt = _key_resp_72_allKeys[-1].rt
                key_resp_72.duration = _key_resp_72_allKeys[-1].duration
                # a response ends the routine
                continueRoutine = False
        
        # check for quit (typically the Esc key)
        if defaultKeyboard.getKeys(keyList=["escape"]):
            thisExp.status = FINISHED
        if thisExp.status == FINISHED or endExpNow:
            endExperiment(thisExp, win=win)
            return
        # pause experiment here if requested
        if thisExp.status == PAUSED:
            pauseExperiment(
                thisExp=thisExp, 
                win=win, 
                timers=[routineTimer], 
                playbackComponents=[]
            )
            # skip the frame we paused on
            continue
        
        # check if all components have finished
        if not continueRoutine:  # a component has requested a forced-end of Routine
            SS5.forceEnded = routineForceEnded = True
            break
        continueRoutine = False  # will revert to True if at least one component still running
        for thisComponent in SS5.components:
            if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:
                continueRoutine = True
                break  # at least one component has not yet finished
        
        # refresh the screen
        if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen
            win.flip()
    
    # --- Ending Routine "SS5" ---
    for thisComponent in SS5.components:
        if hasattr(thisComponent, "setAutoDraw"):
            thisComponent.setAutoDraw(False)
    # store stop times for SS5
    SS5.tStop = globalClock.getTime(format='float')
    SS5.tStopRefresh = tThisFlipGlobal
    thisExp.addData('SS5.stopped', SS5.tStop)
    # check responses
    if key_resp_72.keys in ['', [], None]:  # No response was made
        key_resp_72.keys = None
    thisExp.addData('key_resp_72.keys',key_resp_72.keys)
    if key_resp_72.keys != None:  # we had a response
        thisExp.addData('key_resp_72.rt', key_resp_72.rt)
        thisExp.addData('key_resp_72.duration', key_resp_72.duration)
    thisExp.nextEntry()
    # the Routine "SS5" was not non-slip safe, so reset the non-slip timer
    routineTimer.reset()
    
    # --- Prepare to start Routine "SS6" ---
    # create an object to store info about Routine SS6
    SS6 = data.Routine(
        name='SS6',
        components=[text_232, text_233, text_234, key_resp_73],
    )
    SS6.status = NOT_STARTED
    continueRoutine = True
    # update component parameters for each repeat
    # create starting attributes for key_resp_73
    key_resp_73.keys = []
    key_resp_73.rt = []
    _key_resp_73_allKeys = []
    # store start times for SS6
    SS6.tStartRefresh = win.getFutureFlipTime(clock=globalClock)
    SS6.tStart = globalClock.getTime(format='float')
    SS6.status = STARTED
    thisExp.addData('SS6.started', SS6.tStart)
    SS6.maxDuration = None
    # keep track of which components have finished
    SS6Components = SS6.components
    for thisComponent in SS6.components:
        thisComponent.tStart = None
        thisComponent.tStop = None
        thisComponent.tStartRefresh = None
        thisComponent.tStopRefresh = None
        if hasattr(thisComponent, 'status'):
            thisComponent.status = NOT_STARTED
    # reset timers
    t = 0
    _timeToFirstFrame = win.getFutureFlipTime(clock="now")
    frameN = -1
    
    # --- Run Routine "SS6" ---
    SS6.forceEnded = routineForceEnded = not continueRoutine
    while continueRoutine:
        # get current time
        t = routineTimer.getTime()
        tThisFlip = win.getFutureFlipTime(clock=routineTimer)
        tThisFlipGlobal = win.getFutureFlipTime(clock=None)
        frameN = frameN + 1  # number of completed frames (so 0 is the first frame)
        # update/draw components on each frame
        
        # *text_232* updates
        
        # if text_232 is starting this frame...
        if text_232.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
            # keep track of start time/frame for later
            text_232.frameNStart = frameN  # exact frame index
            text_232.tStart = t  # local t and not account for scr refresh
            text_232.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(text_232, 'tStartRefresh')  # time at next scr refresh
            # add timestamp to datafile
            thisExp.timestampOnFlip(win, 'text_232.started')
            # update status
            text_232.status = STARTED
            text_232.setAutoDraw(True)
        
        # if text_232 is active this frame...
        if text_232.status == STARTED:
            # update params
            pass
        
        # *text_233* updates
        
        # if text_233 is starting this frame...
        if text_233.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
            # keep track of start time/frame for later
            text_233.frameNStart = frameN  # exact frame index
            text_233.tStart = t  # local t and not account for scr refresh
            text_233.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(text_233, 'tStartRefresh')  # time at next scr refresh
            # add timestamp to datafile
            thisExp.timestampOnFlip(win, 'text_233.started')
            # update status
            text_233.status = STARTED
            text_233.setAutoDraw(True)
        
        # if text_233 is active this frame...
        if text_233.status == STARTED:
            # update params
            pass
        
        # *text_234* updates
        
        # if text_234 is starting this frame...
        if text_234.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
            # keep track of start time/frame for later
            text_234.frameNStart = frameN  # exact frame index
            text_234.tStart = t  # local t and not account for scr refresh
            text_234.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(text_234, 'tStartRefresh')  # time at next scr refresh
            # add timestamp to datafile
            thisExp.timestampOnFlip(win, 'text_234.started')
            # update status
            text_234.status = STARTED
            text_234.setAutoDraw(True)
        
        # if text_234 is active this frame...
        if text_234.status == STARTED:
            # update params
            pass
        
        # *key_resp_73* updates
        waitOnFlip = False
        
        # if key_resp_73 is starting this frame...
        if key_resp_73.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
            # keep track of start time/frame for later
            key_resp_73.frameNStart = frameN  # exact frame index
            key_resp_73.tStart = t  # local t and not account for scr refresh
            key_resp_73.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(key_resp_73, 'tStartRefresh')  # time at next scr refresh
            # add timestamp to datafile
            thisExp.timestampOnFlip(win, 'key_resp_73.started')
            # update status
            key_resp_73.status = STARTED
            # keyboard checking is just starting
            waitOnFlip = True
            win.callOnFlip(key_resp_73.clock.reset)  # t=0 on next screen flip
            win.callOnFlip(key_resp_73.clearEvents, eventType='keyboard')  # clear events on next screen flip
        if key_resp_73.status == STARTED and not waitOnFlip:
            theseKeys = key_resp_73.getKeys(keyList=[1,2,3,4,5,'1','2','3','4','5'], ignoreKeys=["escape"], waitRelease=False)
            _key_resp_73_allKeys.extend(theseKeys)
            if len(_key_resp_73_allKeys):
                key_resp_73.keys = _key_resp_73_allKeys[-1].name  # just the last key pressed
                key_resp_73.rt = _key_resp_73_allKeys[-1].rt
                key_resp_73.duration = _key_resp_73_allKeys[-1].duration
                # a response ends the routine
                continueRoutine = False
        
        # check for quit (typically the Esc key)
        if defaultKeyboard.getKeys(keyList=["escape"]):
            thisExp.status = FINISHED
        if thisExp.status == FINISHED or endExpNow:
            endExperiment(thisExp, win=win)
            return
        # pause experiment here if requested
        if thisExp.status == PAUSED:
            pauseExperiment(
                thisExp=thisExp, 
                win=win, 
                timers=[routineTimer], 
                playbackComponents=[]
            )
            # skip the frame we paused on
            continue
        
        # check if all components have finished
        if not continueRoutine:  # a component has requested a forced-end of Routine
            SS6.forceEnded = routineForceEnded = True
            break
        continueRoutine = False  # will revert to True if at least one component still running
        for thisComponent in SS6.components:
            if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:
                continueRoutine = True
                break  # at least one component has not yet finished
        
        # refresh the screen
        if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen
            win.flip()
    
    # --- Ending Routine "SS6" ---
    for thisComponent in SS6.components:
        if hasattr(thisComponent, "setAutoDraw"):
            thisComponent.setAutoDraw(False)
    # store stop times for SS6
    SS6.tStop = globalClock.getTime(format='float')
    SS6.tStopRefresh = tThisFlipGlobal
    thisExp.addData('SS6.stopped', SS6.tStop)
    # check responses
    if key_resp_73.keys in ['', [], None]:  # No response was made
        key_resp_73.keys = None
    thisExp.addData('key_resp_73.keys',key_resp_73.keys)
    if key_resp_73.keys != None:  # we had a response
        thisExp.addData('key_resp_73.rt', key_resp_73.rt)
        thisExp.addData('key_resp_73.duration', key_resp_73.duration)
    thisExp.nextEntry()
    # the Routine "SS6" was not non-slip safe, so reset the non-slip timer
    routineTimer.reset()
    
    # --- Prepare to start Routine "SS7" ---
    # create an object to store info about Routine SS7
    SS7 = data.Routine(
        name='SS7',
        components=[text_235, text_236, text_237, key_resp_74],
    )
    SS7.status = NOT_STARTED
    continueRoutine = True
    # update component parameters for each repeat
    # create starting attributes for key_resp_74
    key_resp_74.keys = []
    key_resp_74.rt = []
    _key_resp_74_allKeys = []
    # store start times for SS7
    SS7.tStartRefresh = win.getFutureFlipTime(clock=globalClock)
    SS7.tStart = globalClock.getTime(format='float')
    SS7.status = STARTED
    thisExp.addData('SS7.started', SS7.tStart)
    SS7.maxDuration = None
    # keep track of which components have finished
    SS7Components = SS7.components
    for thisComponent in SS7.components:
        thisComponent.tStart = None
        thisComponent.tStop = None
        thisComponent.tStartRefresh = None
        thisComponent.tStopRefresh = None
        if hasattr(thisComponent, 'status'):
            thisComponent.status = NOT_STARTED
    # reset timers
    t = 0
    _timeToFirstFrame = win.getFutureFlipTime(clock="now")
    frameN = -1
    
    # --- Run Routine "SS7" ---
    SS7.forceEnded = routineForceEnded = not continueRoutine
    while continueRoutine:
        # get current time
        t = routineTimer.getTime()
        tThisFlip = win.getFutureFlipTime(clock=routineTimer)
        tThisFlipGlobal = win.getFutureFlipTime(clock=None)
        frameN = frameN + 1  # number of completed frames (so 0 is the first frame)
        # update/draw components on each frame
        
        # *text_235* updates
        
        # if text_235 is starting this frame...
        if text_235.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
            # keep track of start time/frame for later
            text_235.frameNStart = frameN  # exact frame index
            text_235.tStart = t  # local t and not account for scr refresh
            text_235.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(text_235, 'tStartRefresh')  # time at next scr refresh
            # add timestamp to datafile
            thisExp.timestampOnFlip(win, 'text_235.started')
            # update status
            text_235.status = STARTED
            text_235.setAutoDraw(True)
        
        # if text_235 is active this frame...
        if text_235.status == STARTED:
            # update params
            pass
        
        # *text_236* updates
        
        # if text_236 is starting this frame...
        if text_236.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
            # keep track of start time/frame for later
            text_236.frameNStart = frameN  # exact frame index
            text_236.tStart = t  # local t and not account for scr refresh
            text_236.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(text_236, 'tStartRefresh')  # time at next scr refresh
            # add timestamp to datafile
            thisExp.timestampOnFlip(win, 'text_236.started')
            # update status
            text_236.status = STARTED
            text_236.setAutoDraw(True)
        
        # if text_236 is active this frame...
        if text_236.status == STARTED:
            # update params
            pass
        
        # *text_237* updates
        
        # if text_237 is starting this frame...
        if text_237.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
            # keep track of start time/frame for later
            text_237.frameNStart = frameN  # exact frame index
            text_237.tStart = t  # local t and not account for scr refresh
            text_237.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(text_237, 'tStartRefresh')  # time at next scr refresh
            # add timestamp to datafile
            thisExp.timestampOnFlip(win, 'text_237.started')
            # update status
            text_237.status = STARTED
            text_237.setAutoDraw(True)
        
        # if text_237 is active this frame...
        if text_237.status == STARTED:
            # update params
            pass
        
        # *key_resp_74* updates
        waitOnFlip = False
        
        # if key_resp_74 is starting this frame...
        if key_resp_74.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
            # keep track of start time/frame for later
            key_resp_74.frameNStart = frameN  # exact frame index
            key_resp_74.tStart = t  # local t and not account for scr refresh
            key_resp_74.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(key_resp_74, 'tStartRefresh')  # time at next scr refresh
            # add timestamp to datafile
            thisExp.timestampOnFlip(win, 'key_resp_74.started')
            # update status
            key_resp_74.status = STARTED
            # keyboard checking is just starting
            waitOnFlip = True
            win.callOnFlip(key_resp_74.clock.reset)  # t=0 on next screen flip
            win.callOnFlip(key_resp_74.clearEvents, eventType='keyboard')  # clear events on next screen flip
        if key_resp_74.status == STARTED and not waitOnFlip:
            theseKeys = key_resp_74.getKeys(keyList=[1,2,3,4,5,'1','2','3','4','5'], ignoreKeys=["escape"], waitRelease=False)
            _key_resp_74_allKeys.extend(theseKeys)
            if len(_key_resp_74_allKeys):
                key_resp_74.keys = _key_resp_74_allKeys[-1].name  # just the last key pressed
                key_resp_74.rt = _key_resp_74_allKeys[-1].rt
                key_resp_74.duration = _key_resp_74_allKeys[-1].duration
                # a response ends the routine
                continueRoutine = False
        
        # check for quit (typically the Esc key)
        if defaultKeyboard.getKeys(keyList=["escape"]):
            thisExp.status = FINISHED
        if thisExp.status == FINISHED or endExpNow:
            endExperiment(thisExp, win=win)
            return
        # pause experiment here if requested
        if thisExp.status == PAUSED:
            pauseExperiment(
                thisExp=thisExp, 
                win=win, 
                timers=[routineTimer], 
                playbackComponents=[]
            )
            # skip the frame we paused on
            continue
        
        # check if all components have finished
        if not continueRoutine:  # a component has requested a forced-end of Routine
            SS7.forceEnded = routineForceEnded = True
            break
        continueRoutine = False  # will revert to True if at least one component still running
        for thisComponent in SS7.components:
            if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:
                continueRoutine = True
                break  # at least one component has not yet finished
        
        # refresh the screen
        if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen
            win.flip()
    
    # --- Ending Routine "SS7" ---
    for thisComponent in SS7.components:
        if hasattr(thisComponent, "setAutoDraw"):
            thisComponent.setAutoDraw(False)
    # store stop times for SS7
    SS7.tStop = globalClock.getTime(format='float')
    SS7.tStopRefresh = tThisFlipGlobal
    thisExp.addData('SS7.stopped', SS7.tStop)
    # check responses
    if key_resp_74.keys in ['', [], None]:  # No response was made
        key_resp_74.keys = None
    thisExp.addData('key_resp_74.keys',key_resp_74.keys)
    if key_resp_74.keys != None:  # we had a response
        thisExp.addData('key_resp_74.rt', key_resp_74.rt)
        thisExp.addData('key_resp_74.duration', key_resp_74.duration)
    thisExp.nextEntry()
    # the Routine "SS7" was not non-slip safe, so reset the non-slip timer
    routineTimer.reset()
    
    # --- Prepare to start Routine "SS8" ---
    # create an object to store info about Routine SS8
    SS8 = data.Routine(
        name='SS8',
        components=[text_238, text_239, text_240, key_resp_75],
    )
    SS8.status = NOT_STARTED
    continueRoutine = True
    # update component parameters for each repeat
    # create starting attributes for key_resp_75
    key_resp_75.keys = []
    key_resp_75.rt = []
    _key_resp_75_allKeys = []
    # store start times for SS8
    SS8.tStartRefresh = win.getFutureFlipTime(clock=globalClock)
    SS8.tStart = globalClock.getTime(format='float')
    SS8.status = STARTED
    thisExp.addData('SS8.started', SS8.tStart)
    SS8.maxDuration = None
    # keep track of which components have finished
    SS8Components = SS8.components
    for thisComponent in SS8.components:
        thisComponent.tStart = None
        thisComponent.tStop = None
        thisComponent.tStartRefresh = None
        thisComponent.tStopRefresh = None
        if hasattr(thisComponent, 'status'):
            thisComponent.status = NOT_STARTED
    # reset timers
    t = 0
    _timeToFirstFrame = win.getFutureFlipTime(clock="now")
    frameN = -1
    
    # --- Run Routine "SS8" ---
    SS8.forceEnded = routineForceEnded = not continueRoutine
    while continueRoutine:
        # get current time
        t = routineTimer.getTime()
        tThisFlip = win.getFutureFlipTime(clock=routineTimer)
        tThisFlipGlobal = win.getFutureFlipTime(clock=None)
        frameN = frameN + 1  # number of completed frames (so 0 is the first frame)
        # update/draw components on each frame
        
        # *text_238* updates
        
        # if text_238 is starting this frame...
        if text_238.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
            # keep track of start time/frame for later
            text_238.frameNStart = frameN  # exact frame index
            text_238.tStart = t  # local t and not account for scr refresh
            text_238.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(text_238, 'tStartRefresh')  # time at next scr refresh
            # add timestamp to datafile
            thisExp.timestampOnFlip(win, 'text_238.started')
            # update status
            text_238.status = STARTED
            text_238.setAutoDraw(True)
        
        # if text_238 is active this frame...
        if text_238.status == STARTED:
            # update params
            pass
        
        # *text_239* updates
        
        # if text_239 is starting this frame...
        if text_239.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
            # keep track of start time/frame for later
            text_239.frameNStart = frameN  # exact frame index
            text_239.tStart = t  # local t and not account for scr refresh
            text_239.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(text_239, 'tStartRefresh')  # time at next scr refresh
            # add timestamp to datafile
            thisExp.timestampOnFlip(win, 'text_239.started')
            # update status
            text_239.status = STARTED
            text_239.setAutoDraw(True)
        
        # if text_239 is active this frame...
        if text_239.status == STARTED:
            # update params
            pass
        
        # *text_240* updates
        
        # if text_240 is starting this frame...
        if text_240.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
            # keep track of start time/frame for later
            text_240.frameNStart = frameN  # exact frame index
            text_240.tStart = t  # local t and not account for scr refresh
            text_240.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(text_240, 'tStartRefresh')  # time at next scr refresh
            # add timestamp to datafile
            thisExp.timestampOnFlip(win, 'text_240.started')
            # update status
            text_240.status = STARTED
            text_240.setAutoDraw(True)
        
        # if text_240 is active this frame...
        if text_240.status == STARTED:
            # update params
            pass
        
        # *key_resp_75* updates
        waitOnFlip = False
        
        # if key_resp_75 is starting this frame...
        if key_resp_75.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
            # keep track of start time/frame for later
            key_resp_75.frameNStart = frameN  # exact frame index
            key_resp_75.tStart = t  # local t and not account for scr refresh
            key_resp_75.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(key_resp_75, 'tStartRefresh')  # time at next scr refresh
            # add timestamp to datafile
            thisExp.timestampOnFlip(win, 'key_resp_75.started')
            # update status
            key_resp_75.status = STARTED
            # keyboard checking is just starting
            waitOnFlip = True
            win.callOnFlip(key_resp_75.clock.reset)  # t=0 on next screen flip
            win.callOnFlip(key_resp_75.clearEvents, eventType='keyboard')  # clear events on next screen flip
        if key_resp_75.status == STARTED and not waitOnFlip:
            theseKeys = key_resp_75.getKeys(keyList=[1,2,3,4,5,'1','2','3','4','5'], ignoreKeys=["escape"], waitRelease=False)
            _key_resp_75_allKeys.extend(theseKeys)
            if len(_key_resp_75_allKeys):
                key_resp_75.keys = _key_resp_75_allKeys[-1].name  # just the last key pressed
                key_resp_75.rt = _key_resp_75_allKeys[-1].rt
                key_resp_75.duration = _key_resp_75_allKeys[-1].duration
                # a response ends the routine
                continueRoutine = False
        
        # check for quit (typically the Esc key)
        if defaultKeyboard.getKeys(keyList=["escape"]):
            thisExp.status = FINISHED
        if thisExp.status == FINISHED or endExpNow:
            endExperiment(thisExp, win=win)
            return
        # pause experiment here if requested
        if thisExp.status == PAUSED:
            pauseExperiment(
                thisExp=thisExp, 
                win=win, 
                timers=[routineTimer], 
                playbackComponents=[]
            )
            # skip the frame we paused on
            continue
        
        # check if all components have finished
        if not continueRoutine:  # a component has requested a forced-end of Routine
            SS8.forceEnded = routineForceEnded = True
            break
        continueRoutine = False  # will revert to True if at least one component still running
        for thisComponent in SS8.components:
            if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:
                continueRoutine = True
                break  # at least one component has not yet finished
        
        # refresh the screen
        if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen
            win.flip()
    
    # --- Ending Routine "SS8" ---
    for thisComponent in SS8.components:
        if hasattr(thisComponent, "setAutoDraw"):
            thisComponent.setAutoDraw(False)
    # store stop times for SS8
    SS8.tStop = globalClock.getTime(format='float')
    SS8.tStopRefresh = tThisFlipGlobal
    thisExp.addData('SS8.stopped', SS8.tStop)
    # check responses
    if key_resp_75.keys in ['', [], None]:  # No response was made
        key_resp_75.keys = None
    thisExp.addData('key_resp_75.keys',key_resp_75.keys)
    if key_resp_75.keys != None:  # we had a response
        thisExp.addData('key_resp_75.rt', key_resp_75.rt)
        thisExp.addData('key_resp_75.duration', key_resp_75.duration)
    thisExp.nextEntry()
    # the Routine "SS8" was not non-slip safe, so reset the non-slip timer
    routineTimer.reset()
    
    # --- Prepare to start Routine "SS9" ---
    # create an object to store info about Routine SS9
    SS9 = data.Routine(
        name='SS9',
        components=[text_241, text_242, text_243, key_resp_76],
    )
    SS9.status = NOT_STARTED
    continueRoutine = True
    # update component parameters for each repeat
    # create starting attributes for key_resp_76
    key_resp_76.keys = []
    key_resp_76.rt = []
    _key_resp_76_allKeys = []
    # store start times for SS9
    SS9.tStartRefresh = win.getFutureFlipTime(clock=globalClock)
    SS9.tStart = globalClock.getTime(format='float')
    SS9.status = STARTED
    thisExp.addData('SS9.started', SS9.tStart)
    SS9.maxDuration = None
    # keep track of which components have finished
    SS9Components = SS9.components
    for thisComponent in SS9.components:
        thisComponent.tStart = None
        thisComponent.tStop = None
        thisComponent.tStartRefresh = None
        thisComponent.tStopRefresh = None
        if hasattr(thisComponent, 'status'):
            thisComponent.status = NOT_STARTED
    # reset timers
    t = 0
    _timeToFirstFrame = win.getFutureFlipTime(clock="now")
    frameN = -1
    
    # --- Run Routine "SS9" ---
    SS9.forceEnded = routineForceEnded = not continueRoutine
    while continueRoutine:
        # get current time
        t = routineTimer.getTime()
        tThisFlip = win.getFutureFlipTime(clock=routineTimer)
        tThisFlipGlobal = win.getFutureFlipTime(clock=None)
        frameN = frameN + 1  # number of completed frames (so 0 is the first frame)
        # update/draw components on each frame
        
        # *text_241* updates
        
        # if text_241 is starting this frame...
        if text_241.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
            # keep track of start time/frame for later
            text_241.frameNStart = frameN  # exact frame index
            text_241.tStart = t  # local t and not account for scr refresh
            text_241.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(text_241, 'tStartRefresh')  # time at next scr refresh
            # add timestamp to datafile
            thisExp.timestampOnFlip(win, 'text_241.started')
            # update status
            text_241.status = STARTED
            text_241.setAutoDraw(True)
        
        # if text_241 is active this frame...
        if text_241.status == STARTED:
            # update params
            pass
        
        # *text_242* updates
        
        # if text_242 is starting this frame...
        if text_242.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
            # keep track of start time/frame for later
            text_242.frameNStart = frameN  # exact frame index
            text_242.tStart = t  # local t and not account for scr refresh
            text_242.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(text_242, 'tStartRefresh')  # time at next scr refresh
            # add timestamp to datafile
            thisExp.timestampOnFlip(win, 'text_242.started')
            # update status
            text_242.status = STARTED
            text_242.setAutoDraw(True)
        
        # if text_242 is active this frame...
        if text_242.status == STARTED:
            # update params
            pass
        
        # *text_243* updates
        
        # if text_243 is starting this frame...
        if text_243.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
            # keep track of start time/frame for later
            text_243.frameNStart = frameN  # exact frame index
            text_243.tStart = t  # local t and not account for scr refresh
            text_243.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(text_243, 'tStartRefresh')  # time at next scr refresh
            # add timestamp to datafile
            thisExp.timestampOnFlip(win, 'text_243.started')
            # update status
            text_243.status = STARTED
            text_243.setAutoDraw(True)
        
        # if text_243 is active this frame...
        if text_243.status == STARTED:
            # update params
            pass
        
        # *key_resp_76* updates
        waitOnFlip = False
        
        # if key_resp_76 is starting this frame...
        if key_resp_76.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
            # keep track of start time/frame for later
            key_resp_76.frameNStart = frameN  # exact frame index
            key_resp_76.tStart = t  # local t and not account for scr refresh
            key_resp_76.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(key_resp_76, 'tStartRefresh')  # time at next scr refresh
            # add timestamp to datafile
            thisExp.timestampOnFlip(win, 'key_resp_76.started')
            # update status
            key_resp_76.status = STARTED
            # keyboard checking is just starting
            waitOnFlip = True
            win.callOnFlip(key_resp_76.clock.reset)  # t=0 on next screen flip
            win.callOnFlip(key_resp_76.clearEvents, eventType='keyboard')  # clear events on next screen flip
        if key_resp_76.status == STARTED and not waitOnFlip:
            theseKeys = key_resp_76.getKeys(keyList=[1,2,3,4,5,'1','2','3','4','5'], ignoreKeys=["escape"], waitRelease=False)
            _key_resp_76_allKeys.extend(theseKeys)
            if len(_key_resp_76_allKeys):
                key_resp_76.keys = _key_resp_76_allKeys[-1].name  # just the last key pressed
                key_resp_76.rt = _key_resp_76_allKeys[-1].rt
                key_resp_76.duration = _key_resp_76_allKeys[-1].duration
                # a response ends the routine
                continueRoutine = False
        
        # check for quit (typically the Esc key)
        if defaultKeyboard.getKeys(keyList=["escape"]):
            thisExp.status = FINISHED
        if thisExp.status == FINISHED or endExpNow:
            endExperiment(thisExp, win=win)
            return
        # pause experiment here if requested
        if thisExp.status == PAUSED:
            pauseExperiment(
                thisExp=thisExp, 
                win=win, 
                timers=[routineTimer], 
                playbackComponents=[]
            )
            # skip the frame we paused on
            continue
        
        # check if all components have finished
        if not continueRoutine:  # a component has requested a forced-end of Routine
            SS9.forceEnded = routineForceEnded = True
            break
        continueRoutine = False  # will revert to True if at least one component still running
        for thisComponent in SS9.components:
            if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:
                continueRoutine = True
                break  # at least one component has not yet finished
        
        # refresh the screen
        if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen
            win.flip()
    
    # --- Ending Routine "SS9" ---
    for thisComponent in SS9.components:
        if hasattr(thisComponent, "setAutoDraw"):
            thisComponent.setAutoDraw(False)
    # store stop times for SS9
    SS9.tStop = globalClock.getTime(format='float')
    SS9.tStopRefresh = tThisFlipGlobal
    thisExp.addData('SS9.stopped', SS9.tStop)
    # check responses
    if key_resp_76.keys in ['', [], None]:  # No response was made
        key_resp_76.keys = None
    thisExp.addData('key_resp_76.keys',key_resp_76.keys)
    if key_resp_76.keys != None:  # we had a response
        thisExp.addData('key_resp_76.rt', key_resp_76.rt)
        thisExp.addData('key_resp_76.duration', key_resp_76.duration)
    thisExp.nextEntry()
    # the Routine "SS9" was not non-slip safe, so reset the non-slip timer
    routineTimer.reset()
    
    # --- Prepare to start Routine "SS10" ---
    # create an object to store info about Routine SS10
    SS10 = data.Routine(
        name='SS10',
        components=[text_244, text_245, text_246, key_resp_77],
    )
    SS10.status = NOT_STARTED
    continueRoutine = True
    # update component parameters for each repeat
    # create starting attributes for key_resp_77
    key_resp_77.keys = []
    key_resp_77.rt = []
    _key_resp_77_allKeys = []
    # store start times for SS10
    SS10.tStartRefresh = win.getFutureFlipTime(clock=globalClock)
    SS10.tStart = globalClock.getTime(format='float')
    SS10.status = STARTED
    thisExp.addData('SS10.started', SS10.tStart)
    SS10.maxDuration = None
    # keep track of which components have finished
    SS10Components = SS10.components
    for thisComponent in SS10.components:
        thisComponent.tStart = None
        thisComponent.tStop = None
        thisComponent.tStartRefresh = None
        thisComponent.tStopRefresh = None
        if hasattr(thisComponent, 'status'):
            thisComponent.status = NOT_STARTED
    # reset timers
    t = 0
    _timeToFirstFrame = win.getFutureFlipTime(clock="now")
    frameN = -1
    
    # --- Run Routine "SS10" ---
    SS10.forceEnded = routineForceEnded = not continueRoutine
    while continueRoutine:
        # get current time
        t = routineTimer.getTime()
        tThisFlip = win.getFutureFlipTime(clock=routineTimer)
        tThisFlipGlobal = win.getFutureFlipTime(clock=None)
        frameN = frameN + 1  # number of completed frames (so 0 is the first frame)
        # update/draw components on each frame
        
        # *text_244* updates
        
        # if text_244 is starting this frame...
        if text_244.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
            # keep track of start time/frame for later
            text_244.frameNStart = frameN  # exact frame index
            text_244.tStart = t  # local t and not account for scr refresh
            text_244.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(text_244, 'tStartRefresh')  # time at next scr refresh
            # add timestamp to datafile
            thisExp.timestampOnFlip(win, 'text_244.started')
            # update status
            text_244.status = STARTED
            text_244.setAutoDraw(True)
        
        # if text_244 is active this frame...
        if text_244.status == STARTED:
            # update params
            pass
        
        # *text_245* updates
        
        # if text_245 is starting this frame...
        if text_245.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
            # keep track of start time/frame for later
            text_245.frameNStart = frameN  # exact frame index
            text_245.tStart = t  # local t and not account for scr refresh
            text_245.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(text_245, 'tStartRefresh')  # time at next scr refresh
            # add timestamp to datafile
            thisExp.timestampOnFlip(win, 'text_245.started')
            # update status
            text_245.status = STARTED
            text_245.setAutoDraw(True)
        
        # if text_245 is active this frame...
        if text_245.status == STARTED:
            # update params
            pass
        
        # *text_246* updates
        
        # if text_246 is starting this frame...
        if text_246.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
            # keep track of start time/frame for later
            text_246.frameNStart = frameN  # exact frame index
            text_246.tStart = t  # local t and not account for scr refresh
            text_246.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(text_246, 'tStartRefresh')  # time at next scr refresh
            # add timestamp to datafile
            thisExp.timestampOnFlip(win, 'text_246.started')
            # update status
            text_246.status = STARTED
            text_246.setAutoDraw(True)
        
        # if text_246 is active this frame...
        if text_246.status == STARTED:
            # update params
            pass
        
        # *key_resp_77* updates
        waitOnFlip = False
        
        # if key_resp_77 is starting this frame...
        if key_resp_77.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
            # keep track of start time/frame for later
            key_resp_77.frameNStart = frameN  # exact frame index
            key_resp_77.tStart = t  # local t and not account for scr refresh
            key_resp_77.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(key_resp_77, 'tStartRefresh')  # time at next scr refresh
            # add timestamp to datafile
            thisExp.timestampOnFlip(win, 'key_resp_77.started')
            # update status
            key_resp_77.status = STARTED
            # keyboard checking is just starting
            waitOnFlip = True
            win.callOnFlip(key_resp_77.clock.reset)  # t=0 on next screen flip
            win.callOnFlip(key_resp_77.clearEvents, eventType='keyboard')  # clear events on next screen flip
        if key_resp_77.status == STARTED and not waitOnFlip:
            theseKeys = key_resp_77.getKeys(keyList=[1,2,3,4,5,'1','2','3','4','5'], ignoreKeys=["escape"], waitRelease=False)
            _key_resp_77_allKeys.extend(theseKeys)
            if len(_key_resp_77_allKeys):
                key_resp_77.keys = _key_resp_77_allKeys[-1].name  # just the last key pressed
                key_resp_77.rt = _key_resp_77_allKeys[-1].rt
                key_resp_77.duration = _key_resp_77_allKeys[-1].duration
                # a response ends the routine
                continueRoutine = False
        
        # check for quit (typically the Esc key)
        if defaultKeyboard.getKeys(keyList=["escape"]):
            thisExp.status = FINISHED
        if thisExp.status == FINISHED or endExpNow:
            endExperiment(thisExp, win=win)
            return
        # pause experiment here if requested
        if thisExp.status == PAUSED:
            pauseExperiment(
                thisExp=thisExp, 
                win=win, 
                timers=[routineTimer], 
                playbackComponents=[]
            )
            # skip the frame we paused on
            continue
        
        # check if all components have finished
        if not continueRoutine:  # a component has requested a forced-end of Routine
            SS10.forceEnded = routineForceEnded = True
            break
        continueRoutine = False  # will revert to True if at least one component still running
        for thisComponent in SS10.components:
            if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:
                continueRoutine = True
                break  # at least one component has not yet finished
        
        # refresh the screen
        if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen
            win.flip()
    
    # --- Ending Routine "SS10" ---
    for thisComponent in SS10.components:
        if hasattr(thisComponent, "setAutoDraw"):
            thisComponent.setAutoDraw(False)
    # store stop times for SS10
    SS10.tStop = globalClock.getTime(format='float')
    SS10.tStopRefresh = tThisFlipGlobal
    thisExp.addData('SS10.stopped', SS10.tStop)
    # check responses
    if key_resp_77.keys in ['', [], None]:  # No response was made
        key_resp_77.keys = None
    thisExp.addData('key_resp_77.keys',key_resp_77.keys)
    if key_resp_77.keys != None:  # we had a response
        thisExp.addData('key_resp_77.rt', key_resp_77.rt)
        thisExp.addData('key_resp_77.duration', key_resp_77.duration)
    thisExp.nextEntry()
    # the Routine "SS10" was not non-slip safe, so reset the non-slip timer
    routineTimer.reset()
    
    # set up handler to look after randomisation of conditions etc
    instructions_get_right = data.TrialHandler2(
        name='instructions_get_right',
        nReps=500.0, 
        method='sequential', 
        extraInfo=expInfo, 
        originPath=-1, 
        trialList=[None], 
        seed=None, 
    )
    thisExp.addLoop(instructions_get_right)  # add the loop to the experiment
    thisInstructions_get_right = instructions_get_right.trialList[0]  # so we can initialise stimuli with some values
    # abbreviate parameter names if possible (e.g. rgb = thisInstructions_get_right.rgb)
    if thisInstructions_get_right != None:
        for paramName in thisInstructions_get_right:
            globals()[paramName] = thisInstructions_get_right[paramName]
    if thisSession is not None:
        # if running in a Session with a Liaison client, send data up to now
        thisSession.sendExperimentData()
    
    for thisInstructions_get_right in instructions_get_right:
        currentLoop = instructions_get_right
        thisExp.timestampOnFlip(win, 'thisRow.t', format=globalClock.format)
        if thisSession is not None:
            # if running in a Session with a Liaison client, send data up to now
            thisSession.sendExperimentData()
        # abbreviate parameter names if possible (e.g. rgb = thisInstructions_get_right.rgb)
        if thisInstructions_get_right != None:
            for paramName in thisInstructions_get_right:
                globals()[paramName] = thisInstructions_get_right[paramName]
        
        # --- Prepare to start Routine "instructions" ---
        # create an object to store info about Routine instructions
        instructions = data.Routine(
            name='instructions',
            components=[instruction_test, end_instructions],
        )
        instructions.status = NOT_STARTED
        continueRoutine = True
        # update component parameters for each repeat
        # create starting attributes for end_instructions
        end_instructions.keys = []
        end_instructions.rt = []
        _end_instructions_allKeys = []
        # store start times for instructions
        instructions.tStartRefresh = win.getFutureFlipTime(clock=globalClock)
        instructions.tStart = globalClock.getTime(format='float')
        instructions.status = STARTED
        thisExp.addData('instructions.started', instructions.tStart)
        instructions.maxDuration = None
        # keep track of which components have finished
        instructionsComponents = instructions.components
        for thisComponent in instructions.components:
            thisComponent.tStart = None
            thisComponent.tStop = None
            thisComponent.tStartRefresh = None
            thisComponent.tStopRefresh = None
            if hasattr(thisComponent, 'status'):
                thisComponent.status = NOT_STARTED
        # reset timers
        t = 0
        _timeToFirstFrame = win.getFutureFlipTime(clock="now")
        frameN = -1
        
        # --- Run Routine "instructions" ---
        # if trial has changed, end Routine now
        if isinstance(instructions_get_right, data.TrialHandler2) and thisInstructions_get_right.thisN != instructions_get_right.thisTrial.thisN:
            continueRoutine = False
        instructions.forceEnded = routineForceEnded = not continueRoutine
        while continueRoutine:
            # get current time
            t = routineTimer.getTime()
            tThisFlip = win.getFutureFlipTime(clock=routineTimer)
            tThisFlipGlobal = win.getFutureFlipTime(clock=None)
            frameN = frameN + 1  # number of completed frames (so 0 is the first frame)
            # update/draw components on each frame
            
            # *instruction_test* updates
            
            # if instruction_test is starting this frame...
            if instruction_test.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
                # keep track of start time/frame for later
                instruction_test.frameNStart = frameN  # exact frame index
                instruction_test.tStart = t  # local t and not account for scr refresh
                instruction_test.tStartRefresh = tThisFlipGlobal  # on global time
                win.timeOnFlip(instruction_test, 'tStartRefresh')  # time at next scr refresh
                # add timestamp to datafile
                thisExp.timestampOnFlip(win, 'instruction_test.started')
                # update status
                instruction_test.status = STARTED
                instruction_test.setAutoDraw(True)
            
            # if instruction_test is active this frame...
            if instruction_test.status == STARTED:
                # update params
                pass
            
            # *end_instructions* updates
            waitOnFlip = False
            
            # if end_instructions is starting this frame...
            if end_instructions.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
                # keep track of start time/frame for later
                end_instructions.frameNStart = frameN  # exact frame index
                end_instructions.tStart = t  # local t and not account for scr refresh
                end_instructions.tStartRefresh = tThisFlipGlobal  # on global time
                win.timeOnFlip(end_instructions, 'tStartRefresh')  # time at next scr refresh
                # add timestamp to datafile
                thisExp.timestampOnFlip(win, 'end_instructions.started')
                # update status
                end_instructions.status = STARTED
                # keyboard checking is just starting
                waitOnFlip = True
                win.callOnFlip(end_instructions.clock.reset)  # t=0 on next screen flip
                win.callOnFlip(end_instructions.clearEvents, eventType='keyboard')  # clear events on next screen flip
            if end_instructions.status == STARTED and not waitOnFlip:
                theseKeys = end_instructions.getKeys(keyList=['space'], ignoreKeys=["escape"], waitRelease=False)
                _end_instructions_allKeys.extend(theseKeys)
                if len(_end_instructions_allKeys):
                    end_instructions.keys = _end_instructions_allKeys[-1].name  # just the last key pressed
                    end_instructions.rt = _end_instructions_allKeys[-1].rt
                    end_instructions.duration = _end_instructions_allKeys[-1].duration
                    # a response ends the routine
                    continueRoutine = False
            
            # check for quit (typically the Esc key)
            if defaultKeyboard.getKeys(keyList=["escape"]):
                thisExp.status = FINISHED
            if thisExp.status == FINISHED or endExpNow:
                endExperiment(thisExp, win=win)
                return
            # pause experiment here if requested
            if thisExp.status == PAUSED:
                pauseExperiment(
                    thisExp=thisExp, 
                    win=win, 
                    timers=[routineTimer], 
                    playbackComponents=[]
                )
                # skip the frame we paused on
                continue
            
            # check if all components have finished
            if not continueRoutine:  # a component has requested a forced-end of Routine
                instructions.forceEnded = routineForceEnded = True
                break
            continueRoutine = False  # will revert to True if at least one component still running
            for thisComponent in instructions.components:
                if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:
                    continueRoutine = True
                    break  # at least one component has not yet finished
            
            # refresh the screen
            if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen
                win.flip()
        
        # --- Ending Routine "instructions" ---
        for thisComponent in instructions.components:
            if hasattr(thisComponent, "setAutoDraw"):
                thisComponent.setAutoDraw(False)
        # store stop times for instructions
        instructions.tStop = globalClock.getTime(format='float')
        instructions.tStopRefresh = tThisFlipGlobal
        thisExp.addData('instructions.stopped', instructions.tStop)
        # the Routine "instructions" was not non-slip safe, so reset the non-slip timer
        routineTimer.reset()
        
        # --- Prepare to start Routine "second_instructions" ---
        # create an object to store info about Routine second_instructions
        second_instructions = data.Routine(
            name='second_instructions',
            components=[key_resp_2, text_22],
        )
        second_instructions.status = NOT_STARTED
        continueRoutine = True
        # update component parameters for each repeat
        # create starting attributes for key_resp_2
        key_resp_2.keys = []
        key_resp_2.rt = []
        _key_resp_2_allKeys = []
        # store start times for second_instructions
        second_instructions.tStartRefresh = win.getFutureFlipTime(clock=globalClock)
        second_instructions.tStart = globalClock.getTime(format='float')
        second_instructions.status = STARTED
        thisExp.addData('second_instructions.started', second_instructions.tStart)
        second_instructions.maxDuration = None
        # keep track of which components have finished
        second_instructionsComponents = second_instructions.components
        for thisComponent in second_instructions.components:
            thisComponent.tStart = None
            thisComponent.tStop = None
            thisComponent.tStartRefresh = None
            thisComponent.tStopRefresh = None
            if hasattr(thisComponent, 'status'):
                thisComponent.status = NOT_STARTED
        # reset timers
        t = 0
        _timeToFirstFrame = win.getFutureFlipTime(clock="now")
        frameN = -1
        
        # --- Run Routine "second_instructions" ---
        # if trial has changed, end Routine now
        if isinstance(instructions_get_right, data.TrialHandler2) and thisInstructions_get_right.thisN != instructions_get_right.thisTrial.thisN:
            continueRoutine = False
        second_instructions.forceEnded = routineForceEnded = not continueRoutine
        while continueRoutine:
            # get current time
            t = routineTimer.getTime()
            tThisFlip = win.getFutureFlipTime(clock=routineTimer)
            tThisFlipGlobal = win.getFutureFlipTime(clock=None)
            frameN = frameN + 1  # number of completed frames (so 0 is the first frame)
            # update/draw components on each frame
            
            # *key_resp_2* updates
            waitOnFlip = False
            
            # if key_resp_2 is starting this frame...
            if key_resp_2.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
                # keep track of start time/frame for later
                key_resp_2.frameNStart = frameN  # exact frame index
                key_resp_2.tStart = t  # local t and not account for scr refresh
                key_resp_2.tStartRefresh = tThisFlipGlobal  # on global time
                win.timeOnFlip(key_resp_2, 'tStartRefresh')  # time at next scr refresh
                # add timestamp to datafile
                thisExp.timestampOnFlip(win, 'key_resp_2.started')
                # update status
                key_resp_2.status = STARTED
                # keyboard checking is just starting
                waitOnFlip = True
                win.callOnFlip(key_resp_2.clock.reset)  # t=0 on next screen flip
                win.callOnFlip(key_resp_2.clearEvents, eventType='keyboard')  # clear events on next screen flip
            if key_resp_2.status == STARTED and not waitOnFlip:
                theseKeys = key_resp_2.getKeys(keyList=['space'], ignoreKeys=["escape"], waitRelease=False)
                _key_resp_2_allKeys.extend(theseKeys)
                if len(_key_resp_2_allKeys):
                    key_resp_2.keys = _key_resp_2_allKeys[-1].name  # just the last key pressed
                    key_resp_2.rt = _key_resp_2_allKeys[-1].rt
                    key_resp_2.duration = _key_resp_2_allKeys[-1].duration
                    # a response ends the routine
                    continueRoutine = False
            
            # *text_22* updates
            
            # if text_22 is starting this frame...
            if text_22.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
                # keep track of start time/frame for later
                text_22.frameNStart = frameN  # exact frame index
                text_22.tStart = t  # local t and not account for scr refresh
                text_22.tStartRefresh = tThisFlipGlobal  # on global time
                win.timeOnFlip(text_22, 'tStartRefresh')  # time at next scr refresh
                # add timestamp to datafile
                thisExp.timestampOnFlip(win, 'text_22.started')
                # update status
                text_22.status = STARTED
                text_22.setAutoDraw(True)
            
            # if text_22 is active this frame...
            if text_22.status == STARTED:
                # update params
                pass
            
            # check for quit (typically the Esc key)
            if defaultKeyboard.getKeys(keyList=["escape"]):
                thisExp.status = FINISHED
            if thisExp.status == FINISHED or endExpNow:
                endExperiment(thisExp, win=win)
                return
            # pause experiment here if requested
            if thisExp.status == PAUSED:
                pauseExperiment(
                    thisExp=thisExp, 
                    win=win, 
                    timers=[routineTimer], 
                    playbackComponents=[]
                )
                # skip the frame we paused on
                continue
            
            # check if all components have finished
            if not continueRoutine:  # a component has requested a forced-end of Routine
                second_instructions.forceEnded = routineForceEnded = True
                break
            continueRoutine = False  # will revert to True if at least one component still running
            for thisComponent in second_instructions.components:
                if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:
                    continueRoutine = True
                    break  # at least one component has not yet finished
            
            # refresh the screen
            if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen
                win.flip()
        
        # --- Ending Routine "second_instructions" ---
        for thisComponent in second_instructions.components:
            if hasattr(thisComponent, "setAutoDraw"):
                thisComponent.setAutoDraw(False)
        # store stop times for second_instructions
        second_instructions.tStop = globalClock.getTime(format='float')
        second_instructions.tStopRefresh = tThisFlipGlobal
        thisExp.addData('second_instructions.stopped', second_instructions.tStop)
        # the Routine "second_instructions" was not non-slip safe, so reset the non-slip timer
        routineTimer.reset()
        
        # --- Prepare to start Routine "third_instructions" ---
        # create an object to store info about Routine third_instructions
        third_instructions = data.Routine(
            name='third_instructions',
            components=[responseleft, text_23],
        )
        third_instructions.status = NOT_STARTED
        continueRoutine = True
        # update component parameters for each repeat
        # create starting attributes for responseleft
        responseleft.keys = []
        responseleft.rt = []
        _responseleft_allKeys = []
        # store start times for third_instructions
        third_instructions.tStartRefresh = win.getFutureFlipTime(clock=globalClock)
        third_instructions.tStart = globalClock.getTime(format='float')
        third_instructions.status = STARTED
        thisExp.addData('third_instructions.started', third_instructions.tStart)
        third_instructions.maxDuration = None
        # keep track of which components have finished
        third_instructionsComponents = third_instructions.components
        for thisComponent in third_instructions.components:
            thisComponent.tStart = None
            thisComponent.tStop = None
            thisComponent.tStartRefresh = None
            thisComponent.tStopRefresh = None
            if hasattr(thisComponent, 'status'):
                thisComponent.status = NOT_STARTED
        # reset timers
        t = 0
        _timeToFirstFrame = win.getFutureFlipTime(clock="now")
        frameN = -1
        
        # --- Run Routine "third_instructions" ---
        # if trial has changed, end Routine now
        if isinstance(instructions_get_right, data.TrialHandler2) and thisInstructions_get_right.thisN != instructions_get_right.thisTrial.thisN:
            continueRoutine = False
        third_instructions.forceEnded = routineForceEnded = not continueRoutine
        while continueRoutine:
            # get current time
            t = routineTimer.getTime()
            tThisFlip = win.getFutureFlipTime(clock=routineTimer)
            tThisFlipGlobal = win.getFutureFlipTime(clock=None)
            frameN = frameN + 1  # number of completed frames (so 0 is the first frame)
            # update/draw components on each frame
            
            # *responseleft* updates
            waitOnFlip = False
            
            # if responseleft is starting this frame...
            if responseleft.status == NOT_STARTED and tThisFlip >= 0.2-frameTolerance:
                # keep track of start time/frame for later
                responseleft.frameNStart = frameN  # exact frame index
                responseleft.tStart = t  # local t and not account for scr refresh
                responseleft.tStartRefresh = tThisFlipGlobal  # on global time
                win.timeOnFlip(responseleft, 'tStartRefresh')  # time at next scr refresh
                # add timestamp to datafile
                thisExp.timestampOnFlip(win, 'responseleft.started')
                # update status
                responseleft.status = STARTED
                # keyboard checking is just starting
                waitOnFlip = True
                win.callOnFlip(responseleft.clock.reset)  # t=0 on next screen flip
                win.callOnFlip(responseleft.clearEvents, eventType='keyboard')  # clear events on next screen flip
            if responseleft.status == STARTED and not waitOnFlip:
                theseKeys = responseleft.getKeys(keyList=['space'], ignoreKeys=["escape"], waitRelease=False)
                _responseleft_allKeys.extend(theseKeys)
                if len(_responseleft_allKeys):
                    responseleft.keys = _responseleft_allKeys[-1].name  # just the last key pressed
                    responseleft.rt = _responseleft_allKeys[-1].rt
                    responseleft.duration = _responseleft_allKeys[-1].duration
                    # a response ends the routine
                    continueRoutine = False
            
            # *text_23* updates
            
            # if text_23 is starting this frame...
            if text_23.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
                # keep track of start time/frame for later
                text_23.frameNStart = frameN  # exact frame index
                text_23.tStart = t  # local t and not account for scr refresh
                text_23.tStartRefresh = tThisFlipGlobal  # on global time
                win.timeOnFlip(text_23, 'tStartRefresh')  # time at next scr refresh
                # add timestamp to datafile
                thisExp.timestampOnFlip(win, 'text_23.started')
                # update status
                text_23.status = STARTED
                text_23.setAutoDraw(True)
            
            # if text_23 is active this frame...
            if text_23.status == STARTED:
                # update params
                pass
            
            # check for quit (typically the Esc key)
            if defaultKeyboard.getKeys(keyList=["escape"]):
                thisExp.status = FINISHED
            if thisExp.status == FINISHED or endExpNow:
                endExperiment(thisExp, win=win)
                return
            # pause experiment here if requested
            if thisExp.status == PAUSED:
                pauseExperiment(
                    thisExp=thisExp, 
                    win=win, 
                    timers=[routineTimer], 
                    playbackComponents=[]
                )
                # skip the frame we paused on
                continue
            
            # check if all components have finished
            if not continueRoutine:  # a component has requested a forced-end of Routine
                third_instructions.forceEnded = routineForceEnded = True
                break
            continueRoutine = False  # will revert to True if at least one component still running
            for thisComponent in third_instructions.components:
                if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:
                    continueRoutine = True
                    break  # at least one component has not yet finished
            
            # refresh the screen
            if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen
                win.flip()
        
        # --- Ending Routine "third_instructions" ---
        for thisComponent in third_instructions.components:
            if hasattr(thisComponent, "setAutoDraw"):
                thisComponent.setAutoDraw(False)
        # store stop times for third_instructions
        third_instructions.tStop = globalClock.getTime(format='float')
        third_instructions.tStopRefresh = tThisFlipGlobal
        thisExp.addData('third_instructions.stopped', third_instructions.tStop)
        # the Routine "third_instructions" was not non-slip safe, so reset the non-slip timer
        routineTimer.reset()
        
        # --- Prepare to start Routine "instructions4" ---
        # create an object to store info about Routine instructions4
        instructions4 = data.Routine(
            name='instructions4',
            components=[text_153],
        )
        instructions4.status = NOT_STARTED
        continueRoutine = True
        # update component parameters for each repeat
        # store start times for instructions4
        instructions4.tStartRefresh = win.getFutureFlipTime(clock=globalClock)
        instructions4.tStart = globalClock.getTime(format='float')
        instructions4.status = STARTED
        thisExp.addData('instructions4.started', instructions4.tStart)
        instructions4.maxDuration = None
        # keep track of which components have finished
        instructions4Components = instructions4.components
        for thisComponent in instructions4.components:
            thisComponent.tStart = None
            thisComponent.tStop = None
            thisComponent.tStartRefresh = None
            thisComponent.tStopRefresh = None
            if hasattr(thisComponent, 'status'):
                thisComponent.status = NOT_STARTED
        # reset timers
        t = 0
        _timeToFirstFrame = win.getFutureFlipTime(clock="now")
        frameN = -1
        
        # --- Run Routine "instructions4" ---
        # if trial has changed, end Routine now
        if isinstance(instructions_get_right, data.TrialHandler2) and thisInstructions_get_right.thisN != instructions_get_right.thisTrial.thisN:
            continueRoutine = False
        instructions4.forceEnded = routineForceEnded = not continueRoutine
        while continueRoutine and routineTimer.getTime() < 1.0:
            # get current time
            t = routineTimer.getTime()
            tThisFlip = win.getFutureFlipTime(clock=routineTimer)
            tThisFlipGlobal = win.getFutureFlipTime(clock=None)
            frameN = frameN + 1  # number of completed frames (so 0 is the first frame)
            # update/draw components on each frame
            
            # *text_153* updates
            
            # if text_153 is starting this frame...
            if text_153.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
                # keep track of start time/frame for later
                text_153.frameNStart = frameN  # exact frame index
                text_153.tStart = t  # local t and not account for scr refresh
                text_153.tStartRefresh = tThisFlipGlobal  # on global time
                win.timeOnFlip(text_153, 'tStartRefresh')  # time at next scr refresh
                # add timestamp to datafile
                thisExp.timestampOnFlip(win, 'text_153.started')
                # update status
                text_153.status = STARTED
                text_153.setAutoDraw(True)
            
            # if text_153 is active this frame...
            if text_153.status == STARTED:
                # update params
                pass
            
            # if text_153 is stopping this frame...
            if text_153.status == STARTED:
                # is it time to stop? (based on global clock, using actual start)
                if tThisFlipGlobal > text_153.tStartRefresh + 1.0-frameTolerance:
                    # keep track of stop time/frame for later
                    text_153.tStop = t  # not accounting for scr refresh
                    text_153.tStopRefresh = tThisFlipGlobal  # on global time
                    text_153.frameNStop = frameN  # exact frame index
                    # add timestamp to datafile
                    thisExp.timestampOnFlip(win, 'text_153.stopped')
                    # update status
                    text_153.status = FINISHED
                    text_153.setAutoDraw(False)
            
            # check for quit (typically the Esc key)
            if defaultKeyboard.getKeys(keyList=["escape"]):
                thisExp.status = FINISHED
            if thisExp.status == FINISHED or endExpNow:
                endExperiment(thisExp, win=win)
                return
            # pause experiment here if requested
            if thisExp.status == PAUSED:
                pauseExperiment(
                    thisExp=thisExp, 
                    win=win, 
                    timers=[routineTimer], 
                    playbackComponents=[]
                )
                # skip the frame we paused on
                continue
            
            # check if all components have finished
            if not continueRoutine:  # a component has requested a forced-end of Routine
                instructions4.forceEnded = routineForceEnded = True
                break
            continueRoutine = False  # will revert to True if at least one component still running
            for thisComponent in instructions4.components:
                if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:
                    continueRoutine = True
                    break  # at least one component has not yet finished
            
            # refresh the screen
            if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen
                win.flip()
        
        # --- Ending Routine "instructions4" ---
        for thisComponent in instructions4.components:
            if hasattr(thisComponent, "setAutoDraw"):
                thisComponent.setAutoDraw(False)
        # store stop times for instructions4
        instructions4.tStop = globalClock.getTime(format='float')
        instructions4.tStopRefresh = tThisFlipGlobal
        thisExp.addData('instructions4.stopped', instructions4.tStop)
        # using non-slip timing so subtract the expected duration of this Routine (unless ended on request)
        if instructions4.maxDurationReached:
            routineTimer.addTime(-instructions4.maxDuration)
        elif instructions4.forceEnded:
            routineTimer.reset()
        else:
            routineTimer.addTime(-1.000000)
        
        # set up handler to look after randomisation of conditions etc
        practice_loop = data.TrialHandler2(
            name='practice_loop',
            nReps=500.0, 
            method='random', 
            extraInfo=expInfo, 
            originPath=-1, 
            trialList=[None], 
            seed=None, 
        )
        thisExp.addLoop(practice_loop)  # add the loop to the experiment
        thisPractice_loop = practice_loop.trialList[0]  # so we can initialise stimuli with some values
        # abbreviate parameter names if possible (e.g. rgb = thisPractice_loop.rgb)
        if thisPractice_loop != None:
            for paramName in thisPractice_loop:
                globals()[paramName] = thisPractice_loop[paramName]
        if thisSession is not None:
            # if running in a Session with a Liaison client, send data up to now
            thisSession.sendExperimentData()
        
        for thisPractice_loop in practice_loop:
            currentLoop = practice_loop
            thisExp.timestampOnFlip(win, 'thisRow.t', format=globalClock.format)
            if thisSession is not None:
                # if running in a Session with a Liaison client, send data up to now
                thisSession.sendExperimentData()
            # abbreviate parameter names if possible (e.g. rgb = thisPractice_loop.rgb)
            if thisPractice_loop != None:
                for paramName in thisPractice_loop:
                    globals()[paramName] = thisPractice_loop[paramName]
            
            # set up handler to look after randomisation of conditions etc
            practice_trials = data.TrialHandler2(
                name='practice_trials',
                nReps=1.0, 
                method='random', 
                extraInfo=expInfo, 
                originPath=-1, 
                trialList=data.importConditions('stage2_4_practice.csv'), 
                seed=None, 
            )
            thisExp.addLoop(practice_trials)  # add the loop to the experiment
            thisPractice_trial = practice_trials.trialList[0]  # so we can initialise stimuli with some values
            # abbreviate parameter names if possible (e.g. rgb = thisPractice_trial.rgb)
            if thisPractice_trial != None:
                for paramName in thisPractice_trial:
                    globals()[paramName] = thisPractice_trial[paramName]
            if thisSession is not None:
                # if running in a Session with a Liaison client, send data up to now
                thisSession.sendExperimentData()
            
            for thisPractice_trial in practice_trials:
                currentLoop = practice_trials
                thisExp.timestampOnFlip(win, 'thisRow.t', format=globalClock.format)
                if thisSession is not None:
                    # if running in a Session with a Liaison client, send data up to now
                    thisSession.sendExperimentData()
                # abbreviate parameter names if possible (e.g. rgb = thisPractice_trial.rgb)
                if thisPractice_trial != None:
                    for paramName in thisPractice_trial:
                        globals()[paramName] = thisPractice_trial[paramName]
                
                # --- Prepare to start Routine "practice1" ---
                # create an object to store info about Routine practice1
                practice1 = data.Routine(
                    name='practice1',
                    components=[image_22, key_resp_10, text_40],
                )
                practice1.status = NOT_STARTED
                continueRoutine = True
                # update component parameters for each repeat
                image_22.setImage('apple.png')
                # create starting attributes for key_resp_10
                key_resp_10.keys = []
                key_resp_10.rt = []
                _key_resp_10_allKeys = []
                # store start times for practice1
                practice1.tStartRefresh = win.getFutureFlipTime(clock=globalClock)
                practice1.tStart = globalClock.getTime(format='float')
                practice1.status = STARTED
                thisExp.addData('practice1.started', practice1.tStart)
                practice1.maxDuration = None
                # keep track of which components have finished
                practice1Components = practice1.components
                for thisComponent in practice1.components:
                    thisComponent.tStart = None
                    thisComponent.tStop = None
                    thisComponent.tStartRefresh = None
                    thisComponent.tStopRefresh = None
                    if hasattr(thisComponent, 'status'):
                        thisComponent.status = NOT_STARTED
                # reset timers
                t = 0
                _timeToFirstFrame = win.getFutureFlipTime(clock="now")
                frameN = -1
                
                # --- Run Routine "practice1" ---
                # if trial has changed, end Routine now
                if isinstance(practice_trials, data.TrialHandler2) and thisPractice_trial.thisN != practice_trials.thisTrial.thisN:
                    continueRoutine = False
                practice1.forceEnded = routineForceEnded = not continueRoutine
                while continueRoutine:
                    # get current time
                    t = routineTimer.getTime()
                    tThisFlip = win.getFutureFlipTime(clock=routineTimer)
                    tThisFlipGlobal = win.getFutureFlipTime(clock=None)
                    frameN = frameN + 1  # number of completed frames (so 0 is the first frame)
                    # update/draw components on each frame
                    
                    # *image_22* updates
                    
                    # if image_22 is starting this frame...
                    if image_22.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
                        # keep track of start time/frame for later
                        image_22.frameNStart = frameN  # exact frame index
                        image_22.tStart = t  # local t and not account for scr refresh
                        image_22.tStartRefresh = tThisFlipGlobal  # on global time
                        win.timeOnFlip(image_22, 'tStartRefresh')  # time at next scr refresh
                        # add timestamp to datafile
                        thisExp.timestampOnFlip(win, 'image_22.started')
                        # update status
                        image_22.status = STARTED
                        image_22.setAutoDraw(True)
                    
                    # if image_22 is active this frame...
                    if image_22.status == STARTED:
                        # update params
                        pass
                    
                    # *key_resp_10* updates
                    waitOnFlip = False
                    
                    # if key_resp_10 is starting this frame...
                    if key_resp_10.status == NOT_STARTED and tThisFlip >= 0.2-frameTolerance:
                        # keep track of start time/frame for later
                        key_resp_10.frameNStart = frameN  # exact frame index
                        key_resp_10.tStart = t  # local t and not account for scr refresh
                        key_resp_10.tStartRefresh = tThisFlipGlobal  # on global time
                        win.timeOnFlip(key_resp_10, 'tStartRefresh')  # time at next scr refresh
                        # add timestamp to datafile
                        thisExp.timestampOnFlip(win, 'key_resp_10.started')
                        # update status
                        key_resp_10.status = STARTED
                        # keyboard checking is just starting
                        waitOnFlip = True
                        win.callOnFlip(key_resp_10.clock.reset)  # t=0 on next screen flip
                        win.callOnFlip(key_resp_10.clearEvents, eventType='keyboard')  # clear events on next screen flip
                    if key_resp_10.status == STARTED and not waitOnFlip:
                        theseKeys = key_resp_10.getKeys(keyList=[1,'1','left'], ignoreKeys=["escape"], waitRelease=False)
                        _key_resp_10_allKeys.extend(theseKeys)
                        if len(_key_resp_10_allKeys):
                            key_resp_10.keys = _key_resp_10_allKeys[-1].name  # just the last key pressed
                            key_resp_10.rt = _key_resp_10_allKeys[-1].rt
                            key_resp_10.duration = _key_resp_10_allKeys[-1].duration
                            # a response ends the routine
                            continueRoutine = False
                    
                    # *text_40* updates
                    
                    # if text_40 is starting this frame...
                    if text_40.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
                        # keep track of start time/frame for later
                        text_40.frameNStart = frameN  # exact frame index
                        text_40.tStart = t  # local t and not account for scr refresh
                        text_40.tStartRefresh = tThisFlipGlobal  # on global time
                        win.timeOnFlip(text_40, 'tStartRefresh')  # time at next scr refresh
                        # add timestamp to datafile
                        thisExp.timestampOnFlip(win, 'text_40.started')
                        # update status
                        text_40.status = STARTED
                        text_40.setAutoDraw(True)
                    
                    # if text_40 is active this frame...
                    if text_40.status == STARTED:
                        # update params
                        pass
                    
                    # check for quit (typically the Esc key)
                    if defaultKeyboard.getKeys(keyList=["escape"]):
                        thisExp.status = FINISHED
                    if thisExp.status == FINISHED or endExpNow:
                        endExperiment(thisExp, win=win)
                        return
                    # pause experiment here if requested
                    if thisExp.status == PAUSED:
                        pauseExperiment(
                            thisExp=thisExp, 
                            win=win, 
                            timers=[routineTimer], 
                            playbackComponents=[]
                        )
                        # skip the frame we paused on
                        continue
                    
                    # check if all components have finished
                    if not continueRoutine:  # a component has requested a forced-end of Routine
                        practice1.forceEnded = routineForceEnded = True
                        break
                    continueRoutine = False  # will revert to True if at least one component still running
                    for thisComponent in practice1.components:
                        if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:
                            continueRoutine = True
                            break  # at least one component has not yet finished
                    
                    # refresh the screen
                    if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen
                        win.flip()
                
                # --- Ending Routine "practice1" ---
                for thisComponent in practice1.components:
                    if hasattr(thisComponent, "setAutoDraw"):
                        thisComponent.setAutoDraw(False)
                # store stop times for practice1
                practice1.tStop = globalClock.getTime(format='float')
                practice1.tStopRefresh = tThisFlipGlobal
                thisExp.addData('practice1.stopped', practice1.tStop)
                # check responses
                if key_resp_10.keys in ['', [], None]:  # No response was made
                    key_resp_10.keys = None
                practice_trials.addData('key_resp_10.keys',key_resp_10.keys)
                if key_resp_10.keys != None:  # we had a response
                    practice_trials.addData('key_resp_10.rt', key_resp_10.rt)
                    practice_trials.addData('key_resp_10.duration', key_resp_10.duration)
                # the Routine "practice1" was not non-slip safe, so reset the non-slip timer
                routineTimer.reset()
                
                # --- Prepare to start Routine "practice1_result" ---
                # create an object to store info about Routine practice1_result
                practice1_result = data.Routine(
                    name='practice1_result',
                    components=[image_20],
                )
                practice1_result.status = NOT_STARTED
                continueRoutine = True
                # update component parameters for each repeat
                image_20.setImage(image_prac2)
                # store start times for practice1_result
                practice1_result.tStartRefresh = win.getFutureFlipTime(clock=globalClock)
                practice1_result.tStart = globalClock.getTime(format='float')
                practice1_result.status = STARTED
                thisExp.addData('practice1_result.started', practice1_result.tStart)
                practice1_result.maxDuration = None
                # keep track of which components have finished
                practice1_resultComponents = practice1_result.components
                for thisComponent in practice1_result.components:
                    thisComponent.tStart = None
                    thisComponent.tStop = None
                    thisComponent.tStartRefresh = None
                    thisComponent.tStopRefresh = None
                    if hasattr(thisComponent, 'status'):
                        thisComponent.status = NOT_STARTED
                # reset timers
                t = 0
                _timeToFirstFrame = win.getFutureFlipTime(clock="now")
                frameN = -1
                
                # --- Run Routine "practice1_result" ---
                # if trial has changed, end Routine now
                if isinstance(practice_trials, data.TrialHandler2) and thisPractice_trial.thisN != practice_trials.thisTrial.thisN:
                    continueRoutine = False
                practice1_result.forceEnded = routineForceEnded = not continueRoutine
                while continueRoutine and routineTimer.getTime() < 1.5:
                    # get current time
                    t = routineTimer.getTime()
                    tThisFlip = win.getFutureFlipTime(clock=routineTimer)
                    tThisFlipGlobal = win.getFutureFlipTime(clock=None)
                    frameN = frameN + 1  # number of completed frames (so 0 is the first frame)
                    # update/draw components on each frame
                    
                    # *image_20* updates
                    
                    # if image_20 is starting this frame...
                    if image_20.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
                        # keep track of start time/frame for later
                        image_20.frameNStart = frameN  # exact frame index
                        image_20.tStart = t  # local t and not account for scr refresh
                        image_20.tStartRefresh = tThisFlipGlobal  # on global time
                        win.timeOnFlip(image_20, 'tStartRefresh')  # time at next scr refresh
                        # add timestamp to datafile
                        thisExp.timestampOnFlip(win, 'image_20.started')
                        # update status
                        image_20.status = STARTED
                        image_20.setAutoDraw(True)
                    
                    # if image_20 is active this frame...
                    if image_20.status == STARTED:
                        # update params
                        pass
                    
                    # if image_20 is stopping this frame...
                    if image_20.status == STARTED:
                        # is it time to stop? (based on global clock, using actual start)
                        if tThisFlipGlobal > image_20.tStartRefresh + 1.5-frameTolerance:
                            # keep track of stop time/frame for later
                            image_20.tStop = t  # not accounting for scr refresh
                            image_20.tStopRefresh = tThisFlipGlobal  # on global time
                            image_20.frameNStop = frameN  # exact frame index
                            # add timestamp to datafile
                            thisExp.timestampOnFlip(win, 'image_20.stopped')
                            # update status
                            image_20.status = FINISHED
                            image_20.setAutoDraw(False)
                    
                    # check for quit (typically the Esc key)
                    if defaultKeyboard.getKeys(keyList=["escape"]):
                        thisExp.status = FINISHED
                    if thisExp.status == FINISHED or endExpNow:
                        endExperiment(thisExp, win=win)
                        return
                    # pause experiment here if requested
                    if thisExp.status == PAUSED:
                        pauseExperiment(
                            thisExp=thisExp, 
                            win=win, 
                            timers=[routineTimer], 
                            playbackComponents=[]
                        )
                        # skip the frame we paused on
                        continue
                    
                    # check if all components have finished
                    if not continueRoutine:  # a component has requested a forced-end of Routine
                        practice1_result.forceEnded = routineForceEnded = True
                        break
                    continueRoutine = False  # will revert to True if at least one component still running
                    for thisComponent in practice1_result.components:
                        if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:
                            continueRoutine = True
                            break  # at least one component has not yet finished
                    
                    # refresh the screen
                    if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen
                        win.flip()
                
                # --- Ending Routine "practice1_result" ---
                for thisComponent in practice1_result.components:
                    if hasattr(thisComponent, "setAutoDraw"):
                        thisComponent.setAutoDraw(False)
                # store stop times for practice1_result
                practice1_result.tStop = globalClock.getTime(format='float')
                practice1_result.tStopRefresh = tThisFlipGlobal
                thisExp.addData('practice1_result.stopped', practice1_result.tStop)
                # using non-slip timing so subtract the expected duration of this Routine (unless ended on request)
                if practice1_result.maxDurationReached:
                    routineTimer.addTime(-practice1_result.maxDuration)
                elif practice1_result.forceEnded:
                    routineTimer.reset()
                else:
                    routineTimer.addTime(-1.500000)
                
                # --- Prepare to start Routine "next_trial" ---
                # create an object to store info about Routine next_trial
                next_trial = data.Routine(
                    name='next_trial',
                    components=[next_trial_text],
                )
                next_trial.status = NOT_STARTED
                continueRoutine = True
                # update component parameters for each repeat
                # store start times for next_trial
                next_trial.tStartRefresh = win.getFutureFlipTime(clock=globalClock)
                next_trial.tStart = globalClock.getTime(format='float')
                next_trial.status = STARTED
                thisExp.addData('next_trial.started', next_trial.tStart)
                next_trial.maxDuration = None
                # keep track of which components have finished
                next_trialComponents = next_trial.components
                for thisComponent in next_trial.components:
                    thisComponent.tStart = None
                    thisComponent.tStop = None
                    thisComponent.tStartRefresh = None
                    thisComponent.tStopRefresh = None
                    if hasattr(thisComponent, 'status'):
                        thisComponent.status = NOT_STARTED
                # reset timers
                t = 0
                _timeToFirstFrame = win.getFutureFlipTime(clock="now")
                frameN = -1
                
                # --- Run Routine "next_trial" ---
                # if trial has changed, end Routine now
                if isinstance(practice_trials, data.TrialHandler2) and thisPractice_trial.thisN != practice_trials.thisTrial.thisN:
                    continueRoutine = False
                next_trial.forceEnded = routineForceEnded = not continueRoutine
                while continueRoutine and routineTimer.getTime() < 1.0:
                    # get current time
                    t = routineTimer.getTime()
                    tThisFlip = win.getFutureFlipTime(clock=routineTimer)
                    tThisFlipGlobal = win.getFutureFlipTime(clock=None)
                    frameN = frameN + 1  # number of completed frames (so 0 is the first frame)
                    # update/draw components on each frame
                    
                    # *next_trial_text* updates
                    
                    # if next_trial_text is starting this frame...
                    if next_trial_text.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
                        # keep track of start time/frame for later
                        next_trial_text.frameNStart = frameN  # exact frame index
                        next_trial_text.tStart = t  # local t and not account for scr refresh
                        next_trial_text.tStartRefresh = tThisFlipGlobal  # on global time
                        win.timeOnFlip(next_trial_text, 'tStartRefresh')  # time at next scr refresh
                        # add timestamp to datafile
                        thisExp.timestampOnFlip(win, 'next_trial_text.started')
                        # update status
                        next_trial_text.status = STARTED
                        next_trial_text.setAutoDraw(True)
                    
                    # if next_trial_text is active this frame...
                    if next_trial_text.status == STARTED:
                        # update params
                        pass
                    
                    # if next_trial_text is stopping this frame...
                    if next_trial_text.status == STARTED:
                        # is it time to stop? (based on global clock, using actual start)
                        if tThisFlipGlobal > next_trial_text.tStartRefresh + 1-frameTolerance:
                            # keep track of stop time/frame for later
                            next_trial_text.tStop = t  # not accounting for scr refresh
                            next_trial_text.tStopRefresh = tThisFlipGlobal  # on global time
                            next_trial_text.frameNStop = frameN  # exact frame index
                            # add timestamp to datafile
                            thisExp.timestampOnFlip(win, 'next_trial_text.stopped')
                            # update status
                            next_trial_text.status = FINISHED
                            next_trial_text.setAutoDraw(False)
                    
                    # check for quit (typically the Esc key)
                    if defaultKeyboard.getKeys(keyList=["escape"]):
                        thisExp.status = FINISHED
                    if thisExp.status == FINISHED or endExpNow:
                        endExperiment(thisExp, win=win)
                        return
                    # pause experiment here if requested
                    if thisExp.status == PAUSED:
                        pauseExperiment(
                            thisExp=thisExp, 
                            win=win, 
                            timers=[routineTimer], 
                            playbackComponents=[]
                        )
                        # skip the frame we paused on
                        continue
                    
                    # check if all components have finished
                    if not continueRoutine:  # a component has requested a forced-end of Routine
                        next_trial.forceEnded = routineForceEnded = True
                        break
                    continueRoutine = False  # will revert to True if at least one component still running
                    for thisComponent in next_trial.components:
                        if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:
                            continueRoutine = True
                            break  # at least one component has not yet finished
                    
                    # refresh the screen
                    if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen
                        win.flip()
                
                # --- Ending Routine "next_trial" ---
                for thisComponent in next_trial.components:
                    if hasattr(thisComponent, "setAutoDraw"):
                        thisComponent.setAutoDraw(False)
                # store stop times for next_trial
                next_trial.tStop = globalClock.getTime(format='float')
                next_trial.tStopRefresh = tThisFlipGlobal
                thisExp.addData('next_trial.stopped', next_trial.tStop)
                # using non-slip timing so subtract the expected duration of this Routine (unless ended on request)
                if next_trial.maxDurationReached:
                    routineTimer.addTime(-next_trial.maxDuration)
                elif next_trial.forceEnded:
                    routineTimer.reset()
                else:
                    routineTimer.addTime(-1.000000)
                thisExp.nextEntry()
                
            # completed 1.0 repeats of 'practice_trials'
            
            if thisSession is not None:
                # if running in a Session with a Liaison client, send data up to now
                thisSession.sendExperimentData()
            
            # --- Prepare to start Routine "practice1_quiz" ---
            # create an object to store info about Routine practice1_quiz
            practice1_quiz = data.Routine(
                name='practice1_quiz',
                components=[basket_2, fireworks_2, tree_2, text_24, text_25, text_27, practice_answer, text_26],
            )
            practice1_quiz.status = NOT_STARTED
            continueRoutine = True
            # update component parameters for each repeat
            tree_2.setImage('tree.png')
            # create starting attributes for practice_answer
            practice_answer.keys = []
            practice_answer.rt = []
            _practice_answer_allKeys = []
            # store start times for practice1_quiz
            practice1_quiz.tStartRefresh = win.getFutureFlipTime(clock=globalClock)
            practice1_quiz.tStart = globalClock.getTime(format='float')
            practice1_quiz.status = STARTED
            thisExp.addData('practice1_quiz.started', practice1_quiz.tStart)
            practice1_quiz.maxDuration = None
            # keep track of which components have finished
            practice1_quizComponents = practice1_quiz.components
            for thisComponent in practice1_quiz.components:
                thisComponent.tStart = None
                thisComponent.tStop = None
                thisComponent.tStartRefresh = None
                thisComponent.tStopRefresh = None
                if hasattr(thisComponent, 'status'):
                    thisComponent.status = NOT_STARTED
            # reset timers
            t = 0
            _timeToFirstFrame = win.getFutureFlipTime(clock="now")
            frameN = -1
            
            # --- Run Routine "practice1_quiz" ---
            # if trial has changed, end Routine now
            if isinstance(practice_loop, data.TrialHandler2) and thisPractice_loop.thisN != practice_loop.thisTrial.thisN:
                continueRoutine = False
            practice1_quiz.forceEnded = routineForceEnded = not continueRoutine
            while continueRoutine:
                # get current time
                t = routineTimer.getTime()
                tThisFlip = win.getFutureFlipTime(clock=routineTimer)
                tThisFlipGlobal = win.getFutureFlipTime(clock=None)
                frameN = frameN + 1  # number of completed frames (so 0 is the first frame)
                # update/draw components on each frame
                
                # *basket_2* updates
                
                # if basket_2 is starting this frame...
                if basket_2.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
                    # keep track of start time/frame for later
                    basket_2.frameNStart = frameN  # exact frame index
                    basket_2.tStart = t  # local t and not account for scr refresh
                    basket_2.tStartRefresh = tThisFlipGlobal  # on global time
                    win.timeOnFlip(basket_2, 'tStartRefresh')  # time at next scr refresh
                    # add timestamp to datafile
                    thisExp.timestampOnFlip(win, 'basket_2.started')
                    # update status
                    basket_2.status = STARTED
                    basket_2.setAutoDraw(True)
                
                # if basket_2 is active this frame...
                if basket_2.status == STARTED:
                    # update params
                    pass
                
                # *fireworks_2* updates
                
                # if fireworks_2 is starting this frame...
                if fireworks_2.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
                    # keep track of start time/frame for later
                    fireworks_2.frameNStart = frameN  # exact frame index
                    fireworks_2.tStart = t  # local t and not account for scr refresh
                    fireworks_2.tStartRefresh = tThisFlipGlobal  # on global time
                    win.timeOnFlip(fireworks_2, 'tStartRefresh')  # time at next scr refresh
                    # add timestamp to datafile
                    thisExp.timestampOnFlip(win, 'fireworks_2.started')
                    # update status
                    fireworks_2.status = STARTED
                    fireworks_2.setAutoDraw(True)
                
                # if fireworks_2 is active this frame...
                if fireworks_2.status == STARTED:
                    # update params
                    pass
                
                # *tree_2* updates
                
                # if tree_2 is starting this frame...
                if tree_2.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
                    # keep track of start time/frame for later
                    tree_2.frameNStart = frameN  # exact frame index
                    tree_2.tStart = t  # local t and not account for scr refresh
                    tree_2.tStartRefresh = tThisFlipGlobal  # on global time
                    win.timeOnFlip(tree_2, 'tStartRefresh')  # time at next scr refresh
                    # add timestamp to datafile
                    thisExp.timestampOnFlip(win, 'tree_2.started')
                    # update status
                    tree_2.status = STARTED
                    tree_2.setAutoDraw(True)
                
                # if tree_2 is active this frame...
                if tree_2.status == STARTED:
                    # update params
                    pass
                
                # *text_24* updates
                
                # if text_24 is starting this frame...
                if text_24.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
                    # keep track of start time/frame for later
                    text_24.frameNStart = frameN  # exact frame index
                    text_24.tStart = t  # local t and not account for scr refresh
                    text_24.tStartRefresh = tThisFlipGlobal  # on global time
                    win.timeOnFlip(text_24, 'tStartRefresh')  # time at next scr refresh
                    # add timestamp to datafile
                    thisExp.timestampOnFlip(win, 'text_24.started')
                    # update status
                    text_24.status = STARTED
                    text_24.setAutoDraw(True)
                
                # if text_24 is active this frame...
                if text_24.status == STARTED:
                    # update params
                    pass
                
                # *text_25* updates
                
                # if text_25 is starting this frame...
                if text_25.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
                    # keep track of start time/frame for later
                    text_25.frameNStart = frameN  # exact frame index
                    text_25.tStart = t  # local t and not account for scr refresh
                    text_25.tStartRefresh = tThisFlipGlobal  # on global time
                    win.timeOnFlip(text_25, 'tStartRefresh')  # time at next scr refresh
                    # add timestamp to datafile
                    thisExp.timestampOnFlip(win, 'text_25.started')
                    # update status
                    text_25.status = STARTED
                    text_25.setAutoDraw(True)
                
                # if text_25 is active this frame...
                if text_25.status == STARTED:
                    # update params
                    pass
                
                # *text_27* updates
                
                # if text_27 is starting this frame...
                if text_27.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
                    # keep track of start time/frame for later
                    text_27.frameNStart = frameN  # exact frame index
                    text_27.tStart = t  # local t and not account for scr refresh
                    text_27.tStartRefresh = tThisFlipGlobal  # on global time
                    win.timeOnFlip(text_27, 'tStartRefresh')  # time at next scr refresh
                    # add timestamp to datafile
                    thisExp.timestampOnFlip(win, 'text_27.started')
                    # update status
                    text_27.status = STARTED
                    text_27.setAutoDraw(True)
                
                # if text_27 is active this frame...
                if text_27.status == STARTED:
                    # update params
                    pass
                
                # *practice_answer* updates
                waitOnFlip = False
                
                # if practice_answer is starting this frame...
                if practice_answer.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
                    # keep track of start time/frame for later
                    practice_answer.frameNStart = frameN  # exact frame index
                    practice_answer.tStart = t  # local t and not account for scr refresh
                    practice_answer.tStartRefresh = tThisFlipGlobal  # on global time
                    win.timeOnFlip(practice_answer, 'tStartRefresh')  # time at next scr refresh
                    # add timestamp to datafile
                    thisExp.timestampOnFlip(win, 'practice_answer.started')
                    # update status
                    practice_answer.status = STARTED
                    # keyboard checking is just starting
                    waitOnFlip = True
                    win.callOnFlip(practice_answer.clock.reset)  # t=0 on next screen flip
                    win.callOnFlip(practice_answer.clearEvents, eventType='keyboard')  # clear events on next screen flip
                if practice_answer.status == STARTED and not waitOnFlip:
                    theseKeys = practice_answer.getKeys(keyList=['a','g','l'], ignoreKeys=["escape"], waitRelease=False)
                    _practice_answer_allKeys.extend(theseKeys)
                    if len(_practice_answer_allKeys):
                        practice_answer.keys = _practice_answer_allKeys[-1].name  # just the last key pressed
                        practice_answer.rt = _practice_answer_allKeys[-1].rt
                        practice_answer.duration = _practice_answer_allKeys[-1].duration
                        # was this correct?
                        if (practice_answer.keys == str('a')) or (practice_answer.keys == 'a'):
                            practice_answer.corr = 1
                        else:
                            practice_answer.corr = 0
                        # a response ends the routine
                        continueRoutine = False
                
                # *text_26* updates
                
                # if text_26 is starting this frame...
                if text_26.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
                    # keep track of start time/frame for later
                    text_26.frameNStart = frameN  # exact frame index
                    text_26.tStart = t  # local t and not account for scr refresh
                    text_26.tStartRefresh = tThisFlipGlobal  # on global time
                    win.timeOnFlip(text_26, 'tStartRefresh')  # time at next scr refresh
                    # add timestamp to datafile
                    thisExp.timestampOnFlip(win, 'text_26.started')
                    # update status
                    text_26.status = STARTED
                    text_26.setAutoDraw(True)
                
                # if text_26 is active this frame...
                if text_26.status == STARTED:
                    # update params
                    pass
                
                # check for quit (typically the Esc key)
                if defaultKeyboard.getKeys(keyList=["escape"]):
                    thisExp.status = FINISHED
                if thisExp.status == FINISHED or endExpNow:
                    endExperiment(thisExp, win=win)
                    return
                # pause experiment here if requested
                if thisExp.status == PAUSED:
                    pauseExperiment(
                        thisExp=thisExp, 
                        win=win, 
                        timers=[routineTimer], 
                        playbackComponents=[]
                    )
                    # skip the frame we paused on
                    continue
                
                # check if all components have finished
                if not continueRoutine:  # a component has requested a forced-end of Routine
                    practice1_quiz.forceEnded = routineForceEnded = True
                    break
                continueRoutine = False  # will revert to True if at least one component still running
                for thisComponent in practice1_quiz.components:
                    if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:
                        continueRoutine = True
                        break  # at least one component has not yet finished
                
                # refresh the screen
                if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen
                    win.flip()
            
            # --- Ending Routine "practice1_quiz" ---
            for thisComponent in practice1_quiz.components:
                if hasattr(thisComponent, "setAutoDraw"):
                    thisComponent.setAutoDraw(False)
            # store stop times for practice1_quiz
            practice1_quiz.tStop = globalClock.getTime(format='float')
            practice1_quiz.tStopRefresh = tThisFlipGlobal
            thisExp.addData('practice1_quiz.stopped', practice1_quiz.tStop)
            # check responses
            if practice_answer.keys in ['', [], None]:  # No response was made
                practice_answer.keys = None
                # was no response the correct answer?!
                if str('a').lower() == 'none':
                   practice_answer.corr = 1;  # correct non-response
                else:
                   practice_answer.corr = 0;  # failed to respond (incorrectly)
            # store data for practice_loop (TrialHandler)
            practice_loop.addData('practice_answer.keys',practice_answer.keys)
            practice_loop.addData('practice_answer.corr', practice_answer.corr)
            if practice_answer.keys != None:  # we had a response
                practice_loop.addData('practice_answer.rt', practice_answer.rt)
                practice_loop.addData('practice_answer.duration', practice_answer.duration)
            # Run 'End Routine' code from code_21
            if practice_answer.corr:
                print('correct answer')
                practice_loop.finished = True
            # the Routine "practice1_quiz" was not non-slip safe, so reset the non-slip timer
            routineTimer.reset()
            
            # --- Prepare to start Routine "practice1_quizfeedback" ---
            # create an object to store info about Routine practice1_quizfeedback
            practice1_quizfeedback = data.Routine(
                name='practice1_quizfeedback',
                components=[text_30],
            )
            practice1_quizfeedback.status = NOT_STARTED
            continueRoutine = True
            # update component parameters for each repeat
            # Run 'Begin Routine' code from code_14
            if practice_answer.corr:
              msg="Correct!" 
            else:
              msg="Wrong! Re-starting practice"
            text_30.setText(msg)
            # store start times for practice1_quizfeedback
            practice1_quizfeedback.tStartRefresh = win.getFutureFlipTime(clock=globalClock)
            practice1_quizfeedback.tStart = globalClock.getTime(format='float')
            practice1_quizfeedback.status = STARTED
            thisExp.addData('practice1_quizfeedback.started', practice1_quizfeedback.tStart)
            practice1_quizfeedback.maxDuration = None
            # keep track of which components have finished
            practice1_quizfeedbackComponents = practice1_quizfeedback.components
            for thisComponent in practice1_quizfeedback.components:
                thisComponent.tStart = None
                thisComponent.tStop = None
                thisComponent.tStartRefresh = None
                thisComponent.tStopRefresh = None
                if hasattr(thisComponent, 'status'):
                    thisComponent.status = NOT_STARTED
            # reset timers
            t = 0
            _timeToFirstFrame = win.getFutureFlipTime(clock="now")
            frameN = -1
            
            # --- Run Routine "practice1_quizfeedback" ---
            # if trial has changed, end Routine now
            if isinstance(practice_loop, data.TrialHandler2) and thisPractice_loop.thisN != practice_loop.thisTrial.thisN:
                continueRoutine = False
            practice1_quizfeedback.forceEnded = routineForceEnded = not continueRoutine
            while continueRoutine and routineTimer.getTime() < 1.0:
                # get current time
                t = routineTimer.getTime()
                tThisFlip = win.getFutureFlipTime(clock=routineTimer)
                tThisFlipGlobal = win.getFutureFlipTime(clock=None)
                frameN = frameN + 1  # number of completed frames (so 0 is the first frame)
                # update/draw components on each frame
                
                # *text_30* updates
                
                # if text_30 is starting this frame...
                if text_30.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
                    # keep track of start time/frame for later
                    text_30.frameNStart = frameN  # exact frame index
                    text_30.tStart = t  # local t and not account for scr refresh
                    text_30.tStartRefresh = tThisFlipGlobal  # on global time
                    win.timeOnFlip(text_30, 'tStartRefresh')  # time at next scr refresh
                    # add timestamp to datafile
                    thisExp.timestampOnFlip(win, 'text_30.started')
                    # update status
                    text_30.status = STARTED
                    text_30.setAutoDraw(True)
                
                # if text_30 is active this frame...
                if text_30.status == STARTED:
                    # update params
                    pass
                
                # if text_30 is stopping this frame...
                if text_30.status == STARTED:
                    # is it time to stop? (based on global clock, using actual start)
                    if tThisFlipGlobal > text_30.tStartRefresh + 1.0-frameTolerance:
                        # keep track of stop time/frame for later
                        text_30.tStop = t  # not accounting for scr refresh
                        text_30.tStopRefresh = tThisFlipGlobal  # on global time
                        text_30.frameNStop = frameN  # exact frame index
                        # add timestamp to datafile
                        thisExp.timestampOnFlip(win, 'text_30.stopped')
                        # update status
                        text_30.status = FINISHED
                        text_30.setAutoDraw(False)
                
                # check for quit (typically the Esc key)
                if defaultKeyboard.getKeys(keyList=["escape"]):
                    thisExp.status = FINISHED
                if thisExp.status == FINISHED or endExpNow:
                    endExperiment(thisExp, win=win)
                    return
                # pause experiment here if requested
                if thisExp.status == PAUSED:
                    pauseExperiment(
                        thisExp=thisExp, 
                        win=win, 
                        timers=[routineTimer], 
                        playbackComponents=[]
                    )
                    # skip the frame we paused on
                    continue
                
                # check if all components have finished
                if not continueRoutine:  # a component has requested a forced-end of Routine
                    practice1_quizfeedback.forceEnded = routineForceEnded = True
                    break
                continueRoutine = False  # will revert to True if at least one component still running
                for thisComponent in practice1_quizfeedback.components:
                    if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:
                        continueRoutine = True
                        break  # at least one component has not yet finished
                
                # refresh the screen
                if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen
                    win.flip()
            
            # --- Ending Routine "practice1_quizfeedback" ---
            for thisComponent in practice1_quizfeedback.components:
                if hasattr(thisComponent, "setAutoDraw"):
                    thisComponent.setAutoDraw(False)
            # store stop times for practice1_quizfeedback
            practice1_quizfeedback.tStop = globalClock.getTime(format='float')
            practice1_quizfeedback.tStopRefresh = tThisFlipGlobal
            thisExp.addData('practice1_quizfeedback.stopped', practice1_quizfeedback.tStop)
            # using non-slip timing so subtract the expected duration of this Routine (unless ended on request)
            if practice1_quizfeedback.maxDurationReached:
                routineTimer.addTime(-practice1_quizfeedback.maxDuration)
            elif practice1_quizfeedback.forceEnded:
                routineTimer.reset()
            else:
                routineTimer.addTime(-1.000000)
            thisExp.nextEntry()
            
        # completed 500.0 repeats of 'practice_loop'
        
        if thisSession is not None:
            # if running in a Session with a Liaison client, send data up to now
            thisSession.sendExperimentData()
        
        # --- Prepare to start Routine "memory_quiz_instructions" ---
        # create an object to store info about Routine memory_quiz_instructions
        memory_quiz_instructions = data.Routine(
            name='memory_quiz_instructions',
            components=[text_75, key_resp_23],
        )
        memory_quiz_instructions.status = NOT_STARTED
        continueRoutine = True
        # update component parameters for each repeat
        # create starting attributes for key_resp_23
        key_resp_23.keys = []
        key_resp_23.rt = []
        _key_resp_23_allKeys = []
        # store start times for memory_quiz_instructions
        memory_quiz_instructions.tStartRefresh = win.getFutureFlipTime(clock=globalClock)
        memory_quiz_instructions.tStart = globalClock.getTime(format='float')
        memory_quiz_instructions.status = STARTED
        thisExp.addData('memory_quiz_instructions.started', memory_quiz_instructions.tStart)
        memory_quiz_instructions.maxDuration = None
        # keep track of which components have finished
        memory_quiz_instructionsComponents = memory_quiz_instructions.components
        for thisComponent in memory_quiz_instructions.components:
            thisComponent.tStart = None
            thisComponent.tStop = None
            thisComponent.tStartRefresh = None
            thisComponent.tStopRefresh = None
            if hasattr(thisComponent, 'status'):
                thisComponent.status = NOT_STARTED
        # reset timers
        t = 0
        _timeToFirstFrame = win.getFutureFlipTime(clock="now")
        frameN = -1
        
        # --- Run Routine "memory_quiz_instructions" ---
        # if trial has changed, end Routine now
        if isinstance(instructions_get_right, data.TrialHandler2) and thisInstructions_get_right.thisN != instructions_get_right.thisTrial.thisN:
            continueRoutine = False
        memory_quiz_instructions.forceEnded = routineForceEnded = not continueRoutine
        while continueRoutine:
            # get current time
            t = routineTimer.getTime()
            tThisFlip = win.getFutureFlipTime(clock=routineTimer)
            tThisFlipGlobal = win.getFutureFlipTime(clock=None)
            frameN = frameN + 1  # number of completed frames (so 0 is the first frame)
            # update/draw components on each frame
            
            # *text_75* updates
            
            # if text_75 is starting this frame...
            if text_75.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
                # keep track of start time/frame for later
                text_75.frameNStart = frameN  # exact frame index
                text_75.tStart = t  # local t and not account for scr refresh
                text_75.tStartRefresh = tThisFlipGlobal  # on global time
                win.timeOnFlip(text_75, 'tStartRefresh')  # time at next scr refresh
                # add timestamp to datafile
                thisExp.timestampOnFlip(win, 'text_75.started')
                # update status
                text_75.status = STARTED
                text_75.setAutoDraw(True)
            
            # if text_75 is active this frame...
            if text_75.status == STARTED:
                # update params
                pass
            
            # *key_resp_23* updates
            waitOnFlip = False
            
            # if key_resp_23 is starting this frame...
            if key_resp_23.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
                # keep track of start time/frame for later
                key_resp_23.frameNStart = frameN  # exact frame index
                key_resp_23.tStart = t  # local t and not account for scr refresh
                key_resp_23.tStartRefresh = tThisFlipGlobal  # on global time
                win.timeOnFlip(key_resp_23, 'tStartRefresh')  # time at next scr refresh
                # add timestamp to datafile
                thisExp.timestampOnFlip(win, 'key_resp_23.started')
                # update status
                key_resp_23.status = STARTED
                # keyboard checking is just starting
                waitOnFlip = True
                win.callOnFlip(key_resp_23.clock.reset)  # t=0 on next screen flip
                win.callOnFlip(key_resp_23.clearEvents, eventType='keyboard')  # clear events on next screen flip
            if key_resp_23.status == STARTED and not waitOnFlip:
                theseKeys = key_resp_23.getKeys(keyList=['space'], ignoreKeys=["escape"], waitRelease=False)
                _key_resp_23_allKeys.extend(theseKeys)
                if len(_key_resp_23_allKeys):
                    key_resp_23.keys = _key_resp_23_allKeys[-1].name  # just the last key pressed
                    key_resp_23.rt = _key_resp_23_allKeys[-1].rt
                    key_resp_23.duration = _key_resp_23_allKeys[-1].duration
                    # a response ends the routine
                    continueRoutine = False
            
            # check for quit (typically the Esc key)
            if defaultKeyboard.getKeys(keyList=["escape"]):
                thisExp.status = FINISHED
            if thisExp.status == FINISHED or endExpNow:
                endExperiment(thisExp, win=win)
                return
            # pause experiment here if requested
            if thisExp.status == PAUSED:
                pauseExperiment(
                    thisExp=thisExp, 
                    win=win, 
                    timers=[routineTimer], 
                    playbackComponents=[]
                )
                # skip the frame we paused on
                continue
            
            # check if all components have finished
            if not continueRoutine:  # a component has requested a forced-end of Routine
                memory_quiz_instructions.forceEnded = routineForceEnded = True
                break
            continueRoutine = False  # will revert to True if at least one component still running
            for thisComponent in memory_quiz_instructions.components:
                if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:
                    continueRoutine = True
                    break  # at least one component has not yet finished
            
            # refresh the screen
            if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen
                win.flip()
        
        # --- Ending Routine "memory_quiz_instructions" ---
        for thisComponent in memory_quiz_instructions.components:
            if hasattr(thisComponent, "setAutoDraw"):
                thisComponent.setAutoDraw(False)
        # store stop times for memory_quiz_instructions
        memory_quiz_instructions.tStop = globalClock.getTime(format='float')
        memory_quiz_instructions.tStopRefresh = tThisFlipGlobal
        thisExp.addData('memory_quiz_instructions.stopped', memory_quiz_instructions.tStop)
        # check responses
        if key_resp_23.keys in ['', [], None]:  # No response was made
            key_resp_23.keys = None
        instructions_get_right.addData('key_resp_23.keys',key_resp_23.keys)
        if key_resp_23.keys != None:  # we had a response
            instructions_get_right.addData('key_resp_23.rt', key_resp_23.rt)
            instructions_get_right.addData('key_resp_23.duration', key_resp_23.duration)
        # the Routine "memory_quiz_instructions" was not non-slip safe, so reset the non-slip timer
        routineTimer.reset()
        
        # --- Prepare to start Routine "quiz1_i" ---
        # create an object to store info about Routine quiz1_i
        quiz1_i = data.Routine(
            name='quiz1_i',
            components=[text_43, key_resp_17],
        )
        quiz1_i.status = NOT_STARTED
        continueRoutine = True
        # update component parameters for each repeat
        # create starting attributes for key_resp_17
        key_resp_17.keys = []
        key_resp_17.rt = []
        _key_resp_17_allKeys = []
        # store start times for quiz1_i
        quiz1_i.tStartRefresh = win.getFutureFlipTime(clock=globalClock)
        quiz1_i.tStart = globalClock.getTime(format='float')
        quiz1_i.status = STARTED
        thisExp.addData('quiz1_i.started', quiz1_i.tStart)
        quiz1_i.maxDuration = None
        # keep track of which components have finished
        quiz1_iComponents = quiz1_i.components
        for thisComponent in quiz1_i.components:
            thisComponent.tStart = None
            thisComponent.tStop = None
            thisComponent.tStartRefresh = None
            thisComponent.tStopRefresh = None
            if hasattr(thisComponent, 'status'):
                thisComponent.status = NOT_STARTED
        # reset timers
        t = 0
        _timeToFirstFrame = win.getFutureFlipTime(clock="now")
        frameN = -1
        
        # --- Run Routine "quiz1_i" ---
        # if trial has changed, end Routine now
        if isinstance(instructions_get_right, data.TrialHandler2) and thisInstructions_get_right.thisN != instructions_get_right.thisTrial.thisN:
            continueRoutine = False
        quiz1_i.forceEnded = routineForceEnded = not continueRoutine
        while continueRoutine:
            # get current time
            t = routineTimer.getTime()
            tThisFlip = win.getFutureFlipTime(clock=routineTimer)
            tThisFlipGlobal = win.getFutureFlipTime(clock=None)
            frameN = frameN + 1  # number of completed frames (so 0 is the first frame)
            # update/draw components on each frame
            
            # *text_43* updates
            
            # if text_43 is starting this frame...
            if text_43.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
                # keep track of start time/frame for later
                text_43.frameNStart = frameN  # exact frame index
                text_43.tStart = t  # local t and not account for scr refresh
                text_43.tStartRefresh = tThisFlipGlobal  # on global time
                win.timeOnFlip(text_43, 'tStartRefresh')  # time at next scr refresh
                # add timestamp to datafile
                thisExp.timestampOnFlip(win, 'text_43.started')
                # update status
                text_43.status = STARTED
                text_43.setAutoDraw(True)
            
            # if text_43 is active this frame...
            if text_43.status == STARTED:
                # update params
                pass
            
            # *key_resp_17* updates
            waitOnFlip = False
            
            # if key_resp_17 is starting this frame...
            if key_resp_17.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
                # keep track of start time/frame for later
                key_resp_17.frameNStart = frameN  # exact frame index
                key_resp_17.tStart = t  # local t and not account for scr refresh
                key_resp_17.tStartRefresh = tThisFlipGlobal  # on global time
                win.timeOnFlip(key_resp_17, 'tStartRefresh')  # time at next scr refresh
                # add timestamp to datafile
                thisExp.timestampOnFlip(win, 'key_resp_17.started')
                # update status
                key_resp_17.status = STARTED
                # keyboard checking is just starting
                waitOnFlip = True
                win.callOnFlip(key_resp_17.clock.reset)  # t=0 on next screen flip
                win.callOnFlip(key_resp_17.clearEvents, eventType='keyboard')  # clear events on next screen flip
            if key_resp_17.status == STARTED and not waitOnFlip:
                theseKeys = key_resp_17.getKeys(keyList=['a','b','c','d'], ignoreKeys=["escape"], waitRelease=False)
                _key_resp_17_allKeys.extend(theseKeys)
                if len(_key_resp_17_allKeys):
                    key_resp_17.keys = _key_resp_17_allKeys[-1].name  # just the last key pressed
                    key_resp_17.rt = _key_resp_17_allKeys[-1].rt
                    key_resp_17.duration = _key_resp_17_allKeys[-1].duration
                    # a response ends the routine
                    continueRoutine = False
            
            # check for quit (typically the Esc key)
            if defaultKeyboard.getKeys(keyList=["escape"]):
                thisExp.status = FINISHED
            if thisExp.status == FINISHED or endExpNow:
                endExperiment(thisExp, win=win)
                return
            # pause experiment here if requested
            if thisExp.status == PAUSED:
                pauseExperiment(
                    thisExp=thisExp, 
                    win=win, 
                    timers=[routineTimer], 
                    playbackComponents=[]
                )
                # skip the frame we paused on
                continue
            
            # check if all components have finished
            if not continueRoutine:  # a component has requested a forced-end of Routine
                quiz1_i.forceEnded = routineForceEnded = True
                break
            continueRoutine = False  # will revert to True if at least one component still running
            for thisComponent in quiz1_i.components:
                if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:
                    continueRoutine = True
                    break  # at least one component has not yet finished
            
            # refresh the screen
            if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen
                win.flip()
        
        # --- Ending Routine "quiz1_i" ---
        for thisComponent in quiz1_i.components:
            if hasattr(thisComponent, "setAutoDraw"):
                thisComponent.setAutoDraw(False)
        # store stop times for quiz1_i
        quiz1_i.tStop = globalClock.getTime(format='float')
        quiz1_i.tStopRefresh = tThisFlipGlobal
        thisExp.addData('quiz1_i.stopped', quiz1_i.tStop)
        # Run 'End Routine' code from code_27
        correct=0
        if key_resp_17.keys=='c':
            correct+=1
        # check responses
        if key_resp_17.keys in ['', [], None]:  # No response was made
            key_resp_17.keys = None
        instructions_get_right.addData('key_resp_17.keys',key_resp_17.keys)
        if key_resp_17.keys != None:  # we had a response
            instructions_get_right.addData('key_resp_17.rt', key_resp_17.rt)
            instructions_get_right.addData('key_resp_17.duration', key_resp_17.duration)
        # the Routine "quiz1_i" was not non-slip safe, so reset the non-slip timer
        routineTimer.reset()
        
        # --- Prepare to start Routine "quiz2_i" ---
        # create an object to store info about Routine quiz2_i
        quiz2_i = data.Routine(
            name='quiz2_i',
            components=[text_70, key_resp_18],
        )
        quiz2_i.status = NOT_STARTED
        continueRoutine = True
        # update component parameters for each repeat
        # create starting attributes for key_resp_18
        key_resp_18.keys = []
        key_resp_18.rt = []
        _key_resp_18_allKeys = []
        # store start times for quiz2_i
        quiz2_i.tStartRefresh = win.getFutureFlipTime(clock=globalClock)
        quiz2_i.tStart = globalClock.getTime(format='float')
        quiz2_i.status = STARTED
        thisExp.addData('quiz2_i.started', quiz2_i.tStart)
        quiz2_i.maxDuration = None
        # keep track of which components have finished
        quiz2_iComponents = quiz2_i.components
        for thisComponent in quiz2_i.components:
            thisComponent.tStart = None
            thisComponent.tStop = None
            thisComponent.tStartRefresh = None
            thisComponent.tStopRefresh = None
            if hasattr(thisComponent, 'status'):
                thisComponent.status = NOT_STARTED
        # reset timers
        t = 0
        _timeToFirstFrame = win.getFutureFlipTime(clock="now")
        frameN = -1
        
        # --- Run Routine "quiz2_i" ---
        # if trial has changed, end Routine now
        if isinstance(instructions_get_right, data.TrialHandler2) and thisInstructions_get_right.thisN != instructions_get_right.thisTrial.thisN:
            continueRoutine = False
        quiz2_i.forceEnded = routineForceEnded = not continueRoutine
        while continueRoutine:
            # get current time
            t = routineTimer.getTime()
            tThisFlip = win.getFutureFlipTime(clock=routineTimer)
            tThisFlipGlobal = win.getFutureFlipTime(clock=None)
            frameN = frameN + 1  # number of completed frames (so 0 is the first frame)
            # update/draw components on each frame
            
            # *text_70* updates
            
            # if text_70 is starting this frame...
            if text_70.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
                # keep track of start time/frame for later
                text_70.frameNStart = frameN  # exact frame index
                text_70.tStart = t  # local t and not account for scr refresh
                text_70.tStartRefresh = tThisFlipGlobal  # on global time
                win.timeOnFlip(text_70, 'tStartRefresh')  # time at next scr refresh
                # add timestamp to datafile
                thisExp.timestampOnFlip(win, 'text_70.started')
                # update status
                text_70.status = STARTED
                text_70.setAutoDraw(True)
            
            # if text_70 is active this frame...
            if text_70.status == STARTED:
                # update params
                pass
            
            # *key_resp_18* updates
            waitOnFlip = False
            
            # if key_resp_18 is starting this frame...
            if key_resp_18.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
                # keep track of start time/frame for later
                key_resp_18.frameNStart = frameN  # exact frame index
                key_resp_18.tStart = t  # local t and not account for scr refresh
                key_resp_18.tStartRefresh = tThisFlipGlobal  # on global time
                win.timeOnFlip(key_resp_18, 'tStartRefresh')  # time at next scr refresh
                # add timestamp to datafile
                thisExp.timestampOnFlip(win, 'key_resp_18.started')
                # update status
                key_resp_18.status = STARTED
                # keyboard checking is just starting
                waitOnFlip = True
                win.callOnFlip(key_resp_18.clock.reset)  # t=0 on next screen flip
                win.callOnFlip(key_resp_18.clearEvents, eventType='keyboard')  # clear events on next screen flip
            if key_resp_18.status == STARTED and not waitOnFlip:
                theseKeys = key_resp_18.getKeys(keyList=['a','b','c','d'], ignoreKeys=["escape"], waitRelease=False)
                _key_resp_18_allKeys.extend(theseKeys)
                if len(_key_resp_18_allKeys):
                    key_resp_18.keys = _key_resp_18_allKeys[-1].name  # just the last key pressed
                    key_resp_18.rt = _key_resp_18_allKeys[-1].rt
                    key_resp_18.duration = _key_resp_18_allKeys[-1].duration
                    # a response ends the routine
                    continueRoutine = False
            
            # check for quit (typically the Esc key)
            if defaultKeyboard.getKeys(keyList=["escape"]):
                thisExp.status = FINISHED
            if thisExp.status == FINISHED or endExpNow:
                endExperiment(thisExp, win=win)
                return
            # pause experiment here if requested
            if thisExp.status == PAUSED:
                pauseExperiment(
                    thisExp=thisExp, 
                    win=win, 
                    timers=[routineTimer], 
                    playbackComponents=[]
                )
                # skip the frame we paused on
                continue
            
            # check if all components have finished
            if not continueRoutine:  # a component has requested a forced-end of Routine
                quiz2_i.forceEnded = routineForceEnded = True
                break
            continueRoutine = False  # will revert to True if at least one component still running
            for thisComponent in quiz2_i.components:
                if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:
                    continueRoutine = True
                    break  # at least one component has not yet finished
            
            # refresh the screen
            if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen
                win.flip()
        
        # --- Ending Routine "quiz2_i" ---
        for thisComponent in quiz2_i.components:
            if hasattr(thisComponent, "setAutoDraw"):
                thisComponent.setAutoDraw(False)
        # store stop times for quiz2_i
        quiz2_i.tStop = globalClock.getTime(format='float')
        quiz2_i.tStopRefresh = tThisFlipGlobal
        thisExp.addData('quiz2_i.stopped', quiz2_i.tStop)
        # Run 'End Routine' code from code_30
        if key_resp_18.keys=='c':
            correct+=1
        # check responses
        if key_resp_18.keys in ['', [], None]:  # No response was made
            key_resp_18.keys = None
        instructions_get_right.addData('key_resp_18.keys',key_resp_18.keys)
        if key_resp_18.keys != None:  # we had a response
            instructions_get_right.addData('key_resp_18.rt', key_resp_18.rt)
            instructions_get_right.addData('key_resp_18.duration', key_resp_18.duration)
        # the Routine "quiz2_i" was not non-slip safe, so reset the non-slip timer
        routineTimer.reset()
        
        # --- Prepare to start Routine "quiz3" ---
        # create an object to store info about Routine quiz3
        quiz3 = data.Routine(
            name='quiz3',
            components=[text_71, key_resp_19],
        )
        quiz3.status = NOT_STARTED
        continueRoutine = True
        # update component parameters for each repeat
        # create starting attributes for key_resp_19
        key_resp_19.keys = []
        key_resp_19.rt = []
        _key_resp_19_allKeys = []
        # store start times for quiz3
        quiz3.tStartRefresh = win.getFutureFlipTime(clock=globalClock)
        quiz3.tStart = globalClock.getTime(format='float')
        quiz3.status = STARTED
        thisExp.addData('quiz3.started', quiz3.tStart)
        quiz3.maxDuration = None
        # keep track of which components have finished
        quiz3Components = quiz3.components
        for thisComponent in quiz3.components:
            thisComponent.tStart = None
            thisComponent.tStop = None
            thisComponent.tStartRefresh = None
            thisComponent.tStopRefresh = None
            if hasattr(thisComponent, 'status'):
                thisComponent.status = NOT_STARTED
        # reset timers
        t = 0
        _timeToFirstFrame = win.getFutureFlipTime(clock="now")
        frameN = -1
        
        # --- Run Routine "quiz3" ---
        # if trial has changed, end Routine now
        if isinstance(instructions_get_right, data.TrialHandler2) and thisInstructions_get_right.thisN != instructions_get_right.thisTrial.thisN:
            continueRoutine = False
        quiz3.forceEnded = routineForceEnded = not continueRoutine
        while continueRoutine:
            # get current time
            t = routineTimer.getTime()
            tThisFlip = win.getFutureFlipTime(clock=routineTimer)
            tThisFlipGlobal = win.getFutureFlipTime(clock=None)
            frameN = frameN + 1  # number of completed frames (so 0 is the first frame)
            # update/draw components on each frame
            
            # *text_71* updates
            
            # if text_71 is starting this frame...
            if text_71.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
                # keep track of start time/frame for later
                text_71.frameNStart = frameN  # exact frame index
                text_71.tStart = t  # local t and not account for scr refresh
                text_71.tStartRefresh = tThisFlipGlobal  # on global time
                win.timeOnFlip(text_71, 'tStartRefresh')  # time at next scr refresh
                # add timestamp to datafile
                thisExp.timestampOnFlip(win, 'text_71.started')
                # update status
                text_71.status = STARTED
                text_71.setAutoDraw(True)
            
            # if text_71 is active this frame...
            if text_71.status == STARTED:
                # update params
                pass
            
            # *key_resp_19* updates
            waitOnFlip = False
            
            # if key_resp_19 is starting this frame...
            if key_resp_19.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
                # keep track of start time/frame for later
                key_resp_19.frameNStart = frameN  # exact frame index
                key_resp_19.tStart = t  # local t and not account for scr refresh
                key_resp_19.tStartRefresh = tThisFlipGlobal  # on global time
                win.timeOnFlip(key_resp_19, 'tStartRefresh')  # time at next scr refresh
                # add timestamp to datafile
                thisExp.timestampOnFlip(win, 'key_resp_19.started')
                # update status
                key_resp_19.status = STARTED
                # keyboard checking is just starting
                waitOnFlip = True
                win.callOnFlip(key_resp_19.clock.reset)  # t=0 on next screen flip
                win.callOnFlip(key_resp_19.clearEvents, eventType='keyboard')  # clear events on next screen flip
            if key_resp_19.status == STARTED and not waitOnFlip:
                theseKeys = key_resp_19.getKeys(keyList=['a','b','c','d'], ignoreKeys=["escape"], waitRelease=False)
                _key_resp_19_allKeys.extend(theseKeys)
                if len(_key_resp_19_allKeys):
                    key_resp_19.keys = _key_resp_19_allKeys[-1].name  # just the last key pressed
                    key_resp_19.rt = _key_resp_19_allKeys[-1].rt
                    key_resp_19.duration = _key_resp_19_allKeys[-1].duration
                    # a response ends the routine
                    continueRoutine = False
            
            # check for quit (typically the Esc key)
            if defaultKeyboard.getKeys(keyList=["escape"]):
                thisExp.status = FINISHED
            if thisExp.status == FINISHED or endExpNow:
                endExperiment(thisExp, win=win)
                return
            # pause experiment here if requested
            if thisExp.status == PAUSED:
                pauseExperiment(
                    thisExp=thisExp, 
                    win=win, 
                    timers=[routineTimer], 
                    playbackComponents=[]
                )
                # skip the frame we paused on
                continue
            
            # check if all components have finished
            if not continueRoutine:  # a component has requested a forced-end of Routine
                quiz3.forceEnded = routineForceEnded = True
                break
            continueRoutine = False  # will revert to True if at least one component still running
            for thisComponent in quiz3.components:
                if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:
                    continueRoutine = True
                    break  # at least one component has not yet finished
            
            # refresh the screen
            if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen
                win.flip()
        
        # --- Ending Routine "quiz3" ---
        for thisComponent in quiz3.components:
            if hasattr(thisComponent, "setAutoDraw"):
                thisComponent.setAutoDraw(False)
        # store stop times for quiz3
        quiz3.tStop = globalClock.getTime(format='float')
        quiz3.tStopRefresh = tThisFlipGlobal
        thisExp.addData('quiz3.stopped', quiz3.tStop)
        # Run 'End Routine' code from code_31
        if key_resp_19.keys=='b':
            correct+=1
        
        # check responses
        if key_resp_19.keys in ['', [], None]:  # No response was made
            key_resp_19.keys = None
        instructions_get_right.addData('key_resp_19.keys',key_resp_19.keys)
        if key_resp_19.keys != None:  # we had a response
            instructions_get_right.addData('key_resp_19.rt', key_resp_19.rt)
            instructions_get_right.addData('key_resp_19.duration', key_resp_19.duration)
        # the Routine "quiz3" was not non-slip safe, so reset the non-slip timer
        routineTimer.reset()
        
        # --- Prepare to start Routine "quiz4" ---
        # create an object to store info about Routine quiz4
        quiz4 = data.Routine(
            name='quiz4',
            components=[text_72, key_resp_20],
        )
        quiz4.status = NOT_STARTED
        continueRoutine = True
        # update component parameters for each repeat
        # create starting attributes for key_resp_20
        key_resp_20.keys = []
        key_resp_20.rt = []
        _key_resp_20_allKeys = []
        # store start times for quiz4
        quiz4.tStartRefresh = win.getFutureFlipTime(clock=globalClock)
        quiz4.tStart = globalClock.getTime(format='float')
        quiz4.status = STARTED
        thisExp.addData('quiz4.started', quiz4.tStart)
        quiz4.maxDuration = None
        # keep track of which components have finished
        quiz4Components = quiz4.components
        for thisComponent in quiz4.components:
            thisComponent.tStart = None
            thisComponent.tStop = None
            thisComponent.tStartRefresh = None
            thisComponent.tStopRefresh = None
            if hasattr(thisComponent, 'status'):
                thisComponent.status = NOT_STARTED
        # reset timers
        t = 0
        _timeToFirstFrame = win.getFutureFlipTime(clock="now")
        frameN = -1
        
        # --- Run Routine "quiz4" ---
        # if trial has changed, end Routine now
        if isinstance(instructions_get_right, data.TrialHandler2) and thisInstructions_get_right.thisN != instructions_get_right.thisTrial.thisN:
            continueRoutine = False
        quiz4.forceEnded = routineForceEnded = not continueRoutine
        while continueRoutine:
            # get current time
            t = routineTimer.getTime()
            tThisFlip = win.getFutureFlipTime(clock=routineTimer)
            tThisFlipGlobal = win.getFutureFlipTime(clock=None)
            frameN = frameN + 1  # number of completed frames (so 0 is the first frame)
            # update/draw components on each frame
            
            # *text_72* updates
            
            # if text_72 is starting this frame...
            if text_72.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
                # keep track of start time/frame for later
                text_72.frameNStart = frameN  # exact frame index
                text_72.tStart = t  # local t and not account for scr refresh
                text_72.tStartRefresh = tThisFlipGlobal  # on global time
                win.timeOnFlip(text_72, 'tStartRefresh')  # time at next scr refresh
                # add timestamp to datafile
                thisExp.timestampOnFlip(win, 'text_72.started')
                # update status
                text_72.status = STARTED
                text_72.setAutoDraw(True)
            
            # if text_72 is active this frame...
            if text_72.status == STARTED:
                # update params
                pass
            
            # *key_resp_20* updates
            waitOnFlip = False
            
            # if key_resp_20 is starting this frame...
            if key_resp_20.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
                # keep track of start time/frame for later
                key_resp_20.frameNStart = frameN  # exact frame index
                key_resp_20.tStart = t  # local t and not account for scr refresh
                key_resp_20.tStartRefresh = tThisFlipGlobal  # on global time
                win.timeOnFlip(key_resp_20, 'tStartRefresh')  # time at next scr refresh
                # add timestamp to datafile
                thisExp.timestampOnFlip(win, 'key_resp_20.started')
                # update status
                key_resp_20.status = STARTED
                # keyboard checking is just starting
                waitOnFlip = True
                win.callOnFlip(key_resp_20.clock.reset)  # t=0 on next screen flip
                win.callOnFlip(key_resp_20.clearEvents, eventType='keyboard')  # clear events on next screen flip
            if key_resp_20.status == STARTED and not waitOnFlip:
                theseKeys = key_resp_20.getKeys(keyList=['a','b','c','d'], ignoreKeys=["escape"], waitRelease=False)
                _key_resp_20_allKeys.extend(theseKeys)
                if len(_key_resp_20_allKeys):
                    key_resp_20.keys = _key_resp_20_allKeys[-1].name  # just the last key pressed
                    key_resp_20.rt = _key_resp_20_allKeys[-1].rt
                    key_resp_20.duration = _key_resp_20_allKeys[-1].duration
                    # a response ends the routine
                    continueRoutine = False
            
            # check for quit (typically the Esc key)
            if defaultKeyboard.getKeys(keyList=["escape"]):
                thisExp.status = FINISHED
            if thisExp.status == FINISHED or endExpNow:
                endExperiment(thisExp, win=win)
                return
            # pause experiment here if requested
            if thisExp.status == PAUSED:
                pauseExperiment(
                    thisExp=thisExp, 
                    win=win, 
                    timers=[routineTimer], 
                    playbackComponents=[]
                )
                # skip the frame we paused on
                continue
            
            # check if all components have finished
            if not continueRoutine:  # a component has requested a forced-end of Routine
                quiz4.forceEnded = routineForceEnded = True
                break
            continueRoutine = False  # will revert to True if at least one component still running
            for thisComponent in quiz4.components:
                if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:
                    continueRoutine = True
                    break  # at least one component has not yet finished
            
            # refresh the screen
            if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen
                win.flip()
        
        # --- Ending Routine "quiz4" ---
        for thisComponent in quiz4.components:
            if hasattr(thisComponent, "setAutoDraw"):
                thisComponent.setAutoDraw(False)
        # store stop times for quiz4
        quiz4.tStop = globalClock.getTime(format='float')
        quiz4.tStopRefresh = tThisFlipGlobal
        thisExp.addData('quiz4.stopped', quiz4.tStop)
        # Run 'End Routine' code from code_35
        if key_resp_20.keys=='b':
            correct+=1
        
        if correct==4:
            instructions_get_right.finished = True
            msg='Correct! You can now move on'
        else:
            msg='Incorrect! You need to repeat the instructions.'
        # check responses
        if key_resp_20.keys in ['', [], None]:  # No response was made
            key_resp_20.keys = None
        instructions_get_right.addData('key_resp_20.keys',key_resp_20.keys)
        if key_resp_20.keys != None:  # we had a response
            instructions_get_right.addData('key_resp_20.rt', key_resp_20.rt)
            instructions_get_right.addData('key_resp_20.duration', key_resp_20.duration)
        # the Routine "quiz4" was not non-slip safe, so reset the non-slip timer
        routineTimer.reset()
        
        # --- Prepare to start Routine "quiz_feedback" ---
        # create an object to store info about Routine quiz_feedback
        quiz_feedback = data.Routine(
            name='quiz_feedback',
            components=[result_q_instr],
        )
        quiz_feedback.status = NOT_STARTED
        continueRoutine = True
        # update component parameters for each repeat
        result_q_instr.setText(msg)
        # store start times for quiz_feedback
        quiz_feedback.tStartRefresh = win.getFutureFlipTime(clock=globalClock)
        quiz_feedback.tStart = globalClock.getTime(format='float')
        quiz_feedback.status = STARTED
        thisExp.addData('quiz_feedback.started', quiz_feedback.tStart)
        quiz_feedback.maxDuration = None
        # keep track of which components have finished
        quiz_feedbackComponents = quiz_feedback.components
        for thisComponent in quiz_feedback.components:
            thisComponent.tStart = None
            thisComponent.tStop = None
            thisComponent.tStartRefresh = None
            thisComponent.tStopRefresh = None
            if hasattr(thisComponent, 'status'):
                thisComponent.status = NOT_STARTED
        # reset timers
        t = 0
        _timeToFirstFrame = win.getFutureFlipTime(clock="now")
        frameN = -1
        
        # --- Run Routine "quiz_feedback" ---
        # if trial has changed, end Routine now
        if isinstance(instructions_get_right, data.TrialHandler2) and thisInstructions_get_right.thisN != instructions_get_right.thisTrial.thisN:
            continueRoutine = False
        quiz_feedback.forceEnded = routineForceEnded = not continueRoutine
        while continueRoutine and routineTimer.getTime() < 1.25:
            # get current time
            t = routineTimer.getTime()
            tThisFlip = win.getFutureFlipTime(clock=routineTimer)
            tThisFlipGlobal = win.getFutureFlipTime(clock=None)
            frameN = frameN + 1  # number of completed frames (so 0 is the first frame)
            # update/draw components on each frame
            
            # *result_q_instr* updates
            
            # if result_q_instr is starting this frame...
            if result_q_instr.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
                # keep track of start time/frame for later
                result_q_instr.frameNStart = frameN  # exact frame index
                result_q_instr.tStart = t  # local t and not account for scr refresh
                result_q_instr.tStartRefresh = tThisFlipGlobal  # on global time
                win.timeOnFlip(result_q_instr, 'tStartRefresh')  # time at next scr refresh
                # add timestamp to datafile
                thisExp.timestampOnFlip(win, 'result_q_instr.started')
                # update status
                result_q_instr.status = STARTED
                result_q_instr.setAutoDraw(True)
            
            # if result_q_instr is active this frame...
            if result_q_instr.status == STARTED:
                # update params
                pass
            
            # if result_q_instr is stopping this frame...
            if result_q_instr.status == STARTED:
                # is it time to stop? (based on global clock, using actual start)
                if tThisFlipGlobal > result_q_instr.tStartRefresh + 1.25-frameTolerance:
                    # keep track of stop time/frame for later
                    result_q_instr.tStop = t  # not accounting for scr refresh
                    result_q_instr.tStopRefresh = tThisFlipGlobal  # on global time
                    result_q_instr.frameNStop = frameN  # exact frame index
                    # add timestamp to datafile
                    thisExp.timestampOnFlip(win, 'result_q_instr.stopped')
                    # update status
                    result_q_instr.status = FINISHED
                    result_q_instr.setAutoDraw(False)
            
            # check for quit (typically the Esc key)
            if defaultKeyboard.getKeys(keyList=["escape"]):
                thisExp.status = FINISHED
            if thisExp.status == FINISHED or endExpNow:
                endExperiment(thisExp, win=win)
                return
            # pause experiment here if requested
            if thisExp.status == PAUSED:
                pauseExperiment(
                    thisExp=thisExp, 
                    win=win, 
                    timers=[routineTimer], 
                    playbackComponents=[]
                )
                # skip the frame we paused on
                continue
            
            # check if all components have finished
            if not continueRoutine:  # a component has requested a forced-end of Routine
                quiz_feedback.forceEnded = routineForceEnded = True
                break
            continueRoutine = False  # will revert to True if at least one component still running
            for thisComponent in quiz_feedback.components:
                if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:
                    continueRoutine = True
                    break  # at least one component has not yet finished
            
            # refresh the screen
            if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen
                win.flip()
        
        # --- Ending Routine "quiz_feedback" ---
        for thisComponent in quiz_feedback.components:
            if hasattr(thisComponent, "setAutoDraw"):
                thisComponent.setAutoDraw(False)
        # store stop times for quiz_feedback
        quiz_feedback.tStop = globalClock.getTime(format='float')
        quiz_feedback.tStopRefresh = tThisFlipGlobal
        thisExp.addData('quiz_feedback.stopped', quiz_feedback.tStop)
        # using non-slip timing so subtract the expected duration of this Routine (unless ended on request)
        if quiz_feedback.maxDurationReached:
            routineTimer.addTime(-quiz_feedback.maxDuration)
        elif quiz_feedback.forceEnded:
            routineTimer.reset()
        else:
            routineTimer.addTime(-1.250000)
        thisExp.nextEntry()
        
    # completed 500.0 repeats of 'instructions_get_right'
    
    if thisSession is not None:
        # if running in a Session with a Liaison client, send data up to now
        thisSession.sendExperimentData()
    
    # --- Prepare to start Routine "start_learning" ---
    # create an object to store info about Routine start_learning
    start_learning = data.Routine(
        name='start_learning',
        components=[text_31, key_resp_7],
    )
    start_learning.status = NOT_STARTED
    continueRoutine = True
    # update component parameters for each repeat
    # create starting attributes for key_resp_7
    key_resp_7.keys = []
    key_resp_7.rt = []
    _key_resp_7_allKeys = []
    # store start times for start_learning
    start_learning.tStartRefresh = win.getFutureFlipTime(clock=globalClock)
    start_learning.tStart = globalClock.getTime(format='float')
    start_learning.status = STARTED
    thisExp.addData('start_learning.started', start_learning.tStart)
    start_learning.maxDuration = None
    # keep track of which components have finished
    start_learningComponents = start_learning.components
    for thisComponent in start_learning.components:
        thisComponent.tStart = None
        thisComponent.tStop = None
        thisComponent.tStartRefresh = None
        thisComponent.tStopRefresh = None
        if hasattr(thisComponent, 'status'):
            thisComponent.status = NOT_STARTED
    # reset timers
    t = 0
    _timeToFirstFrame = win.getFutureFlipTime(clock="now")
    frameN = -1
    
    # --- Run Routine "start_learning" ---
    start_learning.forceEnded = routineForceEnded = not continueRoutine
    while continueRoutine:
        # get current time
        t = routineTimer.getTime()
        tThisFlip = win.getFutureFlipTime(clock=routineTimer)
        tThisFlipGlobal = win.getFutureFlipTime(clock=None)
        frameN = frameN + 1  # number of completed frames (so 0 is the first frame)
        # update/draw components on each frame
        
        # *text_31* updates
        
        # if text_31 is starting this frame...
        if text_31.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
            # keep track of start time/frame for later
            text_31.frameNStart = frameN  # exact frame index
            text_31.tStart = t  # local t and not account for scr refresh
            text_31.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(text_31, 'tStartRefresh')  # time at next scr refresh
            # add timestamp to datafile
            thisExp.timestampOnFlip(win, 'text_31.started')
            # update status
            text_31.status = STARTED
            text_31.setAutoDraw(True)
        
        # if text_31 is active this frame...
        if text_31.status == STARTED:
            # update params
            pass
        
        # *key_resp_7* updates
        waitOnFlip = False
        
        # if key_resp_7 is starting this frame...
        if key_resp_7.status == NOT_STARTED and tThisFlip >= 0-frameTolerance:
            # keep track of start time/frame for later
            key_resp_7.frameNStart = frameN  # exact frame index
            key_resp_7.tStart = t  # local t and not account for scr refresh
            key_resp_7.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(key_resp_7, 'tStartRefresh')  # time at next scr refresh
            # add timestamp to datafile
            thisExp.timestampOnFlip(win, 'key_resp_7.started')
            # update status
            key_resp_7.status = STARTED
            # keyboard checking is just starting
            waitOnFlip = True
            win.callOnFlip(key_resp_7.clock.reset)  # t=0 on next screen flip
            win.callOnFlip(key_resp_7.clearEvents, eventType='keyboard')  # clear events on next screen flip
        if key_resp_7.status == STARTED and not waitOnFlip:
            theseKeys = key_resp_7.getKeys(keyList=['space'], ignoreKeys=["escape"], waitRelease=False)
            _key_resp_7_allKeys.extend(theseKeys)
            if len(_key_resp_7_allKeys):
                key_resp_7.keys = _key_resp_7_allKeys[-1].name  # just the last key pressed
                key_resp_7.rt = _key_resp_7_allKeys[-1].rt
                key_resp_7.duration = _key_resp_7_allKeys[-1].duration
                # a response ends the routine
                continueRoutine = False
        
        # check for quit (typically the Esc key)
        if defaultKeyboard.getKeys(keyList=["escape"]):
            thisExp.status = FINISHED
        if thisExp.status == FINISHED or endExpNow:
            endExperiment(thisExp, win=win)
            return
        # pause experiment here if requested
        if thisExp.status == PAUSED:
            pauseExperiment(
                thisExp=thisExp, 
                win=win, 
                timers=[routineTimer], 
                playbackComponents=[]
            )
            # skip the frame we paused on
            continue
        
        # check if all components have finished
        if not continueRoutine:  # a component has requested a forced-end of Routine
            start_learning.forceEnded = routineForceEnded = True
            break
        continueRoutine = False  # will revert to True if at least one component still running
        for thisComponent in start_learning.components:
            if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:
                continueRoutine = True
                break  # at least one component has not yet finished
        
        # refresh the screen
        if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen
            win.flip()
    
    # --- Ending Routine "start_learning" ---
    for thisComponent in start_learning.components:
        if hasattr(thisComponent, "setAutoDraw"):
            thisComponent.setAutoDraw(False)
    # store stop times for start_learning
    start_learning.tStop = globalClock.getTime(format='float')
    start_learning.tStopRefresh = tThisFlipGlobal
    thisExp.addData('start_learning.stopped', start_learning.tStop)
    thisExp.nextEntry()
    # the Routine "start_learning" was not non-slip safe, so reset the non-slip timer
    routineTimer.reset()
    
    # set up handler to look after randomisation of conditions etc
    learning_phase = data.TrialHandler2(
        name='learning_phase',
        nReps=1.0, 
        method='random', 
        extraInfo=expInfo, 
        originPath=-1, 
        trialList=[None], 
        seed=None, 
    )
    thisExp.addLoop(learning_phase)  # add the loop to the experiment
    thisLearning_phase = learning_phase.trialList[0]  # so we can initialise stimuli with some values
    # abbreviate parameter names if possible (e.g. rgb = thisLearning_phase.rgb)
    if thisLearning_phase != None:
        for paramName in thisLearning_phase:
            globals()[paramName] = thisLearning_phase[paramName]
    if thisSession is not None:
        # if running in a Session with a Liaison client, send data up to now
        thisSession.sendExperimentData()
    
    for thisLearning_phase in learning_phase:
        currentLoop = learning_phase
        thisExp.timestampOnFlip(win, 'thisRow.t', format=globalClock.format)
        if thisSession is not None:
            # if running in a Session with a Liaison client, send data up to now
            thisSession.sendExperimentData()
        # abbreviate parameter names if possible (e.g. rgb = thisLearning_phase.rgb)
        if thisLearning_phase != None:
            for paramName in thisLearning_phase:
                globals()[paramName] = thisLearning_phase[paramName]
        
        # set up handler to look after randomisation of conditions etc
        learn_1 = data.TrialHandler2(
            name='learn_1',
            nReps=1.0, 
            method='random', 
            extraInfo=expInfo, 
            originPath=-1, 
            trialList=data.importConditions('try_game.xlsx'), 
            seed=None, 
        )
        thisExp.addLoop(learn_1)  # add the loop to the experiment
        thisLearn_1 = learn_1.trialList[0]  # so we can initialise stimuli with some values
        # abbreviate parameter names if possible (e.g. rgb = thisLearn_1.rgb)
        if thisLearn_1 != None:
            for paramName in thisLearn_1:
                globals()[paramName] = thisLearn_1[paramName]
        if thisSession is not None:
            # if running in a Session with a Liaison client, send data up to now
            thisSession.sendExperimentData()
        
        for thisLearn_1 in learn_1:
            currentLoop = learn_1
            thisExp.timestampOnFlip(win, 'thisRow.t', format=globalClock.format)
            if thisSession is not None:
                # if running in a Session with a Liaison client, send data up to now
                thisSession.sendExperimentData()
            # abbreviate parameter names if possible (e.g. rgb = thisLearn_1.rgb)
            if thisLearn_1 != None:
                for paramName in thisLearn_1:
                    globals()[paramName] = thisLearn_1[paramName]
            
            # set up handler to look after randomisation of conditions etc
            incorrect_loop = data.TrialHandler2(
                name='incorrect_loop',
                nReps=9999.0, 
                method='random', 
                extraInfo=expInfo, 
                originPath=-1, 
                trialList=[None], 
                seed=None, 
            )
            thisExp.addLoop(incorrect_loop)  # add the loop to the experiment
            thisIncorrect_loop = incorrect_loop.trialList[0]  # so we can initialise stimuli with some values
            # abbreviate parameter names if possible (e.g. rgb = thisIncorrect_loop.rgb)
            if thisIncorrect_loop != None:
                for paramName in thisIncorrect_loop:
                    globals()[paramName] = thisIncorrect_loop[paramName]
            if thisSession is not None:
                # if running in a Session with a Liaison client, send data up to now
                thisSession.sendExperimentData()
            
            for thisIncorrect_loop in incorrect_loop:
                currentLoop = incorrect_loop
                thisExp.timestampOnFlip(win, 'thisRow.t', format=globalClock.format)
                if thisSession is not None:
                    # if running in a Session with a Liaison client, send data up to now
                    thisSession.sendExperimentData()
                # abbreviate parameter names if possible (e.g. rgb = thisIncorrect_loop.rgb)
                if thisIncorrect_loop != None:
                    for paramName in thisIncorrect_loop:
                        globals()[paramName] = thisIncorrect_loop[paramName]
                
                # --- Prepare to start Routine "learn1" ---
                # create an object to store info about Routine learn1
                learn1 = data.Routine(
                    name='learn1',
                    components=[key_resp, image_1, text],
                )
                learn1.status = NOT_STARTED
                continueRoutine = True
                # update component parameters for each repeat
                # create starting attributes for key_resp
                key_resp.keys = []
                key_resp.rt = []
                _key_resp_allKeys = []
                image_1.setImage(image1)
                text.setText(action1)
                # store start times for learn1
                learn1.tStartRefresh = win.getFutureFlipTime(clock=globalClock)
                learn1.tStart = globalClock.getTime(format='float')
                learn1.status = STARTED
                thisExp.addData('learn1.started', learn1.tStart)
                learn1.maxDuration = None
                # keep track of which components have finished
                learn1Components = learn1.components
                for thisComponent in learn1.components:
                    thisComponent.tStart = None
                    thisComponent.tStop = None
                    thisComponent.tStartRefresh = None
                    thisComponent.tStopRefresh = None
                    if hasattr(thisComponent, 'status'):
                        thisComponent.status = NOT_STARTED
                # reset timers
                t = 0
                _timeToFirstFrame = win.getFutureFlipTime(clock="now")
                frameN = -1
                
                # --- Run Routine "learn1" ---
                # if trial has changed, end Routine now
                if isinstance(incorrect_loop, data.TrialHandler2) and thisIncorrect_loop.thisN != incorrect_loop.thisTrial.thisN:
                    continueRoutine = False
                learn1.forceEnded = routineForceEnded = not continueRoutine
                while continueRoutine:
                    # get current time
                    t = routineTimer.getTime()
                    tThisFlip = win.getFutureFlipTime(clock=routineTimer)
                    tThisFlipGlobal = win.getFutureFlipTime(clock=None)
                    frameN = frameN + 1  # number of completed frames (so 0 is the first frame)
                    # update/draw components on each frame
                    
                    # *key_resp* updates
                    waitOnFlip = False
                    
                    # if key_resp is starting this frame...
                    if key_resp.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
                        # keep track of start time/frame for later
                        key_resp.frameNStart = frameN  # exact frame index
                        key_resp.tStart = t  # local t and not account for scr refresh
                        key_resp.tStartRefresh = tThisFlipGlobal  # on global time
                        win.timeOnFlip(key_resp, 'tStartRefresh')  # time at next scr refresh
                        # add timestamp to datafile
                        thisExp.timestampOnFlip(win, 'key_resp.started')
                        # update status
                        key_resp.status = STARTED
                        # keyboard checking is just starting
                        waitOnFlip = True
                        win.callOnFlip(key_resp.clock.reset)  # t=0 on next screen flip
                        win.callOnFlip(key_resp.clearEvents, eventType='keyboard')  # clear events on next screen flip
                    if key_resp.status == STARTED and not waitOnFlip:
                        theseKeys = key_resp.getKeys(keyList=['left','right'], ignoreKeys=["escape"], waitRelease=False)
                        _key_resp_allKeys.extend(theseKeys)
                        if len(_key_resp_allKeys):
                            key_resp.keys = _key_resp_allKeys[-1].name  # just the last key pressed
                            key_resp.rt = _key_resp_allKeys[-1].rt
                            key_resp.duration = _key_resp_allKeys[-1].duration
                            # was this correct?
                            if (key_resp.keys == str(corr_ans)) or (key_resp.keys == corr_ans):
                                key_resp.corr = 1
                            else:
                                key_resp.corr = 0
                            # a response ends the routine
                            continueRoutine = False
                    
                    # *image_1* updates
                    
                    # if image_1 is starting this frame...
                    if image_1.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
                        # keep track of start time/frame for later
                        image_1.frameNStart = frameN  # exact frame index
                        image_1.tStart = t  # local t and not account for scr refresh
                        image_1.tStartRefresh = tThisFlipGlobal  # on global time
                        win.timeOnFlip(image_1, 'tStartRefresh')  # time at next scr refresh
                        # add timestamp to datafile
                        thisExp.timestampOnFlip(win, 'image_1.started')
                        # update status
                        image_1.status = STARTED
                        image_1.setAutoDraw(True)
                    
                    # if image_1 is active this frame...
                    if image_1.status == STARTED:
                        # update params
                        pass
                    
                    # *text* updates
                    
                    # if text is starting this frame...
                    if text.status == NOT_STARTED and tThisFlip >= 1-frameTolerance:
                        # keep track of start time/frame for later
                        text.frameNStart = frameN  # exact frame index
                        text.tStart = t  # local t and not account for scr refresh
                        text.tStartRefresh = tThisFlipGlobal  # on global time
                        win.timeOnFlip(text, 'tStartRefresh')  # time at next scr refresh
                        # add timestamp to datafile
                        thisExp.timestampOnFlip(win, 'text.started')
                        # update status
                        text.status = STARTED
                        text.setAutoDraw(True)
                    
                    # if text is active this frame...
                    if text.status == STARTED:
                        # update params
                        pass
                    
                    # check for quit (typically the Esc key)
                    if defaultKeyboard.getKeys(keyList=["escape"]):
                        thisExp.status = FINISHED
                    if thisExp.status == FINISHED or endExpNow:
                        endExperiment(thisExp, win=win)
                        return
                    # pause experiment here if requested
                    if thisExp.status == PAUSED:
                        pauseExperiment(
                            thisExp=thisExp, 
                            win=win, 
                            timers=[routineTimer], 
                            playbackComponents=[]
                        )
                        # skip the frame we paused on
                        continue
                    
                    # check if all components have finished
                    if not continueRoutine:  # a component has requested a forced-end of Routine
                        learn1.forceEnded = routineForceEnded = True
                        break
                    continueRoutine = False  # will revert to True if at least one component still running
                    for thisComponent in learn1.components:
                        if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:
                            continueRoutine = True
                            break  # at least one component has not yet finished
                    
                    # refresh the screen
                    if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen
                        win.flip()
                
                # --- Ending Routine "learn1" ---
                for thisComponent in learn1.components:
                    if hasattr(thisComponent, "setAutoDraw"):
                        thisComponent.setAutoDraw(False)
                # store stop times for learn1
                learn1.tStop = globalClock.getTime(format='float')
                learn1.tStopRefresh = tThisFlipGlobal
                thisExp.addData('learn1.stopped', learn1.tStop)
                # check responses
                if key_resp.keys in ['', [], None]:  # No response was made
                    key_resp.keys = None
                    # was no response the correct answer?!
                    if str(corr_ans).lower() == 'none':
                       key_resp.corr = 1;  # correct non-response
                    else:
                       key_resp.corr = 0;  # failed to respond (incorrectly)
                # store data for incorrect_loop (TrialHandler)
                incorrect_loop.addData('key_resp.keys',key_resp.keys)
                incorrect_loop.addData('key_resp.corr', key_resp.corr)
                if key_resp.keys != None:  # we had a response
                    incorrect_loop.addData('key_resp.rt', key_resp.rt)
                    incorrect_loop.addData('key_resp.duration', key_resp.duration)
                # the Routine "learn1" was not non-slip safe, so reset the non-slip timer
                routineTimer.reset()
                
                # --- Prepare to start Routine "check_incorrect1" ---
                # create an object to store info about Routine check_incorrect1
                check_incorrect1 = data.Routine(
                    name='check_incorrect1',
                    components=[text_incorrect_2],
                )
                check_incorrect1.status = NOT_STARTED
                continueRoutine = True
                # update component parameters for each repeat
                # Run 'Begin Routine' code from code_3
                if key_resp.corr:
                    msg_incorrect='correct'
                    incorrect_loop.finished = True
                    continueRoutine=False
                else:
                    msg_incorrect='You clicked the wrong button! If you click the wrong button 5 times, the game will stop and you will NOT GET PAID because you failed to follow instructions!'
                    incorrect_actions+=1
                    continueRoutine=True
                    if incorrect_actions>14:
                        psychoJS.quit()
                text_incorrect_2.setText(msg_incorrect)
                # store start times for check_incorrect1
                check_incorrect1.tStartRefresh = win.getFutureFlipTime(clock=globalClock)
                check_incorrect1.tStart = globalClock.getTime(format='float')
                check_incorrect1.status = STARTED
                thisExp.addData('check_incorrect1.started', check_incorrect1.tStart)
                check_incorrect1.maxDuration = None
                # keep track of which components have finished
                check_incorrect1Components = check_incorrect1.components
                for thisComponent in check_incorrect1.components:
                    thisComponent.tStart = None
                    thisComponent.tStop = None
                    thisComponent.tStartRefresh = None
                    thisComponent.tStopRefresh = None
                    if hasattr(thisComponent, 'status'):
                        thisComponent.status = NOT_STARTED
                # reset timers
                t = 0
                _timeToFirstFrame = win.getFutureFlipTime(clock="now")
                frameN = -1
                
                # --- Run Routine "check_incorrect1" ---
                # if trial has changed, end Routine now
                if isinstance(incorrect_loop, data.TrialHandler2) and thisIncorrect_loop.thisN != incorrect_loop.thisTrial.thisN:
                    continueRoutine = False
                check_incorrect1.forceEnded = routineForceEnded = not continueRoutine
                while continueRoutine and routineTimer.getTime() < 3.0:
                    # get current time
                    t = routineTimer.getTime()
                    tThisFlip = win.getFutureFlipTime(clock=routineTimer)
                    tThisFlipGlobal = win.getFutureFlipTime(clock=None)
                    frameN = frameN + 1  # number of completed frames (so 0 is the first frame)
                    # update/draw components on each frame
                    
                    # *text_incorrect_2* updates
                    
                    # if text_incorrect_2 is starting this frame...
                    if text_incorrect_2.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
                        # keep track of start time/frame for later
                        text_incorrect_2.frameNStart = frameN  # exact frame index
                        text_incorrect_2.tStart = t  # local t and not account for scr refresh
                        text_incorrect_2.tStartRefresh = tThisFlipGlobal  # on global time
                        win.timeOnFlip(text_incorrect_2, 'tStartRefresh')  # time at next scr refresh
                        # add timestamp to datafile
                        thisExp.timestampOnFlip(win, 'text_incorrect_2.started')
                        # update status
                        text_incorrect_2.status = STARTED
                        text_incorrect_2.setAutoDraw(True)
                    
                    # if text_incorrect_2 is active this frame...
                    if text_incorrect_2.status == STARTED:
                        # update params
                        pass
                    
                    # if text_incorrect_2 is stopping this frame...
                    if text_incorrect_2.status == STARTED:
                        # is it time to stop? (based on global clock, using actual start)
                        if tThisFlipGlobal > text_incorrect_2.tStartRefresh + 3-frameTolerance:
                            # keep track of stop time/frame for later
                            text_incorrect_2.tStop = t  # not accounting for scr refresh
                            text_incorrect_2.tStopRefresh = tThisFlipGlobal  # on global time
                            text_incorrect_2.frameNStop = frameN  # exact frame index
                            # add timestamp to datafile
                            thisExp.timestampOnFlip(win, 'text_incorrect_2.stopped')
                            # update status
                            text_incorrect_2.status = FINISHED
                            text_incorrect_2.setAutoDraw(False)
                    
                    # check for quit (typically the Esc key)
                    if defaultKeyboard.getKeys(keyList=["escape"]):
                        thisExp.status = FINISHED
                    if thisExp.status == FINISHED or endExpNow:
                        endExperiment(thisExp, win=win)
                        return
                    # pause experiment here if requested
                    if thisExp.status == PAUSED:
                        pauseExperiment(
                            thisExp=thisExp, 
                            win=win, 
                            timers=[routineTimer], 
                            playbackComponents=[]
                        )
                        # skip the frame we paused on
                        continue
                    
                    # check if all components have finished
                    if not continueRoutine:  # a component has requested a forced-end of Routine
                        check_incorrect1.forceEnded = routineForceEnded = True
                        break
                    continueRoutine = False  # will revert to True if at least one component still running
                    for thisComponent in check_incorrect1.components:
                        if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:
                            continueRoutine = True
                            break  # at least one component has not yet finished
                    
                    # refresh the screen
                    if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen
                        win.flip()
                
                # --- Ending Routine "check_incorrect1" ---
                for thisComponent in check_incorrect1.components:
                    if hasattr(thisComponent, "setAutoDraw"):
                        thisComponent.setAutoDraw(False)
                # store stop times for check_incorrect1
                check_incorrect1.tStop = globalClock.getTime(format='float')
                check_incorrect1.tStopRefresh = tThisFlipGlobal
                thisExp.addData('check_incorrect1.stopped', check_incorrect1.tStop)
                # using non-slip timing so subtract the expected duration of this Routine (unless ended on request)
                if check_incorrect1.maxDurationReached:
                    routineTimer.addTime(-check_incorrect1.maxDuration)
                elif check_incorrect1.forceEnded:
                    routineTimer.reset()
                else:
                    routineTimer.addTime(-3.000000)
                thisExp.nextEntry()
                
            # completed 9999.0 repeats of 'incorrect_loop'
            
            if thisSession is not None:
                # if running in a Session with a Liaison client, send data up to now
                thisSession.sendExperimentData()
            
            # --- Prepare to start Routine "learn2" ---
            # create an object to store info about Routine learn2
            learn2 = data.Routine(
                name='learn2',
                components=[image_2],
            )
            learn2.status = NOT_STARTED
            continueRoutine = True
            # update component parameters for each repeat
            image_2.setImage(image2)
            # store start times for learn2
            learn2.tStartRefresh = win.getFutureFlipTime(clock=globalClock)
            learn2.tStart = globalClock.getTime(format='float')
            learn2.status = STARTED
            thisExp.addData('learn2.started', learn2.tStart)
            learn2.maxDuration = None
            # keep track of which components have finished
            learn2Components = learn2.components
            for thisComponent in learn2.components:
                thisComponent.tStart = None
                thisComponent.tStop = None
                thisComponent.tStartRefresh = None
                thisComponent.tStopRefresh = None
                if hasattr(thisComponent, 'status'):
                    thisComponent.status = NOT_STARTED
            # reset timers
            t = 0
            _timeToFirstFrame = win.getFutureFlipTime(clock="now")
            frameN = -1
            
            # --- Run Routine "learn2" ---
            # if trial has changed, end Routine now
            if isinstance(learn_1, data.TrialHandler2) and thisLearn_1.thisN != learn_1.thisTrial.thisN:
                continueRoutine = False
            learn2.forceEnded = routineForceEnded = not continueRoutine
            while continueRoutine and routineTimer.getTime() < 1.0:
                # get current time
                t = routineTimer.getTime()
                tThisFlip = win.getFutureFlipTime(clock=routineTimer)
                tThisFlipGlobal = win.getFutureFlipTime(clock=None)
                frameN = frameN + 1  # number of completed frames (so 0 is the first frame)
                # update/draw components on each frame
                
                # *image_2* updates
                
                # if image_2 is starting this frame...
                if image_2.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
                    # keep track of start time/frame for later
                    image_2.frameNStart = frameN  # exact frame index
                    image_2.tStart = t  # local t and not account for scr refresh
                    image_2.tStartRefresh = tThisFlipGlobal  # on global time
                    win.timeOnFlip(image_2, 'tStartRefresh')  # time at next scr refresh
                    # add timestamp to datafile
                    thisExp.timestampOnFlip(win, 'image_2.started')
                    # update status
                    image_2.status = STARTED
                    image_2.setAutoDraw(True)
                
                # if image_2 is active this frame...
                if image_2.status == STARTED:
                    # update params
                    pass
                
                # if image_2 is stopping this frame...
                if image_2.status == STARTED:
                    # is it time to stop? (based on global clock, using actual start)
                    if tThisFlipGlobal > image_2.tStartRefresh + 1-frameTolerance:
                        # keep track of stop time/frame for later
                        image_2.tStop = t  # not accounting for scr refresh
                        image_2.tStopRefresh = tThisFlipGlobal  # on global time
                        image_2.frameNStop = frameN  # exact frame index
                        # add timestamp to datafile
                        thisExp.timestampOnFlip(win, 'image_2.stopped')
                        # update status
                        image_2.status = FINISHED
                        image_2.setAutoDraw(False)
                
                # check for quit (typically the Esc key)
                if defaultKeyboard.getKeys(keyList=["escape"]):
                    thisExp.status = FINISHED
                if thisExp.status == FINISHED or endExpNow:
                    endExperiment(thisExp, win=win)
                    return
                # pause experiment here if requested
                if thisExp.status == PAUSED:
                    pauseExperiment(
                        thisExp=thisExp, 
                        win=win, 
                        timers=[routineTimer], 
                        playbackComponents=[]
                    )
                    # skip the frame we paused on
                    continue
                
                # check if all components have finished
                if not continueRoutine:  # a component has requested a forced-end of Routine
                    learn2.forceEnded = routineForceEnded = True
                    break
                continueRoutine = False  # will revert to True if at least one component still running
                for thisComponent in learn2.components:
                    if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:
                        continueRoutine = True
                        break  # at least one component has not yet finished
                
                # refresh the screen
                if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen
                    win.flip()
            
            # --- Ending Routine "learn2" ---
            for thisComponent in learn2.components:
                if hasattr(thisComponent, "setAutoDraw"):
                    thisComponent.setAutoDraw(False)
            # store stop times for learn2
            learn2.tStop = globalClock.getTime(format='float')
            learn2.tStopRefresh = tThisFlipGlobal
            thisExp.addData('learn2.stopped', learn2.tStop)
            # using non-slip timing so subtract the expected duration of this Routine (unless ended on request)
            if learn2.maxDurationReached:
                routineTimer.addTime(-learn2.maxDuration)
            elif learn2.forceEnded:
                routineTimer.reset()
            else:
                routineTimer.addTime(-1.000000)
            
            # --- Prepare to start Routine "next_trial" ---
            # create an object to store info about Routine next_trial
            next_trial = data.Routine(
                name='next_trial',
                components=[next_trial_text],
            )
            next_trial.status = NOT_STARTED
            continueRoutine = True
            # update component parameters for each repeat
            # store start times for next_trial
            next_trial.tStartRefresh = win.getFutureFlipTime(clock=globalClock)
            next_trial.tStart = globalClock.getTime(format='float')
            next_trial.status = STARTED
            thisExp.addData('next_trial.started', next_trial.tStart)
            next_trial.maxDuration = None
            # keep track of which components have finished
            next_trialComponents = next_trial.components
            for thisComponent in next_trial.components:
                thisComponent.tStart = None
                thisComponent.tStop = None
                thisComponent.tStartRefresh = None
                thisComponent.tStopRefresh = None
                if hasattr(thisComponent, 'status'):
                    thisComponent.status = NOT_STARTED
            # reset timers
            t = 0
            _timeToFirstFrame = win.getFutureFlipTime(clock="now")
            frameN = -1
            
            # --- Run Routine "next_trial" ---
            # if trial has changed, end Routine now
            if isinstance(learn_1, data.TrialHandler2) and thisLearn_1.thisN != learn_1.thisTrial.thisN:
                continueRoutine = False
            next_trial.forceEnded = routineForceEnded = not continueRoutine
            while continueRoutine and routineTimer.getTime() < 1.0:
                # get current time
                t = routineTimer.getTime()
                tThisFlip = win.getFutureFlipTime(clock=routineTimer)
                tThisFlipGlobal = win.getFutureFlipTime(clock=None)
                frameN = frameN + 1  # number of completed frames (so 0 is the first frame)
                # update/draw components on each frame
                
                # *next_trial_text* updates
                
                # if next_trial_text is starting this frame...
                if next_trial_text.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
                    # keep track of start time/frame for later
                    next_trial_text.frameNStart = frameN  # exact frame index
                    next_trial_text.tStart = t  # local t and not account for scr refresh
                    next_trial_text.tStartRefresh = tThisFlipGlobal  # on global time
                    win.timeOnFlip(next_trial_text, 'tStartRefresh')  # time at next scr refresh
                    # add timestamp to datafile
                    thisExp.timestampOnFlip(win, 'next_trial_text.started')
                    # update status
                    next_trial_text.status = STARTED
                    next_trial_text.setAutoDraw(True)
                
                # if next_trial_text is active this frame...
                if next_trial_text.status == STARTED:
                    # update params
                    pass
                
                # if next_trial_text is stopping this frame...
                if next_trial_text.status == STARTED:
                    # is it time to stop? (based on global clock, using actual start)
                    if tThisFlipGlobal > next_trial_text.tStartRefresh + 1-frameTolerance:
                        # keep track of stop time/frame for later
                        next_trial_text.tStop = t  # not accounting for scr refresh
                        next_trial_text.tStopRefresh = tThisFlipGlobal  # on global time
                        next_trial_text.frameNStop = frameN  # exact frame index
                        # add timestamp to datafile
                        thisExp.timestampOnFlip(win, 'next_trial_text.stopped')
                        # update status
                        next_trial_text.status = FINISHED
                        next_trial_text.setAutoDraw(False)
                
                # check for quit (typically the Esc key)
                if defaultKeyboard.getKeys(keyList=["escape"]):
                    thisExp.status = FINISHED
                if thisExp.status == FINISHED or endExpNow:
                    endExperiment(thisExp, win=win)
                    return
                # pause experiment here if requested
                if thisExp.status == PAUSED:
                    pauseExperiment(
                        thisExp=thisExp, 
                        win=win, 
                        timers=[routineTimer], 
                        playbackComponents=[]
                    )
                    # skip the frame we paused on
                    continue
                
                # check if all components have finished
                if not continueRoutine:  # a component has requested a forced-end of Routine
                    next_trial.forceEnded = routineForceEnded = True
                    break
                continueRoutine = False  # will revert to True if at least one component still running
                for thisComponent in next_trial.components:
                    if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:
                        continueRoutine = True
                        break  # at least one component has not yet finished
                
                # refresh the screen
                if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen
                    win.flip()
            
            # --- Ending Routine "next_trial" ---
            for thisComponent in next_trial.components:
                if hasattr(thisComponent, "setAutoDraw"):
                    thisComponent.setAutoDraw(False)
            # store stop times for next_trial
            next_trial.tStop = globalClock.getTime(format='float')
            next_trial.tStopRefresh = tThisFlipGlobal
            thisExp.addData('next_trial.stopped', next_trial.tStop)
            # using non-slip timing so subtract the expected duration of this Routine (unless ended on request)
            if next_trial.maxDurationReached:
                routineTimer.addTime(-next_trial.maxDuration)
            elif next_trial.forceEnded:
                routineTimer.reset()
            else:
                routineTimer.addTime(-1.000000)
            thisExp.nextEntry()
            
        # completed 1.0 repeats of 'learn_1'
        
        if thisSession is not None:
            # if running in a Session with a Liaison client, send data up to now
            thisSession.sendExperimentData()
        
        # --- Prepare to start Routine "counter_quizzes_round" ---
        # create an object to store info about Routine counter_quizzes_round
        counter_quizzes_round = data.Routine(
            name='counter_quizzes_round',
            components=[],
        )
        counter_quizzes_round.status = NOT_STARTED
        continueRoutine = True
        # update component parameters for each repeat
        # Run 'Begin Routine' code from code_46
        quiz1_score=0
        quiz2_score=0
        # store start times for counter_quizzes_round
        counter_quizzes_round.tStartRefresh = win.getFutureFlipTime(clock=globalClock)
        counter_quizzes_round.tStart = globalClock.getTime(format='float')
        counter_quizzes_round.status = STARTED
        thisExp.addData('counter_quizzes_round.started', counter_quizzes_round.tStart)
        counter_quizzes_round.maxDuration = None
        # keep track of which components have finished
        counter_quizzes_roundComponents = counter_quizzes_round.components
        for thisComponent in counter_quizzes_round.components:
            thisComponent.tStart = None
            thisComponent.tStop = None
            thisComponent.tStartRefresh = None
            thisComponent.tStopRefresh = None
            if hasattr(thisComponent, 'status'):
                thisComponent.status = NOT_STARTED
        # reset timers
        t = 0
        _timeToFirstFrame = win.getFutureFlipTime(clock="now")
        frameN = -1
        
        # --- Run Routine "counter_quizzes_round" ---
        # if trial has changed, end Routine now
        if isinstance(learning_phase, data.TrialHandler2) and thisLearning_phase.thisN != learning_phase.thisTrial.thisN:
            continueRoutine = False
        counter_quizzes_round.forceEnded = routineForceEnded = not continueRoutine
        while continueRoutine:
            # get current time
            t = routineTimer.getTime()
            tThisFlip = win.getFutureFlipTime(clock=routineTimer)
            tThisFlipGlobal = win.getFutureFlipTime(clock=None)
            frameN = frameN + 1  # number of completed frames (so 0 is the first frame)
            # update/draw components on each frame
            
            # check for quit (typically the Esc key)
            if defaultKeyboard.getKeys(keyList=["escape"]):
                thisExp.status = FINISHED
            if thisExp.status == FINISHED or endExpNow:
                endExperiment(thisExp, win=win)
                return
            # pause experiment here if requested
            if thisExp.status == PAUSED:
                pauseExperiment(
                    thisExp=thisExp, 
                    win=win, 
                    timers=[routineTimer], 
                    playbackComponents=[]
                )
                # skip the frame we paused on
                continue
            
            # check if all components have finished
            if not continueRoutine:  # a component has requested a forced-end of Routine
                counter_quizzes_round.forceEnded = routineForceEnded = True
                break
            continueRoutine = False  # will revert to True if at least one component still running
            for thisComponent in counter_quizzes_round.components:
                if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:
                    continueRoutine = True
                    break  # at least one component has not yet finished
            
            # refresh the screen
            if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen
                win.flip()
        
        # --- Ending Routine "counter_quizzes_round" ---
        for thisComponent in counter_quizzes_round.components:
            if hasattr(thisComponent, "setAutoDraw"):
                thisComponent.setAutoDraw(False)
        # store stop times for counter_quizzes_round
        counter_quizzes_round.tStop = globalClock.getTime(format='float')
        counter_quizzes_round.tStopRefresh = tThisFlipGlobal
        thisExp.addData('counter_quizzes_round.stopped', counter_quizzes_round.tStop)
        # the Routine "counter_quizzes_round" was not non-slip safe, so reset the non-slip timer
        routineTimer.reset()
        
        # --- Prepare to start Routine "between" ---
        # create an object to store info about Routine between
        between = data.Routine(
            name='between',
            components=[text_2],
        )
        between.status = NOT_STARTED
        continueRoutine = True
        # update component parameters for each repeat
        # Run 'Begin Routine' code from code_39
        quiz1_count=1
        quiz2_count=1
        
        # store start times for between
        between.tStartRefresh = win.getFutureFlipTime(clock=globalClock)
        between.tStart = globalClock.getTime(format='float')
        between.status = STARTED
        thisExp.addData('between.started', between.tStart)
        between.maxDuration = None
        # keep track of which components have finished
        betweenComponents = between.components
        for thisComponent in between.components:
            thisComponent.tStart = None
            thisComponent.tStop = None
            thisComponent.tStartRefresh = None
            thisComponent.tStopRefresh = None
            if hasattr(thisComponent, 'status'):
                thisComponent.status = NOT_STARTED
        # reset timers
        t = 0
        _timeToFirstFrame = win.getFutureFlipTime(clock="now")
        frameN = -1
        
        # --- Run Routine "between" ---
        # if trial has changed, end Routine now
        if isinstance(learning_phase, data.TrialHandler2) and thisLearning_phase.thisN != learning_phase.thisTrial.thisN:
            continueRoutine = False
        between.forceEnded = routineForceEnded = not continueRoutine
        while continueRoutine and routineTimer.getTime() < 5.0:
            # get current time
            t = routineTimer.getTime()
            tThisFlip = win.getFutureFlipTime(clock=routineTimer)
            tThisFlipGlobal = win.getFutureFlipTime(clock=None)
            frameN = frameN + 1  # number of completed frames (so 0 is the first frame)
            # update/draw components on each frame
            
            # *text_2* updates
            
            # if text_2 is starting this frame...
            if text_2.status == NOT_STARTED and tThisFlip >= 0-frameTolerance:
                # keep track of start time/frame for later
                text_2.frameNStart = frameN  # exact frame index
                text_2.tStart = t  # local t and not account for scr refresh
                text_2.tStartRefresh = tThisFlipGlobal  # on global time
                win.timeOnFlip(text_2, 'tStartRefresh')  # time at next scr refresh
                # add timestamp to datafile
                thisExp.timestampOnFlip(win, 'text_2.started')
                # update status
                text_2.status = STARTED
                text_2.setAutoDraw(True)
            
            # if text_2 is active this frame...
            if text_2.status == STARTED:
                # update params
                pass
            
            # if text_2 is stopping this frame...
            if text_2.status == STARTED:
                # is it time to stop? (based on global clock, using actual start)
                if tThisFlipGlobal > text_2.tStartRefresh + 5-frameTolerance:
                    # keep track of stop time/frame for later
                    text_2.tStop = t  # not accounting for scr refresh
                    text_2.tStopRefresh = tThisFlipGlobal  # on global time
                    text_2.frameNStop = frameN  # exact frame index
                    # add timestamp to datafile
                    thisExp.timestampOnFlip(win, 'text_2.stopped')
                    # update status
                    text_2.status = FINISHED
                    text_2.setAutoDraw(False)
            
            # check for quit (typically the Esc key)
            if defaultKeyboard.getKeys(keyList=["escape"]):
                thisExp.status = FINISHED
            if thisExp.status == FINISHED or endExpNow:
                endExperiment(thisExp, win=win)
                return
            # pause experiment here if requested
            if thisExp.status == PAUSED:
                pauseExperiment(
                    thisExp=thisExp, 
                    win=win, 
                    timers=[routineTimer], 
                    playbackComponents=[]
                )
                # skip the frame we paused on
                continue
            
            # check if all components have finished
            if not continueRoutine:  # a component has requested a forced-end of Routine
                between.forceEnded = routineForceEnded = True
                break
            continueRoutine = False  # will revert to True if at least one component still running
            for thisComponent in between.components:
                if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:
                    continueRoutine = True
                    break  # at least one component has not yet finished
            
            # refresh the screen
            if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen
                win.flip()
        
        # --- Ending Routine "between" ---
        for thisComponent in between.components:
            if hasattr(thisComponent, "setAutoDraw"):
                thisComponent.setAutoDraw(False)
        # store stop times for between
        between.tStop = globalClock.getTime(format='float')
        between.tStopRefresh = tThisFlipGlobal
        thisExp.addData('between.stopped', between.tStop)
        # using non-slip timing so subtract the expected duration of this Routine (unless ended on request)
        if between.maxDurationReached:
            routineTimer.addTime(-between.maxDuration)
        elif between.forceEnded:
            routineTimer.reset()
        else:
            routineTimer.addTime(-5.000000)
        
        # set up handler to look after randomisation of conditions etc
        quiz_loop1 = data.TrialHandler2(
            name='quiz_loop1',
            nReps=1.0, 
            method='random', 
            extraInfo=expInfo, 
            originPath=-1, 
            trialList=data.importConditions('quiz_1.xlsx'), 
            seed=None, 
        )
        thisExp.addLoop(quiz_loop1)  # add the loop to the experiment
        thisQuiz_loop1 = quiz_loop1.trialList[0]  # so we can initialise stimuli with some values
        # abbreviate parameter names if possible (e.g. rgb = thisQuiz_loop1.rgb)
        if thisQuiz_loop1 != None:
            for paramName in thisQuiz_loop1:
                globals()[paramName] = thisQuiz_loop1[paramName]
        if thisSession is not None:
            # if running in a Session with a Liaison client, send data up to now
            thisSession.sendExperimentData()
        
        for thisQuiz_loop1 in quiz_loop1:
            currentLoop = quiz_loop1
            thisExp.timestampOnFlip(win, 'thisRow.t', format=globalClock.format)
            if thisSession is not None:
                # if running in a Session with a Liaison client, send data up to now
                thisSession.sendExperimentData()
            # abbreviate parameter names if possible (e.g. rgb = thisQuiz_loop1.rgb)
            if thisQuiz_loop1 != None:
                for paramName in thisQuiz_loop1:
                    globals()[paramName] = thisQuiz_loop1[paramName]
            
            # --- Prepare to start Routine "quiz" ---
            # create an object to store info about Routine quiz
            quiz = data.Routine(
                name='quiz',
                components=[target_quiz1, question_quiz1, answer_quiz1, answer1, answer2, answer3, answer4, a1, a2, a3, a4],
            )
            quiz.status = NOT_STARTED
            continueRoutine = True
            # update component parameters for each repeat
            target_quiz1.setImage(image1)
            question_quiz1.setText(question)
            # create starting attributes for answer_quiz1
            answer_quiz1.keys = []
            answer_quiz1.rt = []
            _answer_quiz1_allKeys = []
            answer1.setImage(ans1)
            answer2.setImage(ans2)
            answer3.setImage(ans3)
            answer4.setImage(ans4)
            # store start times for quiz
            quiz.tStartRefresh = win.getFutureFlipTime(clock=globalClock)
            quiz.tStart = globalClock.getTime(format='float')
            quiz.status = STARTED
            thisExp.addData('quiz.started', quiz.tStart)
            quiz.maxDuration = None
            # keep track of which components have finished
            quizComponents = quiz.components
            for thisComponent in quiz.components:
                thisComponent.tStart = None
                thisComponent.tStop = None
                thisComponent.tStartRefresh = None
                thisComponent.tStopRefresh = None
                if hasattr(thisComponent, 'status'):
                    thisComponent.status = NOT_STARTED
            # reset timers
            t = 0
            _timeToFirstFrame = win.getFutureFlipTime(clock="now")
            frameN = -1
            
            # --- Run Routine "quiz" ---
            # if trial has changed, end Routine now
            if isinstance(quiz_loop1, data.TrialHandler2) and thisQuiz_loop1.thisN != quiz_loop1.thisTrial.thisN:
                continueRoutine = False
            quiz.forceEnded = routineForceEnded = not continueRoutine
            while continueRoutine:
                # get current time
                t = routineTimer.getTime()
                tThisFlip = win.getFutureFlipTime(clock=routineTimer)
                tThisFlipGlobal = win.getFutureFlipTime(clock=None)
                frameN = frameN + 1  # number of completed frames (so 0 is the first frame)
                # update/draw components on each frame
                
                # *target_quiz1* updates
                
                # if target_quiz1 is starting this frame...
                if target_quiz1.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
                    # keep track of start time/frame for later
                    target_quiz1.frameNStart = frameN  # exact frame index
                    target_quiz1.tStart = t  # local t and not account for scr refresh
                    target_quiz1.tStartRefresh = tThisFlipGlobal  # on global time
                    win.timeOnFlip(target_quiz1, 'tStartRefresh')  # time at next scr refresh
                    # add timestamp to datafile
                    thisExp.timestampOnFlip(win, 'target_quiz1.started')
                    # update status
                    target_quiz1.status = STARTED
                    target_quiz1.setAutoDraw(True)
                
                # if target_quiz1 is active this frame...
                if target_quiz1.status == STARTED:
                    # update params
                    pass
                
                # *question_quiz1* updates
                
                # if question_quiz1 is starting this frame...
                if question_quiz1.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
                    # keep track of start time/frame for later
                    question_quiz1.frameNStart = frameN  # exact frame index
                    question_quiz1.tStart = t  # local t and not account for scr refresh
                    question_quiz1.tStartRefresh = tThisFlipGlobal  # on global time
                    win.timeOnFlip(question_quiz1, 'tStartRefresh')  # time at next scr refresh
                    # add timestamp to datafile
                    thisExp.timestampOnFlip(win, 'question_quiz1.started')
                    # update status
                    question_quiz1.status = STARTED
                    question_quiz1.setAutoDraw(True)
                
                # if question_quiz1 is active this frame...
                if question_quiz1.status == STARTED:
                    # update params
                    pass
                
                # *answer_quiz1* updates
                waitOnFlip = False
                
                # if answer_quiz1 is starting this frame...
                if answer_quiz1.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
                    # keep track of start time/frame for later
                    answer_quiz1.frameNStart = frameN  # exact frame index
                    answer_quiz1.tStart = t  # local t and not account for scr refresh
                    answer_quiz1.tStartRefresh = tThisFlipGlobal  # on global time
                    win.timeOnFlip(answer_quiz1, 'tStartRefresh')  # time at next scr refresh
                    # add timestamp to datafile
                    thisExp.timestampOnFlip(win, 'answer_quiz1.started')
                    # update status
                    answer_quiz1.status = STARTED
                    # keyboard checking is just starting
                    waitOnFlip = True
                    win.callOnFlip(answer_quiz1.clock.reset)  # t=0 on next screen flip
                    win.callOnFlip(answer_quiz1.clearEvents, eventType='keyboard')  # clear events on next screen flip
                if answer_quiz1.status == STARTED and not waitOnFlip:
                    theseKeys = answer_quiz1.getKeys(keyList=['1','2','3','4'], ignoreKeys=["escape"], waitRelease=False)
                    _answer_quiz1_allKeys.extend(theseKeys)
                    if len(_answer_quiz1_allKeys):
                        answer_quiz1.keys = _answer_quiz1_allKeys[-1].name  # just the last key pressed
                        answer_quiz1.rt = _answer_quiz1_allKeys[-1].rt
                        answer_quiz1.duration = _answer_quiz1_allKeys[-1].duration
                        # was this correct?
                        if (answer_quiz1.keys == str(corr_ans)) or (answer_quiz1.keys == corr_ans):
                            answer_quiz1.corr = 1
                        else:
                            answer_quiz1.corr = 0
                        # a response ends the routine
                        continueRoutine = False
                
                # *answer1* updates
                
                # if answer1 is starting this frame...
                if answer1.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
                    # keep track of start time/frame for later
                    answer1.frameNStart = frameN  # exact frame index
                    answer1.tStart = t  # local t and not account for scr refresh
                    answer1.tStartRefresh = tThisFlipGlobal  # on global time
                    win.timeOnFlip(answer1, 'tStartRefresh')  # time at next scr refresh
                    # add timestamp to datafile
                    thisExp.timestampOnFlip(win, 'answer1.started')
                    # update status
                    answer1.status = STARTED
                    answer1.setAutoDraw(True)
                
                # if answer1 is active this frame...
                if answer1.status == STARTED:
                    # update params
                    pass
                
                # *answer2* updates
                
                # if answer2 is starting this frame...
                if answer2.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
                    # keep track of start time/frame for later
                    answer2.frameNStart = frameN  # exact frame index
                    answer2.tStart = t  # local t and not account for scr refresh
                    answer2.tStartRefresh = tThisFlipGlobal  # on global time
                    win.timeOnFlip(answer2, 'tStartRefresh')  # time at next scr refresh
                    # add timestamp to datafile
                    thisExp.timestampOnFlip(win, 'answer2.started')
                    # update status
                    answer2.status = STARTED
                    answer2.setAutoDraw(True)
                
                # if answer2 is active this frame...
                if answer2.status == STARTED:
                    # update params
                    pass
                
                # *answer3* updates
                
                # if answer3 is starting this frame...
                if answer3.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
                    # keep track of start time/frame for later
                    answer3.frameNStart = frameN  # exact frame index
                    answer3.tStart = t  # local t and not account for scr refresh
                    answer3.tStartRefresh = tThisFlipGlobal  # on global time
                    win.timeOnFlip(answer3, 'tStartRefresh')  # time at next scr refresh
                    # add timestamp to datafile
                    thisExp.timestampOnFlip(win, 'answer3.started')
                    # update status
                    answer3.status = STARTED
                    answer3.setAutoDraw(True)
                
                # if answer3 is active this frame...
                if answer3.status == STARTED:
                    # update params
                    pass
                
                # *answer4* updates
                
                # if answer4 is starting this frame...
                if answer4.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
                    # keep track of start time/frame for later
                    answer4.frameNStart = frameN  # exact frame index
                    answer4.tStart = t  # local t and not account for scr refresh
                    answer4.tStartRefresh = tThisFlipGlobal  # on global time
                    win.timeOnFlip(answer4, 'tStartRefresh')  # time at next scr refresh
                    # add timestamp to datafile
                    thisExp.timestampOnFlip(win, 'answer4.started')
                    # update status
                    answer4.status = STARTED
                    answer4.setAutoDraw(True)
                
                # if answer4 is active this frame...
                if answer4.status == STARTED:
                    # update params
                    pass
                
                # *a1* updates
                
                # if a1 is starting this frame...
                if a1.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
                    # keep track of start time/frame for later
                    a1.frameNStart = frameN  # exact frame index
                    a1.tStart = t  # local t and not account for scr refresh
                    a1.tStartRefresh = tThisFlipGlobal  # on global time
                    win.timeOnFlip(a1, 'tStartRefresh')  # time at next scr refresh
                    # add timestamp to datafile
                    thisExp.timestampOnFlip(win, 'a1.started')
                    # update status
                    a1.status = STARTED
                    a1.setAutoDraw(True)
                
                # if a1 is active this frame...
                if a1.status == STARTED:
                    # update params
                    pass
                
                # *a2* updates
                
                # if a2 is starting this frame...
                if a2.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
                    # keep track of start time/frame for later
                    a2.frameNStart = frameN  # exact frame index
                    a2.tStart = t  # local t and not account for scr refresh
                    a2.tStartRefresh = tThisFlipGlobal  # on global time
                    win.timeOnFlip(a2, 'tStartRefresh')  # time at next scr refresh
                    # add timestamp to datafile
                    thisExp.timestampOnFlip(win, 'a2.started')
                    # update status
                    a2.status = STARTED
                    a2.setAutoDraw(True)
                
                # if a2 is active this frame...
                if a2.status == STARTED:
                    # update params
                    pass
                
                # *a3* updates
                
                # if a3 is starting this frame...
                if a3.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
                    # keep track of start time/frame for later
                    a3.frameNStart = frameN  # exact frame index
                    a3.tStart = t  # local t and not account for scr refresh
                    a3.tStartRefresh = tThisFlipGlobal  # on global time
                    win.timeOnFlip(a3, 'tStartRefresh')  # time at next scr refresh
                    # add timestamp to datafile
                    thisExp.timestampOnFlip(win, 'a3.started')
                    # update status
                    a3.status = STARTED
                    a3.setAutoDraw(True)
                
                # if a3 is active this frame...
                if a3.status == STARTED:
                    # update params
                    pass
                
                # *a4* updates
                
                # if a4 is starting this frame...
                if a4.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
                    # keep track of start time/frame for later
                    a4.frameNStart = frameN  # exact frame index
                    a4.tStart = t  # local t and not account for scr refresh
                    a4.tStartRefresh = tThisFlipGlobal  # on global time
                    win.timeOnFlip(a4, 'tStartRefresh')  # time at next scr refresh
                    # add timestamp to datafile
                    thisExp.timestampOnFlip(win, 'a4.started')
                    # update status
                    a4.status = STARTED
                    a4.setAutoDraw(True)
                
                # if a4 is active this frame...
                if a4.status == STARTED:
                    # update params
                    pass
                
                # check for quit (typically the Esc key)
                if defaultKeyboard.getKeys(keyList=["escape"]):
                    thisExp.status = FINISHED
                if thisExp.status == FINISHED or endExpNow:
                    endExperiment(thisExp, win=win)
                    return
                # pause experiment here if requested
                if thisExp.status == PAUSED:
                    pauseExperiment(
                        thisExp=thisExp, 
                        win=win, 
                        timers=[routineTimer], 
                        playbackComponents=[]
                    )
                    # skip the frame we paused on
                    continue
                
                # check if all components have finished
                if not continueRoutine:  # a component has requested a forced-end of Routine
                    quiz.forceEnded = routineForceEnded = True
                    break
                continueRoutine = False  # will revert to True if at least one component still running
                for thisComponent in quiz.components:
                    if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:
                        continueRoutine = True
                        break  # at least one component has not yet finished
                
                # refresh the screen
                if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen
                    win.flip()
            
            # --- Ending Routine "quiz" ---
            for thisComponent in quiz.components:
                if hasattr(thisComponent, "setAutoDraw"):
                    thisComponent.setAutoDraw(False)
            # store stop times for quiz
            quiz.tStop = globalClock.getTime(format='float')
            quiz.tStopRefresh = tThisFlipGlobal
            thisExp.addData('quiz.stopped', quiz.tStop)
            # check responses
            if answer_quiz1.keys in ['', [], None]:  # No response was made
                answer_quiz1.keys = None
                # was no response the correct answer?!
                if str(corr_ans).lower() == 'none':
                   answer_quiz1.corr = 1;  # correct non-response
                else:
                   answer_quiz1.corr = 0;  # failed to respond (incorrectly)
            # store data for quiz_loop1 (TrialHandler)
            quiz_loop1.addData('answer_quiz1.keys',answer_quiz1.keys)
            quiz_loop1.addData('answer_quiz1.corr', answer_quiz1.corr)
            if answer_quiz1.keys != None:  # we had a response
                quiz_loop1.addData('answer_quiz1.rt', answer_quiz1.rt)
                quiz_loop1.addData('answer_quiz1.duration', answer_quiz1.duration)
            # Run 'End Routine' code from code_38
            if answer_quiz1.corr:
                quiz1_score+=1
                msg="Correct! Good job!"
            else:
                msg="INCORRECT :("
            # the Routine "quiz" was not non-slip safe, so reset the non-slip timer
            routineTimer.reset()
            
            # --- Prepare to start Routine "quiz_feedback" ---
            # create an object to store info about Routine quiz_feedback
            quiz_feedback = data.Routine(
                name='quiz_feedback',
                components=[result_q_instr],
            )
            quiz_feedback.status = NOT_STARTED
            continueRoutine = True
            # update component parameters for each repeat
            result_q_instr.setText(msg)
            # store start times for quiz_feedback
            quiz_feedback.tStartRefresh = win.getFutureFlipTime(clock=globalClock)
            quiz_feedback.tStart = globalClock.getTime(format='float')
            quiz_feedback.status = STARTED
            thisExp.addData('quiz_feedback.started', quiz_feedback.tStart)
            quiz_feedback.maxDuration = None
            # keep track of which components have finished
            quiz_feedbackComponents = quiz_feedback.components
            for thisComponent in quiz_feedback.components:
                thisComponent.tStart = None
                thisComponent.tStop = None
                thisComponent.tStartRefresh = None
                thisComponent.tStopRefresh = None
                if hasattr(thisComponent, 'status'):
                    thisComponent.status = NOT_STARTED
            # reset timers
            t = 0
            _timeToFirstFrame = win.getFutureFlipTime(clock="now")
            frameN = -1
            
            # --- Run Routine "quiz_feedback" ---
            # if trial has changed, end Routine now
            if isinstance(quiz_loop1, data.TrialHandler2) and thisQuiz_loop1.thisN != quiz_loop1.thisTrial.thisN:
                continueRoutine = False
            quiz_feedback.forceEnded = routineForceEnded = not continueRoutine
            while continueRoutine and routineTimer.getTime() < 1.25:
                # get current time
                t = routineTimer.getTime()
                tThisFlip = win.getFutureFlipTime(clock=routineTimer)
                tThisFlipGlobal = win.getFutureFlipTime(clock=None)
                frameN = frameN + 1  # number of completed frames (so 0 is the first frame)
                # update/draw components on each frame
                
                # *result_q_instr* updates
                
                # if result_q_instr is starting this frame...
                if result_q_instr.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
                    # keep track of start time/frame for later
                    result_q_instr.frameNStart = frameN  # exact frame index
                    result_q_instr.tStart = t  # local t and not account for scr refresh
                    result_q_instr.tStartRefresh = tThisFlipGlobal  # on global time
                    win.timeOnFlip(result_q_instr, 'tStartRefresh')  # time at next scr refresh
                    # add timestamp to datafile
                    thisExp.timestampOnFlip(win, 'result_q_instr.started')
                    # update status
                    result_q_instr.status = STARTED
                    result_q_instr.setAutoDraw(True)
                
                # if result_q_instr is active this frame...
                if result_q_instr.status == STARTED:
                    # update params
                    pass
                
                # if result_q_instr is stopping this frame...
                if result_q_instr.status == STARTED:
                    # is it time to stop? (based on global clock, using actual start)
                    if tThisFlipGlobal > result_q_instr.tStartRefresh + 1.25-frameTolerance:
                        # keep track of stop time/frame for later
                        result_q_instr.tStop = t  # not accounting for scr refresh
                        result_q_instr.tStopRefresh = tThisFlipGlobal  # on global time
                        result_q_instr.frameNStop = frameN  # exact frame index
                        # add timestamp to datafile
                        thisExp.timestampOnFlip(win, 'result_q_instr.stopped')
                        # update status
                        result_q_instr.status = FINISHED
                        result_q_instr.setAutoDraw(False)
                
                # check for quit (typically the Esc key)
                if defaultKeyboard.getKeys(keyList=["escape"]):
                    thisExp.status = FINISHED
                if thisExp.status == FINISHED or endExpNow:
                    endExperiment(thisExp, win=win)
                    return
                # pause experiment here if requested
                if thisExp.status == PAUSED:
                    pauseExperiment(
                        thisExp=thisExp, 
                        win=win, 
                        timers=[routineTimer], 
                        playbackComponents=[]
                    )
                    # skip the frame we paused on
                    continue
                
                # check if all components have finished
                if not continueRoutine:  # a component has requested a forced-end of Routine
                    quiz_feedback.forceEnded = routineForceEnded = True
                    break
                continueRoutine = False  # will revert to True if at least one component still running
                for thisComponent in quiz_feedback.components:
                    if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:
                        continueRoutine = True
                        break  # at least one component has not yet finished
                
                # refresh the screen
                if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen
                    win.flip()
            
            # --- Ending Routine "quiz_feedback" ---
            for thisComponent in quiz_feedback.components:
                if hasattr(thisComponent, "setAutoDraw"):
                    thisComponent.setAutoDraw(False)
            # store stop times for quiz_feedback
            quiz_feedback.tStop = globalClock.getTime(format='float')
            quiz_feedback.tStopRefresh = tThisFlipGlobal
            thisExp.addData('quiz_feedback.stopped', quiz_feedback.tStop)
            # using non-slip timing so subtract the expected duration of this Routine (unless ended on request)
            if quiz_feedback.maxDurationReached:
                routineTimer.addTime(-quiz_feedback.maxDuration)
            elif quiz_feedback.forceEnded:
                routineTimer.reset()
            else:
                routineTimer.addTime(-1.250000)
            thisExp.nextEntry()
            
        # completed 1.0 repeats of 'quiz_loop1'
        
        if thisSession is not None:
            # if running in a Session with a Liaison client, send data up to now
            thisSession.sendExperimentData()
        
        # --- Prepare to start Routine "back_to_learn" ---
        # create an object to store info about Routine back_to_learn
        back_to_learn = data.Routine(
            name='back_to_learn',
            components=[text_8],
        )
        back_to_learn.status = NOT_STARTED
        continueRoutine = True
        # update component parameters for each repeat
        # store start times for back_to_learn
        back_to_learn.tStartRefresh = win.getFutureFlipTime(clock=globalClock)
        back_to_learn.tStart = globalClock.getTime(format='float')
        back_to_learn.status = STARTED
        thisExp.addData('back_to_learn.started', back_to_learn.tStart)
        back_to_learn.maxDuration = None
        # keep track of which components have finished
        back_to_learnComponents = back_to_learn.components
        for thisComponent in back_to_learn.components:
            thisComponent.tStart = None
            thisComponent.tStop = None
            thisComponent.tStartRefresh = None
            thisComponent.tStopRefresh = None
            if hasattr(thisComponent, 'status'):
                thisComponent.status = NOT_STARTED
        # reset timers
        t = 0
        _timeToFirstFrame = win.getFutureFlipTime(clock="now")
        frameN = -1
        
        # --- Run Routine "back_to_learn" ---
        # if trial has changed, end Routine now
        if isinstance(learning_phase, data.TrialHandler2) and thisLearning_phase.thisN != learning_phase.thisTrial.thisN:
            continueRoutine = False
        back_to_learn.forceEnded = routineForceEnded = not continueRoutine
        while continueRoutine and routineTimer.getTime() < 10.0:
            # get current time
            t = routineTimer.getTime()
            tThisFlip = win.getFutureFlipTime(clock=routineTimer)
            tThisFlipGlobal = win.getFutureFlipTime(clock=None)
            frameN = frameN + 1  # number of completed frames (so 0 is the first frame)
            # update/draw components on each frame
            
            # *text_8* updates
            
            # if text_8 is starting this frame...
            if text_8.status == NOT_STARTED and tThisFlip >= 0-frameTolerance:
                # keep track of start time/frame for later
                text_8.frameNStart = frameN  # exact frame index
                text_8.tStart = t  # local t and not account for scr refresh
                text_8.tStartRefresh = tThisFlipGlobal  # on global time
                win.timeOnFlip(text_8, 'tStartRefresh')  # time at next scr refresh
                # add timestamp to datafile
                thisExp.timestampOnFlip(win, 'text_8.started')
                # update status
                text_8.status = STARTED
                text_8.setAutoDraw(True)
            
            # if text_8 is active this frame...
            if text_8.status == STARTED:
                # update params
                pass
            
            # if text_8 is stopping this frame...
            if text_8.status == STARTED:
                # is it time to stop? (based on global clock, using actual start)
                if tThisFlipGlobal > text_8.tStartRefresh + 10-frameTolerance:
                    # keep track of stop time/frame for later
                    text_8.tStop = t  # not accounting for scr refresh
                    text_8.tStopRefresh = tThisFlipGlobal  # on global time
                    text_8.frameNStop = frameN  # exact frame index
                    # add timestamp to datafile
                    thisExp.timestampOnFlip(win, 'text_8.stopped')
                    # update status
                    text_8.status = FINISHED
                    text_8.setAutoDraw(False)
            
            # check for quit (typically the Esc key)
            if defaultKeyboard.getKeys(keyList=["escape"]):
                thisExp.status = FINISHED
            if thisExp.status == FINISHED or endExpNow:
                endExperiment(thisExp, win=win)
                return
            # pause experiment here if requested
            if thisExp.status == PAUSED:
                pauseExperiment(
                    thisExp=thisExp, 
                    win=win, 
                    timers=[routineTimer], 
                    playbackComponents=[]
                )
                # skip the frame we paused on
                continue
            
            # check if all components have finished
            if not continueRoutine:  # a component has requested a forced-end of Routine
                back_to_learn.forceEnded = routineForceEnded = True
                break
            continueRoutine = False  # will revert to True if at least one component still running
            for thisComponent in back_to_learn.components:
                if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:
                    continueRoutine = True
                    break  # at least one component has not yet finished
            
            # refresh the screen
            if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen
                win.flip()
        
        # --- Ending Routine "back_to_learn" ---
        for thisComponent in back_to_learn.components:
            if hasattr(thisComponent, "setAutoDraw"):
                thisComponent.setAutoDraw(False)
        # store stop times for back_to_learn
        back_to_learn.tStop = globalClock.getTime(format='float')
        back_to_learn.tStopRefresh = tThisFlipGlobal
        thisExp.addData('back_to_learn.stopped', back_to_learn.tStop)
        # using non-slip timing so subtract the expected duration of this Routine (unless ended on request)
        if back_to_learn.maxDurationReached:
            routineTimer.addTime(-back_to_learn.maxDuration)
        elif back_to_learn.forceEnded:
            routineTimer.reset()
        else:
            routineTimer.addTime(-10.000000)
        
        # set up handler to look after randomisation of conditions etc
        learn_1_2 = data.TrialHandler2(
            name='learn_1_2',
            nReps=1.0, 
            method='random', 
            extraInfo=expInfo, 
            originPath=-1, 
            trialList=data.importConditions('try_game.xlsx'), 
            seed=None, 
        )
        thisExp.addLoop(learn_1_2)  # add the loop to the experiment
        thisLearn_1_2 = learn_1_2.trialList[0]  # so we can initialise stimuli with some values
        # abbreviate parameter names if possible (e.g. rgb = thisLearn_1_2.rgb)
        if thisLearn_1_2 != None:
            for paramName in thisLearn_1_2:
                globals()[paramName] = thisLearn_1_2[paramName]
        if thisSession is not None:
            # if running in a Session with a Liaison client, send data up to now
            thisSession.sendExperimentData()
        
        for thisLearn_1_2 in learn_1_2:
            currentLoop = learn_1_2
            thisExp.timestampOnFlip(win, 'thisRow.t', format=globalClock.format)
            if thisSession is not None:
                # if running in a Session with a Liaison client, send data up to now
                thisSession.sendExperimentData()
            # abbreviate parameter names if possible (e.g. rgb = thisLearn_1_2.rgb)
            if thisLearn_1_2 != None:
                for paramName in thisLearn_1_2:
                    globals()[paramName] = thisLearn_1_2[paramName]
            
            # set up handler to look after randomisation of conditions etc
            incorrect_loop2 = data.TrialHandler2(
                name='incorrect_loop2',
                nReps=9999.0, 
                method='random', 
                extraInfo=expInfo, 
                originPath=-1, 
                trialList=[None], 
                seed=None, 
            )
            thisExp.addLoop(incorrect_loop2)  # add the loop to the experiment
            thisIncorrect_loop2 = incorrect_loop2.trialList[0]  # so we can initialise stimuli with some values
            # abbreviate parameter names if possible (e.g. rgb = thisIncorrect_loop2.rgb)
            if thisIncorrect_loop2 != None:
                for paramName in thisIncorrect_loop2:
                    globals()[paramName] = thisIncorrect_loop2[paramName]
            if thisSession is not None:
                # if running in a Session with a Liaison client, send data up to now
                thisSession.sendExperimentData()
            
            for thisIncorrect_loop2 in incorrect_loop2:
                currentLoop = incorrect_loop2
                thisExp.timestampOnFlip(win, 'thisRow.t', format=globalClock.format)
                if thisSession is not None:
                    # if running in a Session with a Liaison client, send data up to now
                    thisSession.sendExperimentData()
                # abbreviate parameter names if possible (e.g. rgb = thisIncorrect_loop2.rgb)
                if thisIncorrect_loop2 != None:
                    for paramName in thisIncorrect_loop2:
                        globals()[paramName] = thisIncorrect_loop2[paramName]
                
                # --- Prepare to start Routine "learn1" ---
                # create an object to store info about Routine learn1
                learn1 = data.Routine(
                    name='learn1',
                    components=[key_resp, image_1, text],
                )
                learn1.status = NOT_STARTED
                continueRoutine = True
                # update component parameters for each repeat
                # create starting attributes for key_resp
                key_resp.keys = []
                key_resp.rt = []
                _key_resp_allKeys = []
                image_1.setImage(image1)
                text.setText(action1)
                # store start times for learn1
                learn1.tStartRefresh = win.getFutureFlipTime(clock=globalClock)
                learn1.tStart = globalClock.getTime(format='float')
                learn1.status = STARTED
                thisExp.addData('learn1.started', learn1.tStart)
                learn1.maxDuration = None
                # keep track of which components have finished
                learn1Components = learn1.components
                for thisComponent in learn1.components:
                    thisComponent.tStart = None
                    thisComponent.tStop = None
                    thisComponent.tStartRefresh = None
                    thisComponent.tStopRefresh = None
                    if hasattr(thisComponent, 'status'):
                        thisComponent.status = NOT_STARTED
                # reset timers
                t = 0
                _timeToFirstFrame = win.getFutureFlipTime(clock="now")
                frameN = -1
                
                # --- Run Routine "learn1" ---
                # if trial has changed, end Routine now
                if isinstance(incorrect_loop2, data.TrialHandler2) and thisIncorrect_loop2.thisN != incorrect_loop2.thisTrial.thisN:
                    continueRoutine = False
                learn1.forceEnded = routineForceEnded = not continueRoutine
                while continueRoutine:
                    # get current time
                    t = routineTimer.getTime()
                    tThisFlip = win.getFutureFlipTime(clock=routineTimer)
                    tThisFlipGlobal = win.getFutureFlipTime(clock=None)
                    frameN = frameN + 1  # number of completed frames (so 0 is the first frame)
                    # update/draw components on each frame
                    
                    # *key_resp* updates
                    waitOnFlip = False
                    
                    # if key_resp is starting this frame...
                    if key_resp.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
                        # keep track of start time/frame for later
                        key_resp.frameNStart = frameN  # exact frame index
                        key_resp.tStart = t  # local t and not account for scr refresh
                        key_resp.tStartRefresh = tThisFlipGlobal  # on global time
                        win.timeOnFlip(key_resp, 'tStartRefresh')  # time at next scr refresh
                        # add timestamp to datafile
                        thisExp.timestampOnFlip(win, 'key_resp.started')
                        # update status
                        key_resp.status = STARTED
                        # keyboard checking is just starting
                        waitOnFlip = True
                        win.callOnFlip(key_resp.clock.reset)  # t=0 on next screen flip
                        win.callOnFlip(key_resp.clearEvents, eventType='keyboard')  # clear events on next screen flip
                    if key_resp.status == STARTED and not waitOnFlip:
                        theseKeys = key_resp.getKeys(keyList=['left','right'], ignoreKeys=["escape"], waitRelease=False)
                        _key_resp_allKeys.extend(theseKeys)
                        if len(_key_resp_allKeys):
                            key_resp.keys = _key_resp_allKeys[-1].name  # just the last key pressed
                            key_resp.rt = _key_resp_allKeys[-1].rt
                            key_resp.duration = _key_resp_allKeys[-1].duration
                            # was this correct?
                            if (key_resp.keys == str(corr_ans)) or (key_resp.keys == corr_ans):
                                key_resp.corr = 1
                            else:
                                key_resp.corr = 0
                            # a response ends the routine
                            continueRoutine = False
                    
                    # *image_1* updates
                    
                    # if image_1 is starting this frame...
                    if image_1.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
                        # keep track of start time/frame for later
                        image_1.frameNStart = frameN  # exact frame index
                        image_1.tStart = t  # local t and not account for scr refresh
                        image_1.tStartRefresh = tThisFlipGlobal  # on global time
                        win.timeOnFlip(image_1, 'tStartRefresh')  # time at next scr refresh
                        # add timestamp to datafile
                        thisExp.timestampOnFlip(win, 'image_1.started')
                        # update status
                        image_1.status = STARTED
                        image_1.setAutoDraw(True)
                    
                    # if image_1 is active this frame...
                    if image_1.status == STARTED:
                        # update params
                        pass
                    
                    # *text* updates
                    
                    # if text is starting this frame...
                    if text.status == NOT_STARTED and tThisFlip >= 1-frameTolerance:
                        # keep track of start time/frame for later
                        text.frameNStart = frameN  # exact frame index
                        text.tStart = t  # local t and not account for scr refresh
                        text.tStartRefresh = tThisFlipGlobal  # on global time
                        win.timeOnFlip(text, 'tStartRefresh')  # time at next scr refresh
                        # add timestamp to datafile
                        thisExp.timestampOnFlip(win, 'text.started')
                        # update status
                        text.status = STARTED
                        text.setAutoDraw(True)
                    
                    # if text is active this frame...
                    if text.status == STARTED:
                        # update params
                        pass
                    
                    # check for quit (typically the Esc key)
                    if defaultKeyboard.getKeys(keyList=["escape"]):
                        thisExp.status = FINISHED
                    if thisExp.status == FINISHED or endExpNow:
                        endExperiment(thisExp, win=win)
                        return
                    # pause experiment here if requested
                    if thisExp.status == PAUSED:
                        pauseExperiment(
                            thisExp=thisExp, 
                            win=win, 
                            timers=[routineTimer], 
                            playbackComponents=[]
                        )
                        # skip the frame we paused on
                        continue
                    
                    # check if all components have finished
                    if not continueRoutine:  # a component has requested a forced-end of Routine
                        learn1.forceEnded = routineForceEnded = True
                        break
                    continueRoutine = False  # will revert to True if at least one component still running
                    for thisComponent in learn1.components:
                        if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:
                            continueRoutine = True
                            break  # at least one component has not yet finished
                    
                    # refresh the screen
                    if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen
                        win.flip()
                
                # --- Ending Routine "learn1" ---
                for thisComponent in learn1.components:
                    if hasattr(thisComponent, "setAutoDraw"):
                        thisComponent.setAutoDraw(False)
                # store stop times for learn1
                learn1.tStop = globalClock.getTime(format='float')
                learn1.tStopRefresh = tThisFlipGlobal
                thisExp.addData('learn1.stopped', learn1.tStop)
                # check responses
                if key_resp.keys in ['', [], None]:  # No response was made
                    key_resp.keys = None
                    # was no response the correct answer?!
                    if str(corr_ans).lower() == 'none':
                       key_resp.corr = 1;  # correct non-response
                    else:
                       key_resp.corr = 0;  # failed to respond (incorrectly)
                # store data for incorrect_loop2 (TrialHandler)
                incorrect_loop2.addData('key_resp.keys',key_resp.keys)
                incorrect_loop2.addData('key_resp.corr', key_resp.corr)
                if key_resp.keys != None:  # we had a response
                    incorrect_loop2.addData('key_resp.rt', key_resp.rt)
                    incorrect_loop2.addData('key_resp.duration', key_resp.duration)
                # the Routine "learn1" was not non-slip safe, so reset the non-slip timer
                routineTimer.reset()
                
                # --- Prepare to start Routine "check_incorrect" ---
                # create an object to store info about Routine check_incorrect
                check_incorrect = data.Routine(
                    name='check_incorrect',
                    components=[text_incorrect],
                )
                check_incorrect.status = NOT_STARTED
                continueRoutine = True
                # update component parameters for each repeat
                # Run 'Begin Routine' code from code
                if key_resp.corr:
                    msg_incorrect='correct'
                    incorrect_loop2.finished = True
                    continueRoutine=False
                else:
                    msg_incorrect='You clicked the wrong button! If you click the wrong button 5 times, the game will stop and you will NOT GET PAID because you failed to follow instructions!'
                    incorrect_actions+=1
                    continueRoutine=True
                    if incorrect_actions>15:
                        psychoJS.quit()
                text_incorrect.setText(msg_incorrect)
                # store start times for check_incorrect
                check_incorrect.tStartRefresh = win.getFutureFlipTime(clock=globalClock)
                check_incorrect.tStart = globalClock.getTime(format='float')
                check_incorrect.status = STARTED
                thisExp.addData('check_incorrect.started', check_incorrect.tStart)
                check_incorrect.maxDuration = None
                # keep track of which components have finished
                check_incorrectComponents = check_incorrect.components
                for thisComponent in check_incorrect.components:
                    thisComponent.tStart = None
                    thisComponent.tStop = None
                    thisComponent.tStartRefresh = None
                    thisComponent.tStopRefresh = None
                    if hasattr(thisComponent, 'status'):
                        thisComponent.status = NOT_STARTED
                # reset timers
                t = 0
                _timeToFirstFrame = win.getFutureFlipTime(clock="now")
                frameN = -1
                
                # --- Run Routine "check_incorrect" ---
                # if trial has changed, end Routine now
                if isinstance(incorrect_loop2, data.TrialHandler2) and thisIncorrect_loop2.thisN != incorrect_loop2.thisTrial.thisN:
                    continueRoutine = False
                check_incorrect.forceEnded = routineForceEnded = not continueRoutine
                while continueRoutine and routineTimer.getTime() < 3.0:
                    # get current time
                    t = routineTimer.getTime()
                    tThisFlip = win.getFutureFlipTime(clock=routineTimer)
                    tThisFlipGlobal = win.getFutureFlipTime(clock=None)
                    frameN = frameN + 1  # number of completed frames (so 0 is the first frame)
                    # update/draw components on each frame
                    
                    # *text_incorrect* updates
                    
                    # if text_incorrect is starting this frame...
                    if text_incorrect.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
                        # keep track of start time/frame for later
                        text_incorrect.frameNStart = frameN  # exact frame index
                        text_incorrect.tStart = t  # local t and not account for scr refresh
                        text_incorrect.tStartRefresh = tThisFlipGlobal  # on global time
                        win.timeOnFlip(text_incorrect, 'tStartRefresh')  # time at next scr refresh
                        # add timestamp to datafile
                        thisExp.timestampOnFlip(win, 'text_incorrect.started')
                        # update status
                        text_incorrect.status = STARTED
                        text_incorrect.setAutoDraw(True)
                    
                    # if text_incorrect is active this frame...
                    if text_incorrect.status == STARTED:
                        # update params
                        pass
                    
                    # if text_incorrect is stopping this frame...
                    if text_incorrect.status == STARTED:
                        # is it time to stop? (based on global clock, using actual start)
                        if tThisFlipGlobal > text_incorrect.tStartRefresh + 3-frameTolerance:
                            # keep track of stop time/frame for later
                            text_incorrect.tStop = t  # not accounting for scr refresh
                            text_incorrect.tStopRefresh = tThisFlipGlobal  # on global time
                            text_incorrect.frameNStop = frameN  # exact frame index
                            # add timestamp to datafile
                            thisExp.timestampOnFlip(win, 'text_incorrect.stopped')
                            # update status
                            text_incorrect.status = FINISHED
                            text_incorrect.setAutoDraw(False)
                    
                    # check for quit (typically the Esc key)
                    if defaultKeyboard.getKeys(keyList=["escape"]):
                        thisExp.status = FINISHED
                    if thisExp.status == FINISHED or endExpNow:
                        endExperiment(thisExp, win=win)
                        return
                    # pause experiment here if requested
                    if thisExp.status == PAUSED:
                        pauseExperiment(
                            thisExp=thisExp, 
                            win=win, 
                            timers=[routineTimer], 
                            playbackComponents=[]
                        )
                        # skip the frame we paused on
                        continue
                    
                    # check if all components have finished
                    if not continueRoutine:  # a component has requested a forced-end of Routine
                        check_incorrect.forceEnded = routineForceEnded = True
                        break
                    continueRoutine = False  # will revert to True if at least one component still running
                    for thisComponent in check_incorrect.components:
                        if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:
                            continueRoutine = True
                            break  # at least one component has not yet finished
                    
                    # refresh the screen
                    if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen
                        win.flip()
                
                # --- Ending Routine "check_incorrect" ---
                for thisComponent in check_incorrect.components:
                    if hasattr(thisComponent, "setAutoDraw"):
                        thisComponent.setAutoDraw(False)
                # store stop times for check_incorrect
                check_incorrect.tStop = globalClock.getTime(format='float')
                check_incorrect.tStopRefresh = tThisFlipGlobal
                thisExp.addData('check_incorrect.stopped', check_incorrect.tStop)
                # using non-slip timing so subtract the expected duration of this Routine (unless ended on request)
                if check_incorrect.maxDurationReached:
                    routineTimer.addTime(-check_incorrect.maxDuration)
                elif check_incorrect.forceEnded:
                    routineTimer.reset()
                else:
                    routineTimer.addTime(-3.000000)
                thisExp.nextEntry()
                
            # completed 9999.0 repeats of 'incorrect_loop2'
            
            if thisSession is not None:
                # if running in a Session with a Liaison client, send data up to now
                thisSession.sendExperimentData()
            
            # --- Prepare to start Routine "learn2" ---
            # create an object to store info about Routine learn2
            learn2 = data.Routine(
                name='learn2',
                components=[image_2],
            )
            learn2.status = NOT_STARTED
            continueRoutine = True
            # update component parameters for each repeat
            image_2.setImage(image2)
            # store start times for learn2
            learn2.tStartRefresh = win.getFutureFlipTime(clock=globalClock)
            learn2.tStart = globalClock.getTime(format='float')
            learn2.status = STARTED
            thisExp.addData('learn2.started', learn2.tStart)
            learn2.maxDuration = None
            # keep track of which components have finished
            learn2Components = learn2.components
            for thisComponent in learn2.components:
                thisComponent.tStart = None
                thisComponent.tStop = None
                thisComponent.tStartRefresh = None
                thisComponent.tStopRefresh = None
                if hasattr(thisComponent, 'status'):
                    thisComponent.status = NOT_STARTED
            # reset timers
            t = 0
            _timeToFirstFrame = win.getFutureFlipTime(clock="now")
            frameN = -1
            
            # --- Run Routine "learn2" ---
            # if trial has changed, end Routine now
            if isinstance(learn_1_2, data.TrialHandler2) and thisLearn_1_2.thisN != learn_1_2.thisTrial.thisN:
                continueRoutine = False
            learn2.forceEnded = routineForceEnded = not continueRoutine
            while continueRoutine and routineTimer.getTime() < 1.0:
                # get current time
                t = routineTimer.getTime()
                tThisFlip = win.getFutureFlipTime(clock=routineTimer)
                tThisFlipGlobal = win.getFutureFlipTime(clock=None)
                frameN = frameN + 1  # number of completed frames (so 0 is the first frame)
                # update/draw components on each frame
                
                # *image_2* updates
                
                # if image_2 is starting this frame...
                if image_2.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
                    # keep track of start time/frame for later
                    image_2.frameNStart = frameN  # exact frame index
                    image_2.tStart = t  # local t and not account for scr refresh
                    image_2.tStartRefresh = tThisFlipGlobal  # on global time
                    win.timeOnFlip(image_2, 'tStartRefresh')  # time at next scr refresh
                    # add timestamp to datafile
                    thisExp.timestampOnFlip(win, 'image_2.started')
                    # update status
                    image_2.status = STARTED
                    image_2.setAutoDraw(True)
                
                # if image_2 is active this frame...
                if image_2.status == STARTED:
                    # update params
                    pass
                
                # if image_2 is stopping this frame...
                if image_2.status == STARTED:
                    # is it time to stop? (based on global clock, using actual start)
                    if tThisFlipGlobal > image_2.tStartRefresh + 1-frameTolerance:
                        # keep track of stop time/frame for later
                        image_2.tStop = t  # not accounting for scr refresh
                        image_2.tStopRefresh = tThisFlipGlobal  # on global time
                        image_2.frameNStop = frameN  # exact frame index
                        # add timestamp to datafile
                        thisExp.timestampOnFlip(win, 'image_2.stopped')
                        # update status
                        image_2.status = FINISHED
                        image_2.setAutoDraw(False)
                
                # check for quit (typically the Esc key)
                if defaultKeyboard.getKeys(keyList=["escape"]):
                    thisExp.status = FINISHED
                if thisExp.status == FINISHED or endExpNow:
                    endExperiment(thisExp, win=win)
                    return
                # pause experiment here if requested
                if thisExp.status == PAUSED:
                    pauseExperiment(
                        thisExp=thisExp, 
                        win=win, 
                        timers=[routineTimer], 
                        playbackComponents=[]
                    )
                    # skip the frame we paused on
                    continue
                
                # check if all components have finished
                if not continueRoutine:  # a component has requested a forced-end of Routine
                    learn2.forceEnded = routineForceEnded = True
                    break
                continueRoutine = False  # will revert to True if at least one component still running
                for thisComponent in learn2.components:
                    if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:
                        continueRoutine = True
                        break  # at least one component has not yet finished
                
                # refresh the screen
                if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen
                    win.flip()
            
            # --- Ending Routine "learn2" ---
            for thisComponent in learn2.components:
                if hasattr(thisComponent, "setAutoDraw"):
                    thisComponent.setAutoDraw(False)
            # store stop times for learn2
            learn2.tStop = globalClock.getTime(format='float')
            learn2.tStopRefresh = tThisFlipGlobal
            thisExp.addData('learn2.stopped', learn2.tStop)
            # using non-slip timing so subtract the expected duration of this Routine (unless ended on request)
            if learn2.maxDurationReached:
                routineTimer.addTime(-learn2.maxDuration)
            elif learn2.forceEnded:
                routineTimer.reset()
            else:
                routineTimer.addTime(-1.000000)
            
            # --- Prepare to start Routine "next_trial" ---
            # create an object to store info about Routine next_trial
            next_trial = data.Routine(
                name='next_trial',
                components=[next_trial_text],
            )
            next_trial.status = NOT_STARTED
            continueRoutine = True
            # update component parameters for each repeat
            # store start times for next_trial
            next_trial.tStartRefresh = win.getFutureFlipTime(clock=globalClock)
            next_trial.tStart = globalClock.getTime(format='float')
            next_trial.status = STARTED
            thisExp.addData('next_trial.started', next_trial.tStart)
            next_trial.maxDuration = None
            # keep track of which components have finished
            next_trialComponents = next_trial.components
            for thisComponent in next_trial.components:
                thisComponent.tStart = None
                thisComponent.tStop = None
                thisComponent.tStartRefresh = None
                thisComponent.tStopRefresh = None
                if hasattr(thisComponent, 'status'):
                    thisComponent.status = NOT_STARTED
            # reset timers
            t = 0
            _timeToFirstFrame = win.getFutureFlipTime(clock="now")
            frameN = -1
            
            # --- Run Routine "next_trial" ---
            # if trial has changed, end Routine now
            if isinstance(learn_1_2, data.TrialHandler2) and thisLearn_1_2.thisN != learn_1_2.thisTrial.thisN:
                continueRoutine = False
            next_trial.forceEnded = routineForceEnded = not continueRoutine
            while continueRoutine and routineTimer.getTime() < 1.0:
                # get current time
                t = routineTimer.getTime()
                tThisFlip = win.getFutureFlipTime(clock=routineTimer)
                tThisFlipGlobal = win.getFutureFlipTime(clock=None)
                frameN = frameN + 1  # number of completed frames (so 0 is the first frame)
                # update/draw components on each frame
                
                # *next_trial_text* updates
                
                # if next_trial_text is starting this frame...
                if next_trial_text.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
                    # keep track of start time/frame for later
                    next_trial_text.frameNStart = frameN  # exact frame index
                    next_trial_text.tStart = t  # local t and not account for scr refresh
                    next_trial_text.tStartRefresh = tThisFlipGlobal  # on global time
                    win.timeOnFlip(next_trial_text, 'tStartRefresh')  # time at next scr refresh
                    # add timestamp to datafile
                    thisExp.timestampOnFlip(win, 'next_trial_text.started')
                    # update status
                    next_trial_text.status = STARTED
                    next_trial_text.setAutoDraw(True)
                
                # if next_trial_text is active this frame...
                if next_trial_text.status == STARTED:
                    # update params
                    pass
                
                # if next_trial_text is stopping this frame...
                if next_trial_text.status == STARTED:
                    # is it time to stop? (based on global clock, using actual start)
                    if tThisFlipGlobal > next_trial_text.tStartRefresh + 1-frameTolerance:
                        # keep track of stop time/frame for later
                        next_trial_text.tStop = t  # not accounting for scr refresh
                        next_trial_text.tStopRefresh = tThisFlipGlobal  # on global time
                        next_trial_text.frameNStop = frameN  # exact frame index
                        # add timestamp to datafile
                        thisExp.timestampOnFlip(win, 'next_trial_text.stopped')
                        # update status
                        next_trial_text.status = FINISHED
                        next_trial_text.setAutoDraw(False)
                
                # check for quit (typically the Esc key)
                if defaultKeyboard.getKeys(keyList=["escape"]):
                    thisExp.status = FINISHED
                if thisExp.status == FINISHED or endExpNow:
                    endExperiment(thisExp, win=win)
                    return
                # pause experiment here if requested
                if thisExp.status == PAUSED:
                    pauseExperiment(
                        thisExp=thisExp, 
                        win=win, 
                        timers=[routineTimer], 
                        playbackComponents=[]
                    )
                    # skip the frame we paused on
                    continue
                
                # check if all components have finished
                if not continueRoutine:  # a component has requested a forced-end of Routine
                    next_trial.forceEnded = routineForceEnded = True
                    break
                continueRoutine = False  # will revert to True if at least one component still running
                for thisComponent in next_trial.components:
                    if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:
                        continueRoutine = True
                        break  # at least one component has not yet finished
                
                # refresh the screen
                if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen
                    win.flip()
            
            # --- Ending Routine "next_trial" ---
            for thisComponent in next_trial.components:
                if hasattr(thisComponent, "setAutoDraw"):
                    thisComponent.setAutoDraw(False)
            # store stop times for next_trial
            next_trial.tStop = globalClock.getTime(format='float')
            next_trial.tStopRefresh = tThisFlipGlobal
            thisExp.addData('next_trial.stopped', next_trial.tStop)
            # using non-slip timing so subtract the expected duration of this Routine (unless ended on request)
            if next_trial.maxDurationReached:
                routineTimer.addTime(-next_trial.maxDuration)
            elif next_trial.forceEnded:
                routineTimer.reset()
            else:
                routineTimer.addTime(-1.000000)
            thisExp.nextEntry()
            
        # completed 1.0 repeats of 'learn_1_2'
        
        if thisSession is not None:
            # if running in a Session with a Liaison client, send data up to now
            thisSession.sendExperimentData()
        
        # --- Prepare to start Routine "between" ---
        # create an object to store info about Routine between
        between = data.Routine(
            name='between',
            components=[text_2],
        )
        between.status = NOT_STARTED
        continueRoutine = True
        # update component parameters for each repeat
        # Run 'Begin Routine' code from code_39
        quiz1_count=1
        quiz2_count=1
        
        # store start times for between
        between.tStartRefresh = win.getFutureFlipTime(clock=globalClock)
        between.tStart = globalClock.getTime(format='float')
        between.status = STARTED
        thisExp.addData('between.started', between.tStart)
        between.maxDuration = None
        # keep track of which components have finished
        betweenComponents = between.components
        for thisComponent in between.components:
            thisComponent.tStart = None
            thisComponent.tStop = None
            thisComponent.tStartRefresh = None
            thisComponent.tStopRefresh = None
            if hasattr(thisComponent, 'status'):
                thisComponent.status = NOT_STARTED
        # reset timers
        t = 0
        _timeToFirstFrame = win.getFutureFlipTime(clock="now")
        frameN = -1
        
        # --- Run Routine "between" ---
        # if trial has changed, end Routine now
        if isinstance(learning_phase, data.TrialHandler2) and thisLearning_phase.thisN != learning_phase.thisTrial.thisN:
            continueRoutine = False
        between.forceEnded = routineForceEnded = not continueRoutine
        while continueRoutine and routineTimer.getTime() < 5.0:
            # get current time
            t = routineTimer.getTime()
            tThisFlip = win.getFutureFlipTime(clock=routineTimer)
            tThisFlipGlobal = win.getFutureFlipTime(clock=None)
            frameN = frameN + 1  # number of completed frames (so 0 is the first frame)
            # update/draw components on each frame
            
            # *text_2* updates
            
            # if text_2 is starting this frame...
            if text_2.status == NOT_STARTED and tThisFlip >= 0-frameTolerance:
                # keep track of start time/frame for later
                text_2.frameNStart = frameN  # exact frame index
                text_2.tStart = t  # local t and not account for scr refresh
                text_2.tStartRefresh = tThisFlipGlobal  # on global time
                win.timeOnFlip(text_2, 'tStartRefresh')  # time at next scr refresh
                # add timestamp to datafile
                thisExp.timestampOnFlip(win, 'text_2.started')
                # update status
                text_2.status = STARTED
                text_2.setAutoDraw(True)
            
            # if text_2 is active this frame...
            if text_2.status == STARTED:
                # update params
                pass
            
            # if text_2 is stopping this frame...
            if text_2.status == STARTED:
                # is it time to stop? (based on global clock, using actual start)
                if tThisFlipGlobal > text_2.tStartRefresh + 5-frameTolerance:
                    # keep track of stop time/frame for later
                    text_2.tStop = t  # not accounting for scr refresh
                    text_2.tStopRefresh = tThisFlipGlobal  # on global time
                    text_2.frameNStop = frameN  # exact frame index
                    # add timestamp to datafile
                    thisExp.timestampOnFlip(win, 'text_2.stopped')
                    # update status
                    text_2.status = FINISHED
                    text_2.setAutoDraw(False)
            
            # check for quit (typically the Esc key)
            if defaultKeyboard.getKeys(keyList=["escape"]):
                thisExp.status = FINISHED
            if thisExp.status == FINISHED or endExpNow:
                endExperiment(thisExp, win=win)
                return
            # pause experiment here if requested
            if thisExp.status == PAUSED:
                pauseExperiment(
                    thisExp=thisExp, 
                    win=win, 
                    timers=[routineTimer], 
                    playbackComponents=[]
                )
                # skip the frame we paused on
                continue
            
            # check if all components have finished
            if not continueRoutine:  # a component has requested a forced-end of Routine
                between.forceEnded = routineForceEnded = True
                break
            continueRoutine = False  # will revert to True if at least one component still running
            for thisComponent in between.components:
                if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:
                    continueRoutine = True
                    break  # at least one component has not yet finished
            
            # refresh the screen
            if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen
                win.flip()
        
        # --- Ending Routine "between" ---
        for thisComponent in between.components:
            if hasattr(thisComponent, "setAutoDraw"):
                thisComponent.setAutoDraw(False)
        # store stop times for between
        between.tStop = globalClock.getTime(format='float')
        between.tStopRefresh = tThisFlipGlobal
        thisExp.addData('between.stopped', between.tStop)
        # using non-slip timing so subtract the expected duration of this Routine (unless ended on request)
        if between.maxDurationReached:
            routineTimer.addTime(-between.maxDuration)
        elif between.forceEnded:
            routineTimer.reset()
        else:
            routineTimer.addTime(-5.000000)
        
        # set up handler to look after randomisation of conditions etc
        quizloop2 = data.TrialHandler2(
            name='quizloop2',
            nReps=1.0, 
            method='random', 
            extraInfo=expInfo, 
            originPath=-1, 
            trialList=data.importConditions('quiz_1.xlsx'), 
            seed=None, 
        )
        thisExp.addLoop(quizloop2)  # add the loop to the experiment
        thisQuizloop2 = quizloop2.trialList[0]  # so we can initialise stimuli with some values
        # abbreviate parameter names if possible (e.g. rgb = thisQuizloop2.rgb)
        if thisQuizloop2 != None:
            for paramName in thisQuizloop2:
                globals()[paramName] = thisQuizloop2[paramName]
        if thisSession is not None:
            # if running in a Session with a Liaison client, send data up to now
            thisSession.sendExperimentData()
        
        for thisQuizloop2 in quizloop2:
            currentLoop = quizloop2
            thisExp.timestampOnFlip(win, 'thisRow.t', format=globalClock.format)
            if thisSession is not None:
                # if running in a Session with a Liaison client, send data up to now
                thisSession.sendExperimentData()
            # abbreviate parameter names if possible (e.g. rgb = thisQuizloop2.rgb)
            if thisQuizloop2 != None:
                for paramName in thisQuizloop2:
                    globals()[paramName] = thisQuizloop2[paramName]
            
            # --- Prepare to start Routine "quiz2" ---
            # create an object to store info about Routine quiz2
            quiz2 = data.Routine(
                name='quiz2',
                components=[target_quiz1_2, question_quiz1_2, answer_quiz1_2, answer1_2, answer2_2, answer3_2, answer4_2, a1_2, a2_2, a3_2, a4_2],
            )
            quiz2.status = NOT_STARTED
            continueRoutine = True
            # update component parameters for each repeat
            target_quiz1_2.setImage(image1)
            question_quiz1_2.setText(question)
            # create starting attributes for answer_quiz1_2
            answer_quiz1_2.keys = []
            answer_quiz1_2.rt = []
            _answer_quiz1_2_allKeys = []
            answer1_2.setImage(ans1)
            answer2_2.setImage(ans2)
            answer3_2.setImage(ans3)
            answer4_2.setImage(ans4)
            # store start times for quiz2
            quiz2.tStartRefresh = win.getFutureFlipTime(clock=globalClock)
            quiz2.tStart = globalClock.getTime(format='float')
            quiz2.status = STARTED
            thisExp.addData('quiz2.started', quiz2.tStart)
            quiz2.maxDuration = None
            # keep track of which components have finished
            quiz2Components = quiz2.components
            for thisComponent in quiz2.components:
                thisComponent.tStart = None
                thisComponent.tStop = None
                thisComponent.tStartRefresh = None
                thisComponent.tStopRefresh = None
                if hasattr(thisComponent, 'status'):
                    thisComponent.status = NOT_STARTED
            # reset timers
            t = 0
            _timeToFirstFrame = win.getFutureFlipTime(clock="now")
            frameN = -1
            
            # --- Run Routine "quiz2" ---
            # if trial has changed, end Routine now
            if isinstance(quizloop2, data.TrialHandler2) and thisQuizloop2.thisN != quizloop2.thisTrial.thisN:
                continueRoutine = False
            quiz2.forceEnded = routineForceEnded = not continueRoutine
            while continueRoutine:
                # get current time
                t = routineTimer.getTime()
                tThisFlip = win.getFutureFlipTime(clock=routineTimer)
                tThisFlipGlobal = win.getFutureFlipTime(clock=None)
                frameN = frameN + 1  # number of completed frames (so 0 is the first frame)
                # update/draw components on each frame
                
                # *target_quiz1_2* updates
                
                # if target_quiz1_2 is starting this frame...
                if target_quiz1_2.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
                    # keep track of start time/frame for later
                    target_quiz1_2.frameNStart = frameN  # exact frame index
                    target_quiz1_2.tStart = t  # local t and not account for scr refresh
                    target_quiz1_2.tStartRefresh = tThisFlipGlobal  # on global time
                    win.timeOnFlip(target_quiz1_2, 'tStartRefresh')  # time at next scr refresh
                    # add timestamp to datafile
                    thisExp.timestampOnFlip(win, 'target_quiz1_2.started')
                    # update status
                    target_quiz1_2.status = STARTED
                    target_quiz1_2.setAutoDraw(True)
                
                # if target_quiz1_2 is active this frame...
                if target_quiz1_2.status == STARTED:
                    # update params
                    pass
                
                # *question_quiz1_2* updates
                
                # if question_quiz1_2 is starting this frame...
                if question_quiz1_2.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
                    # keep track of start time/frame for later
                    question_quiz1_2.frameNStart = frameN  # exact frame index
                    question_quiz1_2.tStart = t  # local t and not account for scr refresh
                    question_quiz1_2.tStartRefresh = tThisFlipGlobal  # on global time
                    win.timeOnFlip(question_quiz1_2, 'tStartRefresh')  # time at next scr refresh
                    # add timestamp to datafile
                    thisExp.timestampOnFlip(win, 'question_quiz1_2.started')
                    # update status
                    question_quiz1_2.status = STARTED
                    question_quiz1_2.setAutoDraw(True)
                
                # if question_quiz1_2 is active this frame...
                if question_quiz1_2.status == STARTED:
                    # update params
                    pass
                
                # *answer_quiz1_2* updates
                waitOnFlip = False
                
                # if answer_quiz1_2 is starting this frame...
                if answer_quiz1_2.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
                    # keep track of start time/frame for later
                    answer_quiz1_2.frameNStart = frameN  # exact frame index
                    answer_quiz1_2.tStart = t  # local t and not account for scr refresh
                    answer_quiz1_2.tStartRefresh = tThisFlipGlobal  # on global time
                    win.timeOnFlip(answer_quiz1_2, 'tStartRefresh')  # time at next scr refresh
                    # add timestamp to datafile
                    thisExp.timestampOnFlip(win, 'answer_quiz1_2.started')
                    # update status
                    answer_quiz1_2.status = STARTED
                    # keyboard checking is just starting
                    waitOnFlip = True
                    win.callOnFlip(answer_quiz1_2.clock.reset)  # t=0 on next screen flip
                    win.callOnFlip(answer_quiz1_2.clearEvents, eventType='keyboard')  # clear events on next screen flip
                if answer_quiz1_2.status == STARTED and not waitOnFlip:
                    theseKeys = answer_quiz1_2.getKeys(keyList=['1','2','3','4'], ignoreKeys=["escape"], waitRelease=False)
                    _answer_quiz1_2_allKeys.extend(theseKeys)
                    if len(_answer_quiz1_2_allKeys):
                        answer_quiz1_2.keys = _answer_quiz1_2_allKeys[-1].name  # just the last key pressed
                        answer_quiz1_2.rt = _answer_quiz1_2_allKeys[-1].rt
                        answer_quiz1_2.duration = _answer_quiz1_2_allKeys[-1].duration
                        # was this correct?
                        if (answer_quiz1_2.keys == str(corr_ans)) or (answer_quiz1_2.keys == corr_ans):
                            answer_quiz1_2.corr = 1
                        else:
                            answer_quiz1_2.corr = 0
                        # a response ends the routine
                        continueRoutine = False
                
                # *answer1_2* updates
                
                # if answer1_2 is starting this frame...
                if answer1_2.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
                    # keep track of start time/frame for later
                    answer1_2.frameNStart = frameN  # exact frame index
                    answer1_2.tStart = t  # local t and not account for scr refresh
                    answer1_2.tStartRefresh = tThisFlipGlobal  # on global time
                    win.timeOnFlip(answer1_2, 'tStartRefresh')  # time at next scr refresh
                    # add timestamp to datafile
                    thisExp.timestampOnFlip(win, 'answer1_2.started')
                    # update status
                    answer1_2.status = STARTED
                    answer1_2.setAutoDraw(True)
                
                # if answer1_2 is active this frame...
                if answer1_2.status == STARTED:
                    # update params
                    pass
                
                # *answer2_2* updates
                
                # if answer2_2 is starting this frame...
                if answer2_2.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
                    # keep track of start time/frame for later
                    answer2_2.frameNStart = frameN  # exact frame index
                    answer2_2.tStart = t  # local t and not account for scr refresh
                    answer2_2.tStartRefresh = tThisFlipGlobal  # on global time
                    win.timeOnFlip(answer2_2, 'tStartRefresh')  # time at next scr refresh
                    # add timestamp to datafile
                    thisExp.timestampOnFlip(win, 'answer2_2.started')
                    # update status
                    answer2_2.status = STARTED
                    answer2_2.setAutoDraw(True)
                
                # if answer2_2 is active this frame...
                if answer2_2.status == STARTED:
                    # update params
                    pass
                
                # *answer3_2* updates
                
                # if answer3_2 is starting this frame...
                if answer3_2.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
                    # keep track of start time/frame for later
                    answer3_2.frameNStart = frameN  # exact frame index
                    answer3_2.tStart = t  # local t and not account for scr refresh
                    answer3_2.tStartRefresh = tThisFlipGlobal  # on global time
                    win.timeOnFlip(answer3_2, 'tStartRefresh')  # time at next scr refresh
                    # add timestamp to datafile
                    thisExp.timestampOnFlip(win, 'answer3_2.started')
                    # update status
                    answer3_2.status = STARTED
                    answer3_2.setAutoDraw(True)
                
                # if answer3_2 is active this frame...
                if answer3_2.status == STARTED:
                    # update params
                    pass
                
                # *answer4_2* updates
                
                # if answer4_2 is starting this frame...
                if answer4_2.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
                    # keep track of start time/frame for later
                    answer4_2.frameNStart = frameN  # exact frame index
                    answer4_2.tStart = t  # local t and not account for scr refresh
                    answer4_2.tStartRefresh = tThisFlipGlobal  # on global time
                    win.timeOnFlip(answer4_2, 'tStartRefresh')  # time at next scr refresh
                    # add timestamp to datafile
                    thisExp.timestampOnFlip(win, 'answer4_2.started')
                    # update status
                    answer4_2.status = STARTED
                    answer4_2.setAutoDraw(True)
                
                # if answer4_2 is active this frame...
                if answer4_2.status == STARTED:
                    # update params
                    pass
                
                # *a1_2* updates
                
                # if a1_2 is starting this frame...
                if a1_2.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
                    # keep track of start time/frame for later
                    a1_2.frameNStart = frameN  # exact frame index
                    a1_2.tStart = t  # local t and not account for scr refresh
                    a1_2.tStartRefresh = tThisFlipGlobal  # on global time
                    win.timeOnFlip(a1_2, 'tStartRefresh')  # time at next scr refresh
                    # add timestamp to datafile
                    thisExp.timestampOnFlip(win, 'a1_2.started')
                    # update status
                    a1_2.status = STARTED
                    a1_2.setAutoDraw(True)
                
                # if a1_2 is active this frame...
                if a1_2.status == STARTED:
                    # update params
                    pass
                
                # *a2_2* updates
                
                # if a2_2 is starting this frame...
                if a2_2.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
                    # keep track of start time/frame for later
                    a2_2.frameNStart = frameN  # exact frame index
                    a2_2.tStart = t  # local t and not account for scr refresh
                    a2_2.tStartRefresh = tThisFlipGlobal  # on global time
                    win.timeOnFlip(a2_2, 'tStartRefresh')  # time at next scr refresh
                    # add timestamp to datafile
                    thisExp.timestampOnFlip(win, 'a2_2.started')
                    # update status
                    a2_2.status = STARTED
                    a2_2.setAutoDraw(True)
                
                # if a2_2 is active this frame...
                if a2_2.status == STARTED:
                    # update params
                    pass
                
                # *a3_2* updates
                
                # if a3_2 is starting this frame...
                if a3_2.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
                    # keep track of start time/frame for later
                    a3_2.frameNStart = frameN  # exact frame index
                    a3_2.tStart = t  # local t and not account for scr refresh
                    a3_2.tStartRefresh = tThisFlipGlobal  # on global time
                    win.timeOnFlip(a3_2, 'tStartRefresh')  # time at next scr refresh
                    # add timestamp to datafile
                    thisExp.timestampOnFlip(win, 'a3_2.started')
                    # update status
                    a3_2.status = STARTED
                    a3_2.setAutoDraw(True)
                
                # if a3_2 is active this frame...
                if a3_2.status == STARTED:
                    # update params
                    pass
                
                # *a4_2* updates
                
                # if a4_2 is starting this frame...
                if a4_2.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
                    # keep track of start time/frame for later
                    a4_2.frameNStart = frameN  # exact frame index
                    a4_2.tStart = t  # local t and not account for scr refresh
                    a4_2.tStartRefresh = tThisFlipGlobal  # on global time
                    win.timeOnFlip(a4_2, 'tStartRefresh')  # time at next scr refresh
                    # add timestamp to datafile
                    thisExp.timestampOnFlip(win, 'a4_2.started')
                    # update status
                    a4_2.status = STARTED
                    a4_2.setAutoDraw(True)
                
                # if a4_2 is active this frame...
                if a4_2.status == STARTED:
                    # update params
                    pass
                
                # check for quit (typically the Esc key)
                if defaultKeyboard.getKeys(keyList=["escape"]):
                    thisExp.status = FINISHED
                if thisExp.status == FINISHED or endExpNow:
                    endExperiment(thisExp, win=win)
                    return
                # pause experiment here if requested
                if thisExp.status == PAUSED:
                    pauseExperiment(
                        thisExp=thisExp, 
                        win=win, 
                        timers=[routineTimer], 
                        playbackComponents=[]
                    )
                    # skip the frame we paused on
                    continue
                
                # check if all components have finished
                if not continueRoutine:  # a component has requested a forced-end of Routine
                    quiz2.forceEnded = routineForceEnded = True
                    break
                continueRoutine = False  # will revert to True if at least one component still running
                for thisComponent in quiz2.components:
                    if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:
                        continueRoutine = True
                        break  # at least one component has not yet finished
                
                # refresh the screen
                if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen
                    win.flip()
            
            # --- Ending Routine "quiz2" ---
            for thisComponent in quiz2.components:
                if hasattr(thisComponent, "setAutoDraw"):
                    thisComponent.setAutoDraw(False)
            # store stop times for quiz2
            quiz2.tStop = globalClock.getTime(format='float')
            quiz2.tStopRefresh = tThisFlipGlobal
            thisExp.addData('quiz2.stopped', quiz2.tStop)
            # check responses
            if answer_quiz1_2.keys in ['', [], None]:  # No response was made
                answer_quiz1_2.keys = None
                # was no response the correct answer?!
                if str(corr_ans).lower() == 'none':
                   answer_quiz1_2.corr = 1;  # correct non-response
                else:
                   answer_quiz1_2.corr = 0;  # failed to respond (incorrectly)
            # store data for quizloop2 (TrialHandler)
            quizloop2.addData('answer_quiz1_2.keys',answer_quiz1_2.keys)
            quizloop2.addData('answer_quiz1_2.corr', answer_quiz1_2.corr)
            if answer_quiz1_2.keys != None:  # we had a response
                quizloop2.addData('answer_quiz1_2.rt', answer_quiz1_2.rt)
                quizloop2.addData('answer_quiz1_2.duration', answer_quiz1_2.duration)
            # Run 'End Routine' code from code_45
            if answer_quiz1_2.corr:
                quiz2_score+=1
                msg="Correct! Good job!"
            else:
                msg="INCORRECT :("
            # the Routine "quiz2" was not non-slip safe, so reset the non-slip timer
            routineTimer.reset()
            
            # --- Prepare to start Routine "quiz_feedback" ---
            # create an object to store info about Routine quiz_feedback
            quiz_feedback = data.Routine(
                name='quiz_feedback',
                components=[result_q_instr],
            )
            quiz_feedback.status = NOT_STARTED
            continueRoutine = True
            # update component parameters for each repeat
            result_q_instr.setText(msg)
            # store start times for quiz_feedback
            quiz_feedback.tStartRefresh = win.getFutureFlipTime(clock=globalClock)
            quiz_feedback.tStart = globalClock.getTime(format='float')
            quiz_feedback.status = STARTED
            thisExp.addData('quiz_feedback.started', quiz_feedback.tStart)
            quiz_feedback.maxDuration = None
            # keep track of which components have finished
            quiz_feedbackComponents = quiz_feedback.components
            for thisComponent in quiz_feedback.components:
                thisComponent.tStart = None
                thisComponent.tStop = None
                thisComponent.tStartRefresh = None
                thisComponent.tStopRefresh = None
                if hasattr(thisComponent, 'status'):
                    thisComponent.status = NOT_STARTED
            # reset timers
            t = 0
            _timeToFirstFrame = win.getFutureFlipTime(clock="now")
            frameN = -1
            
            # --- Run Routine "quiz_feedback" ---
            # if trial has changed, end Routine now
            if isinstance(quizloop2, data.TrialHandler2) and thisQuizloop2.thisN != quizloop2.thisTrial.thisN:
                continueRoutine = False
            quiz_feedback.forceEnded = routineForceEnded = not continueRoutine
            while continueRoutine and routineTimer.getTime() < 1.25:
                # get current time
                t = routineTimer.getTime()
                tThisFlip = win.getFutureFlipTime(clock=routineTimer)
                tThisFlipGlobal = win.getFutureFlipTime(clock=None)
                frameN = frameN + 1  # number of completed frames (so 0 is the first frame)
                # update/draw components on each frame
                
                # *result_q_instr* updates
                
                # if result_q_instr is starting this frame...
                if result_q_instr.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
                    # keep track of start time/frame for later
                    result_q_instr.frameNStart = frameN  # exact frame index
                    result_q_instr.tStart = t  # local t and not account for scr refresh
                    result_q_instr.tStartRefresh = tThisFlipGlobal  # on global time
                    win.timeOnFlip(result_q_instr, 'tStartRefresh')  # time at next scr refresh
                    # add timestamp to datafile
                    thisExp.timestampOnFlip(win, 'result_q_instr.started')
                    # update status
                    result_q_instr.status = STARTED
                    result_q_instr.setAutoDraw(True)
                
                # if result_q_instr is active this frame...
                if result_q_instr.status == STARTED:
                    # update params
                    pass
                
                # if result_q_instr is stopping this frame...
                if result_q_instr.status == STARTED:
                    # is it time to stop? (based on global clock, using actual start)
                    if tThisFlipGlobal > result_q_instr.tStartRefresh + 1.25-frameTolerance:
                        # keep track of stop time/frame for later
                        result_q_instr.tStop = t  # not accounting for scr refresh
                        result_q_instr.tStopRefresh = tThisFlipGlobal  # on global time
                        result_q_instr.frameNStop = frameN  # exact frame index
                        # add timestamp to datafile
                        thisExp.timestampOnFlip(win, 'result_q_instr.stopped')
                        # update status
                        result_q_instr.status = FINISHED
                        result_q_instr.setAutoDraw(False)
                
                # check for quit (typically the Esc key)
                if defaultKeyboard.getKeys(keyList=["escape"]):
                    thisExp.status = FINISHED
                if thisExp.status == FINISHED or endExpNow:
                    endExperiment(thisExp, win=win)
                    return
                # pause experiment here if requested
                if thisExp.status == PAUSED:
                    pauseExperiment(
                        thisExp=thisExp, 
                        win=win, 
                        timers=[routineTimer], 
                        playbackComponents=[]
                    )
                    # skip the frame we paused on
                    continue
                
                # check if all components have finished
                if not continueRoutine:  # a component has requested a forced-end of Routine
                    quiz_feedback.forceEnded = routineForceEnded = True
                    break
                continueRoutine = False  # will revert to True if at least one component still running
                for thisComponent in quiz_feedback.components:
                    if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:
                        continueRoutine = True
                        break  # at least one component has not yet finished
                
                # refresh the screen
                if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen
                    win.flip()
            
            # --- Ending Routine "quiz_feedback" ---
            for thisComponent in quiz_feedback.components:
                if hasattr(thisComponent, "setAutoDraw"):
                    thisComponent.setAutoDraw(False)
            # store stop times for quiz_feedback
            quiz_feedback.tStop = globalClock.getTime(format='float')
            quiz_feedback.tStopRefresh = tThisFlipGlobal
            thisExp.addData('quiz_feedback.stopped', quiz_feedback.tStop)
            # using non-slip timing so subtract the expected duration of this Routine (unless ended on request)
            if quiz_feedback.maxDurationReached:
                routineTimer.addTime(-quiz_feedback.maxDuration)
            elif quiz_feedback.forceEnded:
                routineTimer.reset()
            else:
                routineTimer.addTime(-1.250000)
            thisExp.nextEntry()
            
        # completed 1.0 repeats of 'quizloop2'
        
        if thisSession is not None:
            # if running in a Session with a Liaison client, send data up to now
            thisSession.sendExperimentData()
        
        # --- Prepare to start Routine "planning_paths" ---
        # create an object to store info about Routine planning_paths
        planning_paths = data.Routine(
            name='planning_paths',
            components=[text_149, key_resp_40, text_49],
        )
        planning_paths.status = NOT_STARTED
        continueRoutine = True
        # update component parameters for each repeat
        # Run 'Begin Routine' code from code_42
        quiz1_count=1
        quiz_planning_corr=0
        
        # create starting attributes for key_resp_40
        key_resp_40.keys = []
        key_resp_40.rt = []
        _key_resp_40_allKeys = []
        # store start times for planning_paths
        planning_paths.tStartRefresh = win.getFutureFlipTime(clock=globalClock)
        planning_paths.tStart = globalClock.getTime(format='float')
        planning_paths.status = STARTED
        thisExp.addData('planning_paths.started', planning_paths.tStart)
        planning_paths.maxDuration = None
        # keep track of which components have finished
        planning_pathsComponents = planning_paths.components
        for thisComponent in planning_paths.components:
            thisComponent.tStart = None
            thisComponent.tStop = None
            thisComponent.tStartRefresh = None
            thisComponent.tStopRefresh = None
            if hasattr(thisComponent, 'status'):
                thisComponent.status = NOT_STARTED
        # reset timers
        t = 0
        _timeToFirstFrame = win.getFutureFlipTime(clock="now")
        frameN = -1
        
        # --- Run Routine "planning_paths" ---
        # if trial has changed, end Routine now
        if isinstance(learning_phase, data.TrialHandler2) and thisLearning_phase.thisN != learning_phase.thisTrial.thisN:
            continueRoutine = False
        planning_paths.forceEnded = routineForceEnded = not continueRoutine
        while continueRoutine:
            # get current time
            t = routineTimer.getTime()
            tThisFlip = win.getFutureFlipTime(clock=routineTimer)
            tThisFlipGlobal = win.getFutureFlipTime(clock=None)
            frameN = frameN + 1  # number of completed frames (so 0 is the first frame)
            # update/draw components on each frame
            
            # *text_149* updates
            
            # if text_149 is starting this frame...
            if text_149.status == NOT_STARTED and tThisFlip >= 0-frameTolerance:
                # keep track of start time/frame for later
                text_149.frameNStart = frameN  # exact frame index
                text_149.tStart = t  # local t and not account for scr refresh
                text_149.tStartRefresh = tThisFlipGlobal  # on global time
                win.timeOnFlip(text_149, 'tStartRefresh')  # time at next scr refresh
                # add timestamp to datafile
                thisExp.timestampOnFlip(win, 'text_149.started')
                # update status
                text_149.status = STARTED
                text_149.setAutoDraw(True)
            
            # if text_149 is active this frame...
            if text_149.status == STARTED:
                # update params
                pass
            
            # *key_resp_40* updates
            waitOnFlip = False
            
            # if key_resp_40 is starting this frame...
            if key_resp_40.status == NOT_STARTED and tThisFlip >= 5.0-frameTolerance:
                # keep track of start time/frame for later
                key_resp_40.frameNStart = frameN  # exact frame index
                key_resp_40.tStart = t  # local t and not account for scr refresh
                key_resp_40.tStartRefresh = tThisFlipGlobal  # on global time
                win.timeOnFlip(key_resp_40, 'tStartRefresh')  # time at next scr refresh
                # add timestamp to datafile
                thisExp.timestampOnFlip(win, 'key_resp_40.started')
                # update status
                key_resp_40.status = STARTED
                # keyboard checking is just starting
                waitOnFlip = True
                win.callOnFlip(key_resp_40.clock.reset)  # t=0 on next screen flip
                win.callOnFlip(key_resp_40.clearEvents, eventType='keyboard')  # clear events on next screen flip
            if key_resp_40.status == STARTED and not waitOnFlip:
                theseKeys = key_resp_40.getKeys(keyList=['space'], ignoreKeys=["escape"], waitRelease=False)
                _key_resp_40_allKeys.extend(theseKeys)
                if len(_key_resp_40_allKeys):
                    key_resp_40.keys = _key_resp_40_allKeys[-1].name  # just the last key pressed
                    key_resp_40.rt = _key_resp_40_allKeys[-1].rt
                    key_resp_40.duration = _key_resp_40_allKeys[-1].duration
                    # a response ends the routine
                    continueRoutine = False
            
            # *text_49* updates
            
            # if text_49 is starting this frame...
            if text_49.status == NOT_STARTED and tThisFlip >= 5.0-frameTolerance:
                # keep track of start time/frame for later
                text_49.frameNStart = frameN  # exact frame index
                text_49.tStart = t  # local t and not account for scr refresh
                text_49.tStartRefresh = tThisFlipGlobal  # on global time
                win.timeOnFlip(text_49, 'tStartRefresh')  # time at next scr refresh
                # add timestamp to datafile
                thisExp.timestampOnFlip(win, 'text_49.started')
                # update status
                text_49.status = STARTED
                text_49.setAutoDraw(True)
            
            # if text_49 is active this frame...
            if text_49.status == STARTED:
                # update params
                pass
            
            # check for quit (typically the Esc key)
            if defaultKeyboard.getKeys(keyList=["escape"]):
                thisExp.status = FINISHED
            if thisExp.status == FINISHED or endExpNow:
                endExperiment(thisExp, win=win)
                return
            # pause experiment here if requested
            if thisExp.status == PAUSED:
                pauseExperiment(
                    thisExp=thisExp, 
                    win=win, 
                    timers=[routineTimer], 
                    playbackComponents=[]
                )
                # skip the frame we paused on
                continue
            
            # check if all components have finished
            if not continueRoutine:  # a component has requested a forced-end of Routine
                planning_paths.forceEnded = routineForceEnded = True
                break
            continueRoutine = False  # will revert to True if at least one component still running
            for thisComponent in planning_paths.components:
                if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:
                    continueRoutine = True
                    break  # at least one component has not yet finished
            
            # refresh the screen
            if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen
                win.flip()
        
        # --- Ending Routine "planning_paths" ---
        for thisComponent in planning_paths.components:
            if hasattr(thisComponent, "setAutoDraw"):
                thisComponent.setAutoDraw(False)
        # store stop times for planning_paths
        planning_paths.tStop = globalClock.getTime(format='float')
        planning_paths.tStopRefresh = tThisFlipGlobal
        thisExp.addData('planning_paths.stopped', planning_paths.tStop)
        # check responses
        if key_resp_40.keys in ['', [], None]:  # No response was made
            key_resp_40.keys = None
        learning_phase.addData('key_resp_40.keys',key_resp_40.keys)
        if key_resp_40.keys != None:  # we had a response
            learning_phase.addData('key_resp_40.rt', key_resp_40.rt)
            learning_phase.addData('key_resp_40.duration', key_resp_40.duration)
        # the Routine "planning_paths" was not non-slip safe, so reset the non-slip timer
        routineTimer.reset()
        
        # set up handler to look after randomisation of conditions etc
        planning_during_training = data.TrialHandler2(
            name='planning_during_training',
            nReps=1.0, 
            method='random', 
            extraInfo=expInfo, 
            originPath=-1, 
            trialList=data.importConditions('forgetting1.xlsx'), 
            seed=None, 
        )
        thisExp.addLoop(planning_during_training)  # add the loop to the experiment
        thisPlanning_during_training = planning_during_training.trialList[0]  # so we can initialise stimuli with some values
        # abbreviate parameter names if possible (e.g. rgb = thisPlanning_during_training.rgb)
        if thisPlanning_during_training != None:
            for paramName in thisPlanning_during_training:
                globals()[paramName] = thisPlanning_during_training[paramName]
        if thisSession is not None:
            # if running in a Session with a Liaison client, send data up to now
            thisSession.sendExperimentData()
        
        for thisPlanning_during_training in planning_during_training:
            currentLoop = planning_during_training
            thisExp.timestampOnFlip(win, 'thisRow.t', format=globalClock.format)
            if thisSession is not None:
                # if running in a Session with a Liaison client, send data up to now
                thisSession.sendExperimentData()
            # abbreviate parameter names if possible (e.g. rgb = thisPlanning_during_training.rgb)
            if thisPlanning_during_training != None:
                for paramName in thisPlanning_during_training:
                    globals()[paramName] = thisPlanning_during_training[paramName]
            
            # --- Prepare to start Routine "forgetting_paths1" ---
            # create an object to store info about Routine forgetting_paths1
            forgetting_paths1 = data.Routine(
                name='forgetting_paths1',
                components=[question_quiz1_3, answer_quiz1_3, answer1_3, answer2_3, answer3_3, a1_3, a2_3, text_146],
            )
            forgetting_paths1.status = NOT_STARTED
            continueRoutine = True
            # update component parameters for each repeat
            # create starting attributes for answer_quiz1_3
            answer_quiz1_3.keys = []
            answer_quiz1_3.rt = []
            _answer_quiz1_3_allKeys = []
            answer1_3.setImage(ans1)
            answer2_3.setImage(ans2)
            answer3_3.setImage(ans3)
            # store start times for forgetting_paths1
            forgetting_paths1.tStartRefresh = win.getFutureFlipTime(clock=globalClock)
            forgetting_paths1.tStart = globalClock.getTime(format='float')
            forgetting_paths1.status = STARTED
            thisExp.addData('forgetting_paths1.started', forgetting_paths1.tStart)
            forgetting_paths1.maxDuration = None
            # keep track of which components have finished
            forgetting_paths1Components = forgetting_paths1.components
            for thisComponent in forgetting_paths1.components:
                thisComponent.tStart = None
                thisComponent.tStop = None
                thisComponent.tStartRefresh = None
                thisComponent.tStopRefresh = None
                if hasattr(thisComponent, 'status'):
                    thisComponent.status = NOT_STARTED
            # reset timers
            t = 0
            _timeToFirstFrame = win.getFutureFlipTime(clock="now")
            frameN = -1
            
            # --- Run Routine "forgetting_paths1" ---
            # if trial has changed, end Routine now
            if isinstance(planning_during_training, data.TrialHandler2) and thisPlanning_during_training.thisN != planning_during_training.thisTrial.thisN:
                continueRoutine = False
            forgetting_paths1.forceEnded = routineForceEnded = not continueRoutine
            while continueRoutine and routineTimer.getTime() < 120.0:
                # get current time
                t = routineTimer.getTime()
                tThisFlip = win.getFutureFlipTime(clock=routineTimer)
                tThisFlipGlobal = win.getFutureFlipTime(clock=None)
                frameN = frameN + 1  # number of completed frames (so 0 is the first frame)
                # update/draw components on each frame
                
                # *question_quiz1_3* updates
                
                # if question_quiz1_3 is starting this frame...
                if question_quiz1_3.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
                    # keep track of start time/frame for later
                    question_quiz1_3.frameNStart = frameN  # exact frame index
                    question_quiz1_3.tStart = t  # local t and not account for scr refresh
                    question_quiz1_3.tStartRefresh = tThisFlipGlobal  # on global time
                    win.timeOnFlip(question_quiz1_3, 'tStartRefresh')  # time at next scr refresh
                    # add timestamp to datafile
                    thisExp.timestampOnFlip(win, 'question_quiz1_3.started')
                    # update status
                    question_quiz1_3.status = STARTED
                    question_quiz1_3.setAutoDraw(True)
                
                # if question_quiz1_3 is active this frame...
                if question_quiz1_3.status == STARTED:
                    # update params
                    pass
                
                # if question_quiz1_3 is stopping this frame...
                if question_quiz1_3.status == STARTED:
                    # is it time to stop? (based on global clock, using actual start)
                    if tThisFlipGlobal > question_quiz1_3.tStartRefresh + 120-frameTolerance:
                        # keep track of stop time/frame for later
                        question_quiz1_3.tStop = t  # not accounting for scr refresh
                        question_quiz1_3.tStopRefresh = tThisFlipGlobal  # on global time
                        question_quiz1_3.frameNStop = frameN  # exact frame index
                        # add timestamp to datafile
                        thisExp.timestampOnFlip(win, 'question_quiz1_3.stopped')
                        # update status
                        question_quiz1_3.status = FINISHED
                        question_quiz1_3.setAutoDraw(False)
                
                # *answer_quiz1_3* updates
                waitOnFlip = False
                
                # if answer_quiz1_3 is starting this frame...
                if answer_quiz1_3.status == NOT_STARTED and tThisFlip >= 0-frameTolerance:
                    # keep track of start time/frame for later
                    answer_quiz1_3.frameNStart = frameN  # exact frame index
                    answer_quiz1_3.tStart = t  # local t and not account for scr refresh
                    answer_quiz1_3.tStartRefresh = tThisFlipGlobal  # on global time
                    win.timeOnFlip(answer_quiz1_3, 'tStartRefresh')  # time at next scr refresh
                    # add timestamp to datafile
                    thisExp.timestampOnFlip(win, 'answer_quiz1_3.started')
                    # update status
                    answer_quiz1_3.status = STARTED
                    # keyboard checking is just starting
                    waitOnFlip = True
                    win.callOnFlip(answer_quiz1_3.clock.reset)  # t=0 on next screen flip
                    win.callOnFlip(answer_quiz1_3.clearEvents, eventType='keyboard')  # clear events on next screen flip
                
                # if answer_quiz1_3 is stopping this frame...
                if answer_quiz1_3.status == STARTED:
                    # is it time to stop? (based on global clock, using actual start)
                    if tThisFlipGlobal > answer_quiz1_3.tStartRefresh + 120-frameTolerance:
                        # keep track of stop time/frame for later
                        answer_quiz1_3.tStop = t  # not accounting for scr refresh
                        answer_quiz1_3.tStopRefresh = tThisFlipGlobal  # on global time
                        answer_quiz1_3.frameNStop = frameN  # exact frame index
                        # add timestamp to datafile
                        thisExp.timestampOnFlip(win, 'answer_quiz1_3.stopped')
                        # update status
                        answer_quiz1_3.status = FINISHED
                        answer_quiz1_3.status = FINISHED
                if answer_quiz1_3.status == STARTED and not waitOnFlip:
                    theseKeys = answer_quiz1_3.getKeys(keyList=["left","right"], ignoreKeys=["escape"], waitRelease=False)
                    _answer_quiz1_3_allKeys.extend(theseKeys)
                    if len(_answer_quiz1_3_allKeys):
                        answer_quiz1_3.keys = _answer_quiz1_3_allKeys[0].name  # just the first key pressed
                        answer_quiz1_3.rt = _answer_quiz1_3_allKeys[0].rt
                        answer_quiz1_3.duration = _answer_quiz1_3_allKeys[0].duration
                        # was this correct?
                        if (answer_quiz1_3.keys == str(correct_answer1)) or (answer_quiz1_3.keys == correct_answer1):
                            answer_quiz1_3.corr = 1
                        else:
                            answer_quiz1_3.corr = 0
                        # a response ends the routine
                        continueRoutine = False
                
                # *answer1_3* updates
                
                # if answer1_3 is starting this frame...
                if answer1_3.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
                    # keep track of start time/frame for later
                    answer1_3.frameNStart = frameN  # exact frame index
                    answer1_3.tStart = t  # local t and not account for scr refresh
                    answer1_3.tStartRefresh = tThisFlipGlobal  # on global time
                    win.timeOnFlip(answer1_3, 'tStartRefresh')  # time at next scr refresh
                    # add timestamp to datafile
                    thisExp.timestampOnFlip(win, 'answer1_3.started')
                    # update status
                    answer1_3.status = STARTED
                    answer1_3.setAutoDraw(True)
                
                # if answer1_3 is active this frame...
                if answer1_3.status == STARTED:
                    # update params
                    pass
                
                # if answer1_3 is stopping this frame...
                if answer1_3.status == STARTED:
                    # is it time to stop? (based on global clock, using actual start)
                    if tThisFlipGlobal > answer1_3.tStartRefresh + 120-frameTolerance:
                        # keep track of stop time/frame for later
                        answer1_3.tStop = t  # not accounting for scr refresh
                        answer1_3.tStopRefresh = tThisFlipGlobal  # on global time
                        answer1_3.frameNStop = frameN  # exact frame index
                        # add timestamp to datafile
                        thisExp.timestampOnFlip(win, 'answer1_3.stopped')
                        # update status
                        answer1_3.status = FINISHED
                        answer1_3.setAutoDraw(False)
                
                # *answer2_3* updates
                
                # if answer2_3 is starting this frame...
                if answer2_3.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
                    # keep track of start time/frame for later
                    answer2_3.frameNStart = frameN  # exact frame index
                    answer2_3.tStart = t  # local t and not account for scr refresh
                    answer2_3.tStartRefresh = tThisFlipGlobal  # on global time
                    win.timeOnFlip(answer2_3, 'tStartRefresh')  # time at next scr refresh
                    # add timestamp to datafile
                    thisExp.timestampOnFlip(win, 'answer2_3.started')
                    # update status
                    answer2_3.status = STARTED
                    answer2_3.setAutoDraw(True)
                
                # if answer2_3 is active this frame...
                if answer2_3.status == STARTED:
                    # update params
                    pass
                
                # if answer2_3 is stopping this frame...
                if answer2_3.status == STARTED:
                    # is it time to stop? (based on global clock, using actual start)
                    if tThisFlipGlobal > answer2_3.tStartRefresh + 120-frameTolerance:
                        # keep track of stop time/frame for later
                        answer2_3.tStop = t  # not accounting for scr refresh
                        answer2_3.tStopRefresh = tThisFlipGlobal  # on global time
                        answer2_3.frameNStop = frameN  # exact frame index
                        # add timestamp to datafile
                        thisExp.timestampOnFlip(win, 'answer2_3.stopped')
                        # update status
                        answer2_3.status = FINISHED
                        answer2_3.setAutoDraw(False)
                
                # *answer3_3* updates
                
                # if answer3_3 is starting this frame...
                if answer3_3.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
                    # keep track of start time/frame for later
                    answer3_3.frameNStart = frameN  # exact frame index
                    answer3_3.tStart = t  # local t and not account for scr refresh
                    answer3_3.tStartRefresh = tThisFlipGlobal  # on global time
                    win.timeOnFlip(answer3_3, 'tStartRefresh')  # time at next scr refresh
                    # add timestamp to datafile
                    thisExp.timestampOnFlip(win, 'answer3_3.started')
                    # update status
                    answer3_3.status = STARTED
                    answer3_3.setAutoDraw(True)
                
                # if answer3_3 is active this frame...
                if answer3_3.status == STARTED:
                    # update params
                    pass
                
                # if answer3_3 is stopping this frame...
                if answer3_3.status == STARTED:
                    # is it time to stop? (based on global clock, using actual start)
                    if tThisFlipGlobal > answer3_3.tStartRefresh + 120-frameTolerance:
                        # keep track of stop time/frame for later
                        answer3_3.tStop = t  # not accounting for scr refresh
                        answer3_3.tStopRefresh = tThisFlipGlobal  # on global time
                        answer3_3.frameNStop = frameN  # exact frame index
                        # add timestamp to datafile
                        thisExp.timestampOnFlip(win, 'answer3_3.stopped')
                        # update status
                        answer3_3.status = FINISHED
                        answer3_3.setAutoDraw(False)
                
                # *a1_3* updates
                
                # if a1_3 is starting this frame...
                if a1_3.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
                    # keep track of start time/frame for later
                    a1_3.frameNStart = frameN  # exact frame index
                    a1_3.tStart = t  # local t and not account for scr refresh
                    a1_3.tStartRefresh = tThisFlipGlobal  # on global time
                    win.timeOnFlip(a1_3, 'tStartRefresh')  # time at next scr refresh
                    # add timestamp to datafile
                    thisExp.timestampOnFlip(win, 'a1_3.started')
                    # update status
                    a1_3.status = STARTED
                    a1_3.setAutoDraw(True)
                
                # if a1_3 is active this frame...
                if a1_3.status == STARTED:
                    # update params
                    pass
                
                # if a1_3 is stopping this frame...
                if a1_3.status == STARTED:
                    # is it time to stop? (based on global clock, using actual start)
                    if tThisFlipGlobal > a1_3.tStartRefresh + 120-frameTolerance:
                        # keep track of stop time/frame for later
                        a1_3.tStop = t  # not accounting for scr refresh
                        a1_3.tStopRefresh = tThisFlipGlobal  # on global time
                        a1_3.frameNStop = frameN  # exact frame index
                        # add timestamp to datafile
                        thisExp.timestampOnFlip(win, 'a1_3.stopped')
                        # update status
                        a1_3.status = FINISHED
                        a1_3.setAutoDraw(False)
                
                # *a2_3* updates
                
                # if a2_3 is starting this frame...
                if a2_3.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
                    # keep track of start time/frame for later
                    a2_3.frameNStart = frameN  # exact frame index
                    a2_3.tStart = t  # local t and not account for scr refresh
                    a2_3.tStartRefresh = tThisFlipGlobal  # on global time
                    win.timeOnFlip(a2_3, 'tStartRefresh')  # time at next scr refresh
                    # add timestamp to datafile
                    thisExp.timestampOnFlip(win, 'a2_3.started')
                    # update status
                    a2_3.status = STARTED
                    a2_3.setAutoDraw(True)
                
                # if a2_3 is active this frame...
                if a2_3.status == STARTED:
                    # update params
                    pass
                
                # if a2_3 is stopping this frame...
                if a2_3.status == STARTED:
                    # is it time to stop? (based on global clock, using actual start)
                    if tThisFlipGlobal > a2_3.tStartRefresh + 120-frameTolerance:
                        # keep track of stop time/frame for later
                        a2_3.tStop = t  # not accounting for scr refresh
                        a2_3.tStopRefresh = tThisFlipGlobal  # on global time
                        a2_3.frameNStop = frameN  # exact frame index
                        # add timestamp to datafile
                        thisExp.timestampOnFlip(win, 'a2_3.stopped')
                        # update status
                        a2_3.status = FINISHED
                        a2_3.setAutoDraw(False)
                
                # *text_146* updates
                
                # if text_146 is starting this frame...
                if text_146.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
                    # keep track of start time/frame for later
                    text_146.frameNStart = frameN  # exact frame index
                    text_146.tStart = t  # local t and not account for scr refresh
                    text_146.tStartRefresh = tThisFlipGlobal  # on global time
                    win.timeOnFlip(text_146, 'tStartRefresh')  # time at next scr refresh
                    # add timestamp to datafile
                    thisExp.timestampOnFlip(win, 'text_146.started')
                    # update status
                    text_146.status = STARTED
                    text_146.setAutoDraw(True)
                
                # if text_146 is active this frame...
                if text_146.status == STARTED:
                    # update params
                    pass
                
                # if text_146 is stopping this frame...
                if text_146.status == STARTED:
                    # is it time to stop? (based on global clock, using actual start)
                    if tThisFlipGlobal > text_146.tStartRefresh + 120.0-frameTolerance:
                        # keep track of stop time/frame for later
                        text_146.tStop = t  # not accounting for scr refresh
                        text_146.tStopRefresh = tThisFlipGlobal  # on global time
                        text_146.frameNStop = frameN  # exact frame index
                        # add timestamp to datafile
                        thisExp.timestampOnFlip(win, 'text_146.stopped')
                        # update status
                        text_146.status = FINISHED
                        text_146.setAutoDraw(False)
                
                # check for quit (typically the Esc key)
                if defaultKeyboard.getKeys(keyList=["escape"]):
                    thisExp.status = FINISHED
                if thisExp.status == FINISHED or endExpNow:
                    endExperiment(thisExp, win=win)
                    return
                # pause experiment here if requested
                if thisExp.status == PAUSED:
                    pauseExperiment(
                        thisExp=thisExp, 
                        win=win, 
                        timers=[routineTimer], 
                        playbackComponents=[]
                    )
                    # skip the frame we paused on
                    continue
                
                # check if all components have finished
                if not continueRoutine:  # a component has requested a forced-end of Routine
                    forgetting_paths1.forceEnded = routineForceEnded = True
                    break
                continueRoutine = False  # will revert to True if at least one component still running
                for thisComponent in forgetting_paths1.components:
                    if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:
                        continueRoutine = True
                        break  # at least one component has not yet finished
                
                # refresh the screen
                if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen
                    win.flip()
            
            # --- Ending Routine "forgetting_paths1" ---
            for thisComponent in forgetting_paths1.components:
                if hasattr(thisComponent, "setAutoDraw"):
                    thisComponent.setAutoDraw(False)
            # store stop times for forgetting_paths1
            forgetting_paths1.tStop = globalClock.getTime(format='float')
            forgetting_paths1.tStopRefresh = tThisFlipGlobal
            thisExp.addData('forgetting_paths1.stopped', forgetting_paths1.tStop)
            # check responses
            if answer_quiz1_3.keys in ['', [], None]:  # No response was made
                answer_quiz1_3.keys = None
                # was no response the correct answer?!
                if str(correct_answer1).lower() == 'none':
                   answer_quiz1_3.corr = 1;  # correct non-response
                else:
                   answer_quiz1_3.corr = 0;  # failed to respond (incorrectly)
            # store data for planning_during_training (TrialHandler)
            planning_during_training.addData('answer_quiz1_3.keys',answer_quiz1_3.keys)
            planning_during_training.addData('answer_quiz1_3.corr', answer_quiz1_3.corr)
            if answer_quiz1_3.keys != None:  # we had a response
                planning_during_training.addData('answer_quiz1_3.rt', answer_quiz1_3.rt)
                planning_during_training.addData('answer_quiz1_3.duration', answer_quiz1_3.duration)
            # using non-slip timing so subtract the expected duration of this Routine (unless ended on request)
            if forgetting_paths1.maxDurationReached:
                routineTimer.addTime(-forgetting_paths1.maxDuration)
            elif forgetting_paths1.forceEnded:
                routineTimer.reset()
            else:
                routineTimer.addTime(-120.000000)
            
            # --- Prepare to start Routine "planningpathstraining2" ---
            # create an object to store info about Routine planningpathstraining2
            planningpathstraining2 = data.Routine(
                name='planningpathstraining2',
                components=[question_quiz1_5, answer_quiz1_5, answer1_5, answer2_5, answer3_5, a1_5, a2_5, text_152],
            )
            planningpathstraining2.status = NOT_STARTED
            continueRoutine = True
            # update component parameters for each repeat
            # create starting attributes for answer_quiz1_5
            answer_quiz1_5.keys = []
            answer_quiz1_5.rt = []
            _answer_quiz1_5_allKeys = []
            answer1_5.setImage(ans1)
            answer2_5.setImage(ans2)
            answer3_5.setImage(ans3)
            # store start times for planningpathstraining2
            planningpathstraining2.tStartRefresh = win.getFutureFlipTime(clock=globalClock)
            planningpathstraining2.tStart = globalClock.getTime(format='float')
            planningpathstraining2.status = STARTED
            thisExp.addData('planningpathstraining2.started', planningpathstraining2.tStart)
            planningpathstraining2.maxDuration = None
            # keep track of which components have finished
            planningpathstraining2Components = planningpathstraining2.components
            for thisComponent in planningpathstraining2.components:
                thisComponent.tStart = None
                thisComponent.tStop = None
                thisComponent.tStartRefresh = None
                thisComponent.tStopRefresh = None
                if hasattr(thisComponent, 'status'):
                    thisComponent.status = NOT_STARTED
            # reset timers
            t = 0
            _timeToFirstFrame = win.getFutureFlipTime(clock="now")
            frameN = -1
            
            # --- Run Routine "planningpathstraining2" ---
            # if trial has changed, end Routine now
            if isinstance(planning_during_training, data.TrialHandler2) and thisPlanning_during_training.thisN != planning_during_training.thisTrial.thisN:
                continueRoutine = False
            planningpathstraining2.forceEnded = routineForceEnded = not continueRoutine
            while continueRoutine and routineTimer.getTime() < 120.0:
                # get current time
                t = routineTimer.getTime()
                tThisFlip = win.getFutureFlipTime(clock=routineTimer)
                tThisFlipGlobal = win.getFutureFlipTime(clock=None)
                frameN = frameN + 1  # number of completed frames (so 0 is the first frame)
                # update/draw components on each frame
                
                # *question_quiz1_5* updates
                
                # if question_quiz1_5 is starting this frame...
                if question_quiz1_5.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
                    # keep track of start time/frame for later
                    question_quiz1_5.frameNStart = frameN  # exact frame index
                    question_quiz1_5.tStart = t  # local t and not account for scr refresh
                    question_quiz1_5.tStartRefresh = tThisFlipGlobal  # on global time
                    win.timeOnFlip(question_quiz1_5, 'tStartRefresh')  # time at next scr refresh
                    # add timestamp to datafile
                    thisExp.timestampOnFlip(win, 'question_quiz1_5.started')
                    # update status
                    question_quiz1_5.status = STARTED
                    question_quiz1_5.setAutoDraw(True)
                
                # if question_quiz1_5 is active this frame...
                if question_quiz1_5.status == STARTED:
                    # update params
                    pass
                
                # if question_quiz1_5 is stopping this frame...
                if question_quiz1_5.status == STARTED:
                    # is it time to stop? (based on global clock, using actual start)
                    if tThisFlipGlobal > question_quiz1_5.tStartRefresh + 120-frameTolerance:
                        # keep track of stop time/frame for later
                        question_quiz1_5.tStop = t  # not accounting for scr refresh
                        question_quiz1_5.tStopRefresh = tThisFlipGlobal  # on global time
                        question_quiz1_5.frameNStop = frameN  # exact frame index
                        # add timestamp to datafile
                        thisExp.timestampOnFlip(win, 'question_quiz1_5.stopped')
                        # update status
                        question_quiz1_5.status = FINISHED
                        question_quiz1_5.setAutoDraw(False)
                
                # *answer_quiz1_5* updates
                waitOnFlip = False
                
                # if answer_quiz1_5 is starting this frame...
                if answer_quiz1_5.status == NOT_STARTED and tThisFlip >= 0-frameTolerance:
                    # keep track of start time/frame for later
                    answer_quiz1_5.frameNStart = frameN  # exact frame index
                    answer_quiz1_5.tStart = t  # local t and not account for scr refresh
                    answer_quiz1_5.tStartRefresh = tThisFlipGlobal  # on global time
                    win.timeOnFlip(answer_quiz1_5, 'tStartRefresh')  # time at next scr refresh
                    # add timestamp to datafile
                    thisExp.timestampOnFlip(win, 'answer_quiz1_5.started')
                    # update status
                    answer_quiz1_5.status = STARTED
                    # keyboard checking is just starting
                    waitOnFlip = True
                    win.callOnFlip(answer_quiz1_5.clock.reset)  # t=0 on next screen flip
                    win.callOnFlip(answer_quiz1_5.clearEvents, eventType='keyboard')  # clear events on next screen flip
                
                # if answer_quiz1_5 is stopping this frame...
                if answer_quiz1_5.status == STARTED:
                    # is it time to stop? (based on global clock, using actual start)
                    if tThisFlipGlobal > answer_quiz1_5.tStartRefresh + 120-frameTolerance:
                        # keep track of stop time/frame for later
                        answer_quiz1_5.tStop = t  # not accounting for scr refresh
                        answer_quiz1_5.tStopRefresh = tThisFlipGlobal  # on global time
                        answer_quiz1_5.frameNStop = frameN  # exact frame index
                        # add timestamp to datafile
                        thisExp.timestampOnFlip(win, 'answer_quiz1_5.stopped')
                        # update status
                        answer_quiz1_5.status = FINISHED
                        answer_quiz1_5.status = FINISHED
                if answer_quiz1_5.status == STARTED and not waitOnFlip:
                    theseKeys = answer_quiz1_5.getKeys(keyList=["left","right"], ignoreKeys=["escape"], waitRelease=False)
                    _answer_quiz1_5_allKeys.extend(theseKeys)
                    if len(_answer_quiz1_5_allKeys):
                        answer_quiz1_5.keys = _answer_quiz1_5_allKeys[0].name  # just the first key pressed
                        answer_quiz1_5.rt = _answer_quiz1_5_allKeys[0].rt
                        answer_quiz1_5.duration = _answer_quiz1_5_allKeys[0].duration
                        # was this correct?
                        if (answer_quiz1_5.keys == str(correct_answer2)) or (answer_quiz1_5.keys == correct_answer2):
                            answer_quiz1_5.corr = 1
                        else:
                            answer_quiz1_5.corr = 0
                        # a response ends the routine
                        continueRoutine = False
                
                # *answer1_5* updates
                
                # if answer1_5 is starting this frame...
                if answer1_5.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
                    # keep track of start time/frame for later
                    answer1_5.frameNStart = frameN  # exact frame index
                    answer1_5.tStart = t  # local t and not account for scr refresh
                    answer1_5.tStartRefresh = tThisFlipGlobal  # on global time
                    win.timeOnFlip(answer1_5, 'tStartRefresh')  # time at next scr refresh
                    # add timestamp to datafile
                    thisExp.timestampOnFlip(win, 'answer1_5.started')
                    # update status
                    answer1_5.status = STARTED
                    answer1_5.setAutoDraw(True)
                
                # if answer1_5 is active this frame...
                if answer1_5.status == STARTED:
                    # update params
                    pass
                
                # if answer1_5 is stopping this frame...
                if answer1_5.status == STARTED:
                    # is it time to stop? (based on global clock, using actual start)
                    if tThisFlipGlobal > answer1_5.tStartRefresh + 120-frameTolerance:
                        # keep track of stop time/frame for later
                        answer1_5.tStop = t  # not accounting for scr refresh
                        answer1_5.tStopRefresh = tThisFlipGlobal  # on global time
                        answer1_5.frameNStop = frameN  # exact frame index
                        # add timestamp to datafile
                        thisExp.timestampOnFlip(win, 'answer1_5.stopped')
                        # update status
                        answer1_5.status = FINISHED
                        answer1_5.setAutoDraw(False)
                
                # *answer2_5* updates
                
                # if answer2_5 is starting this frame...
                if answer2_5.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
                    # keep track of start time/frame for later
                    answer2_5.frameNStart = frameN  # exact frame index
                    answer2_5.tStart = t  # local t and not account for scr refresh
                    answer2_5.tStartRefresh = tThisFlipGlobal  # on global time
                    win.timeOnFlip(answer2_5, 'tStartRefresh')  # time at next scr refresh
                    # add timestamp to datafile
                    thisExp.timestampOnFlip(win, 'answer2_5.started')
                    # update status
                    answer2_5.status = STARTED
                    answer2_5.setAutoDraw(True)
                
                # if answer2_5 is active this frame...
                if answer2_5.status == STARTED:
                    # update params
                    pass
                
                # if answer2_5 is stopping this frame...
                if answer2_5.status == STARTED:
                    # is it time to stop? (based on global clock, using actual start)
                    if tThisFlipGlobal > answer2_5.tStartRefresh + 120-frameTolerance:
                        # keep track of stop time/frame for later
                        answer2_5.tStop = t  # not accounting for scr refresh
                        answer2_5.tStopRefresh = tThisFlipGlobal  # on global time
                        answer2_5.frameNStop = frameN  # exact frame index
                        # add timestamp to datafile
                        thisExp.timestampOnFlip(win, 'answer2_5.stopped')
                        # update status
                        answer2_5.status = FINISHED
                        answer2_5.setAutoDraw(False)
                
                # *answer3_5* updates
                
                # if answer3_5 is starting this frame...
                if answer3_5.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
                    # keep track of start time/frame for later
                    answer3_5.frameNStart = frameN  # exact frame index
                    answer3_5.tStart = t  # local t and not account for scr refresh
                    answer3_5.tStartRefresh = tThisFlipGlobal  # on global time
                    win.timeOnFlip(answer3_5, 'tStartRefresh')  # time at next scr refresh
                    # add timestamp to datafile
                    thisExp.timestampOnFlip(win, 'answer3_5.started')
                    # update status
                    answer3_5.status = STARTED
                    answer3_5.setAutoDraw(True)
                
                # if answer3_5 is active this frame...
                if answer3_5.status == STARTED:
                    # update params
                    pass
                
                # if answer3_5 is stopping this frame...
                if answer3_5.status == STARTED:
                    # is it time to stop? (based on global clock, using actual start)
                    if tThisFlipGlobal > answer3_5.tStartRefresh + 120-frameTolerance:
                        # keep track of stop time/frame for later
                        answer3_5.tStop = t  # not accounting for scr refresh
                        answer3_5.tStopRefresh = tThisFlipGlobal  # on global time
                        answer3_5.frameNStop = frameN  # exact frame index
                        # add timestamp to datafile
                        thisExp.timestampOnFlip(win, 'answer3_5.stopped')
                        # update status
                        answer3_5.status = FINISHED
                        answer3_5.setAutoDraw(False)
                
                # *a1_5* updates
                
                # if a1_5 is starting this frame...
                if a1_5.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
                    # keep track of start time/frame for later
                    a1_5.frameNStart = frameN  # exact frame index
                    a1_5.tStart = t  # local t and not account for scr refresh
                    a1_5.tStartRefresh = tThisFlipGlobal  # on global time
                    win.timeOnFlip(a1_5, 'tStartRefresh')  # time at next scr refresh
                    # add timestamp to datafile
                    thisExp.timestampOnFlip(win, 'a1_5.started')
                    # update status
                    a1_5.status = STARTED
                    a1_5.setAutoDraw(True)
                
                # if a1_5 is active this frame...
                if a1_5.status == STARTED:
                    # update params
                    pass
                
                # if a1_5 is stopping this frame...
                if a1_5.status == STARTED:
                    # is it time to stop? (based on global clock, using actual start)
                    if tThisFlipGlobal > a1_5.tStartRefresh + 120-frameTolerance:
                        # keep track of stop time/frame for later
                        a1_5.tStop = t  # not accounting for scr refresh
                        a1_5.tStopRefresh = tThisFlipGlobal  # on global time
                        a1_5.frameNStop = frameN  # exact frame index
                        # add timestamp to datafile
                        thisExp.timestampOnFlip(win, 'a1_5.stopped')
                        # update status
                        a1_5.status = FINISHED
                        a1_5.setAutoDraw(False)
                
                # *a2_5* updates
                
                # if a2_5 is starting this frame...
                if a2_5.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
                    # keep track of start time/frame for later
                    a2_5.frameNStart = frameN  # exact frame index
                    a2_5.tStart = t  # local t and not account for scr refresh
                    a2_5.tStartRefresh = tThisFlipGlobal  # on global time
                    win.timeOnFlip(a2_5, 'tStartRefresh')  # time at next scr refresh
                    # add timestamp to datafile
                    thisExp.timestampOnFlip(win, 'a2_5.started')
                    # update status
                    a2_5.status = STARTED
                    a2_5.setAutoDraw(True)
                
                # if a2_5 is active this frame...
                if a2_5.status == STARTED:
                    # update params
                    pass
                
                # if a2_5 is stopping this frame...
                if a2_5.status == STARTED:
                    # is it time to stop? (based on global clock, using actual start)
                    if tThisFlipGlobal > a2_5.tStartRefresh + 120-frameTolerance:
                        # keep track of stop time/frame for later
                        a2_5.tStop = t  # not accounting for scr refresh
                        a2_5.tStopRefresh = tThisFlipGlobal  # on global time
                        a2_5.frameNStop = frameN  # exact frame index
                        # add timestamp to datafile
                        thisExp.timestampOnFlip(win, 'a2_5.stopped')
                        # update status
                        a2_5.status = FINISHED
                        a2_5.setAutoDraw(False)
                
                # *text_152* updates
                
                # if text_152 is starting this frame...
                if text_152.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
                    # keep track of start time/frame for later
                    text_152.frameNStart = frameN  # exact frame index
                    text_152.tStart = t  # local t and not account for scr refresh
                    text_152.tStartRefresh = tThisFlipGlobal  # on global time
                    win.timeOnFlip(text_152, 'tStartRefresh')  # time at next scr refresh
                    # add timestamp to datafile
                    thisExp.timestampOnFlip(win, 'text_152.started')
                    # update status
                    text_152.status = STARTED
                    text_152.setAutoDraw(True)
                
                # if text_152 is active this frame...
                if text_152.status == STARTED:
                    # update params
                    pass
                
                # if text_152 is stopping this frame...
                if text_152.status == STARTED:
                    # is it time to stop? (based on global clock, using actual start)
                    if tThisFlipGlobal > text_152.tStartRefresh + 120.0-frameTolerance:
                        # keep track of stop time/frame for later
                        text_152.tStop = t  # not accounting for scr refresh
                        text_152.tStopRefresh = tThisFlipGlobal  # on global time
                        text_152.frameNStop = frameN  # exact frame index
                        # add timestamp to datafile
                        thisExp.timestampOnFlip(win, 'text_152.stopped')
                        # update status
                        text_152.status = FINISHED
                        text_152.setAutoDraw(False)
                
                # check for quit (typically the Esc key)
                if defaultKeyboard.getKeys(keyList=["escape"]):
                    thisExp.status = FINISHED
                if thisExp.status == FINISHED or endExpNow:
                    endExperiment(thisExp, win=win)
                    return
                # pause experiment here if requested
                if thisExp.status == PAUSED:
                    pauseExperiment(
                        thisExp=thisExp, 
                        win=win, 
                        timers=[routineTimer], 
                        playbackComponents=[]
                    )
                    # skip the frame we paused on
                    continue
                
                # check if all components have finished
                if not continueRoutine:  # a component has requested a forced-end of Routine
                    planningpathstraining2.forceEnded = routineForceEnded = True
                    break
                continueRoutine = False  # will revert to True if at least one component still running
                for thisComponent in planningpathstraining2.components:
                    if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:
                        continueRoutine = True
                        break  # at least one component has not yet finished
                
                # refresh the screen
                if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen
                    win.flip()
            
            # --- Ending Routine "planningpathstraining2" ---
            for thisComponent in planningpathstraining2.components:
                if hasattr(thisComponent, "setAutoDraw"):
                    thisComponent.setAutoDraw(False)
            # store stop times for planningpathstraining2
            planningpathstraining2.tStop = globalClock.getTime(format='float')
            planningpathstraining2.tStopRefresh = tThisFlipGlobal
            thisExp.addData('planningpathstraining2.stopped', planningpathstraining2.tStop)
            # check responses
            if answer_quiz1_5.keys in ['', [], None]:  # No response was made
                answer_quiz1_5.keys = None
                # was no response the correct answer?!
                if str(correct_answer2).lower() == 'none':
                   answer_quiz1_5.corr = 1;  # correct non-response
                else:
                   answer_quiz1_5.corr = 0;  # failed to respond (incorrectly)
            # store data for planning_during_training (TrialHandler)
            planning_during_training.addData('answer_quiz1_5.keys',answer_quiz1_5.keys)
            planning_during_training.addData('answer_quiz1_5.corr', answer_quiz1_5.corr)
            if answer_quiz1_5.keys != None:  # we had a response
                planning_during_training.addData('answer_quiz1_5.rt', answer_quiz1_5.rt)
                planning_during_training.addData('answer_quiz1_5.duration', answer_quiz1_5.duration)
            # using non-slip timing so subtract the expected duration of this Routine (unless ended on request)
            if planningpathstraining2.maxDurationReached:
                routineTimer.addTime(-planningpathstraining2.maxDuration)
            elif planningpathstraining2.forceEnded:
                routineTimer.reset()
            else:
                routineTimer.addTime(-120.000000)
            
            # --- Prepare to start Routine "correct_forget_paths" ---
            # create an object to store info about Routine correct_forget_paths
            correct_forget_paths = data.Routine(
                name='correct_forget_paths',
                components=[next_trial_text_2, text_151],
            )
            correct_forget_paths.status = NOT_STARTED
            continueRoutine = True
            # update component parameters for each repeat
            next_trial_text_2.setText(msg)
            text_151.setText(quiz_planning_corr)
            # store start times for correct_forget_paths
            correct_forget_paths.tStartRefresh = win.getFutureFlipTime(clock=globalClock)
            correct_forget_paths.tStart = globalClock.getTime(format='float')
            correct_forget_paths.status = STARTED
            thisExp.addData('correct_forget_paths.started', correct_forget_paths.tStart)
            correct_forget_paths.maxDuration = None
            # keep track of which components have finished
            correct_forget_pathsComponents = correct_forget_paths.components
            for thisComponent in correct_forget_paths.components:
                thisComponent.tStart = None
                thisComponent.tStop = None
                thisComponent.tStartRefresh = None
                thisComponent.tStopRefresh = None
                if hasattr(thisComponent, 'status'):
                    thisComponent.status = NOT_STARTED
            # reset timers
            t = 0
            _timeToFirstFrame = win.getFutureFlipTime(clock="now")
            frameN = -1
            
            # --- Run Routine "correct_forget_paths" ---
            # if trial has changed, end Routine now
            if isinstance(planning_during_training, data.TrialHandler2) and thisPlanning_during_training.thisN != planning_during_training.thisTrial.thisN:
                continueRoutine = False
            correct_forget_paths.forceEnded = routineForceEnded = not continueRoutine
            while continueRoutine and routineTimer.getTime() < 3.0:
                # get current time
                t = routineTimer.getTime()
                tThisFlip = win.getFutureFlipTime(clock=routineTimer)
                tThisFlipGlobal = win.getFutureFlipTime(clock=None)
                frameN = frameN + 1  # number of completed frames (so 0 is the first frame)
                # update/draw components on each frame
                
                # *next_trial_text_2* updates
                
                # if next_trial_text_2 is starting this frame...
                if next_trial_text_2.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
                    # keep track of start time/frame for later
                    next_trial_text_2.frameNStart = frameN  # exact frame index
                    next_trial_text_2.tStart = t  # local t and not account for scr refresh
                    next_trial_text_2.tStartRefresh = tThisFlipGlobal  # on global time
                    win.timeOnFlip(next_trial_text_2, 'tStartRefresh')  # time at next scr refresh
                    # add timestamp to datafile
                    thisExp.timestampOnFlip(win, 'next_trial_text_2.started')
                    # update status
                    next_trial_text_2.status = STARTED
                    next_trial_text_2.setAutoDraw(True)
                
                # if next_trial_text_2 is active this frame...
                if next_trial_text_2.status == STARTED:
                    # update params
                    pass
                
                # if next_trial_text_2 is stopping this frame...
                if next_trial_text_2.status == STARTED:
                    # is it time to stop? (based on global clock, using actual start)
                    if tThisFlipGlobal > next_trial_text_2.tStartRefresh + 3-frameTolerance:
                        # keep track of stop time/frame for later
                        next_trial_text_2.tStop = t  # not accounting for scr refresh
                        next_trial_text_2.tStopRefresh = tThisFlipGlobal  # on global time
                        next_trial_text_2.frameNStop = frameN  # exact frame index
                        # add timestamp to datafile
                        thisExp.timestampOnFlip(win, 'next_trial_text_2.stopped')
                        # update status
                        next_trial_text_2.status = FINISHED
                        next_trial_text_2.setAutoDraw(False)
                
                # *text_151* updates
                
                # if text_151 is starting this frame...
                if text_151.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
                    # keep track of start time/frame for later
                    text_151.frameNStart = frameN  # exact frame index
                    text_151.tStart = t  # local t and not account for scr refresh
                    text_151.tStartRefresh = tThisFlipGlobal  # on global time
                    win.timeOnFlip(text_151, 'tStartRefresh')  # time at next scr refresh
                    # add timestamp to datafile
                    thisExp.timestampOnFlip(win, 'text_151.started')
                    # update status
                    text_151.status = STARTED
                    text_151.setAutoDraw(True)
                
                # if text_151 is active this frame...
                if text_151.status == STARTED:
                    # update params
                    pass
                
                # if text_151 is stopping this frame...
                if text_151.status == STARTED:
                    # is it time to stop? (based on global clock, using actual start)
                    if tThisFlipGlobal > text_151.tStartRefresh + 3.0-frameTolerance:
                        # keep track of stop time/frame for later
                        text_151.tStop = t  # not accounting for scr refresh
                        text_151.tStopRefresh = tThisFlipGlobal  # on global time
                        text_151.frameNStop = frameN  # exact frame index
                        # add timestamp to datafile
                        thisExp.timestampOnFlip(win, 'text_151.stopped')
                        # update status
                        text_151.status = FINISHED
                        text_151.setAutoDraw(False)
                
                # check for quit (typically the Esc key)
                if defaultKeyboard.getKeys(keyList=["escape"]):
                    thisExp.status = FINISHED
                if thisExp.status == FINISHED or endExpNow:
                    endExperiment(thisExp, win=win)
                    return
                # pause experiment here if requested
                if thisExp.status == PAUSED:
                    pauseExperiment(
                        thisExp=thisExp, 
                        win=win, 
                        timers=[routineTimer], 
                        playbackComponents=[]
                    )
                    # skip the frame we paused on
                    continue
                
                # check if all components have finished
                if not continueRoutine:  # a component has requested a forced-end of Routine
                    correct_forget_paths.forceEnded = routineForceEnded = True
                    break
                continueRoutine = False  # will revert to True if at least one component still running
                for thisComponent in correct_forget_paths.components:
                    if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:
                        continueRoutine = True
                        break  # at least one component has not yet finished
                
                # refresh the screen
                if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen
                    win.flip()
            
            # --- Ending Routine "correct_forget_paths" ---
            for thisComponent in correct_forget_paths.components:
                if hasattr(thisComponent, "setAutoDraw"):
                    thisComponent.setAutoDraw(False)
            # store stop times for correct_forget_paths
            correct_forget_paths.tStop = globalClock.getTime(format='float')
            correct_forget_paths.tStopRefresh = tThisFlipGlobal
            thisExp.addData('correct_forget_paths.stopped', correct_forget_paths.tStop)
            # using non-slip timing so subtract the expected duration of this Routine (unless ended on request)
            if correct_forget_paths.maxDurationReached:
                routineTimer.addTime(-correct_forget_paths.maxDuration)
            elif correct_forget_paths.forceEnded:
                routineTimer.reset()
            else:
                routineTimer.addTime(-3.000000)
            thisExp.nextEntry()
            
        # completed 1.0 repeats of 'planning_during_training'
        
        if thisSession is not None:
            # if running in a Session with a Liaison client, send data up to now
            thisSession.sendExperimentData()
        
        # --- Prepare to start Routine "total_score_planning" ---
        # create an object to store info about Routine total_score_planning
        total_score_planning = data.Routine(
            name='total_score_planning',
            components=[next_trial_text_3, text_150],
        )
        total_score_planning.status = NOT_STARTED
        continueRoutine = True
        # update component parameters for each repeat
        # Run 'Begin Routine' code from code_43
        total_planning_score_training=(quiz_planning_corr/8.0)*100
        next_trial_text_3.setText(total_planning_score_training)
        # store start times for total_score_planning
        total_score_planning.tStartRefresh = win.getFutureFlipTime(clock=globalClock)
        total_score_planning.tStart = globalClock.getTime(format='float')
        total_score_planning.status = STARTED
        thisExp.addData('total_score_planning.started', total_score_planning.tStart)
        total_score_planning.maxDuration = None
        # keep track of which components have finished
        total_score_planningComponents = total_score_planning.components
        for thisComponent in total_score_planning.components:
            thisComponent.tStart = None
            thisComponent.tStop = None
            thisComponent.tStartRefresh = None
            thisComponent.tStopRefresh = None
            if hasattr(thisComponent, 'status'):
                thisComponent.status = NOT_STARTED
        # reset timers
        t = 0
        _timeToFirstFrame = win.getFutureFlipTime(clock="now")
        frameN = -1
        
        # --- Run Routine "total_score_planning" ---
        # if trial has changed, end Routine now
        if isinstance(learning_phase, data.TrialHandler2) and thisLearning_phase.thisN != learning_phase.thisTrial.thisN:
            continueRoutine = False
        total_score_planning.forceEnded = routineForceEnded = not continueRoutine
        while continueRoutine and routineTimer.getTime() < 3.0:
            # get current time
            t = routineTimer.getTime()
            tThisFlip = win.getFutureFlipTime(clock=routineTimer)
            tThisFlipGlobal = win.getFutureFlipTime(clock=None)
            frameN = frameN + 1  # number of completed frames (so 0 is the first frame)
            # update/draw components on each frame
            
            # *next_trial_text_3* updates
            
            # if next_trial_text_3 is starting this frame...
            if next_trial_text_3.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
                # keep track of start time/frame for later
                next_trial_text_3.frameNStart = frameN  # exact frame index
                next_trial_text_3.tStart = t  # local t and not account for scr refresh
                next_trial_text_3.tStartRefresh = tThisFlipGlobal  # on global time
                win.timeOnFlip(next_trial_text_3, 'tStartRefresh')  # time at next scr refresh
                # add timestamp to datafile
                thisExp.timestampOnFlip(win, 'next_trial_text_3.started')
                # update status
                next_trial_text_3.status = STARTED
                next_trial_text_3.setAutoDraw(True)
            
            # if next_trial_text_3 is active this frame...
            if next_trial_text_3.status == STARTED:
                # update params
                pass
            
            # if next_trial_text_3 is stopping this frame...
            if next_trial_text_3.status == STARTED:
                # is it time to stop? (based on global clock, using actual start)
                if tThisFlipGlobal > next_trial_text_3.tStartRefresh + 3-frameTolerance:
                    # keep track of stop time/frame for later
                    next_trial_text_3.tStop = t  # not accounting for scr refresh
                    next_trial_text_3.tStopRefresh = tThisFlipGlobal  # on global time
                    next_trial_text_3.frameNStop = frameN  # exact frame index
                    # add timestamp to datafile
                    thisExp.timestampOnFlip(win, 'next_trial_text_3.stopped')
                    # update status
                    next_trial_text_3.status = FINISHED
                    next_trial_text_3.setAutoDraw(False)
            
            # *text_150* updates
            
            # if text_150 is starting this frame...
            if text_150.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
                # keep track of start time/frame for later
                text_150.frameNStart = frameN  # exact frame index
                text_150.tStart = t  # local t and not account for scr refresh
                text_150.tStartRefresh = tThisFlipGlobal  # on global time
                win.timeOnFlip(text_150, 'tStartRefresh')  # time at next scr refresh
                # add timestamp to datafile
                thisExp.timestampOnFlip(win, 'text_150.started')
                # update status
                text_150.status = STARTED
                text_150.setAutoDraw(True)
            
            # if text_150 is active this frame...
            if text_150.status == STARTED:
                # update params
                pass
            
            # if text_150 is stopping this frame...
            if text_150.status == STARTED:
                # is it time to stop? (based on global clock, using actual start)
                if tThisFlipGlobal > text_150.tStartRefresh + 3.0-frameTolerance:
                    # keep track of stop time/frame for later
                    text_150.tStop = t  # not accounting for scr refresh
                    text_150.tStopRefresh = tThisFlipGlobal  # on global time
                    text_150.frameNStop = frameN  # exact frame index
                    # add timestamp to datafile
                    thisExp.timestampOnFlip(win, 'text_150.stopped')
                    # update status
                    text_150.status = FINISHED
                    text_150.setAutoDraw(False)
            
            # check for quit (typically the Esc key)
            if defaultKeyboard.getKeys(keyList=["escape"]):
                thisExp.status = FINISHED
            if thisExp.status == FINISHED or endExpNow:
                endExperiment(thisExp, win=win)
                return
            # pause experiment here if requested
            if thisExp.status == PAUSED:
                pauseExperiment(
                    thisExp=thisExp, 
                    win=win, 
                    timers=[routineTimer], 
                    playbackComponents=[]
                )
                # skip the frame we paused on
                continue
            
            # check if all components have finished
            if not continueRoutine:  # a component has requested a forced-end of Routine
                total_score_planning.forceEnded = routineForceEnded = True
                break
            continueRoutine = False  # will revert to True if at least one component still running
            for thisComponent in total_score_planning.components:
                if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:
                    continueRoutine = True
                    break  # at least one component has not yet finished
            
            # refresh the screen
            if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen
                win.flip()
        
        # --- Ending Routine "total_score_planning" ---
        for thisComponent in total_score_planning.components:
            if hasattr(thisComponent, "setAutoDraw"):
                thisComponent.setAutoDraw(False)
        # store stop times for total_score_planning
        total_score_planning.tStop = globalClock.getTime(format='float')
        total_score_planning.tStopRefresh = tThisFlipGlobal
        thisExp.addData('total_score_planning.stopped', total_score_planning.tStop)
        # using non-slip timing so subtract the expected duration of this Routine (unless ended on request)
        if total_score_planning.maxDurationReached:
            routineTimer.addTime(-total_score_planning.maxDuration)
        elif total_score_planning.forceEnded:
            routineTimer.reset()
        else:
            routineTimer.addTime(-3.000000)
        thisExp.nextEntry()
        
    # completed 1.0 repeats of 'learning_phase'
    
    if thisSession is not None:
        # if running in a Session with a Liaison client, send data up to now
        thisSession.sendExperimentData()
    
    # --- Prepare to start Routine "break_routine" ---
    # create an object to store info about Routine break_routine
    break_routine = data.Routine(
        name='break_routine',
        components=[text_9],
    )
    break_routine.status = NOT_STARTED
    continueRoutine = True
    # update component parameters for each repeat
    # store start times for break_routine
    break_routine.tStartRefresh = win.getFutureFlipTime(clock=globalClock)
    break_routine.tStart = globalClock.getTime(format='float')
    break_routine.status = STARTED
    thisExp.addData('break_routine.started', break_routine.tStart)
    break_routine.maxDuration = None
    # keep track of which components have finished
    break_routineComponents = break_routine.components
    for thisComponent in break_routine.components:
        thisComponent.tStart = None
        thisComponent.tStop = None
        thisComponent.tStartRefresh = None
        thisComponent.tStopRefresh = None
        if hasattr(thisComponent, 'status'):
            thisComponent.status = NOT_STARTED
    # reset timers
    t = 0
    _timeToFirstFrame = win.getFutureFlipTime(clock="now")
    frameN = -1
    
    # --- Run Routine "break_routine" ---
    break_routine.forceEnded = routineForceEnded = not continueRoutine
    while continueRoutine and routineTimer.getTime() < 5.0:
        # get current time
        t = routineTimer.getTime()
        tThisFlip = win.getFutureFlipTime(clock=routineTimer)
        tThisFlipGlobal = win.getFutureFlipTime(clock=None)
        frameN = frameN + 1  # number of completed frames (so 0 is the first frame)
        # update/draw components on each frame
        
        # *text_9* updates
        
        # if text_9 is starting this frame...
        if text_9.status == NOT_STARTED and tThisFlip >= 0-frameTolerance:
            # keep track of start time/frame for later
            text_9.frameNStart = frameN  # exact frame index
            text_9.tStart = t  # local t and not account for scr refresh
            text_9.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(text_9, 'tStartRefresh')  # time at next scr refresh
            # add timestamp to datafile
            thisExp.timestampOnFlip(win, 'text_9.started')
            # update status
            text_9.status = STARTED
            text_9.setAutoDraw(True)
        
        # if text_9 is active this frame...
        if text_9.status == STARTED:
            # update params
            pass
        
        # if text_9 is stopping this frame...
        if text_9.status == STARTED:
            # is it time to stop? (based on global clock, using actual start)
            if tThisFlipGlobal > text_9.tStartRefresh + 5-frameTolerance:
                # keep track of stop time/frame for later
                text_9.tStop = t  # not accounting for scr refresh
                text_9.tStopRefresh = tThisFlipGlobal  # on global time
                text_9.frameNStop = frameN  # exact frame index
                # add timestamp to datafile
                thisExp.timestampOnFlip(win, 'text_9.stopped')
                # update status
                text_9.status = FINISHED
                text_9.setAutoDraw(False)
        
        # check for quit (typically the Esc key)
        if defaultKeyboard.getKeys(keyList=["escape"]):
            thisExp.status = FINISHED
        if thisExp.status == FINISHED or endExpNow:
            endExperiment(thisExp, win=win)
            return
        # pause experiment here if requested
        if thisExp.status == PAUSED:
            pauseExperiment(
                thisExp=thisExp, 
                win=win, 
                timers=[routineTimer], 
                playbackComponents=[]
            )
            # skip the frame we paused on
            continue
        
        # check if all components have finished
        if not continueRoutine:  # a component has requested a forced-end of Routine
            break_routine.forceEnded = routineForceEnded = True
            break
        continueRoutine = False  # will revert to True if at least one component still running
        for thisComponent in break_routine.components:
            if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:
                continueRoutine = True
                break  # at least one component has not yet finished
        
        # refresh the screen
        if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen
            win.flip()
    
    # --- Ending Routine "break_routine" ---
    for thisComponent in break_routine.components:
        if hasattr(thisComponent, "setAutoDraw"):
            thisComponent.setAutoDraw(False)
    # store stop times for break_routine
    break_routine.tStop = globalClock.getTime(format='float')
    break_routine.tStopRefresh = tThisFlipGlobal
    thisExp.addData('break_routine.stopped', break_routine.tStop)
    # using non-slip timing so subtract the expected duration of this Routine (unless ended on request)
    if break_routine.maxDurationReached:
        routineTimer.addTime(-break_routine.maxDuration)
    elif break_routine.forceEnded:
        routineTimer.reset()
    else:
        routineTimer.addTime(-5.000000)
    thisExp.nextEntry()
    
    # set up handler to look after randomisation of conditions etc
    instructions_planning_get_right = data.TrialHandler2(
        name='instructions_planning_get_right',
        nReps=999.0, 
        method='random', 
        extraInfo=expInfo, 
        originPath=-1, 
        trialList=[None], 
        seed=None, 
    )
    thisExp.addLoop(instructions_planning_get_right)  # add the loop to the experiment
    thisInstructions_planning_get_right = instructions_planning_get_right.trialList[0]  # so we can initialise stimuli with some values
    # abbreviate parameter names if possible (e.g. rgb = thisInstructions_planning_get_right.rgb)
    if thisInstructions_planning_get_right != None:
        for paramName in thisInstructions_planning_get_right:
            globals()[paramName] = thisInstructions_planning_get_right[paramName]
    if thisSession is not None:
        # if running in a Session with a Liaison client, send data up to now
        thisSession.sendExperimentData()
    
    for thisInstructions_planning_get_right in instructions_planning_get_right:
        currentLoop = instructions_planning_get_right
        thisExp.timestampOnFlip(win, 'thisRow.t', format=globalClock.format)
        if thisSession is not None:
            # if running in a Session with a Liaison client, send data up to now
            thisSession.sendExperimentData()
        # abbreviate parameter names if possible (e.g. rgb = thisInstructions_planning_get_right.rgb)
        if thisInstructions_planning_get_right != None:
            for paramName in thisInstructions_planning_get_right:
                globals()[paramName] = thisInstructions_planning_get_right[paramName]
        
        # --- Prepare to start Routine "instructions_reward" ---
        # create an object to store info about Routine instructions_reward
        instructions_reward = data.Routine(
            name='instructions_reward',
            components=[instructions_rewardstage, key_resp_11, text_46],
        )
        instructions_reward.status = NOT_STARTED
        continueRoutine = True
        # update component parameters for each repeat
        # create starting attributes for key_resp_11
        key_resp_11.keys = []
        key_resp_11.rt = []
        _key_resp_11_allKeys = []
        # store start times for instructions_reward
        instructions_reward.tStartRefresh = win.getFutureFlipTime(clock=globalClock)
        instructions_reward.tStart = globalClock.getTime(format='float')
        instructions_reward.status = STARTED
        thisExp.addData('instructions_reward.started', instructions_reward.tStart)
        instructions_reward.maxDuration = None
        # keep track of which components have finished
        instructions_rewardComponents = instructions_reward.components
        for thisComponent in instructions_reward.components:
            thisComponent.tStart = None
            thisComponent.tStop = None
            thisComponent.tStartRefresh = None
            thisComponent.tStopRefresh = None
            if hasattr(thisComponent, 'status'):
                thisComponent.status = NOT_STARTED
        # reset timers
        t = 0
        _timeToFirstFrame = win.getFutureFlipTime(clock="now")
        frameN = -1
        
        # --- Run Routine "instructions_reward" ---
        # if trial has changed, end Routine now
        if isinstance(instructions_planning_get_right, data.TrialHandler2) and thisInstructions_planning_get_right.thisN != instructions_planning_get_right.thisTrial.thisN:
            continueRoutine = False
        instructions_reward.forceEnded = routineForceEnded = not continueRoutine
        while continueRoutine:
            # get current time
            t = routineTimer.getTime()
            tThisFlip = win.getFutureFlipTime(clock=routineTimer)
            tThisFlipGlobal = win.getFutureFlipTime(clock=None)
            frameN = frameN + 1  # number of completed frames (so 0 is the first frame)
            # update/draw components on each frame
            
            # *instructions_rewardstage* updates
            
            # if instructions_rewardstage is starting this frame...
            if instructions_rewardstage.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
                # keep track of start time/frame for later
                instructions_rewardstage.frameNStart = frameN  # exact frame index
                instructions_rewardstage.tStart = t  # local t and not account for scr refresh
                instructions_rewardstage.tStartRefresh = tThisFlipGlobal  # on global time
                win.timeOnFlip(instructions_rewardstage, 'tStartRefresh')  # time at next scr refresh
                # add timestamp to datafile
                thisExp.timestampOnFlip(win, 'instructions_rewardstage.started')
                # update status
                instructions_rewardstage.status = STARTED
                instructions_rewardstage.setAutoDraw(True)
            
            # if instructions_rewardstage is active this frame...
            if instructions_rewardstage.status == STARTED:
                # update params
                pass
            
            # *key_resp_11* updates
            waitOnFlip = False
            
            # if key_resp_11 is starting this frame...
            if key_resp_11.status == NOT_STARTED and tThisFlip >= 10.0-frameTolerance:
                # keep track of start time/frame for later
                key_resp_11.frameNStart = frameN  # exact frame index
                key_resp_11.tStart = t  # local t and not account for scr refresh
                key_resp_11.tStartRefresh = tThisFlipGlobal  # on global time
                win.timeOnFlip(key_resp_11, 'tStartRefresh')  # time at next scr refresh
                # add timestamp to datafile
                thisExp.timestampOnFlip(win, 'key_resp_11.started')
                # update status
                key_resp_11.status = STARTED
                # keyboard checking is just starting
                waitOnFlip = True
                win.callOnFlip(key_resp_11.clock.reset)  # t=0 on next screen flip
                win.callOnFlip(key_resp_11.clearEvents, eventType='keyboard')  # clear events on next screen flip
            if key_resp_11.status == STARTED and not waitOnFlip:
                theseKeys = key_resp_11.getKeys(keyList=['space'], ignoreKeys=["escape"], waitRelease=False)
                _key_resp_11_allKeys.extend(theseKeys)
                if len(_key_resp_11_allKeys):
                    key_resp_11.keys = _key_resp_11_allKeys[-1].name  # just the last key pressed
                    key_resp_11.rt = _key_resp_11_allKeys[-1].rt
                    key_resp_11.duration = _key_resp_11_allKeys[-1].duration
                    # a response ends the routine
                    continueRoutine = False
            
            # *text_46* updates
            
            # if text_46 is starting this frame...
            if text_46.status == NOT_STARTED and tThisFlip >= 10.0-frameTolerance:
                # keep track of start time/frame for later
                text_46.frameNStart = frameN  # exact frame index
                text_46.tStart = t  # local t and not account for scr refresh
                text_46.tStartRefresh = tThisFlipGlobal  # on global time
                win.timeOnFlip(text_46, 'tStartRefresh')  # time at next scr refresh
                # add timestamp to datafile
                thisExp.timestampOnFlip(win, 'text_46.started')
                # update status
                text_46.status = STARTED
                text_46.setAutoDraw(True)
            
            # if text_46 is active this frame...
            if text_46.status == STARTED:
                # update params
                pass
            
            # check for quit (typically the Esc key)
            if defaultKeyboard.getKeys(keyList=["escape"]):
                thisExp.status = FINISHED
            if thisExp.status == FINISHED or endExpNow:
                endExperiment(thisExp, win=win)
                return
            # pause experiment here if requested
            if thisExp.status == PAUSED:
                pauseExperiment(
                    thisExp=thisExp, 
                    win=win, 
                    timers=[routineTimer], 
                    playbackComponents=[]
                )
                # skip the frame we paused on
                continue
            
            # check if all components have finished
            if not continueRoutine:  # a component has requested a forced-end of Routine
                instructions_reward.forceEnded = routineForceEnded = True
                break
            continueRoutine = False  # will revert to True if at least one component still running
            for thisComponent in instructions_reward.components:
                if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:
                    continueRoutine = True
                    break  # at least one component has not yet finished
            
            # refresh the screen
            if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen
                win.flip()
        
        # --- Ending Routine "instructions_reward" ---
        for thisComponent in instructions_reward.components:
            if hasattr(thisComponent, "setAutoDraw"):
                thisComponent.setAutoDraw(False)
        # store stop times for instructions_reward
        instructions_reward.tStop = globalClock.getTime(format='float')
        instructions_reward.tStopRefresh = tThisFlipGlobal
        thisExp.addData('instructions_reward.stopped', instructions_reward.tStop)
        # the Routine "instructions_reward" was not non-slip safe, so reset the non-slip timer
        routineTimer.reset()
        
        # --- Prepare to start Routine "instructions_planning_2" ---
        # create an object to store info about Routine instructions_planning_2
        instructions_planning_2 = data.Routine(
            name='instructions_planning_2',
            components=[text_50, key_resp_9],
        )
        instructions_planning_2.status = NOT_STARTED
        continueRoutine = True
        # update component parameters for each repeat
        # create starting attributes for key_resp_9
        key_resp_9.keys = []
        key_resp_9.rt = []
        _key_resp_9_allKeys = []
        # store start times for instructions_planning_2
        instructions_planning_2.tStartRefresh = win.getFutureFlipTime(clock=globalClock)
        instructions_planning_2.tStart = globalClock.getTime(format='float')
        instructions_planning_2.status = STARTED
        thisExp.addData('instructions_planning_2.started', instructions_planning_2.tStart)
        instructions_planning_2.maxDuration = None
        # keep track of which components have finished
        instructions_planning_2Components = instructions_planning_2.components
        for thisComponent in instructions_planning_2.components:
            thisComponent.tStart = None
            thisComponent.tStop = None
            thisComponent.tStartRefresh = None
            thisComponent.tStopRefresh = None
            if hasattr(thisComponent, 'status'):
                thisComponent.status = NOT_STARTED
        # reset timers
        t = 0
        _timeToFirstFrame = win.getFutureFlipTime(clock="now")
        frameN = -1
        
        # --- Run Routine "instructions_planning_2" ---
        # if trial has changed, end Routine now
        if isinstance(instructions_planning_get_right, data.TrialHandler2) and thisInstructions_planning_get_right.thisN != instructions_planning_get_right.thisTrial.thisN:
            continueRoutine = False
        instructions_planning_2.forceEnded = routineForceEnded = not continueRoutine
        while continueRoutine:
            # get current time
            t = routineTimer.getTime()
            tThisFlip = win.getFutureFlipTime(clock=routineTimer)
            tThisFlipGlobal = win.getFutureFlipTime(clock=None)
            frameN = frameN + 1  # number of completed frames (so 0 is the first frame)
            # update/draw components on each frame
            
            # *text_50* updates
            
            # if text_50 is starting this frame...
            if text_50.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
                # keep track of start time/frame for later
                text_50.frameNStart = frameN  # exact frame index
                text_50.tStart = t  # local t and not account for scr refresh
                text_50.tStartRefresh = tThisFlipGlobal  # on global time
                win.timeOnFlip(text_50, 'tStartRefresh')  # time at next scr refresh
                # add timestamp to datafile
                thisExp.timestampOnFlip(win, 'text_50.started')
                # update status
                text_50.status = STARTED
                text_50.setAutoDraw(True)
            
            # if text_50 is active this frame...
            if text_50.status == STARTED:
                # update params
                pass
            
            # *key_resp_9* updates
            waitOnFlip = False
            
            # if key_resp_9 is starting this frame...
            if key_resp_9.status == NOT_STARTED and tThisFlip >= 0-frameTolerance:
                # keep track of start time/frame for later
                key_resp_9.frameNStart = frameN  # exact frame index
                key_resp_9.tStart = t  # local t and not account for scr refresh
                key_resp_9.tStartRefresh = tThisFlipGlobal  # on global time
                win.timeOnFlip(key_resp_9, 'tStartRefresh')  # time at next scr refresh
                # add timestamp to datafile
                thisExp.timestampOnFlip(win, 'key_resp_9.started')
                # update status
                key_resp_9.status = STARTED
                # keyboard checking is just starting
                waitOnFlip = True
                win.callOnFlip(key_resp_9.clock.reset)  # t=0 on next screen flip
                win.callOnFlip(key_resp_9.clearEvents, eventType='keyboard')  # clear events on next screen flip
            if key_resp_9.status == STARTED and not waitOnFlip:
                theseKeys = key_resp_9.getKeys(keyList=['space'], ignoreKeys=["escape"], waitRelease=False)
                _key_resp_9_allKeys.extend(theseKeys)
                if len(_key_resp_9_allKeys):
                    key_resp_9.keys = _key_resp_9_allKeys[-1].name  # just the last key pressed
                    key_resp_9.rt = _key_resp_9_allKeys[-1].rt
                    key_resp_9.duration = _key_resp_9_allKeys[-1].duration
                    # a response ends the routine
                    continueRoutine = False
            
            # check for quit (typically the Esc key)
            if defaultKeyboard.getKeys(keyList=["escape"]):
                thisExp.status = FINISHED
            if thisExp.status == FINISHED or endExpNow:
                endExperiment(thisExp, win=win)
                return
            # pause experiment here if requested
            if thisExp.status == PAUSED:
                pauseExperiment(
                    thisExp=thisExp, 
                    win=win, 
                    timers=[routineTimer], 
                    playbackComponents=[]
                )
                # skip the frame we paused on
                continue
            
            # check if all components have finished
            if not continueRoutine:  # a component has requested a forced-end of Routine
                instructions_planning_2.forceEnded = routineForceEnded = True
                break
            continueRoutine = False  # will revert to True if at least one component still running
            for thisComponent in instructions_planning_2.components:
                if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:
                    continueRoutine = True
                    break  # at least one component has not yet finished
            
            # refresh the screen
            if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen
                win.flip()
        
        # --- Ending Routine "instructions_planning_2" ---
        for thisComponent in instructions_planning_2.components:
            if hasattr(thisComponent, "setAutoDraw"):
                thisComponent.setAutoDraw(False)
        # store stop times for instructions_planning_2
        instructions_planning_2.tStop = globalClock.getTime(format='float')
        instructions_planning_2.tStopRefresh = tThisFlipGlobal
        thisExp.addData('instructions_planning_2.stopped', instructions_planning_2.tStop)
        # the Routine "instructions_planning_2" was not non-slip safe, so reset the non-slip timer
        routineTimer.reset()
        
        # --- Prepare to start Routine "instructions_example_trial" ---
        # create an object to store info about Routine instructions_example_trial
        instructions_example_trial = data.Routine(
            name='instructions_example_trial',
            components=[text_13, R1_5, R2_5, rew1_5, rew2_5, text_21, plan2_response_2, current_image_decision2_2],
        )
        instructions_example_trial.status = NOT_STARTED
        continueRoutine = True
        # update component parameters for each repeat
        # Run 'Begin Routine' code from code_13
        al1=400
        al2=50
        
        # create starting attributes for plan2_response_2
        plan2_response_2.keys = []
        plan2_response_2.rt = []
        _plan2_response_2_allKeys = []
        # store start times for instructions_example_trial
        instructions_example_trial.tStartRefresh = win.getFutureFlipTime(clock=globalClock)
        instructions_example_trial.tStart = globalClock.getTime(format='float')
        instructions_example_trial.status = STARTED
        thisExp.addData('instructions_example_trial.started', instructions_example_trial.tStart)
        instructions_example_trial.maxDuration = None
        # keep track of which components have finished
        instructions_example_trialComponents = instructions_example_trial.components
        for thisComponent in instructions_example_trial.components:
            thisComponent.tStart = None
            thisComponent.tStop = None
            thisComponent.tStartRefresh = None
            thisComponent.tStopRefresh = None
            if hasattr(thisComponent, 'status'):
                thisComponent.status = NOT_STARTED
        # reset timers
        t = 0
        _timeToFirstFrame = win.getFutureFlipTime(clock="now")
        frameN = -1
        
        # --- Run Routine "instructions_example_trial" ---
        # if trial has changed, end Routine now
        if isinstance(instructions_planning_get_right, data.TrialHandler2) and thisInstructions_planning_get_right.thisN != instructions_planning_get_right.thisTrial.thisN:
            continueRoutine = False
        instructions_example_trial.forceEnded = routineForceEnded = not continueRoutine
        while continueRoutine and routineTimer.getTime() < 30.0:
            # get current time
            t = routineTimer.getTime()
            tThisFlip = win.getFutureFlipTime(clock=routineTimer)
            tThisFlipGlobal = win.getFutureFlipTime(clock=None)
            frameN = frameN + 1  # number of completed frames (so 0 is the first frame)
            # update/draw components on each frame
            
            # *text_13* updates
            
            # if text_13 is starting this frame...
            if text_13.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
                # keep track of start time/frame for later
                text_13.frameNStart = frameN  # exact frame index
                text_13.tStart = t  # local t and not account for scr refresh
                text_13.tStartRefresh = tThisFlipGlobal  # on global time
                win.timeOnFlip(text_13, 'tStartRefresh')  # time at next scr refresh
                # add timestamp to datafile
                thisExp.timestampOnFlip(win, 'text_13.started')
                # update status
                text_13.status = STARTED
                text_13.setAutoDraw(True)
            
            # if text_13 is active this frame...
            if text_13.status == STARTED:
                # update params
                pass
            
            # if text_13 is stopping this frame...
            if text_13.status == STARTED:
                # is it time to stop? (based on global clock, using actual start)
                if tThisFlipGlobal > text_13.tStartRefresh + 30.0-frameTolerance:
                    # keep track of stop time/frame for later
                    text_13.tStop = t  # not accounting for scr refresh
                    text_13.tStopRefresh = tThisFlipGlobal  # on global time
                    text_13.frameNStop = frameN  # exact frame index
                    # add timestamp to datafile
                    thisExp.timestampOnFlip(win, 'text_13.stopped')
                    # update status
                    text_13.status = FINISHED
                    text_13.setAutoDraw(False)
            
            # *R1_5* updates
            
            # if R1_5 is starting this frame...
            if R1_5.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
                # keep track of start time/frame for later
                R1_5.frameNStart = frameN  # exact frame index
                R1_5.tStart = t  # local t and not account for scr refresh
                R1_5.tStartRefresh = tThisFlipGlobal  # on global time
                win.timeOnFlip(R1_5, 'tStartRefresh')  # time at next scr refresh
                # add timestamp to datafile
                thisExp.timestampOnFlip(win, 'R1_5.started')
                # update status
                R1_5.status = STARTED
                R1_5.setAutoDraw(True)
            
            # if R1_5 is active this frame...
            if R1_5.status == STARTED:
                # update params
                pass
            
            # if R1_5 is stopping this frame...
            if R1_5.status == STARTED:
                # is it time to stop? (based on global clock, using actual start)
                if tThisFlipGlobal > R1_5.tStartRefresh + 30.0-frameTolerance:
                    # keep track of stop time/frame for later
                    R1_5.tStop = t  # not accounting for scr refresh
                    R1_5.tStopRefresh = tThisFlipGlobal  # on global time
                    R1_5.frameNStop = frameN  # exact frame index
                    # add timestamp to datafile
                    thisExp.timestampOnFlip(win, 'R1_5.stopped')
                    # update status
                    R1_5.status = FINISHED
                    R1_5.setAutoDraw(False)
            
            # *R2_5* updates
            
            # if R2_5 is starting this frame...
            if R2_5.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
                # keep track of start time/frame for later
                R2_5.frameNStart = frameN  # exact frame index
                R2_5.tStart = t  # local t and not account for scr refresh
                R2_5.tStartRefresh = tThisFlipGlobal  # on global time
                win.timeOnFlip(R2_5, 'tStartRefresh')  # time at next scr refresh
                # add timestamp to datafile
                thisExp.timestampOnFlip(win, 'R2_5.started')
                # update status
                R2_5.status = STARTED
                R2_5.setAutoDraw(True)
            
            # if R2_5 is active this frame...
            if R2_5.status == STARTED:
                # update params
                pass
            
            # if R2_5 is stopping this frame...
            if R2_5.status == STARTED:
                # is it time to stop? (based on global clock, using actual start)
                if tThisFlipGlobal > R2_5.tStartRefresh + 30.0-frameTolerance:
                    # keep track of stop time/frame for later
                    R2_5.tStop = t  # not accounting for scr refresh
                    R2_5.tStopRefresh = tThisFlipGlobal  # on global time
                    R2_5.frameNStop = frameN  # exact frame index
                    # add timestamp to datafile
                    thisExp.timestampOnFlip(win, 'R2_5.stopped')
                    # update status
                    R2_5.status = FINISHED
                    R2_5.setAutoDraw(False)
            
            # *rew1_5* updates
            
            # if rew1_5 is starting this frame...
            if rew1_5.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
                # keep track of start time/frame for later
                rew1_5.frameNStart = frameN  # exact frame index
                rew1_5.tStart = t  # local t and not account for scr refresh
                rew1_5.tStartRefresh = tThisFlipGlobal  # on global time
                win.timeOnFlip(rew1_5, 'tStartRefresh')  # time at next scr refresh
                # add timestamp to datafile
                thisExp.timestampOnFlip(win, 'rew1_5.started')
                # update status
                rew1_5.status = STARTED
                rew1_5.setAutoDraw(True)
            
            # if rew1_5 is active this frame...
            if rew1_5.status == STARTED:
                # update params
                rew1_5.setText(al1, log=False)
            
            # if rew1_5 is stopping this frame...
            if rew1_5.status == STARTED:
                # is it time to stop? (based on global clock, using actual start)
                if tThisFlipGlobal > rew1_5.tStartRefresh + 30.0-frameTolerance:
                    # keep track of stop time/frame for later
                    rew1_5.tStop = t  # not accounting for scr refresh
                    rew1_5.tStopRefresh = tThisFlipGlobal  # on global time
                    rew1_5.frameNStop = frameN  # exact frame index
                    # add timestamp to datafile
                    thisExp.timestampOnFlip(win, 'rew1_5.stopped')
                    # update status
                    rew1_5.status = FINISHED
                    rew1_5.setAutoDraw(False)
            
            # *rew2_5* updates
            
            # if rew2_5 is starting this frame...
            if rew2_5.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
                # keep track of start time/frame for later
                rew2_5.frameNStart = frameN  # exact frame index
                rew2_5.tStart = t  # local t and not account for scr refresh
                rew2_5.tStartRefresh = tThisFlipGlobal  # on global time
                win.timeOnFlip(rew2_5, 'tStartRefresh')  # time at next scr refresh
                # add timestamp to datafile
                thisExp.timestampOnFlip(win, 'rew2_5.started')
                # update status
                rew2_5.status = STARTED
                rew2_5.setAutoDraw(True)
            
            # if rew2_5 is active this frame...
            if rew2_5.status == STARTED:
                # update params
                rew2_5.setText('SPACE: Win 100\n', log=False)
            
            # if rew2_5 is stopping this frame...
            if rew2_5.status == STARTED:
                # is it time to stop? (based on global clock, using actual start)
                if tThisFlipGlobal > rew2_5.tStartRefresh + 30.0-frameTolerance:
                    # keep track of stop time/frame for later
                    rew2_5.tStop = t  # not accounting for scr refresh
                    rew2_5.tStopRefresh = tThisFlipGlobal  # on global time
                    rew2_5.frameNStop = frameN  # exact frame index
                    # add timestamp to datafile
                    thisExp.timestampOnFlip(win, 'rew2_5.stopped')
                    # update status
                    rew2_5.status = FINISHED
                    rew2_5.setAutoDraw(False)
            
            # *text_21* updates
            
            # if text_21 is starting this frame...
            if text_21.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
                # keep track of start time/frame for later
                text_21.frameNStart = frameN  # exact frame index
                text_21.tStart = t  # local t and not account for scr refresh
                text_21.tStartRefresh = tThisFlipGlobal  # on global time
                win.timeOnFlip(text_21, 'tStartRefresh')  # time at next scr refresh
                # add timestamp to datafile
                thisExp.timestampOnFlip(win, 'text_21.started')
                # update status
                text_21.status = STARTED
                text_21.setAutoDraw(True)
            
            # if text_21 is active this frame...
            if text_21.status == STARTED:
                # update params
                pass
            
            # if text_21 is stopping this frame...
            if text_21.status == STARTED:
                # is it time to stop? (based on global clock, using actual start)
                if tThisFlipGlobal > text_21.tStartRefresh + 30.0-frameTolerance:
                    # keep track of stop time/frame for later
                    text_21.tStop = t  # not accounting for scr refresh
                    text_21.tStopRefresh = tThisFlipGlobal  # on global time
                    text_21.frameNStop = frameN  # exact frame index
                    # add timestamp to datafile
                    thisExp.timestampOnFlip(win, 'text_21.stopped')
                    # update status
                    text_21.status = FINISHED
                    text_21.setAutoDraw(False)
            
            # *plan2_response_2* updates
            waitOnFlip = False
            
            # if plan2_response_2 is starting this frame...
            if plan2_response_2.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
                # keep track of start time/frame for later
                plan2_response_2.frameNStart = frameN  # exact frame index
                plan2_response_2.tStart = t  # local t and not account for scr refresh
                plan2_response_2.tStartRefresh = tThisFlipGlobal  # on global time
                win.timeOnFlip(plan2_response_2, 'tStartRefresh')  # time at next scr refresh
                # add timestamp to datafile
                thisExp.timestampOnFlip(win, 'plan2_response_2.started')
                # update status
                plan2_response_2.status = STARTED
                # keyboard checking is just starting
                waitOnFlip = True
                win.callOnFlip(plan2_response_2.clock.reset)  # t=0 on next screen flip
                win.callOnFlip(plan2_response_2.clearEvents, eventType='keyboard')  # clear events on next screen flip
            
            # if plan2_response_2 is stopping this frame...
            if plan2_response_2.status == STARTED:
                # is it time to stop? (based on global clock, using actual start)
                if tThisFlipGlobal > plan2_response_2.tStartRefresh + 30.0-frameTolerance:
                    # keep track of stop time/frame for later
                    plan2_response_2.tStop = t  # not accounting for scr refresh
                    plan2_response_2.tStopRefresh = tThisFlipGlobal  # on global time
                    plan2_response_2.frameNStop = frameN  # exact frame index
                    # add timestamp to datafile
                    thisExp.timestampOnFlip(win, 'plan2_response_2.stopped')
                    # update status
                    plan2_response_2.status = FINISHED
                    plan2_response_2.status = FINISHED
            if plan2_response_2.status == STARTED and not waitOnFlip:
                theseKeys = plan2_response_2.getKeys(keyList=['left', 'right','space'], ignoreKeys=["escape"], waitRelease=False)
                _plan2_response_2_allKeys.extend(theseKeys)
                if len(_plan2_response_2_allKeys):
                    plan2_response_2.keys = _plan2_response_2_allKeys[-1].name  # just the last key pressed
                    plan2_response_2.rt = _plan2_response_2_allKeys[-1].rt
                    plan2_response_2.duration = _plan2_response_2_allKeys[-1].duration
                    # a response ends the routine
                    continueRoutine = False
            
            # *current_image_decision2_2* updates
            
            # if current_image_decision2_2 is starting this frame...
            if current_image_decision2_2.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
                # keep track of start time/frame for later
                current_image_decision2_2.frameNStart = frameN  # exact frame index
                current_image_decision2_2.tStart = t  # local t and not account for scr refresh
                current_image_decision2_2.tStartRefresh = tThisFlipGlobal  # on global time
                win.timeOnFlip(current_image_decision2_2, 'tStartRefresh')  # time at next scr refresh
                # add timestamp to datafile
                thisExp.timestampOnFlip(win, 'current_image_decision2_2.started')
                # update status
                current_image_decision2_2.status = STARTED
                current_image_decision2_2.setAutoDraw(True)
            
            # if current_image_decision2_2 is active this frame...
            if current_image_decision2_2.status == STARTED:
                # update params
                pass
            
            # if current_image_decision2_2 is stopping this frame...
            if current_image_decision2_2.status == STARTED:
                # is it time to stop? (based on global clock, using actual start)
                if tThisFlipGlobal > current_image_decision2_2.tStartRefresh + 30.0-frameTolerance:
                    # keep track of stop time/frame for later
                    current_image_decision2_2.tStop = t  # not accounting for scr refresh
                    current_image_decision2_2.tStopRefresh = tThisFlipGlobal  # on global time
                    current_image_decision2_2.frameNStop = frameN  # exact frame index
                    # add timestamp to datafile
                    thisExp.timestampOnFlip(win, 'current_image_decision2_2.stopped')
                    # update status
                    current_image_decision2_2.status = FINISHED
                    current_image_decision2_2.setAutoDraw(False)
            
            # check for quit (typically the Esc key)
            if defaultKeyboard.getKeys(keyList=["escape"]):
                thisExp.status = FINISHED
            if thisExp.status == FINISHED or endExpNow:
                endExperiment(thisExp, win=win)
                return
            # pause experiment here if requested
            if thisExp.status == PAUSED:
                pauseExperiment(
                    thisExp=thisExp, 
                    win=win, 
                    timers=[routineTimer], 
                    playbackComponents=[]
                )
                # skip the frame we paused on
                continue
            
            # check if all components have finished
            if not continueRoutine:  # a component has requested a forced-end of Routine
                instructions_example_trial.forceEnded = routineForceEnded = True
                break
            continueRoutine = False  # will revert to True if at least one component still running
            for thisComponent in instructions_example_trial.components:
                if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:
                    continueRoutine = True
                    break  # at least one component has not yet finished
            
            # refresh the screen
            if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen
                win.flip()
        
        # --- Ending Routine "instructions_example_trial" ---
        for thisComponent in instructions_example_trial.components:
            if hasattr(thisComponent, "setAutoDraw"):
                thisComponent.setAutoDraw(False)
        # store stop times for instructions_example_trial
        instructions_example_trial.tStop = globalClock.getTime(format='float')
        instructions_example_trial.tStopRefresh = tThisFlipGlobal
        thisExp.addData('instructions_example_trial.stopped', instructions_example_trial.tStop)
        # check responses
        if plan2_response_2.keys in ['', [], None]:  # No response was made
            plan2_response_2.keys = None
        instructions_planning_get_right.addData('plan2_response_2.keys',plan2_response_2.keys)
        if plan2_response_2.keys != None:  # we had a response
            instructions_planning_get_right.addData('plan2_response_2.rt', plan2_response_2.rt)
            instructions_planning_get_right.addData('plan2_response_2.duration', plan2_response_2.duration)
        # using non-slip timing so subtract the expected duration of this Routine (unless ended on request)
        if instructions_example_trial.maxDurationReached:
            routineTimer.addTime(-instructions_example_trial.maxDuration)
        elif instructions_example_trial.forceEnded:
            routineTimer.reset()
        else:
            routineTimer.addTime(-30.000000)
        
        # --- Prepare to start Routine "long_term_reward_instructions" ---
        # create an object to store info about Routine long_term_reward_instructions
        long_term_reward_instructions = data.Routine(
            name='long_term_reward_instructions',
            components=[instructions_rewardstage_2, key_resp_12, text_45],
        )
        long_term_reward_instructions.status = NOT_STARTED
        continueRoutine = True
        # update component parameters for each repeat
        # create starting attributes for key_resp_12
        key_resp_12.keys = []
        key_resp_12.rt = []
        _key_resp_12_allKeys = []
        # store start times for long_term_reward_instructions
        long_term_reward_instructions.tStartRefresh = win.getFutureFlipTime(clock=globalClock)
        long_term_reward_instructions.tStart = globalClock.getTime(format='float')
        long_term_reward_instructions.status = STARTED
        thisExp.addData('long_term_reward_instructions.started', long_term_reward_instructions.tStart)
        long_term_reward_instructions.maxDuration = None
        # keep track of which components have finished
        long_term_reward_instructionsComponents = long_term_reward_instructions.components
        for thisComponent in long_term_reward_instructions.components:
            thisComponent.tStart = None
            thisComponent.tStop = None
            thisComponent.tStartRefresh = None
            thisComponent.tStopRefresh = None
            if hasattr(thisComponent, 'status'):
                thisComponent.status = NOT_STARTED
        # reset timers
        t = 0
        _timeToFirstFrame = win.getFutureFlipTime(clock="now")
        frameN = -1
        
        # --- Run Routine "long_term_reward_instructions" ---
        # if trial has changed, end Routine now
        if isinstance(instructions_planning_get_right, data.TrialHandler2) and thisInstructions_planning_get_right.thisN != instructions_planning_get_right.thisTrial.thisN:
            continueRoutine = False
        long_term_reward_instructions.forceEnded = routineForceEnded = not continueRoutine
        while continueRoutine:
            # get current time
            t = routineTimer.getTime()
            tThisFlip = win.getFutureFlipTime(clock=routineTimer)
            tThisFlipGlobal = win.getFutureFlipTime(clock=None)
            frameN = frameN + 1  # number of completed frames (so 0 is the first frame)
            # update/draw components on each frame
            
            # *instructions_rewardstage_2* updates
            
            # if instructions_rewardstage_2 is starting this frame...
            if instructions_rewardstage_2.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
                # keep track of start time/frame for later
                instructions_rewardstage_2.frameNStart = frameN  # exact frame index
                instructions_rewardstage_2.tStart = t  # local t and not account for scr refresh
                instructions_rewardstage_2.tStartRefresh = tThisFlipGlobal  # on global time
                win.timeOnFlip(instructions_rewardstage_2, 'tStartRefresh')  # time at next scr refresh
                # add timestamp to datafile
                thisExp.timestampOnFlip(win, 'instructions_rewardstage_2.started')
                # update status
                instructions_rewardstage_2.status = STARTED
                instructions_rewardstage_2.setAutoDraw(True)
            
            # if instructions_rewardstage_2 is active this frame...
            if instructions_rewardstage_2.status == STARTED:
                # update params
                pass
            
            # *key_resp_12* updates
            waitOnFlip = False
            
            # if key_resp_12 is starting this frame...
            if key_resp_12.status == NOT_STARTED and tThisFlip >= 10.0-frameTolerance:
                # keep track of start time/frame for later
                key_resp_12.frameNStart = frameN  # exact frame index
                key_resp_12.tStart = t  # local t and not account for scr refresh
                key_resp_12.tStartRefresh = tThisFlipGlobal  # on global time
                win.timeOnFlip(key_resp_12, 'tStartRefresh')  # time at next scr refresh
                # add timestamp to datafile
                thisExp.timestampOnFlip(win, 'key_resp_12.started')
                # update status
                key_resp_12.status = STARTED
                # keyboard checking is just starting
                waitOnFlip = True
                win.callOnFlip(key_resp_12.clock.reset)  # t=0 on next screen flip
                win.callOnFlip(key_resp_12.clearEvents, eventType='keyboard')  # clear events on next screen flip
            if key_resp_12.status == STARTED and not waitOnFlip:
                theseKeys = key_resp_12.getKeys(keyList=['space'], ignoreKeys=["escape"], waitRelease=False)
                _key_resp_12_allKeys.extend(theseKeys)
                if len(_key_resp_12_allKeys):
                    key_resp_12.keys = _key_resp_12_allKeys[-1].name  # just the last key pressed
                    key_resp_12.rt = _key_resp_12_allKeys[-1].rt
                    key_resp_12.duration = _key_resp_12_allKeys[-1].duration
                    # a response ends the routine
                    continueRoutine = False
            
            # *text_45* updates
            
            # if text_45 is starting this frame...
            if text_45.status == NOT_STARTED and tThisFlip >= 10.0-frameTolerance:
                # keep track of start time/frame for later
                text_45.frameNStart = frameN  # exact frame index
                text_45.tStart = t  # local t and not account for scr refresh
                text_45.tStartRefresh = tThisFlipGlobal  # on global time
                win.timeOnFlip(text_45, 'tStartRefresh')  # time at next scr refresh
                # add timestamp to datafile
                thisExp.timestampOnFlip(win, 'text_45.started')
                # update status
                text_45.status = STARTED
                text_45.setAutoDraw(True)
            
            # if text_45 is active this frame...
            if text_45.status == STARTED:
                # update params
                pass
            
            # check for quit (typically the Esc key)
            if defaultKeyboard.getKeys(keyList=["escape"]):
                thisExp.status = FINISHED
            if thisExp.status == FINISHED or endExpNow:
                endExperiment(thisExp, win=win)
                return
            # pause experiment here if requested
            if thisExp.status == PAUSED:
                pauseExperiment(
                    thisExp=thisExp, 
                    win=win, 
                    timers=[routineTimer], 
                    playbackComponents=[]
                )
                # skip the frame we paused on
                continue
            
            # check if all components have finished
            if not continueRoutine:  # a component has requested a forced-end of Routine
                long_term_reward_instructions.forceEnded = routineForceEnded = True
                break
            continueRoutine = False  # will revert to True if at least one component still running
            for thisComponent in long_term_reward_instructions.components:
                if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:
                    continueRoutine = True
                    break  # at least one component has not yet finished
            
            # refresh the screen
            if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen
                win.flip()
        
        # --- Ending Routine "long_term_reward_instructions" ---
        for thisComponent in long_term_reward_instructions.components:
            if hasattr(thisComponent, "setAutoDraw"):
                thisComponent.setAutoDraw(False)
        # store stop times for long_term_reward_instructions
        long_term_reward_instructions.tStop = globalClock.getTime(format='float')
        long_term_reward_instructions.tStopRefresh = tThisFlipGlobal
        thisExp.addData('long_term_reward_instructions.stopped', long_term_reward_instructions.tStop)
        # the Routine "long_term_reward_instructions" was not non-slip safe, so reset the non-slip timer
        routineTimer.reset()
        
        # --- Prepare to start Routine "quiz_planning_1" ---
        # create an object to store info about Routine quiz_planning_1
        quiz_planning_1 = data.Routine(
            name='quiz_planning_1',
            components=[text_47, key_resp_21],
        )
        quiz_planning_1.status = NOT_STARTED
        continueRoutine = True
        # update component parameters for each repeat
        # create starting attributes for key_resp_21
        key_resp_21.keys = []
        key_resp_21.rt = []
        _key_resp_21_allKeys = []
        # store start times for quiz_planning_1
        quiz_planning_1.tStartRefresh = win.getFutureFlipTime(clock=globalClock)
        quiz_planning_1.tStart = globalClock.getTime(format='float')
        quiz_planning_1.status = STARTED
        thisExp.addData('quiz_planning_1.started', quiz_planning_1.tStart)
        quiz_planning_1.maxDuration = None
        # keep track of which components have finished
        quiz_planning_1Components = quiz_planning_1.components
        for thisComponent in quiz_planning_1.components:
            thisComponent.tStart = None
            thisComponent.tStop = None
            thisComponent.tStartRefresh = None
            thisComponent.tStopRefresh = None
            if hasattr(thisComponent, 'status'):
                thisComponent.status = NOT_STARTED
        # reset timers
        t = 0
        _timeToFirstFrame = win.getFutureFlipTime(clock="now")
        frameN = -1
        
        # --- Run Routine "quiz_planning_1" ---
        # if trial has changed, end Routine now
        if isinstance(instructions_planning_get_right, data.TrialHandler2) and thisInstructions_planning_get_right.thisN != instructions_planning_get_right.thisTrial.thisN:
            continueRoutine = False
        quiz_planning_1.forceEnded = routineForceEnded = not continueRoutine
        while continueRoutine:
            # get current time
            t = routineTimer.getTime()
            tThisFlip = win.getFutureFlipTime(clock=routineTimer)
            tThisFlipGlobal = win.getFutureFlipTime(clock=None)
            frameN = frameN + 1  # number of completed frames (so 0 is the first frame)
            # update/draw components on each frame
            
            # *text_47* updates
            
            # if text_47 is starting this frame...
            if text_47.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
                # keep track of start time/frame for later
                text_47.frameNStart = frameN  # exact frame index
                text_47.tStart = t  # local t and not account for scr refresh
                text_47.tStartRefresh = tThisFlipGlobal  # on global time
                win.timeOnFlip(text_47, 'tStartRefresh')  # time at next scr refresh
                # add timestamp to datafile
                thisExp.timestampOnFlip(win, 'text_47.started')
                # update status
                text_47.status = STARTED
                text_47.setAutoDraw(True)
            
            # if text_47 is active this frame...
            if text_47.status == STARTED:
                # update params
                pass
            
            # *key_resp_21* updates
            waitOnFlip = False
            
            # if key_resp_21 is starting this frame...
            if key_resp_21.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
                # keep track of start time/frame for later
                key_resp_21.frameNStart = frameN  # exact frame index
                key_resp_21.tStart = t  # local t and not account for scr refresh
                key_resp_21.tStartRefresh = tThisFlipGlobal  # on global time
                win.timeOnFlip(key_resp_21, 'tStartRefresh')  # time at next scr refresh
                # add timestamp to datafile
                thisExp.timestampOnFlip(win, 'key_resp_21.started')
                # update status
                key_resp_21.status = STARTED
                # keyboard checking is just starting
                waitOnFlip = True
                win.callOnFlip(key_resp_21.clock.reset)  # t=0 on next screen flip
                win.callOnFlip(key_resp_21.clearEvents, eventType='keyboard')  # clear events on next screen flip
            if key_resp_21.status == STARTED and not waitOnFlip:
                theseKeys = key_resp_21.getKeys(keyList=['a','b','c','d'], ignoreKeys=["escape"], waitRelease=False)
                _key_resp_21_allKeys.extend(theseKeys)
                if len(_key_resp_21_allKeys):
                    key_resp_21.keys = _key_resp_21_allKeys[-1].name  # just the last key pressed
                    key_resp_21.rt = _key_resp_21_allKeys[-1].rt
                    key_resp_21.duration = _key_resp_21_allKeys[-1].duration
                    # a response ends the routine
                    continueRoutine = False
            
            # check for quit (typically the Esc key)
            if defaultKeyboard.getKeys(keyList=["escape"]):
                thisExp.status = FINISHED
            if thisExp.status == FINISHED or endExpNow:
                endExperiment(thisExp, win=win)
                return
            # pause experiment here if requested
            if thisExp.status == PAUSED:
                pauseExperiment(
                    thisExp=thisExp, 
                    win=win, 
                    timers=[routineTimer], 
                    playbackComponents=[]
                )
                # skip the frame we paused on
                continue
            
            # check if all components have finished
            if not continueRoutine:  # a component has requested a forced-end of Routine
                quiz_planning_1.forceEnded = routineForceEnded = True
                break
            continueRoutine = False  # will revert to True if at least one component still running
            for thisComponent in quiz_planning_1.components:
                if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:
                    continueRoutine = True
                    break  # at least one component has not yet finished
            
            # refresh the screen
            if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen
                win.flip()
        
        # --- Ending Routine "quiz_planning_1" ---
        for thisComponent in quiz_planning_1.components:
            if hasattr(thisComponent, "setAutoDraw"):
                thisComponent.setAutoDraw(False)
        # store stop times for quiz_planning_1
        quiz_planning_1.tStop = globalClock.getTime(format='float')
        quiz_planning_1.tStopRefresh = tThisFlipGlobal
        thisExp.addData('quiz_planning_1.stopped', quiz_planning_1.tStop)
        # Run 'End Routine' code from code_28
        correct=0
        if key_resp_21.keys=='c':
            correct+=1
        # check responses
        if key_resp_21.keys in ['', [], None]:  # No response was made
            key_resp_21.keys = None
        instructions_planning_get_right.addData('key_resp_21.keys',key_resp_21.keys)
        if key_resp_21.keys != None:  # we had a response
            instructions_planning_get_right.addData('key_resp_21.rt', key_resp_21.rt)
            instructions_planning_get_right.addData('key_resp_21.duration', key_resp_21.duration)
        # the Routine "quiz_planning_1" was not non-slip safe, so reset the non-slip timer
        routineTimer.reset()
        
        # --- Prepare to start Routine "quiz_planning_2" ---
        # create an object to store info about Routine quiz_planning_2
        quiz_planning_2 = data.Routine(
            name='quiz_planning_2',
            components=[text_73, key_resp_22],
        )
        quiz_planning_2.status = NOT_STARTED
        continueRoutine = True
        # update component parameters for each repeat
        # create starting attributes for key_resp_22
        key_resp_22.keys = []
        key_resp_22.rt = []
        _key_resp_22_allKeys = []
        # store start times for quiz_planning_2
        quiz_planning_2.tStartRefresh = win.getFutureFlipTime(clock=globalClock)
        quiz_planning_2.tStart = globalClock.getTime(format='float')
        quiz_planning_2.status = STARTED
        thisExp.addData('quiz_planning_2.started', quiz_planning_2.tStart)
        quiz_planning_2.maxDuration = None
        # keep track of which components have finished
        quiz_planning_2Components = quiz_planning_2.components
        for thisComponent in quiz_planning_2.components:
            thisComponent.tStart = None
            thisComponent.tStop = None
            thisComponent.tStartRefresh = None
            thisComponent.tStopRefresh = None
            if hasattr(thisComponent, 'status'):
                thisComponent.status = NOT_STARTED
        # reset timers
        t = 0
        _timeToFirstFrame = win.getFutureFlipTime(clock="now")
        frameN = -1
        
        # --- Run Routine "quiz_planning_2" ---
        # if trial has changed, end Routine now
        if isinstance(instructions_planning_get_right, data.TrialHandler2) and thisInstructions_planning_get_right.thisN != instructions_planning_get_right.thisTrial.thisN:
            continueRoutine = False
        quiz_planning_2.forceEnded = routineForceEnded = not continueRoutine
        while continueRoutine:
            # get current time
            t = routineTimer.getTime()
            tThisFlip = win.getFutureFlipTime(clock=routineTimer)
            tThisFlipGlobal = win.getFutureFlipTime(clock=None)
            frameN = frameN + 1  # number of completed frames (so 0 is the first frame)
            # update/draw components on each frame
            
            # *text_73* updates
            
            # if text_73 is starting this frame...
            if text_73.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
                # keep track of start time/frame for later
                text_73.frameNStart = frameN  # exact frame index
                text_73.tStart = t  # local t and not account for scr refresh
                text_73.tStartRefresh = tThisFlipGlobal  # on global time
                win.timeOnFlip(text_73, 'tStartRefresh')  # time at next scr refresh
                # add timestamp to datafile
                thisExp.timestampOnFlip(win, 'text_73.started')
                # update status
                text_73.status = STARTED
                text_73.setAutoDraw(True)
            
            # if text_73 is active this frame...
            if text_73.status == STARTED:
                # update params
                pass
            
            # *key_resp_22* updates
            waitOnFlip = False
            
            # if key_resp_22 is starting this frame...
            if key_resp_22.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
                # keep track of start time/frame for later
                key_resp_22.frameNStart = frameN  # exact frame index
                key_resp_22.tStart = t  # local t and not account for scr refresh
                key_resp_22.tStartRefresh = tThisFlipGlobal  # on global time
                win.timeOnFlip(key_resp_22, 'tStartRefresh')  # time at next scr refresh
                # add timestamp to datafile
                thisExp.timestampOnFlip(win, 'key_resp_22.started')
                # update status
                key_resp_22.status = STARTED
                # keyboard checking is just starting
                waitOnFlip = True
                win.callOnFlip(key_resp_22.clock.reset)  # t=0 on next screen flip
                win.callOnFlip(key_resp_22.clearEvents, eventType='keyboard')  # clear events on next screen flip
            if key_resp_22.status == STARTED and not waitOnFlip:
                theseKeys = key_resp_22.getKeys(keyList=['a','b','c','d'], ignoreKeys=["escape"], waitRelease=False)
                _key_resp_22_allKeys.extend(theseKeys)
                if len(_key_resp_22_allKeys):
                    key_resp_22.keys = _key_resp_22_allKeys[-1].name  # just the last key pressed
                    key_resp_22.rt = _key_resp_22_allKeys[-1].rt
                    key_resp_22.duration = _key_resp_22_allKeys[-1].duration
                    # a response ends the routine
                    continueRoutine = False
            
            # check for quit (typically the Esc key)
            if defaultKeyboard.getKeys(keyList=["escape"]):
                thisExp.status = FINISHED
            if thisExp.status == FINISHED or endExpNow:
                endExperiment(thisExp, win=win)
                return
            # pause experiment here if requested
            if thisExp.status == PAUSED:
                pauseExperiment(
                    thisExp=thisExp, 
                    win=win, 
                    timers=[routineTimer], 
                    playbackComponents=[]
                )
                # skip the frame we paused on
                continue
            
            # check if all components have finished
            if not continueRoutine:  # a component has requested a forced-end of Routine
                quiz_planning_2.forceEnded = routineForceEnded = True
                break
            continueRoutine = False  # will revert to True if at least one component still running
            for thisComponent in quiz_planning_2.components:
                if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:
                    continueRoutine = True
                    break  # at least one component has not yet finished
            
            # refresh the screen
            if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen
                win.flip()
        
        # --- Ending Routine "quiz_planning_2" ---
        for thisComponent in quiz_planning_2.components:
            if hasattr(thisComponent, "setAutoDraw"):
                thisComponent.setAutoDraw(False)
        # store stop times for quiz_planning_2
        quiz_planning_2.tStop = globalClock.getTime(format='float')
        quiz_planning_2.tStopRefresh = tThisFlipGlobal
        thisExp.addData('quiz_planning_2.stopped', quiz_planning_2.tStop)
        # Run 'End Routine' code from code_32
        if key_resp_22.keys=='b':
            correct+=1
        
        # check responses
        if key_resp_22.keys in ['', [], None]:  # No response was made
            key_resp_22.keys = None
        instructions_planning_get_right.addData('key_resp_22.keys',key_resp_22.keys)
        if key_resp_22.keys != None:  # we had a response
            instructions_planning_get_right.addData('key_resp_22.rt', key_resp_22.rt)
            instructions_planning_get_right.addData('key_resp_22.duration', key_resp_22.duration)
        # the Routine "quiz_planning_2" was not non-slip safe, so reset the non-slip timer
        routineTimer.reset()
        
        # --- Prepare to start Routine "quiz_planning_3" ---
        # create an object to store info about Routine quiz_planning_3
        quiz_planning_3 = data.Routine(
            name='quiz_planning_3',
            components=[text_74, key_resp_24],
        )
        quiz_planning_3.status = NOT_STARTED
        continueRoutine = True
        # update component parameters for each repeat
        # create starting attributes for key_resp_24
        key_resp_24.keys = []
        key_resp_24.rt = []
        _key_resp_24_allKeys = []
        # store start times for quiz_planning_3
        quiz_planning_3.tStartRefresh = win.getFutureFlipTime(clock=globalClock)
        quiz_planning_3.tStart = globalClock.getTime(format='float')
        quiz_planning_3.status = STARTED
        thisExp.addData('quiz_planning_3.started', quiz_planning_3.tStart)
        quiz_planning_3.maxDuration = None
        # keep track of which components have finished
        quiz_planning_3Components = quiz_planning_3.components
        for thisComponent in quiz_planning_3.components:
            thisComponent.tStart = None
            thisComponent.tStop = None
            thisComponent.tStartRefresh = None
            thisComponent.tStopRefresh = None
            if hasattr(thisComponent, 'status'):
                thisComponent.status = NOT_STARTED
        # reset timers
        t = 0
        _timeToFirstFrame = win.getFutureFlipTime(clock="now")
        frameN = -1
        
        # --- Run Routine "quiz_planning_3" ---
        # if trial has changed, end Routine now
        if isinstance(instructions_planning_get_right, data.TrialHandler2) and thisInstructions_planning_get_right.thisN != instructions_planning_get_right.thisTrial.thisN:
            continueRoutine = False
        quiz_planning_3.forceEnded = routineForceEnded = not continueRoutine
        while continueRoutine:
            # get current time
            t = routineTimer.getTime()
            tThisFlip = win.getFutureFlipTime(clock=routineTimer)
            tThisFlipGlobal = win.getFutureFlipTime(clock=None)
            frameN = frameN + 1  # number of completed frames (so 0 is the first frame)
            # update/draw components on each frame
            
            # *text_74* updates
            
            # if text_74 is starting this frame...
            if text_74.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
                # keep track of start time/frame for later
                text_74.frameNStart = frameN  # exact frame index
                text_74.tStart = t  # local t and not account for scr refresh
                text_74.tStartRefresh = tThisFlipGlobal  # on global time
                win.timeOnFlip(text_74, 'tStartRefresh')  # time at next scr refresh
                # add timestamp to datafile
                thisExp.timestampOnFlip(win, 'text_74.started')
                # update status
                text_74.status = STARTED
                text_74.setAutoDraw(True)
            
            # if text_74 is active this frame...
            if text_74.status == STARTED:
                # update params
                pass
            
            # *key_resp_24* updates
            waitOnFlip = False
            
            # if key_resp_24 is starting this frame...
            if key_resp_24.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
                # keep track of start time/frame for later
                key_resp_24.frameNStart = frameN  # exact frame index
                key_resp_24.tStart = t  # local t and not account for scr refresh
                key_resp_24.tStartRefresh = tThisFlipGlobal  # on global time
                win.timeOnFlip(key_resp_24, 'tStartRefresh')  # time at next scr refresh
                # add timestamp to datafile
                thisExp.timestampOnFlip(win, 'key_resp_24.started')
                # update status
                key_resp_24.status = STARTED
                # keyboard checking is just starting
                waitOnFlip = True
                win.callOnFlip(key_resp_24.clock.reset)  # t=0 on next screen flip
                win.callOnFlip(key_resp_24.clearEvents, eventType='keyboard')  # clear events on next screen flip
            if key_resp_24.status == STARTED and not waitOnFlip:
                theseKeys = key_resp_24.getKeys(keyList=['a','b','c','d'], ignoreKeys=["escape"], waitRelease=False)
                _key_resp_24_allKeys.extend(theseKeys)
                if len(_key_resp_24_allKeys):
                    key_resp_24.keys = _key_resp_24_allKeys[-1].name  # just the last key pressed
                    key_resp_24.rt = _key_resp_24_allKeys[-1].rt
                    key_resp_24.duration = _key_resp_24_allKeys[-1].duration
                    # a response ends the routine
                    continueRoutine = False
            
            # check for quit (typically the Esc key)
            if defaultKeyboard.getKeys(keyList=["escape"]):
                thisExp.status = FINISHED
            if thisExp.status == FINISHED or endExpNow:
                endExperiment(thisExp, win=win)
                return
            # pause experiment here if requested
            if thisExp.status == PAUSED:
                pauseExperiment(
                    thisExp=thisExp, 
                    win=win, 
                    timers=[routineTimer], 
                    playbackComponents=[]
                )
                # skip the frame we paused on
                continue
            
            # check if all components have finished
            if not continueRoutine:  # a component has requested a forced-end of Routine
                quiz_planning_3.forceEnded = routineForceEnded = True
                break
            continueRoutine = False  # will revert to True if at least one component still running
            for thisComponent in quiz_planning_3.components:
                if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:
                    continueRoutine = True
                    break  # at least one component has not yet finished
            
            # refresh the screen
            if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen
                win.flip()
        
        # --- Ending Routine "quiz_planning_3" ---
        for thisComponent in quiz_planning_3.components:
            if hasattr(thisComponent, "setAutoDraw"):
                thisComponent.setAutoDraw(False)
        # store stop times for quiz_planning_3
        quiz_planning_3.tStop = globalClock.getTime(format='float')
        quiz_planning_3.tStopRefresh = tThisFlipGlobal
        thisExp.addData('quiz_planning_3.stopped', quiz_planning_3.tStop)
        # Run 'End Routine' code from code_36
        if key_resp_24.keys=='b':
            correct+=1
        
        if correct==3:
            instructions_planning_get_right.finished = True
            msg='Correct! You can now move on'
        else:
            msg='Incorrect! You need to repeat the instructions.'
        # check responses
        if key_resp_24.keys in ['', [], None]:  # No response was made
            key_resp_24.keys = None
        instructions_planning_get_right.addData('key_resp_24.keys',key_resp_24.keys)
        if key_resp_24.keys != None:  # we had a response
            instructions_planning_get_right.addData('key_resp_24.rt', key_resp_24.rt)
            instructions_planning_get_right.addData('key_resp_24.duration', key_resp_24.duration)
        # the Routine "quiz_planning_3" was not non-slip safe, so reset the non-slip timer
        routineTimer.reset()
        
        # --- Prepare to start Routine "quiz_feedback" ---
        # create an object to store info about Routine quiz_feedback
        quiz_feedback = data.Routine(
            name='quiz_feedback',
            components=[result_q_instr],
        )
        quiz_feedback.status = NOT_STARTED
        continueRoutine = True
        # update component parameters for each repeat
        result_q_instr.setText(msg)
        # store start times for quiz_feedback
        quiz_feedback.tStartRefresh = win.getFutureFlipTime(clock=globalClock)
        quiz_feedback.tStart = globalClock.getTime(format='float')
        quiz_feedback.status = STARTED
        thisExp.addData('quiz_feedback.started', quiz_feedback.tStart)
        quiz_feedback.maxDuration = None
        # keep track of which components have finished
        quiz_feedbackComponents = quiz_feedback.components
        for thisComponent in quiz_feedback.components:
            thisComponent.tStart = None
            thisComponent.tStop = None
            thisComponent.tStartRefresh = None
            thisComponent.tStopRefresh = None
            if hasattr(thisComponent, 'status'):
                thisComponent.status = NOT_STARTED
        # reset timers
        t = 0
        _timeToFirstFrame = win.getFutureFlipTime(clock="now")
        frameN = -1
        
        # --- Run Routine "quiz_feedback" ---
        # if trial has changed, end Routine now
        if isinstance(instructions_planning_get_right, data.TrialHandler2) and thisInstructions_planning_get_right.thisN != instructions_planning_get_right.thisTrial.thisN:
            continueRoutine = False
        quiz_feedback.forceEnded = routineForceEnded = not continueRoutine
        while continueRoutine and routineTimer.getTime() < 1.25:
            # get current time
            t = routineTimer.getTime()
            tThisFlip = win.getFutureFlipTime(clock=routineTimer)
            tThisFlipGlobal = win.getFutureFlipTime(clock=None)
            frameN = frameN + 1  # number of completed frames (so 0 is the first frame)
            # update/draw components on each frame
            
            # *result_q_instr* updates
            
            # if result_q_instr is starting this frame...
            if result_q_instr.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
                # keep track of start time/frame for later
                result_q_instr.frameNStart = frameN  # exact frame index
                result_q_instr.tStart = t  # local t and not account for scr refresh
                result_q_instr.tStartRefresh = tThisFlipGlobal  # on global time
                win.timeOnFlip(result_q_instr, 'tStartRefresh')  # time at next scr refresh
                # add timestamp to datafile
                thisExp.timestampOnFlip(win, 'result_q_instr.started')
                # update status
                result_q_instr.status = STARTED
                result_q_instr.setAutoDraw(True)
            
            # if result_q_instr is active this frame...
            if result_q_instr.status == STARTED:
                # update params
                pass
            
            # if result_q_instr is stopping this frame...
            if result_q_instr.status == STARTED:
                # is it time to stop? (based on global clock, using actual start)
                if tThisFlipGlobal > result_q_instr.tStartRefresh + 1.25-frameTolerance:
                    # keep track of stop time/frame for later
                    result_q_instr.tStop = t  # not accounting for scr refresh
                    result_q_instr.tStopRefresh = tThisFlipGlobal  # on global time
                    result_q_instr.frameNStop = frameN  # exact frame index
                    # add timestamp to datafile
                    thisExp.timestampOnFlip(win, 'result_q_instr.stopped')
                    # update status
                    result_q_instr.status = FINISHED
                    result_q_instr.setAutoDraw(False)
            
            # check for quit (typically the Esc key)
            if defaultKeyboard.getKeys(keyList=["escape"]):
                thisExp.status = FINISHED
            if thisExp.status == FINISHED or endExpNow:
                endExperiment(thisExp, win=win)
                return
            # pause experiment here if requested
            if thisExp.status == PAUSED:
                pauseExperiment(
                    thisExp=thisExp, 
                    win=win, 
                    timers=[routineTimer], 
                    playbackComponents=[]
                )
                # skip the frame we paused on
                continue
            
            # check if all components have finished
            if not continueRoutine:  # a component has requested a forced-end of Routine
                quiz_feedback.forceEnded = routineForceEnded = True
                break
            continueRoutine = False  # will revert to True if at least one component still running
            for thisComponent in quiz_feedback.components:
                if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:
                    continueRoutine = True
                    break  # at least one component has not yet finished
            
            # refresh the screen
            if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen
                win.flip()
        
        # --- Ending Routine "quiz_feedback" ---
        for thisComponent in quiz_feedback.components:
            if hasattr(thisComponent, "setAutoDraw"):
                thisComponent.setAutoDraw(False)
        # store stop times for quiz_feedback
        quiz_feedback.tStop = globalClock.getTime(format='float')
        quiz_feedback.tStopRefresh = tThisFlipGlobal
        thisExp.addData('quiz_feedback.stopped', quiz_feedback.tStop)
        # using non-slip timing so subtract the expected duration of this Routine (unless ended on request)
        if quiz_feedback.maxDurationReached:
            routineTimer.addTime(-quiz_feedback.maxDuration)
        elif quiz_feedback.forceEnded:
            routineTimer.reset()
        else:
            routineTimer.addTime(-1.250000)
        thisExp.nextEntry()
        
    # completed 999.0 repeats of 'instructions_planning_get_right'
    
    if thisSession is not None:
        # if running in a Session with a Liaison client, send data up to now
        thisSession.sendExperimentData()
    
    # --- Prepare to start Routine "see_planning_trials" ---
    # create an object to store info about Routine see_planning_trials
    see_planning_trials = data.Routine(
        name='see_planning_trials',
        components=[text_48, key_resp_8],
    )
    see_planning_trials.status = NOT_STARTED
    continueRoutine = True
    # update component parameters for each repeat
    # create starting attributes for key_resp_8
    key_resp_8.keys = []
    key_resp_8.rt = []
    _key_resp_8_allKeys = []
    # Run 'Begin Routine' code from code_12
    total_practice_planning=0
    w2=400
    # store start times for see_planning_trials
    see_planning_trials.tStartRefresh = win.getFutureFlipTime(clock=globalClock)
    see_planning_trials.tStart = globalClock.getTime(format='float')
    see_planning_trials.status = STARTED
    thisExp.addData('see_planning_trials.started', see_planning_trials.tStart)
    see_planning_trials.maxDuration = None
    # keep track of which components have finished
    see_planning_trialsComponents = see_planning_trials.components
    for thisComponent in see_planning_trials.components:
        thisComponent.tStart = None
        thisComponent.tStop = None
        thisComponent.tStartRefresh = None
        thisComponent.tStopRefresh = None
        if hasattr(thisComponent, 'status'):
            thisComponent.status = NOT_STARTED
    # reset timers
    t = 0
    _timeToFirstFrame = win.getFutureFlipTime(clock="now")
    frameN = -1
    
    # --- Run Routine "see_planning_trials" ---
    see_planning_trials.forceEnded = routineForceEnded = not continueRoutine
    while continueRoutine:
        # get current time
        t = routineTimer.getTime()
        tThisFlip = win.getFutureFlipTime(clock=routineTimer)
        tThisFlipGlobal = win.getFutureFlipTime(clock=None)
        frameN = frameN + 1  # number of completed frames (so 0 is the first frame)
        # update/draw components on each frame
        
        # *text_48* updates
        
        # if text_48 is starting this frame...
        if text_48.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
            # keep track of start time/frame for later
            text_48.frameNStart = frameN  # exact frame index
            text_48.tStart = t  # local t and not account for scr refresh
            text_48.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(text_48, 'tStartRefresh')  # time at next scr refresh
            # add timestamp to datafile
            thisExp.timestampOnFlip(win, 'text_48.started')
            # update status
            text_48.status = STARTED
            text_48.setAutoDraw(True)
        
        # if text_48 is active this frame...
        if text_48.status == STARTED:
            # update params
            pass
        
        # *key_resp_8* updates
        waitOnFlip = False
        
        # if key_resp_8 is starting this frame...
        if key_resp_8.status == NOT_STARTED and tThisFlip >= 0-frameTolerance:
            # keep track of start time/frame for later
            key_resp_8.frameNStart = frameN  # exact frame index
            key_resp_8.tStart = t  # local t and not account for scr refresh
            key_resp_8.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(key_resp_8, 'tStartRefresh')  # time at next scr refresh
            # add timestamp to datafile
            thisExp.timestampOnFlip(win, 'key_resp_8.started')
            # update status
            key_resp_8.status = STARTED
            # keyboard checking is just starting
            waitOnFlip = True
            win.callOnFlip(key_resp_8.clock.reset)  # t=0 on next screen flip
            win.callOnFlip(key_resp_8.clearEvents, eventType='keyboard')  # clear events on next screen flip
        if key_resp_8.status == STARTED and not waitOnFlip:
            theseKeys = key_resp_8.getKeys(keyList=['space'], ignoreKeys=["escape"], waitRelease=False)
            _key_resp_8_allKeys.extend(theseKeys)
            if len(_key_resp_8_allKeys):
                key_resp_8.keys = _key_resp_8_allKeys[-1].name  # just the last key pressed
                key_resp_8.rt = _key_resp_8_allKeys[-1].rt
                key_resp_8.duration = _key_resp_8_allKeys[-1].duration
                # a response ends the routine
                continueRoutine = False
        
        # check for quit (typically the Esc key)
        if defaultKeyboard.getKeys(keyList=["escape"]):
            thisExp.status = FINISHED
        if thisExp.status == FINISHED or endExpNow:
            endExperiment(thisExp, win=win)
            return
        # pause experiment here if requested
        if thisExp.status == PAUSED:
            pauseExperiment(
                thisExp=thisExp, 
                win=win, 
                timers=[routineTimer], 
                playbackComponents=[]
            )
            # skip the frame we paused on
            continue
        
        # check if all components have finished
        if not continueRoutine:  # a component has requested a forced-end of Routine
            see_planning_trials.forceEnded = routineForceEnded = True
            break
        continueRoutine = False  # will revert to True if at least one component still running
        for thisComponent in see_planning_trials.components:
            if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:
                continueRoutine = True
                break  # at least one component has not yet finished
        
        # refresh the screen
        if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen
            win.flip()
    
    # --- Ending Routine "see_planning_trials" ---
    for thisComponent in see_planning_trials.components:
        if hasattr(thisComponent, "setAutoDraw"):
            thisComponent.setAutoDraw(False)
    # store stop times for see_planning_trials
    see_planning_trials.tStop = globalClock.getTime(format='float')
    see_planning_trials.tStopRefresh = tThisFlipGlobal
    thisExp.addData('see_planning_trials.stopped', see_planning_trials.tStop)
    thisExp.nextEntry()
    # the Routine "see_planning_trials" was not non-slip safe, so reset the non-slip timer
    routineTimer.reset()
    
    # --- Prepare to start Routine "instructions_planning_new" ---
    # create an object to store info about Routine instructions_planning_new
    instructions_planning_new = data.Routine(
        name='instructions_planning_new',
        components=[text_32, R1_6, R2_6, rew1_6, rew2_6, plan2_response_3, text_34, text_41, text_114, text_128],
    )
    instructions_planning_new.status = NOT_STARTED
    continueRoutine = True
    # update component parameters for each repeat
    # Run 'Begin Routine' code from code_15
    al1=400
    w2=400
    
    planning_total="Total = 0"
    # create starting attributes for plan2_response_3
    plan2_response_3.keys = []
    plan2_response_3.rt = []
    _plan2_response_3_allKeys = []
    text_114.setText(total_practice_planning)
    # store start times for instructions_planning_new
    instructions_planning_new.tStartRefresh = win.getFutureFlipTime(clock=globalClock)
    instructions_planning_new.tStart = globalClock.getTime(format='float')
    instructions_planning_new.status = STARTED
    thisExp.addData('instructions_planning_new.started', instructions_planning_new.tStart)
    instructions_planning_new.maxDuration = None
    # keep track of which components have finished
    instructions_planning_newComponents = instructions_planning_new.components
    for thisComponent in instructions_planning_new.components:
        thisComponent.tStart = None
        thisComponent.tStop = None
        thisComponent.tStartRefresh = None
        thisComponent.tStopRefresh = None
        if hasattr(thisComponent, 'status'):
            thisComponent.status = NOT_STARTED
    # reset timers
    t = 0
    _timeToFirstFrame = win.getFutureFlipTime(clock="now")
    frameN = -1
    
    # --- Run Routine "instructions_planning_new" ---
    instructions_planning_new.forceEnded = routineForceEnded = not continueRoutine
    while continueRoutine:
        # get current time
        t = routineTimer.getTime()
        tThisFlip = win.getFutureFlipTime(clock=routineTimer)
        tThisFlipGlobal = win.getFutureFlipTime(clock=None)
        frameN = frameN + 1  # number of completed frames (so 0 is the first frame)
        # update/draw components on each frame
        
        # *text_32* updates
        
        # if text_32 is starting this frame...
        if text_32.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
            # keep track of start time/frame for later
            text_32.frameNStart = frameN  # exact frame index
            text_32.tStart = t  # local t and not account for scr refresh
            text_32.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(text_32, 'tStartRefresh')  # time at next scr refresh
            # add timestamp to datafile
            thisExp.timestampOnFlip(win, 'text_32.started')
            # update status
            text_32.status = STARTED
            text_32.setAutoDraw(True)
        
        # if text_32 is active this frame...
        if text_32.status == STARTED:
            # update params
            pass
        
        # if text_32 is stopping this frame...
        if text_32.status == STARTED:
            # is it time to stop? (based on global clock, using actual start)
            if tThisFlipGlobal > text_32.tStartRefresh + 30.0-frameTolerance:
                # keep track of stop time/frame for later
                text_32.tStop = t  # not accounting for scr refresh
                text_32.tStopRefresh = tThisFlipGlobal  # on global time
                text_32.frameNStop = frameN  # exact frame index
                # add timestamp to datafile
                thisExp.timestampOnFlip(win, 'text_32.stopped')
                # update status
                text_32.status = FINISHED
                text_32.setAutoDraw(False)
        
        # *R1_6* updates
        
        # if R1_6 is starting this frame...
        if R1_6.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
            # keep track of start time/frame for later
            R1_6.frameNStart = frameN  # exact frame index
            R1_6.tStart = t  # local t and not account for scr refresh
            R1_6.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(R1_6, 'tStartRefresh')  # time at next scr refresh
            # add timestamp to datafile
            thisExp.timestampOnFlip(win, 'R1_6.started')
            # update status
            R1_6.status = STARTED
            R1_6.setAutoDraw(True)
        
        # if R1_6 is active this frame...
        if R1_6.status == STARTED:
            # update params
            pass
        
        # if R1_6 is stopping this frame...
        if R1_6.status == STARTED:
            # is it time to stop? (based on global clock, using actual start)
            if tThisFlipGlobal > R1_6.tStartRefresh + 30.0-frameTolerance:
                # keep track of stop time/frame for later
                R1_6.tStop = t  # not accounting for scr refresh
                R1_6.tStopRefresh = tThisFlipGlobal  # on global time
                R1_6.frameNStop = frameN  # exact frame index
                # add timestamp to datafile
                thisExp.timestampOnFlip(win, 'R1_6.stopped')
                # update status
                R1_6.status = FINISHED
                R1_6.setAutoDraw(False)
        
        # *R2_6* updates
        
        # if R2_6 is starting this frame...
        if R2_6.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
            # keep track of start time/frame for later
            R2_6.frameNStart = frameN  # exact frame index
            R2_6.tStart = t  # local t and not account for scr refresh
            R2_6.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(R2_6, 'tStartRefresh')  # time at next scr refresh
            # add timestamp to datafile
            thisExp.timestampOnFlip(win, 'R2_6.started')
            # update status
            R2_6.status = STARTED
            R2_6.setAutoDraw(True)
        
        # if R2_6 is active this frame...
        if R2_6.status == STARTED:
            # update params
            pass
        
        # if R2_6 is stopping this frame...
        if R2_6.status == STARTED:
            # is it time to stop? (based on global clock, using actual start)
            if tThisFlipGlobal > R2_6.tStartRefresh + 30.0-frameTolerance:
                # keep track of stop time/frame for later
                R2_6.tStop = t  # not accounting for scr refresh
                R2_6.tStopRefresh = tThisFlipGlobal  # on global time
                R2_6.frameNStop = frameN  # exact frame index
                # add timestamp to datafile
                thisExp.timestampOnFlip(win, 'R2_6.stopped')
                # update status
                R2_6.status = FINISHED
                R2_6.setAutoDraw(False)
        
        # *rew1_6* updates
        
        # if rew1_6 is starting this frame...
        if rew1_6.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
            # keep track of start time/frame for later
            rew1_6.frameNStart = frameN  # exact frame index
            rew1_6.tStart = t  # local t and not account for scr refresh
            rew1_6.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(rew1_6, 'tStartRefresh')  # time at next scr refresh
            # add timestamp to datafile
            thisExp.timestampOnFlip(win, 'rew1_6.started')
            # update status
            rew1_6.status = STARTED
            rew1_6.setAutoDraw(True)
        
        # if rew1_6 is active this frame...
        if rew1_6.status == STARTED:
            # update params
            rew1_6.setText('SPACE for 100', log=False)
        
        # if rew1_6 is stopping this frame...
        if rew1_6.status == STARTED:
            # is it time to stop? (based on global clock, using actual start)
            if tThisFlipGlobal > rew1_6.tStartRefresh + 30.0-frameTolerance:
                # keep track of stop time/frame for later
                rew1_6.tStop = t  # not accounting for scr refresh
                rew1_6.tStopRefresh = tThisFlipGlobal  # on global time
                rew1_6.frameNStop = frameN  # exact frame index
                # add timestamp to datafile
                thisExp.timestampOnFlip(win, 'rew1_6.stopped')
                # update status
                rew1_6.status = FINISHED
                rew1_6.setAutoDraw(False)
        
        # *rew2_6* updates
        
        # if rew2_6 is starting this frame...
        if rew2_6.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
            # keep track of start time/frame for later
            rew2_6.frameNStart = frameN  # exact frame index
            rew2_6.tStart = t  # local t and not account for scr refresh
            rew2_6.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(rew2_6, 'tStartRefresh')  # time at next scr refresh
            # add timestamp to datafile
            thisExp.timestampOnFlip(win, 'rew2_6.started')
            # update status
            rew2_6.status = STARTED
            rew2_6.setAutoDraw(True)
        
        # if rew2_6 is active this frame...
        if rew2_6.status == STARTED:
            # update params
            rew2_6.setText(w2, log=False)
        
        # if rew2_6 is stopping this frame...
        if rew2_6.status == STARTED:
            # is it time to stop? (based on global clock, using actual start)
            if tThisFlipGlobal > rew2_6.tStartRefresh + 30.0-frameTolerance:
                # keep track of stop time/frame for later
                rew2_6.tStop = t  # not accounting for scr refresh
                rew2_6.tStopRefresh = tThisFlipGlobal  # on global time
                rew2_6.frameNStop = frameN  # exact frame index
                # add timestamp to datafile
                thisExp.timestampOnFlip(win, 'rew2_6.stopped')
                # update status
                rew2_6.status = FINISHED
                rew2_6.setAutoDraw(False)
        
        # *plan2_response_3* updates
        waitOnFlip = False
        
        # if plan2_response_3 is starting this frame...
        if plan2_response_3.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
            # keep track of start time/frame for later
            plan2_response_3.frameNStart = frameN  # exact frame index
            plan2_response_3.tStart = t  # local t and not account for scr refresh
            plan2_response_3.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(plan2_response_3, 'tStartRefresh')  # time at next scr refresh
            # add timestamp to datafile
            thisExp.timestampOnFlip(win, 'plan2_response_3.started')
            # update status
            plan2_response_3.status = STARTED
            # keyboard checking is just starting
            waitOnFlip = True
            win.callOnFlip(plan2_response_3.clock.reset)  # t=0 on next screen flip
            win.callOnFlip(plan2_response_3.clearEvents, eventType='keyboard')  # clear events on next screen flip
        
        # if plan2_response_3 is stopping this frame...
        if plan2_response_3.status == STARTED:
            # is it time to stop? (based on global clock, using actual start)
            if tThisFlipGlobal > plan2_response_3.tStartRefresh + 30.0-frameTolerance:
                # keep track of stop time/frame for later
                plan2_response_3.tStop = t  # not accounting for scr refresh
                plan2_response_3.tStopRefresh = tThisFlipGlobal  # on global time
                plan2_response_3.frameNStop = frameN  # exact frame index
                # add timestamp to datafile
                thisExp.timestampOnFlip(win, 'plan2_response_3.stopped')
                # update status
                plan2_response_3.status = FINISHED
                plan2_response_3.status = FINISHED
        if plan2_response_3.status == STARTED and not waitOnFlip:
            theseKeys = plan2_response_3.getKeys(keyList=['space'], ignoreKeys=["escape"], waitRelease=False)
            _plan2_response_3_allKeys.extend(theseKeys)
            if len(_plan2_response_3_allKeys):
                plan2_response_3.keys = _plan2_response_3_allKeys[-1].name  # just the last key pressed
                plan2_response_3.rt = _plan2_response_3_allKeys[-1].rt
                plan2_response_3.duration = _plan2_response_3_allKeys[-1].duration
                # a response ends the routine
                continueRoutine = False
        
        # *text_34* updates
        
        # if text_34 is starting this frame...
        if text_34.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
            # keep track of start time/frame for later
            text_34.frameNStart = frameN  # exact frame index
            text_34.tStart = t  # local t and not account for scr refresh
            text_34.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(text_34, 'tStartRefresh')  # time at next scr refresh
            # add timestamp to datafile
            thisExp.timestampOnFlip(win, 'text_34.started')
            # update status
            text_34.status = STARTED
            text_34.setAutoDraw(True)
        
        # if text_34 is active this frame...
        if text_34.status == STARTED:
            # update params
            pass
        
        # if text_34 is stopping this frame...
        if text_34.status == STARTED:
            # is it time to stop? (based on global clock, using actual start)
            if tThisFlipGlobal > text_34.tStartRefresh + 30.0-frameTolerance:
                # keep track of stop time/frame for later
                text_34.tStop = t  # not accounting for scr refresh
                text_34.tStopRefresh = tThisFlipGlobal  # on global time
                text_34.frameNStop = frameN  # exact frame index
                # add timestamp to datafile
                thisExp.timestampOnFlip(win, 'text_34.stopped')
                # update status
                text_34.status = FINISHED
                text_34.setAutoDraw(False)
        
        # *text_41* updates
        
        # if text_41 is starting this frame...
        if text_41.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
            # keep track of start time/frame for later
            text_41.frameNStart = frameN  # exact frame index
            text_41.tStart = t  # local t and not account for scr refresh
            text_41.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(text_41, 'tStartRefresh')  # time at next scr refresh
            # add timestamp to datafile
            thisExp.timestampOnFlip(win, 'text_41.started')
            # update status
            text_41.status = STARTED
            text_41.setAutoDraw(True)
        
        # if text_41 is active this frame...
        if text_41.status == STARTED:
            # update params
            pass
        
        # if text_41 is stopping this frame...
        if text_41.status == STARTED:
            # is it time to stop? (based on global clock, using actual start)
            if tThisFlipGlobal > text_41.tStartRefresh + 30.0-frameTolerance:
                # keep track of stop time/frame for later
                text_41.tStop = t  # not accounting for scr refresh
                text_41.tStopRefresh = tThisFlipGlobal  # on global time
                text_41.frameNStop = frameN  # exact frame index
                # add timestamp to datafile
                thisExp.timestampOnFlip(win, 'text_41.stopped')
                # update status
                text_41.status = FINISHED
                text_41.setAutoDraw(False)
        
        # *text_114* updates
        
        # if text_114 is starting this frame...
        if text_114.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
            # keep track of start time/frame for later
            text_114.frameNStart = frameN  # exact frame index
            text_114.tStart = t  # local t and not account for scr refresh
            text_114.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(text_114, 'tStartRefresh')  # time at next scr refresh
            # add timestamp to datafile
            thisExp.timestampOnFlip(win, 'text_114.started')
            # update status
            text_114.status = STARTED
            text_114.setAutoDraw(True)
        
        # if text_114 is active this frame...
        if text_114.status == STARTED:
            # update params
            pass
        
        # *text_128* updates
        
        # if text_128 is starting this frame...
        if text_128.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
            # keep track of start time/frame for later
            text_128.frameNStart = frameN  # exact frame index
            text_128.tStart = t  # local t and not account for scr refresh
            text_128.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(text_128, 'tStartRefresh')  # time at next scr refresh
            # add timestamp to datafile
            thisExp.timestampOnFlip(win, 'text_128.started')
            # update status
            text_128.status = STARTED
            text_128.setAutoDraw(True)
        
        # if text_128 is active this frame...
        if text_128.status == STARTED:
            # update params
            pass
        
        # check for quit (typically the Esc key)
        if defaultKeyboard.getKeys(keyList=["escape"]):
            thisExp.status = FINISHED
        if thisExp.status == FINISHED or endExpNow:
            endExperiment(thisExp, win=win)
            return
        # pause experiment here if requested
        if thisExp.status == PAUSED:
            pauseExperiment(
                thisExp=thisExp, 
                win=win, 
                timers=[routineTimer], 
                playbackComponents=[]
            )
            # skip the frame we paused on
            continue
        
        # check if all components have finished
        if not continueRoutine:  # a component has requested a forced-end of Routine
            instructions_planning_new.forceEnded = routineForceEnded = True
            break
        continueRoutine = False  # will revert to True if at least one component still running
        for thisComponent in instructions_planning_new.components:
            if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:
                continueRoutine = True
                break  # at least one component has not yet finished
        
        # refresh the screen
        if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen
            win.flip()
    
    # --- Ending Routine "instructions_planning_new" ---
    for thisComponent in instructions_planning_new.components:
        if hasattr(thisComponent, "setAutoDraw"):
            thisComponent.setAutoDraw(False)
    # store stop times for instructions_planning_new
    instructions_planning_new.tStop = globalClock.getTime(format='float')
    instructions_planning_new.tStopRefresh = tThisFlipGlobal
    thisExp.addData('instructions_planning_new.stopped', instructions_planning_new.tStop)
    # check responses
    if plan2_response_3.keys in ['', [], None]:  # No response was made
        plan2_response_3.keys = None
    thisExp.addData('plan2_response_3.keys',plan2_response_3.keys)
    if plan2_response_3.keys != None:  # we had a response
        thisExp.addData('plan2_response_3.rt', plan2_response_3.rt)
        thisExp.addData('plan2_response_3.duration', plan2_response_3.duration)
    thisExp.nextEntry()
    # the Routine "instructions_planning_new" was not non-slip safe, so reset the non-slip timer
    routineTimer.reset()
    
    # --- Prepare to start Routine "planning_2_instructions" ---
    # create an object to store info about Routine planning_2_instructions
    planning_2_instructions = data.Routine(
        name='planning_2_instructions',
        components=[text_52, R1_9, R2_9, rew1_9, rew2_9, text_53, plan2_response_6, current_image_decision2_5, text_115, text_129],
    )
    planning_2_instructions.status = NOT_STARTED
    continueRoutine = True
    # update component parameters for each repeat
    # Run 'Begin Routine' code from code_23
    total_practice_planning=total_practice_planning+100
    
    # create starting attributes for plan2_response_6
    plan2_response_6.keys = []
    plan2_response_6.rt = []
    _plan2_response_6_allKeys = []
    text_115.setText(total_practice_planning)
    # store start times for planning_2_instructions
    planning_2_instructions.tStartRefresh = win.getFutureFlipTime(clock=globalClock)
    planning_2_instructions.tStart = globalClock.getTime(format='float')
    planning_2_instructions.status = STARTED
    thisExp.addData('planning_2_instructions.started', planning_2_instructions.tStart)
    planning_2_instructions.maxDuration = None
    # keep track of which components have finished
    planning_2_instructionsComponents = planning_2_instructions.components
    for thisComponent in planning_2_instructions.components:
        thisComponent.tStart = None
        thisComponent.tStop = None
        thisComponent.tStartRefresh = None
        thisComponent.tStopRefresh = None
        if hasattr(thisComponent, 'status'):
            thisComponent.status = NOT_STARTED
    # reset timers
    t = 0
    _timeToFirstFrame = win.getFutureFlipTime(clock="now")
    frameN = -1
    
    # --- Run Routine "planning_2_instructions" ---
    planning_2_instructions.forceEnded = routineForceEnded = not continueRoutine
    while continueRoutine:
        # get current time
        t = routineTimer.getTime()
        tThisFlip = win.getFutureFlipTime(clock=routineTimer)
        tThisFlipGlobal = win.getFutureFlipTime(clock=None)
        frameN = frameN + 1  # number of completed frames (so 0 is the first frame)
        # update/draw components on each frame
        
        # *text_52* updates
        
        # if text_52 is starting this frame...
        if text_52.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
            # keep track of start time/frame for later
            text_52.frameNStart = frameN  # exact frame index
            text_52.tStart = t  # local t and not account for scr refresh
            text_52.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(text_52, 'tStartRefresh')  # time at next scr refresh
            # add timestamp to datafile
            thisExp.timestampOnFlip(win, 'text_52.started')
            # update status
            text_52.status = STARTED
            text_52.setAutoDraw(True)
        
        # if text_52 is active this frame...
        if text_52.status == STARTED:
            # update params
            pass
        
        # if text_52 is stopping this frame...
        if text_52.status == STARTED:
            # is it time to stop? (based on global clock, using actual start)
            if tThisFlipGlobal > text_52.tStartRefresh + 30.0-frameTolerance:
                # keep track of stop time/frame for later
                text_52.tStop = t  # not accounting for scr refresh
                text_52.tStopRefresh = tThisFlipGlobal  # on global time
                text_52.frameNStop = frameN  # exact frame index
                # add timestamp to datafile
                thisExp.timestampOnFlip(win, 'text_52.stopped')
                # update status
                text_52.status = FINISHED
                text_52.setAutoDraw(False)
        
        # *R1_9* updates
        
        # if R1_9 is starting this frame...
        if R1_9.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
            # keep track of start time/frame for later
            R1_9.frameNStart = frameN  # exact frame index
            R1_9.tStart = t  # local t and not account for scr refresh
            R1_9.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(R1_9, 'tStartRefresh')  # time at next scr refresh
            # add timestamp to datafile
            thisExp.timestampOnFlip(win, 'R1_9.started')
            # update status
            R1_9.status = STARTED
            R1_9.setAutoDraw(True)
        
        # if R1_9 is active this frame...
        if R1_9.status == STARTED:
            # update params
            pass
        
        # if R1_9 is stopping this frame...
        if R1_9.status == STARTED:
            # is it time to stop? (based on global clock, using actual start)
            if tThisFlipGlobal > R1_9.tStartRefresh + 30.0-frameTolerance:
                # keep track of stop time/frame for later
                R1_9.tStop = t  # not accounting for scr refresh
                R1_9.tStopRefresh = tThisFlipGlobal  # on global time
                R1_9.frameNStop = frameN  # exact frame index
                # add timestamp to datafile
                thisExp.timestampOnFlip(win, 'R1_9.stopped')
                # update status
                R1_9.status = FINISHED
                R1_9.setAutoDraw(False)
        
        # *R2_9* updates
        
        # if R2_9 is starting this frame...
        if R2_9.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
            # keep track of start time/frame for later
            R2_9.frameNStart = frameN  # exact frame index
            R2_9.tStart = t  # local t and not account for scr refresh
            R2_9.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(R2_9, 'tStartRefresh')  # time at next scr refresh
            # add timestamp to datafile
            thisExp.timestampOnFlip(win, 'R2_9.started')
            # update status
            R2_9.status = STARTED
            R2_9.setAutoDraw(True)
        
        # if R2_9 is active this frame...
        if R2_9.status == STARTED:
            # update params
            pass
        
        # if R2_9 is stopping this frame...
        if R2_9.status == STARTED:
            # is it time to stop? (based on global clock, using actual start)
            if tThisFlipGlobal > R2_9.tStartRefresh + 30.0-frameTolerance:
                # keep track of stop time/frame for later
                R2_9.tStop = t  # not accounting for scr refresh
                R2_9.tStopRefresh = tThisFlipGlobal  # on global time
                R2_9.frameNStop = frameN  # exact frame index
                # add timestamp to datafile
                thisExp.timestampOnFlip(win, 'R2_9.stopped')
                # update status
                R2_9.status = FINISHED
                R2_9.setAutoDraw(False)
        
        # *rew1_9* updates
        
        # if rew1_9 is starting this frame...
        if rew1_9.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
            # keep track of start time/frame for later
            rew1_9.frameNStart = frameN  # exact frame index
            rew1_9.tStart = t  # local t and not account for scr refresh
            rew1_9.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(rew1_9, 'tStartRefresh')  # time at next scr refresh
            # add timestamp to datafile
            thisExp.timestampOnFlip(win, 'rew1_9.started')
            # update status
            rew1_9.status = STARTED
            rew1_9.setAutoDraw(True)
        
        # if rew1_9 is active this frame...
        if rew1_9.status == STARTED:
            # update params
            rew1_9.setText('SPACE for 100', log=False)
        
        # if rew1_9 is stopping this frame...
        if rew1_9.status == STARTED:
            # is it time to stop? (based on global clock, using actual start)
            if tThisFlipGlobal > rew1_9.tStartRefresh + 30.0-frameTolerance:
                # keep track of stop time/frame for later
                rew1_9.tStop = t  # not accounting for scr refresh
                rew1_9.tStopRefresh = tThisFlipGlobal  # on global time
                rew1_9.frameNStop = frameN  # exact frame index
                # add timestamp to datafile
                thisExp.timestampOnFlip(win, 'rew1_9.stopped')
                # update status
                rew1_9.status = FINISHED
                rew1_9.setAutoDraw(False)
        
        # *rew2_9* updates
        
        # if rew2_9 is starting this frame...
        if rew2_9.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
            # keep track of start time/frame for later
            rew2_9.frameNStart = frameN  # exact frame index
            rew2_9.tStart = t  # local t and not account for scr refresh
            rew2_9.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(rew2_9, 'tStartRefresh')  # time at next scr refresh
            # add timestamp to datafile
            thisExp.timestampOnFlip(win, 'rew2_9.started')
            # update status
            rew2_9.status = STARTED
            rew2_9.setAutoDraw(True)
        
        # if rew2_9 is active this frame...
        if rew2_9.status == STARTED:
            # update params
            rew2_9.setText(w2, log=False)
        
        # if rew2_9 is stopping this frame...
        if rew2_9.status == STARTED:
            # is it time to stop? (based on global clock, using actual start)
            if tThisFlipGlobal > rew2_9.tStartRefresh + 30.0-frameTolerance:
                # keep track of stop time/frame for later
                rew2_9.tStop = t  # not accounting for scr refresh
                rew2_9.tStopRefresh = tThisFlipGlobal  # on global time
                rew2_9.frameNStop = frameN  # exact frame index
                # add timestamp to datafile
                thisExp.timestampOnFlip(win, 'rew2_9.stopped')
                # update status
                rew2_9.status = FINISHED
                rew2_9.setAutoDraw(False)
        
        # *text_53* updates
        
        # if text_53 is starting this frame...
        if text_53.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
            # keep track of start time/frame for later
            text_53.frameNStart = frameN  # exact frame index
            text_53.tStart = t  # local t and not account for scr refresh
            text_53.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(text_53, 'tStartRefresh')  # time at next scr refresh
            # add timestamp to datafile
            thisExp.timestampOnFlip(win, 'text_53.started')
            # update status
            text_53.status = STARTED
            text_53.setAutoDraw(True)
        
        # if text_53 is active this frame...
        if text_53.status == STARTED:
            # update params
            pass
        
        # if text_53 is stopping this frame...
        if text_53.status == STARTED:
            # is it time to stop? (based on global clock, using actual start)
            if tThisFlipGlobal > text_53.tStartRefresh + 30.0-frameTolerance:
                # keep track of stop time/frame for later
                text_53.tStop = t  # not accounting for scr refresh
                text_53.tStopRefresh = tThisFlipGlobal  # on global time
                text_53.frameNStop = frameN  # exact frame index
                # add timestamp to datafile
                thisExp.timestampOnFlip(win, 'text_53.stopped')
                # update status
                text_53.status = FINISHED
                text_53.setAutoDraw(False)
        
        # *plan2_response_6* updates
        waitOnFlip = False
        
        # if plan2_response_6 is starting this frame...
        if plan2_response_6.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
            # keep track of start time/frame for later
            plan2_response_6.frameNStart = frameN  # exact frame index
            plan2_response_6.tStart = t  # local t and not account for scr refresh
            plan2_response_6.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(plan2_response_6, 'tStartRefresh')  # time at next scr refresh
            # add timestamp to datafile
            thisExp.timestampOnFlip(win, 'plan2_response_6.started')
            # update status
            plan2_response_6.status = STARTED
            # keyboard checking is just starting
            waitOnFlip = True
            win.callOnFlip(plan2_response_6.clock.reset)  # t=0 on next screen flip
            win.callOnFlip(plan2_response_6.clearEvents, eventType='keyboard')  # clear events on next screen flip
        
        # if plan2_response_6 is stopping this frame...
        if plan2_response_6.status == STARTED:
            # is it time to stop? (based on global clock, using actual start)
            if tThisFlipGlobal > plan2_response_6.tStartRefresh + 30.0-frameTolerance:
                # keep track of stop time/frame for later
                plan2_response_6.tStop = t  # not accounting for scr refresh
                plan2_response_6.tStopRefresh = tThisFlipGlobal  # on global time
                plan2_response_6.frameNStop = frameN  # exact frame index
                # add timestamp to datafile
                thisExp.timestampOnFlip(win, 'plan2_response_6.stopped')
                # update status
                plan2_response_6.status = FINISHED
                plan2_response_6.status = FINISHED
        if plan2_response_6.status == STARTED and not waitOnFlip:
            theseKeys = plan2_response_6.getKeys(keyList=['space'], ignoreKeys=["escape"], waitRelease=False)
            _plan2_response_6_allKeys.extend(theseKeys)
            if len(_plan2_response_6_allKeys):
                plan2_response_6.keys = _plan2_response_6_allKeys[-1].name  # just the last key pressed
                plan2_response_6.rt = _plan2_response_6_allKeys[-1].rt
                plan2_response_6.duration = _plan2_response_6_allKeys[-1].duration
                # a response ends the routine
                continueRoutine = False
        
        # *current_image_decision2_5* updates
        
        # if current_image_decision2_5 is starting this frame...
        if current_image_decision2_5.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
            # keep track of start time/frame for later
            current_image_decision2_5.frameNStart = frameN  # exact frame index
            current_image_decision2_5.tStart = t  # local t and not account for scr refresh
            current_image_decision2_5.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(current_image_decision2_5, 'tStartRefresh')  # time at next scr refresh
            # add timestamp to datafile
            thisExp.timestampOnFlip(win, 'current_image_decision2_5.started')
            # update status
            current_image_decision2_5.status = STARTED
            current_image_decision2_5.setAutoDraw(True)
        
        # if current_image_decision2_5 is active this frame...
        if current_image_decision2_5.status == STARTED:
            # update params
            pass
        
        # if current_image_decision2_5 is stopping this frame...
        if current_image_decision2_5.status == STARTED:
            # is it time to stop? (based on global clock, using actual start)
            if tThisFlipGlobal > current_image_decision2_5.tStartRefresh + 30.0-frameTolerance:
                # keep track of stop time/frame for later
                current_image_decision2_5.tStop = t  # not accounting for scr refresh
                current_image_decision2_5.tStopRefresh = tThisFlipGlobal  # on global time
                current_image_decision2_5.frameNStop = frameN  # exact frame index
                # add timestamp to datafile
                thisExp.timestampOnFlip(win, 'current_image_decision2_5.stopped')
                # update status
                current_image_decision2_5.status = FINISHED
                current_image_decision2_5.setAutoDraw(False)
        
        # *text_115* updates
        
        # if text_115 is starting this frame...
        if text_115.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
            # keep track of start time/frame for later
            text_115.frameNStart = frameN  # exact frame index
            text_115.tStart = t  # local t and not account for scr refresh
            text_115.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(text_115, 'tStartRefresh')  # time at next scr refresh
            # add timestamp to datafile
            thisExp.timestampOnFlip(win, 'text_115.started')
            # update status
            text_115.status = STARTED
            text_115.setAutoDraw(True)
        
        # if text_115 is active this frame...
        if text_115.status == STARTED:
            # update params
            pass
        
        # *text_129* updates
        
        # if text_129 is starting this frame...
        if text_129.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
            # keep track of start time/frame for later
            text_129.frameNStart = frameN  # exact frame index
            text_129.tStart = t  # local t and not account for scr refresh
            text_129.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(text_129, 'tStartRefresh')  # time at next scr refresh
            # add timestamp to datafile
            thisExp.timestampOnFlip(win, 'text_129.started')
            # update status
            text_129.status = STARTED
            text_129.setAutoDraw(True)
        
        # if text_129 is active this frame...
        if text_129.status == STARTED:
            # update params
            pass
        
        # check for quit (typically the Esc key)
        if defaultKeyboard.getKeys(keyList=["escape"]):
            thisExp.status = FINISHED
        if thisExp.status == FINISHED or endExpNow:
            endExperiment(thisExp, win=win)
            return
        # pause experiment here if requested
        if thisExp.status == PAUSED:
            pauseExperiment(
                thisExp=thisExp, 
                win=win, 
                timers=[routineTimer], 
                playbackComponents=[]
            )
            # skip the frame we paused on
            continue
        
        # check if all components have finished
        if not continueRoutine:  # a component has requested a forced-end of Routine
            planning_2_instructions.forceEnded = routineForceEnded = True
            break
        continueRoutine = False  # will revert to True if at least one component still running
        for thisComponent in planning_2_instructions.components:
            if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:
                continueRoutine = True
                break  # at least one component has not yet finished
        
        # refresh the screen
        if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen
            win.flip()
    
    # --- Ending Routine "planning_2_instructions" ---
    for thisComponent in planning_2_instructions.components:
        if hasattr(thisComponent, "setAutoDraw"):
            thisComponent.setAutoDraw(False)
    # store stop times for planning_2_instructions
    planning_2_instructions.tStop = globalClock.getTime(format='float')
    planning_2_instructions.tStopRefresh = tThisFlipGlobal
    thisExp.addData('planning_2_instructions.stopped', planning_2_instructions.tStop)
    # check responses
    if plan2_response_6.keys in ['', [], None]:  # No response was made
        plan2_response_6.keys = None
    thisExp.addData('plan2_response_6.keys',plan2_response_6.keys)
    if plan2_response_6.keys != None:  # we had a response
        thisExp.addData('plan2_response_6.rt', plan2_response_6.rt)
        thisExp.addData('plan2_response_6.duration', plan2_response_6.duration)
    thisExp.nextEntry()
    # the Routine "planning_2_instructions" was not non-slip safe, so reset the non-slip timer
    routineTimer.reset()
    
    # --- Prepare to start Routine "instructions_planning_new3" ---
    # create an object to store info about Routine instructions_planning_new3
    instructions_planning_new3 = data.Routine(
        name='instructions_planning_new3',
        components=[text_136, R1_11, R2_11, rew1_11, rew2_11, plan2_response_5, current_image_decision2_6, text_137, text_138, text_139, text_140],
    )
    instructions_planning_new3.status = NOT_STARTED
    continueRoutine = True
    # update component parameters for each repeat
    # Run 'Begin Routine' code from code_29
    total_practice_planning=total_practice_planning
    # create starting attributes for plan2_response_5
    plan2_response_5.keys = []
    plan2_response_5.rt = []
    _plan2_response_5_allKeys = []
    text_139.setText(total_practice_planning)
    # store start times for instructions_planning_new3
    instructions_planning_new3.tStartRefresh = win.getFutureFlipTime(clock=globalClock)
    instructions_planning_new3.tStart = globalClock.getTime(format='float')
    instructions_planning_new3.status = STARTED
    thisExp.addData('instructions_planning_new3.started', instructions_planning_new3.tStart)
    instructions_planning_new3.maxDuration = None
    # keep track of which components have finished
    instructions_planning_new3Components = instructions_planning_new3.components
    for thisComponent in instructions_planning_new3.components:
        thisComponent.tStart = None
        thisComponent.tStop = None
        thisComponent.tStartRefresh = None
        thisComponent.tStopRefresh = None
        if hasattr(thisComponent, 'status'):
            thisComponent.status = NOT_STARTED
    # reset timers
    t = 0
    _timeToFirstFrame = win.getFutureFlipTime(clock="now")
    frameN = -1
    
    # --- Run Routine "instructions_planning_new3" ---
    instructions_planning_new3.forceEnded = routineForceEnded = not continueRoutine
    while continueRoutine:
        # get current time
        t = routineTimer.getTime()
        tThisFlip = win.getFutureFlipTime(clock=routineTimer)
        tThisFlipGlobal = win.getFutureFlipTime(clock=None)
        frameN = frameN + 1  # number of completed frames (so 0 is the first frame)
        # update/draw components on each frame
        
        # *text_136* updates
        
        # if text_136 is starting this frame...
        if text_136.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
            # keep track of start time/frame for later
            text_136.frameNStart = frameN  # exact frame index
            text_136.tStart = t  # local t and not account for scr refresh
            text_136.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(text_136, 'tStartRefresh')  # time at next scr refresh
            # add timestamp to datafile
            thisExp.timestampOnFlip(win, 'text_136.started')
            # update status
            text_136.status = STARTED
            text_136.setAutoDraw(True)
        
        # if text_136 is active this frame...
        if text_136.status == STARTED:
            # update params
            pass
        
        # if text_136 is stopping this frame...
        if text_136.status == STARTED:
            # is it time to stop? (based on global clock, using actual start)
            if tThisFlipGlobal > text_136.tStartRefresh + 30.0-frameTolerance:
                # keep track of stop time/frame for later
                text_136.tStop = t  # not accounting for scr refresh
                text_136.tStopRefresh = tThisFlipGlobal  # on global time
                text_136.frameNStop = frameN  # exact frame index
                # add timestamp to datafile
                thisExp.timestampOnFlip(win, 'text_136.stopped')
                # update status
                text_136.status = FINISHED
                text_136.setAutoDraw(False)
        
        # *R1_11* updates
        
        # if R1_11 is starting this frame...
        if R1_11.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
            # keep track of start time/frame for later
            R1_11.frameNStart = frameN  # exact frame index
            R1_11.tStart = t  # local t and not account for scr refresh
            R1_11.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(R1_11, 'tStartRefresh')  # time at next scr refresh
            # add timestamp to datafile
            thisExp.timestampOnFlip(win, 'R1_11.started')
            # update status
            R1_11.status = STARTED
            R1_11.setAutoDraw(True)
        
        # if R1_11 is active this frame...
        if R1_11.status == STARTED:
            # update params
            pass
        
        # if R1_11 is stopping this frame...
        if R1_11.status == STARTED:
            # is it time to stop? (based on global clock, using actual start)
            if tThisFlipGlobal > R1_11.tStartRefresh + 30.0-frameTolerance:
                # keep track of stop time/frame for later
                R1_11.tStop = t  # not accounting for scr refresh
                R1_11.tStopRefresh = tThisFlipGlobal  # on global time
                R1_11.frameNStop = frameN  # exact frame index
                # add timestamp to datafile
                thisExp.timestampOnFlip(win, 'R1_11.stopped')
                # update status
                R1_11.status = FINISHED
                R1_11.setAutoDraw(False)
        
        # *R2_11* updates
        
        # if R2_11 is starting this frame...
        if R2_11.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
            # keep track of start time/frame for later
            R2_11.frameNStart = frameN  # exact frame index
            R2_11.tStart = t  # local t and not account for scr refresh
            R2_11.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(R2_11, 'tStartRefresh')  # time at next scr refresh
            # add timestamp to datafile
            thisExp.timestampOnFlip(win, 'R2_11.started')
            # update status
            R2_11.status = STARTED
            R2_11.setAutoDraw(True)
        
        # if R2_11 is active this frame...
        if R2_11.status == STARTED:
            # update params
            pass
        
        # if R2_11 is stopping this frame...
        if R2_11.status == STARTED:
            # is it time to stop? (based on global clock, using actual start)
            if tThisFlipGlobal > R2_11.tStartRefresh + 30.0-frameTolerance:
                # keep track of stop time/frame for later
                R2_11.tStop = t  # not accounting for scr refresh
                R2_11.tStopRefresh = tThisFlipGlobal  # on global time
                R2_11.frameNStop = frameN  # exact frame index
                # add timestamp to datafile
                thisExp.timestampOnFlip(win, 'R2_11.stopped')
                # update status
                R2_11.status = FINISHED
                R2_11.setAutoDraw(False)
        
        # *rew1_11* updates
        
        # if rew1_11 is starting this frame...
        if rew1_11.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
            # keep track of start time/frame for later
            rew1_11.frameNStart = frameN  # exact frame index
            rew1_11.tStart = t  # local t and not account for scr refresh
            rew1_11.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(rew1_11, 'tStartRefresh')  # time at next scr refresh
            # add timestamp to datafile
            thisExp.timestampOnFlip(win, 'rew1_11.started')
            # update status
            rew1_11.status = STARTED
            rew1_11.setAutoDraw(True)
        
        # if rew1_11 is active this frame...
        if rew1_11.status == STARTED:
            # update params
            rew1_11.setText('SPACE for 100', log=False)
        
        # if rew1_11 is stopping this frame...
        if rew1_11.status == STARTED:
            # is it time to stop? (based on global clock, using actual start)
            if tThisFlipGlobal > rew1_11.tStartRefresh + 30.0-frameTolerance:
                # keep track of stop time/frame for later
                rew1_11.tStop = t  # not accounting for scr refresh
                rew1_11.tStopRefresh = tThisFlipGlobal  # on global time
                rew1_11.frameNStop = frameN  # exact frame index
                # add timestamp to datafile
                thisExp.timestampOnFlip(win, 'rew1_11.stopped')
                # update status
                rew1_11.status = FINISHED
                rew1_11.setAutoDraw(False)
        
        # *rew2_11* updates
        
        # if rew2_11 is starting this frame...
        if rew2_11.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
            # keep track of start time/frame for later
            rew2_11.frameNStart = frameN  # exact frame index
            rew2_11.tStart = t  # local t and not account for scr refresh
            rew2_11.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(rew2_11, 'tStartRefresh')  # time at next scr refresh
            # add timestamp to datafile
            thisExp.timestampOnFlip(win, 'rew2_11.started')
            # update status
            rew2_11.status = STARTED
            rew2_11.setAutoDraw(True)
        
        # if rew2_11 is active this frame...
        if rew2_11.status == STARTED:
            # update params
            rew2_11.setText(w2, log=False)
        
        # if rew2_11 is stopping this frame...
        if rew2_11.status == STARTED:
            # is it time to stop? (based on global clock, using actual start)
            if tThisFlipGlobal > rew2_11.tStartRefresh + 30.0-frameTolerance:
                # keep track of stop time/frame for later
                rew2_11.tStop = t  # not accounting for scr refresh
                rew2_11.tStopRefresh = tThisFlipGlobal  # on global time
                rew2_11.frameNStop = frameN  # exact frame index
                # add timestamp to datafile
                thisExp.timestampOnFlip(win, 'rew2_11.stopped')
                # update status
                rew2_11.status = FINISHED
                rew2_11.setAutoDraw(False)
        
        # *plan2_response_5* updates
        waitOnFlip = False
        
        # if plan2_response_5 is starting this frame...
        if plan2_response_5.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
            # keep track of start time/frame for later
            plan2_response_5.frameNStart = frameN  # exact frame index
            plan2_response_5.tStart = t  # local t and not account for scr refresh
            plan2_response_5.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(plan2_response_5, 'tStartRefresh')  # time at next scr refresh
            # add timestamp to datafile
            thisExp.timestampOnFlip(win, 'plan2_response_5.started')
            # update status
            plan2_response_5.status = STARTED
            # keyboard checking is just starting
            waitOnFlip = True
            win.callOnFlip(plan2_response_5.clock.reset)  # t=0 on next screen flip
            win.callOnFlip(plan2_response_5.clearEvents, eventType='keyboard')  # clear events on next screen flip
        
        # if plan2_response_5 is stopping this frame...
        if plan2_response_5.status == STARTED:
            # is it time to stop? (based on global clock, using actual start)
            if tThisFlipGlobal > plan2_response_5.tStartRefresh + 30.0-frameTolerance:
                # keep track of stop time/frame for later
                plan2_response_5.tStop = t  # not accounting for scr refresh
                plan2_response_5.tStopRefresh = tThisFlipGlobal  # on global time
                plan2_response_5.frameNStop = frameN  # exact frame index
                # add timestamp to datafile
                thisExp.timestampOnFlip(win, 'plan2_response_5.stopped')
                # update status
                plan2_response_5.status = FINISHED
                plan2_response_5.status = FINISHED
        if plan2_response_5.status == STARTED and not waitOnFlip:
            theseKeys = plan2_response_5.getKeys(keyList=['right','space','left'], ignoreKeys=["escape"], waitRelease=False)
            _plan2_response_5_allKeys.extend(theseKeys)
            if len(_plan2_response_5_allKeys):
                plan2_response_5.keys = _plan2_response_5_allKeys[-1].name  # just the last key pressed
                plan2_response_5.rt = _plan2_response_5_allKeys[-1].rt
                plan2_response_5.duration = _plan2_response_5_allKeys[-1].duration
                # a response ends the routine
                continueRoutine = False
        
        # *current_image_decision2_6* updates
        
        # if current_image_decision2_6 is starting this frame...
        if current_image_decision2_6.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
            # keep track of start time/frame for later
            current_image_decision2_6.frameNStart = frameN  # exact frame index
            current_image_decision2_6.tStart = t  # local t and not account for scr refresh
            current_image_decision2_6.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(current_image_decision2_6, 'tStartRefresh')  # time at next scr refresh
            # add timestamp to datafile
            thisExp.timestampOnFlip(win, 'current_image_decision2_6.started')
            # update status
            current_image_decision2_6.status = STARTED
            current_image_decision2_6.setAutoDraw(True)
        
        # if current_image_decision2_6 is active this frame...
        if current_image_decision2_6.status == STARTED:
            # update params
            pass
        
        # if current_image_decision2_6 is stopping this frame...
        if current_image_decision2_6.status == STARTED:
            # is it time to stop? (based on global clock, using actual start)
            if tThisFlipGlobal > current_image_decision2_6.tStartRefresh + 30.0-frameTolerance:
                # keep track of stop time/frame for later
                current_image_decision2_6.tStop = t  # not accounting for scr refresh
                current_image_decision2_6.tStopRefresh = tThisFlipGlobal  # on global time
                current_image_decision2_6.frameNStop = frameN  # exact frame index
                # add timestamp to datafile
                thisExp.timestampOnFlip(win, 'current_image_decision2_6.stopped')
                # update status
                current_image_decision2_6.status = FINISHED
                current_image_decision2_6.setAutoDraw(False)
        
        # *text_137* updates
        
        # if text_137 is starting this frame...
        if text_137.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
            # keep track of start time/frame for later
            text_137.frameNStart = frameN  # exact frame index
            text_137.tStart = t  # local t and not account for scr refresh
            text_137.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(text_137, 'tStartRefresh')  # time at next scr refresh
            # add timestamp to datafile
            thisExp.timestampOnFlip(win, 'text_137.started')
            # update status
            text_137.status = STARTED
            text_137.setAutoDraw(True)
        
        # if text_137 is active this frame...
        if text_137.status == STARTED:
            # update params
            pass
        
        # if text_137 is stopping this frame...
        if text_137.status == STARTED:
            # is it time to stop? (based on global clock, using actual start)
            if tThisFlipGlobal > text_137.tStartRefresh + 30.0-frameTolerance:
                # keep track of stop time/frame for later
                text_137.tStop = t  # not accounting for scr refresh
                text_137.tStopRefresh = tThisFlipGlobal  # on global time
                text_137.frameNStop = frameN  # exact frame index
                # add timestamp to datafile
                thisExp.timestampOnFlip(win, 'text_137.stopped')
                # update status
                text_137.status = FINISHED
                text_137.setAutoDraw(False)
        
        # *text_138* updates
        
        # if text_138 is starting this frame...
        if text_138.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
            # keep track of start time/frame for later
            text_138.frameNStart = frameN  # exact frame index
            text_138.tStart = t  # local t and not account for scr refresh
            text_138.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(text_138, 'tStartRefresh')  # time at next scr refresh
            # add timestamp to datafile
            thisExp.timestampOnFlip(win, 'text_138.started')
            # update status
            text_138.status = STARTED
            text_138.setAutoDraw(True)
        
        # if text_138 is active this frame...
        if text_138.status == STARTED:
            # update params
            pass
        
        # if text_138 is stopping this frame...
        if text_138.status == STARTED:
            # is it time to stop? (based on global clock, using actual start)
            if tThisFlipGlobal > text_138.tStartRefresh + 30.0-frameTolerance:
                # keep track of stop time/frame for later
                text_138.tStop = t  # not accounting for scr refresh
                text_138.tStopRefresh = tThisFlipGlobal  # on global time
                text_138.frameNStop = frameN  # exact frame index
                # add timestamp to datafile
                thisExp.timestampOnFlip(win, 'text_138.stopped')
                # update status
                text_138.status = FINISHED
                text_138.setAutoDraw(False)
        
        # *text_139* updates
        
        # if text_139 is starting this frame...
        if text_139.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
            # keep track of start time/frame for later
            text_139.frameNStart = frameN  # exact frame index
            text_139.tStart = t  # local t and not account for scr refresh
            text_139.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(text_139, 'tStartRefresh')  # time at next scr refresh
            # add timestamp to datafile
            thisExp.timestampOnFlip(win, 'text_139.started')
            # update status
            text_139.status = STARTED
            text_139.setAutoDraw(True)
        
        # if text_139 is active this frame...
        if text_139.status == STARTED:
            # update params
            pass
        
        # *text_140* updates
        
        # if text_140 is starting this frame...
        if text_140.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
            # keep track of start time/frame for later
            text_140.frameNStart = frameN  # exact frame index
            text_140.tStart = t  # local t and not account for scr refresh
            text_140.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(text_140, 'tStartRefresh')  # time at next scr refresh
            # add timestamp to datafile
            thisExp.timestampOnFlip(win, 'text_140.started')
            # update status
            text_140.status = STARTED
            text_140.setAutoDraw(True)
        
        # if text_140 is active this frame...
        if text_140.status == STARTED:
            # update params
            pass
        
        # check for quit (typically the Esc key)
        if defaultKeyboard.getKeys(keyList=["escape"]):
            thisExp.status = FINISHED
        if thisExp.status == FINISHED or endExpNow:
            endExperiment(thisExp, win=win)
            return
        # pause experiment here if requested
        if thisExp.status == PAUSED:
            pauseExperiment(
                thisExp=thisExp, 
                win=win, 
                timers=[routineTimer], 
                playbackComponents=[]
            )
            # skip the frame we paused on
            continue
        
        # check if all components have finished
        if not continueRoutine:  # a component has requested a forced-end of Routine
            instructions_planning_new3.forceEnded = routineForceEnded = True
            break
        continueRoutine = False  # will revert to True if at least one component still running
        for thisComponent in instructions_planning_new3.components:
            if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:
                continueRoutine = True
                break  # at least one component has not yet finished
        
        # refresh the screen
        if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen
            win.flip()
    
    # --- Ending Routine "instructions_planning_new3" ---
    for thisComponent in instructions_planning_new3.components:
        if hasattr(thisComponent, "setAutoDraw"):
            thisComponent.setAutoDraw(False)
    # store stop times for instructions_planning_new3
    instructions_planning_new3.tStop = globalClock.getTime(format='float')
    instructions_planning_new3.tStopRefresh = tThisFlipGlobal
    thisExp.addData('instructions_planning_new3.stopped', instructions_planning_new3.tStop)
    # check responses
    if plan2_response_5.keys in ['', [], None]:  # No response was made
        plan2_response_5.keys = None
    thisExp.addData('plan2_response_5.keys',plan2_response_5.keys)
    if plan2_response_5.keys != None:  # we had a response
        thisExp.addData('plan2_response_5.rt', plan2_response_5.rt)
        thisExp.addData('plan2_response_5.duration', plan2_response_5.duration)
    thisExp.nextEntry()
    # the Routine "instructions_planning_new3" was not non-slip safe, so reset the non-slip timer
    routineTimer.reset()
    
    # --- Prepare to start Routine "practice_planning_outcomes" ---
    # create an object to store info about Routine practice_planning_outcomes
    practice_planning_outcomes = data.Routine(
        name='practice_planning_outcomes',
        components=[image_6, text_141, text_142, text_143],
    )
    practice_planning_outcomes.status = NOT_STARTED
    continueRoutine = True
    # update component parameters for each repeat
    # Run 'Begin Routine' code from code_33
    total_practice_planning+=400
    text_142.setText(total_practice_planning)
    # store start times for practice_planning_outcomes
    practice_planning_outcomes.tStartRefresh = win.getFutureFlipTime(clock=globalClock)
    practice_planning_outcomes.tStart = globalClock.getTime(format='float')
    practice_planning_outcomes.status = STARTED
    thisExp.addData('practice_planning_outcomes.started', practice_planning_outcomes.tStart)
    practice_planning_outcomes.maxDuration = None
    # keep track of which components have finished
    practice_planning_outcomesComponents = practice_planning_outcomes.components
    for thisComponent in practice_planning_outcomes.components:
        thisComponent.tStart = None
        thisComponent.tStop = None
        thisComponent.tStartRefresh = None
        thisComponent.tStopRefresh = None
        if hasattr(thisComponent, 'status'):
            thisComponent.status = NOT_STARTED
    # reset timers
    t = 0
    _timeToFirstFrame = win.getFutureFlipTime(clock="now")
    frameN = -1
    
    # --- Run Routine "practice_planning_outcomes" ---
    practice_planning_outcomes.forceEnded = routineForceEnded = not continueRoutine
    while continueRoutine and routineTimer.getTime() < 2.0:
        # get current time
        t = routineTimer.getTime()
        tThisFlip = win.getFutureFlipTime(clock=routineTimer)
        tThisFlipGlobal = win.getFutureFlipTime(clock=None)
        frameN = frameN + 1  # number of completed frames (so 0 is the first frame)
        # update/draw components on each frame
        
        # *image_6* updates
        
        # if image_6 is starting this frame...
        if image_6.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
            # keep track of start time/frame for later
            image_6.frameNStart = frameN  # exact frame index
            image_6.tStart = t  # local t and not account for scr refresh
            image_6.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(image_6, 'tStartRefresh')  # time at next scr refresh
            # add timestamp to datafile
            thisExp.timestampOnFlip(win, 'image_6.started')
            # update status
            image_6.status = STARTED
            image_6.setAutoDraw(True)
        
        # if image_6 is active this frame...
        if image_6.status == STARTED:
            # update params
            pass
        
        # if image_6 is stopping this frame...
        if image_6.status == STARTED:
            # is it time to stop? (based on global clock, using actual start)
            if tThisFlipGlobal > image_6.tStartRefresh + 2.0-frameTolerance:
                # keep track of stop time/frame for later
                image_6.tStop = t  # not accounting for scr refresh
                image_6.tStopRefresh = tThisFlipGlobal  # on global time
                image_6.frameNStop = frameN  # exact frame index
                # add timestamp to datafile
                thisExp.timestampOnFlip(win, 'image_6.stopped')
                # update status
                image_6.status = FINISHED
                image_6.setAutoDraw(False)
        
        # *text_141* updates
        
        # if text_141 is starting this frame...
        if text_141.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
            # keep track of start time/frame for later
            text_141.frameNStart = frameN  # exact frame index
            text_141.tStart = t  # local t and not account for scr refresh
            text_141.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(text_141, 'tStartRefresh')  # time at next scr refresh
            # add timestamp to datafile
            thisExp.timestampOnFlip(win, 'text_141.started')
            # update status
            text_141.status = STARTED
            text_141.setAutoDraw(True)
        
        # if text_141 is active this frame...
        if text_141.status == STARTED:
            # update params
            pass
        
        # if text_141 is stopping this frame...
        if text_141.status == STARTED:
            # is it time to stop? (based on global clock, using actual start)
            if tThisFlipGlobal > text_141.tStartRefresh + 2.0-frameTolerance:
                # keep track of stop time/frame for later
                text_141.tStop = t  # not accounting for scr refresh
                text_141.tStopRefresh = tThisFlipGlobal  # on global time
                text_141.frameNStop = frameN  # exact frame index
                # add timestamp to datafile
                thisExp.timestampOnFlip(win, 'text_141.stopped')
                # update status
                text_141.status = FINISHED
                text_141.setAutoDraw(False)
        
        # *text_142* updates
        
        # if text_142 is starting this frame...
        if text_142.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
            # keep track of start time/frame for later
            text_142.frameNStart = frameN  # exact frame index
            text_142.tStart = t  # local t and not account for scr refresh
            text_142.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(text_142, 'tStartRefresh')  # time at next scr refresh
            # add timestamp to datafile
            thisExp.timestampOnFlip(win, 'text_142.started')
            # update status
            text_142.status = STARTED
            text_142.setAutoDraw(True)
        
        # if text_142 is active this frame...
        if text_142.status == STARTED:
            # update params
            pass
        
        # if text_142 is stopping this frame...
        if text_142.status == STARTED:
            # is it time to stop? (based on global clock, using actual start)
            if tThisFlipGlobal > text_142.tStartRefresh + 2.0-frameTolerance:
                # keep track of stop time/frame for later
                text_142.tStop = t  # not accounting for scr refresh
                text_142.tStopRefresh = tThisFlipGlobal  # on global time
                text_142.frameNStop = frameN  # exact frame index
                # add timestamp to datafile
                thisExp.timestampOnFlip(win, 'text_142.stopped')
                # update status
                text_142.status = FINISHED
                text_142.setAutoDraw(False)
        
        # *text_143* updates
        
        # if text_143 is starting this frame...
        if text_143.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
            # keep track of start time/frame for later
            text_143.frameNStart = frameN  # exact frame index
            text_143.tStart = t  # local t and not account for scr refresh
            text_143.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(text_143, 'tStartRefresh')  # time at next scr refresh
            # add timestamp to datafile
            thisExp.timestampOnFlip(win, 'text_143.started')
            # update status
            text_143.status = STARTED
            text_143.setAutoDraw(True)
        
        # if text_143 is active this frame...
        if text_143.status == STARTED:
            # update params
            pass
        
        # if text_143 is stopping this frame...
        if text_143.status == STARTED:
            # is it time to stop? (based on global clock, using actual start)
            if tThisFlipGlobal > text_143.tStartRefresh + 2.0-frameTolerance:
                # keep track of stop time/frame for later
                text_143.tStop = t  # not accounting for scr refresh
                text_143.tStopRefresh = tThisFlipGlobal  # on global time
                text_143.frameNStop = frameN  # exact frame index
                # add timestamp to datafile
                thisExp.timestampOnFlip(win, 'text_143.stopped')
                # update status
                text_143.status = FINISHED
                text_143.setAutoDraw(False)
        
        # check for quit (typically the Esc key)
        if defaultKeyboard.getKeys(keyList=["escape"]):
            thisExp.status = FINISHED
        if thisExp.status == FINISHED or endExpNow:
            endExperiment(thisExp, win=win)
            return
        # pause experiment here if requested
        if thisExp.status == PAUSED:
            pauseExperiment(
                thisExp=thisExp, 
                win=win, 
                timers=[routineTimer], 
                playbackComponents=[]
            )
            # skip the frame we paused on
            continue
        
        # check if all components have finished
        if not continueRoutine:  # a component has requested a forced-end of Routine
            practice_planning_outcomes.forceEnded = routineForceEnded = True
            break
        continueRoutine = False  # will revert to True if at least one component still running
        for thisComponent in practice_planning_outcomes.components:
            if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:
                continueRoutine = True
                break  # at least one component has not yet finished
        
        # refresh the screen
        if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen
            win.flip()
    
    # --- Ending Routine "practice_planning_outcomes" ---
    for thisComponent in practice_planning_outcomes.components:
        if hasattr(thisComponent, "setAutoDraw"):
            thisComponent.setAutoDraw(False)
    # store stop times for practice_planning_outcomes
    practice_planning_outcomes.tStop = globalClock.getTime(format='float')
    practice_planning_outcomes.tStopRefresh = tThisFlipGlobal
    thisExp.addData('practice_planning_outcomes.stopped', practice_planning_outcomes.tStop)
    # using non-slip timing so subtract the expected duration of this Routine (unless ended on request)
    if practice_planning_outcomes.maxDurationReached:
        routineTimer.addTime(-practice_planning_outcomes.maxDuration)
    elif practice_planning_outcomes.forceEnded:
        routineTimer.reset()
    else:
        routineTimer.addTime(-2.000000)
    thisExp.nextEntry()
    
    # --- Prepare to start Routine "immediate_rewar_lesson" ---
    # create an object to store info about Routine immediate_rewar_lesson
    immediate_rewar_lesson = data.Routine(
        name='immediate_rewar_lesson',
        components=[text_148, key_resp_39],
    )
    immediate_rewar_lesson.status = NOT_STARTED
    continueRoutine = True
    # update component parameters for each repeat
    # create starting attributes for key_resp_39
    key_resp_39.keys = []
    key_resp_39.rt = []
    _key_resp_39_allKeys = []
    # Run 'Begin Routine' code from code_41
    total_practice_planning=0
    # store start times for immediate_rewar_lesson
    immediate_rewar_lesson.tStartRefresh = win.getFutureFlipTime(clock=globalClock)
    immediate_rewar_lesson.tStart = globalClock.getTime(format='float')
    immediate_rewar_lesson.status = STARTED
    thisExp.addData('immediate_rewar_lesson.started', immediate_rewar_lesson.tStart)
    immediate_rewar_lesson.maxDuration = None
    # keep track of which components have finished
    immediate_rewar_lessonComponents = immediate_rewar_lesson.components
    for thisComponent in immediate_rewar_lesson.components:
        thisComponent.tStart = None
        thisComponent.tStop = None
        thisComponent.tStartRefresh = None
        thisComponent.tStopRefresh = None
        if hasattr(thisComponent, 'status'):
            thisComponent.status = NOT_STARTED
    # reset timers
    t = 0
    _timeToFirstFrame = win.getFutureFlipTime(clock="now")
    frameN = -1
    
    # --- Run Routine "immediate_rewar_lesson" ---
    immediate_rewar_lesson.forceEnded = routineForceEnded = not continueRoutine
    while continueRoutine:
        # get current time
        t = routineTimer.getTime()
        tThisFlip = win.getFutureFlipTime(clock=routineTimer)
        tThisFlipGlobal = win.getFutureFlipTime(clock=None)
        frameN = frameN + 1  # number of completed frames (so 0 is the first frame)
        # update/draw components on each frame
        
        # *text_148* updates
        
        # if text_148 is starting this frame...
        if text_148.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
            # keep track of start time/frame for later
            text_148.frameNStart = frameN  # exact frame index
            text_148.tStart = t  # local t and not account for scr refresh
            text_148.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(text_148, 'tStartRefresh')  # time at next scr refresh
            # add timestamp to datafile
            thisExp.timestampOnFlip(win, 'text_148.started')
            # update status
            text_148.status = STARTED
            text_148.setAutoDraw(True)
        
        # if text_148 is active this frame...
        if text_148.status == STARTED:
            # update params
            pass
        
        # *key_resp_39* updates
        waitOnFlip = False
        
        # if key_resp_39 is starting this frame...
        if key_resp_39.status == NOT_STARTED and tThisFlip >= 0-frameTolerance:
            # keep track of start time/frame for later
            key_resp_39.frameNStart = frameN  # exact frame index
            key_resp_39.tStart = t  # local t and not account for scr refresh
            key_resp_39.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(key_resp_39, 'tStartRefresh')  # time at next scr refresh
            # add timestamp to datafile
            thisExp.timestampOnFlip(win, 'key_resp_39.started')
            # update status
            key_resp_39.status = STARTED
            # keyboard checking is just starting
            waitOnFlip = True
            win.callOnFlip(key_resp_39.clock.reset)  # t=0 on next screen flip
            win.callOnFlip(key_resp_39.clearEvents, eventType='keyboard')  # clear events on next screen flip
        if key_resp_39.status == STARTED and not waitOnFlip:
            theseKeys = key_resp_39.getKeys(keyList=['space'], ignoreKeys=["escape"], waitRelease=False)
            _key_resp_39_allKeys.extend(theseKeys)
            if len(_key_resp_39_allKeys):
                key_resp_39.keys = _key_resp_39_allKeys[-1].name  # just the last key pressed
                key_resp_39.rt = _key_resp_39_allKeys[-1].rt
                key_resp_39.duration = _key_resp_39_allKeys[-1].duration
                # a response ends the routine
                continueRoutine = False
        
        # check for quit (typically the Esc key)
        if defaultKeyboard.getKeys(keyList=["escape"]):
            thisExp.status = FINISHED
        if thisExp.status == FINISHED or endExpNow:
            endExperiment(thisExp, win=win)
            return
        # pause experiment here if requested
        if thisExp.status == PAUSED:
            pauseExperiment(
                thisExp=thisExp, 
                win=win, 
                timers=[routineTimer], 
                playbackComponents=[]
            )
            # skip the frame we paused on
            continue
        
        # check if all components have finished
        if not continueRoutine:  # a component has requested a forced-end of Routine
            immediate_rewar_lesson.forceEnded = routineForceEnded = True
            break
        continueRoutine = False  # will revert to True if at least one component still running
        for thisComponent in immediate_rewar_lesson.components:
            if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:
                continueRoutine = True
                break  # at least one component has not yet finished
        
        # refresh the screen
        if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen
            win.flip()
    
    # --- Ending Routine "immediate_rewar_lesson" ---
    for thisComponent in immediate_rewar_lesson.components:
        if hasattr(thisComponent, "setAutoDraw"):
            thisComponent.setAutoDraw(False)
    # store stop times for immediate_rewar_lesson
    immediate_rewar_lesson.tStop = globalClock.getTime(format='float')
    immediate_rewar_lesson.tStopRefresh = tThisFlipGlobal
    thisExp.addData('immediate_rewar_lesson.stopped', immediate_rewar_lesson.tStop)
    thisExp.nextEntry()
    # the Routine "immediate_rewar_lesson" was not non-slip safe, so reset the non-slip timer
    routineTimer.reset()
    
    # --- Prepare to start Routine "lesson_practice" ---
    # create an object to store info about Routine lesson_practice
    lesson_practice = data.Routine(
        name='lesson_practice',
        components=[text_144, key_resp_37],
    )
    lesson_practice.status = NOT_STARTED
    continueRoutine = True
    # update component parameters for each repeat
    # create starting attributes for key_resp_37
    key_resp_37.keys = []
    key_resp_37.rt = []
    _key_resp_37_allKeys = []
    # Run 'Begin Routine' code from code_34
    total_practice_planning=0
    # store start times for lesson_practice
    lesson_practice.tStartRefresh = win.getFutureFlipTime(clock=globalClock)
    lesson_practice.tStart = globalClock.getTime(format='float')
    lesson_practice.status = STARTED
    thisExp.addData('lesson_practice.started', lesson_practice.tStart)
    lesson_practice.maxDuration = None
    # keep track of which components have finished
    lesson_practiceComponents = lesson_practice.components
    for thisComponent in lesson_practice.components:
        thisComponent.tStart = None
        thisComponent.tStop = None
        thisComponent.tStartRefresh = None
        thisComponent.tStopRefresh = None
        if hasattr(thisComponent, 'status'):
            thisComponent.status = NOT_STARTED
    # reset timers
    t = 0
    _timeToFirstFrame = win.getFutureFlipTime(clock="now")
    frameN = -1
    
    # --- Run Routine "lesson_practice" ---
    lesson_practice.forceEnded = routineForceEnded = not continueRoutine
    while continueRoutine:
        # get current time
        t = routineTimer.getTime()
        tThisFlip = win.getFutureFlipTime(clock=routineTimer)
        tThisFlipGlobal = win.getFutureFlipTime(clock=None)
        frameN = frameN + 1  # number of completed frames (so 0 is the first frame)
        # update/draw components on each frame
        
        # *text_144* updates
        
        # if text_144 is starting this frame...
        if text_144.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
            # keep track of start time/frame for later
            text_144.frameNStart = frameN  # exact frame index
            text_144.tStart = t  # local t and not account for scr refresh
            text_144.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(text_144, 'tStartRefresh')  # time at next scr refresh
            # add timestamp to datafile
            thisExp.timestampOnFlip(win, 'text_144.started')
            # update status
            text_144.status = STARTED
            text_144.setAutoDraw(True)
        
        # if text_144 is active this frame...
        if text_144.status == STARTED:
            # update params
            pass
        
        # *key_resp_37* updates
        waitOnFlip = False
        
        # if key_resp_37 is starting this frame...
        if key_resp_37.status == NOT_STARTED and tThisFlip >= 0-frameTolerance:
            # keep track of start time/frame for later
            key_resp_37.frameNStart = frameN  # exact frame index
            key_resp_37.tStart = t  # local t and not account for scr refresh
            key_resp_37.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(key_resp_37, 'tStartRefresh')  # time at next scr refresh
            # add timestamp to datafile
            thisExp.timestampOnFlip(win, 'key_resp_37.started')
            # update status
            key_resp_37.status = STARTED
            # keyboard checking is just starting
            waitOnFlip = True
            win.callOnFlip(key_resp_37.clock.reset)  # t=0 on next screen flip
            win.callOnFlip(key_resp_37.clearEvents, eventType='keyboard')  # clear events on next screen flip
        if key_resp_37.status == STARTED and not waitOnFlip:
            theseKeys = key_resp_37.getKeys(keyList=['space'], ignoreKeys=["escape"], waitRelease=False)
            _key_resp_37_allKeys.extend(theseKeys)
            if len(_key_resp_37_allKeys):
                key_resp_37.keys = _key_resp_37_allKeys[-1].name  # just the last key pressed
                key_resp_37.rt = _key_resp_37_allKeys[-1].rt
                key_resp_37.duration = _key_resp_37_allKeys[-1].duration
                # a response ends the routine
                continueRoutine = False
        
        # check for quit (typically the Esc key)
        if defaultKeyboard.getKeys(keyList=["escape"]):
            thisExp.status = FINISHED
        if thisExp.status == FINISHED or endExpNow:
            endExperiment(thisExp, win=win)
            return
        # pause experiment here if requested
        if thisExp.status == PAUSED:
            pauseExperiment(
                thisExp=thisExp, 
                win=win, 
                timers=[routineTimer], 
                playbackComponents=[]
            )
            # skip the frame we paused on
            continue
        
        # check if all components have finished
        if not continueRoutine:  # a component has requested a forced-end of Routine
            lesson_practice.forceEnded = routineForceEnded = True
            break
        continueRoutine = False  # will revert to True if at least one component still running
        for thisComponent in lesson_practice.components:
            if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:
                continueRoutine = True
                break  # at least one component has not yet finished
        
        # refresh the screen
        if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen
            win.flip()
    
    # --- Ending Routine "lesson_practice" ---
    for thisComponent in lesson_practice.components:
        if hasattr(thisComponent, "setAutoDraw"):
            thisComponent.setAutoDraw(False)
    # store stop times for lesson_practice
    lesson_practice.tStop = globalClock.getTime(format='float')
    lesson_practice.tStopRefresh = tThisFlipGlobal
    thisExp.addData('lesson_practice.stopped', lesson_practice.tStop)
    thisExp.nextEntry()
    # the Routine "lesson_practice" was not non-slip safe, so reset the non-slip timer
    routineTimer.reset()
    
    # --- Prepare to start Routine "lesson_practice_2" ---
    # create an object to store info about Routine lesson_practice_2
    lesson_practice_2 = data.Routine(
        name='lesson_practice_2',
        components=[text_145, key_resp_38],
    )
    lesson_practice_2.status = NOT_STARTED
    continueRoutine = True
    # update component parameters for each repeat
    # create starting attributes for key_resp_38
    key_resp_38.keys = []
    key_resp_38.rt = []
    _key_resp_38_allKeys = []
    # Run 'Begin Routine' code from code_37
    total_practice_planning=0
    # store start times for lesson_practice_2
    lesson_practice_2.tStartRefresh = win.getFutureFlipTime(clock=globalClock)
    lesson_practice_2.tStart = globalClock.getTime(format='float')
    lesson_practice_2.status = STARTED
    thisExp.addData('lesson_practice_2.started', lesson_practice_2.tStart)
    lesson_practice_2.maxDuration = None
    # keep track of which components have finished
    lesson_practice_2Components = lesson_practice_2.components
    for thisComponent in lesson_practice_2.components:
        thisComponent.tStart = None
        thisComponent.tStop = None
        thisComponent.tStartRefresh = None
        thisComponent.tStopRefresh = None
        if hasattr(thisComponent, 'status'):
            thisComponent.status = NOT_STARTED
    # reset timers
    t = 0
    _timeToFirstFrame = win.getFutureFlipTime(clock="now")
    frameN = -1
    
    # --- Run Routine "lesson_practice_2" ---
    lesson_practice_2.forceEnded = routineForceEnded = not continueRoutine
    while continueRoutine:
        # get current time
        t = routineTimer.getTime()
        tThisFlip = win.getFutureFlipTime(clock=routineTimer)
        tThisFlipGlobal = win.getFutureFlipTime(clock=None)
        frameN = frameN + 1  # number of completed frames (so 0 is the first frame)
        # update/draw components on each frame
        
        # *text_145* updates
        
        # if text_145 is starting this frame...
        if text_145.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
            # keep track of start time/frame for later
            text_145.frameNStart = frameN  # exact frame index
            text_145.tStart = t  # local t and not account for scr refresh
            text_145.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(text_145, 'tStartRefresh')  # time at next scr refresh
            # add timestamp to datafile
            thisExp.timestampOnFlip(win, 'text_145.started')
            # update status
            text_145.status = STARTED
            text_145.setAutoDraw(True)
        
        # if text_145 is active this frame...
        if text_145.status == STARTED:
            # update params
            pass
        
        # *key_resp_38* updates
        waitOnFlip = False
        
        # if key_resp_38 is starting this frame...
        if key_resp_38.status == NOT_STARTED and tThisFlip >= 0-frameTolerance:
            # keep track of start time/frame for later
            key_resp_38.frameNStart = frameN  # exact frame index
            key_resp_38.tStart = t  # local t and not account for scr refresh
            key_resp_38.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(key_resp_38, 'tStartRefresh')  # time at next scr refresh
            # add timestamp to datafile
            thisExp.timestampOnFlip(win, 'key_resp_38.started')
            # update status
            key_resp_38.status = STARTED
            # keyboard checking is just starting
            waitOnFlip = True
            win.callOnFlip(key_resp_38.clock.reset)  # t=0 on next screen flip
            win.callOnFlip(key_resp_38.clearEvents, eventType='keyboard')  # clear events on next screen flip
        if key_resp_38.status == STARTED and not waitOnFlip:
            theseKeys = key_resp_38.getKeys(keyList=['space'], ignoreKeys=["escape"], waitRelease=False)
            _key_resp_38_allKeys.extend(theseKeys)
            if len(_key_resp_38_allKeys):
                key_resp_38.keys = _key_resp_38_allKeys[-1].name  # just the last key pressed
                key_resp_38.rt = _key_resp_38_allKeys[-1].rt
                key_resp_38.duration = _key_resp_38_allKeys[-1].duration
                # a response ends the routine
                continueRoutine = False
        
        # check for quit (typically the Esc key)
        if defaultKeyboard.getKeys(keyList=["escape"]):
            thisExp.status = FINISHED
        if thisExp.status == FINISHED or endExpNow:
            endExperiment(thisExp, win=win)
            return
        # pause experiment here if requested
        if thisExp.status == PAUSED:
            pauseExperiment(
                thisExp=thisExp, 
                win=win, 
                timers=[routineTimer], 
                playbackComponents=[]
            )
            # skip the frame we paused on
            continue
        
        # check if all components have finished
        if not continueRoutine:  # a component has requested a forced-end of Routine
            lesson_practice_2.forceEnded = routineForceEnded = True
            break
        continueRoutine = False  # will revert to True if at least one component still running
        for thisComponent in lesson_practice_2.components:
            if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:
                continueRoutine = True
                break  # at least one component has not yet finished
        
        # refresh the screen
        if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen
            win.flip()
    
    # --- Ending Routine "lesson_practice_2" ---
    for thisComponent in lesson_practice_2.components:
        if hasattr(thisComponent, "setAutoDraw"):
            thisComponent.setAutoDraw(False)
    # store stop times for lesson_practice_2
    lesson_practice_2.tStop = globalClock.getTime(format='float')
    lesson_practice_2.tStopRefresh = tThisFlipGlobal
    thisExp.addData('lesson_practice_2.stopped', lesson_practice_2.tStop)
    thisExp.nextEntry()
    # the Routine "lesson_practice_2" was not non-slip safe, so reset the non-slip timer
    routineTimer.reset()
    
    # --- Prepare to start Routine "start_real_planning" ---
    # create an object to store info about Routine start_real_planning
    start_real_planning = data.Routine(
        name='start_real_planning',
        components=[text_42, key_resp_6],
    )
    start_real_planning.status = NOT_STARTED
    continueRoutine = True
    # update component parameters for each repeat
    # create starting attributes for key_resp_6
    key_resp_6.keys = []
    key_resp_6.rt = []
    _key_resp_6_allKeys = []
    # Run 'Begin Routine' code from code_17
    total_planning=0
    # store start times for start_real_planning
    start_real_planning.tStartRefresh = win.getFutureFlipTime(clock=globalClock)
    start_real_planning.tStart = globalClock.getTime(format='float')
    start_real_planning.status = STARTED
    thisExp.addData('start_real_planning.started', start_real_planning.tStart)
    start_real_planning.maxDuration = None
    # keep track of which components have finished
    start_real_planningComponents = start_real_planning.components
    for thisComponent in start_real_planning.components:
        thisComponent.tStart = None
        thisComponent.tStop = None
        thisComponent.tStartRefresh = None
        thisComponent.tStopRefresh = None
        if hasattr(thisComponent, 'status'):
            thisComponent.status = NOT_STARTED
    # reset timers
    t = 0
    _timeToFirstFrame = win.getFutureFlipTime(clock="now")
    frameN = -1
    
    # --- Run Routine "start_real_planning" ---
    start_real_planning.forceEnded = routineForceEnded = not continueRoutine
    while continueRoutine:
        # get current time
        t = routineTimer.getTime()
        tThisFlip = win.getFutureFlipTime(clock=routineTimer)
        tThisFlipGlobal = win.getFutureFlipTime(clock=None)
        frameN = frameN + 1  # number of completed frames (so 0 is the first frame)
        # update/draw components on each frame
        
        # *text_42* updates
        
        # if text_42 is starting this frame...
        if text_42.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
            # keep track of start time/frame for later
            text_42.frameNStart = frameN  # exact frame index
            text_42.tStart = t  # local t and not account for scr refresh
            text_42.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(text_42, 'tStartRefresh')  # time at next scr refresh
            # add timestamp to datafile
            thisExp.timestampOnFlip(win, 'text_42.started')
            # update status
            text_42.status = STARTED
            text_42.setAutoDraw(True)
        
        # if text_42 is active this frame...
        if text_42.status == STARTED:
            # update params
            pass
        
        # *key_resp_6* updates
        waitOnFlip = False
        
        # if key_resp_6 is starting this frame...
        if key_resp_6.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
            # keep track of start time/frame for later
            key_resp_6.frameNStart = frameN  # exact frame index
            key_resp_6.tStart = t  # local t and not account for scr refresh
            key_resp_6.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(key_resp_6, 'tStartRefresh')  # time at next scr refresh
            # add timestamp to datafile
            thisExp.timestampOnFlip(win, 'key_resp_6.started')
            # update status
            key_resp_6.status = STARTED
            # keyboard checking is just starting
            waitOnFlip = True
            win.callOnFlip(key_resp_6.clock.reset)  # t=0 on next screen flip
            win.callOnFlip(key_resp_6.clearEvents, eventType='keyboard')  # clear events on next screen flip
        if key_resp_6.status == STARTED and not waitOnFlip:
            theseKeys = key_resp_6.getKeys(keyList=['space'], ignoreKeys=["escape"], waitRelease=False)
            _key_resp_6_allKeys.extend(theseKeys)
            if len(_key_resp_6_allKeys):
                key_resp_6.keys = _key_resp_6_allKeys[-1].name  # just the last key pressed
                key_resp_6.rt = _key_resp_6_allKeys[-1].rt
                key_resp_6.duration = _key_resp_6_allKeys[-1].duration
                # a response ends the routine
                continueRoutine = False
        
        # check for quit (typically the Esc key)
        if defaultKeyboard.getKeys(keyList=["escape"]):
            thisExp.status = FINISHED
        if thisExp.status == FINISHED or endExpNow:
            endExperiment(thisExp, win=win)
            return
        # pause experiment here if requested
        if thisExp.status == PAUSED:
            pauseExperiment(
                thisExp=thisExp, 
                win=win, 
                timers=[routineTimer], 
                playbackComponents=[]
            )
            # skip the frame we paused on
            continue
        
        # check if all components have finished
        if not continueRoutine:  # a component has requested a forced-end of Routine
            start_real_planning.forceEnded = routineForceEnded = True
            break
        continueRoutine = False  # will revert to True if at least one component still running
        for thisComponent in start_real_planning.components:
            if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:
                continueRoutine = True
                break  # at least one component has not yet finished
        
        # refresh the screen
        if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen
            win.flip()
    
    # --- Ending Routine "start_real_planning" ---
    for thisComponent in start_real_planning.components:
        if hasattr(thisComponent, "setAutoDraw"):
            thisComponent.setAutoDraw(False)
    # store stop times for start_real_planning
    start_real_planning.tStop = globalClock.getTime(format='float')
    start_real_planning.tStopRefresh = tThisFlipGlobal
    thisExp.addData('start_real_planning.stopped', start_real_planning.tStop)
    # check responses
    if key_resp_6.keys in ['', [], None]:  # No response was made
        key_resp_6.keys = None
    thisExp.addData('key_resp_6.keys',key_resp_6.keys)
    if key_resp_6.keys != None:  # we had a response
        thisExp.addData('key_resp_6.rt', key_resp_6.rt)
        thisExp.addData('key_resp_6.duration', key_resp_6.duration)
    thisExp.nextEntry()
    # the Routine "start_real_planning" was not non-slip safe, so reset the non-slip timer
    routineTimer.reset()
    
    # set up handler to look after randomisation of conditions etc
    planning_loop = data.TrialHandler2(
        name='planning_loop',
        nReps=1.0, 
        method='random', 
        extraInfo=expInfo, 
        originPath=-1, 
        trialList=data.importConditions('planning_trials.xlsx'), 
        seed=None, 
    )
    thisExp.addLoop(planning_loop)  # add the loop to the experiment
    thisPlanning_loop = planning_loop.trialList[0]  # so we can initialise stimuli with some values
    # abbreviate parameter names if possible (e.g. rgb = thisPlanning_loop.rgb)
    if thisPlanning_loop != None:
        for paramName in thisPlanning_loop:
            globals()[paramName] = thisPlanning_loop[paramName]
    if thisSession is not None:
        # if running in a Session with a Liaison client, send data up to now
        thisSession.sendExperimentData()
    
    for thisPlanning_loop in planning_loop:
        currentLoop = planning_loop
        thisExp.timestampOnFlip(win, 'thisRow.t', format=globalClock.format)
        if thisSession is not None:
            # if running in a Session with a Liaison client, send data up to now
            thisSession.sendExperimentData()
        # abbreviate parameter names if possible (e.g. rgb = thisPlanning_loop.rgb)
        if thisPlanning_loop != None:
            for paramName in thisPlanning_loop:
                globals()[paramName] = thisPlanning_loop[paramName]
        
        # --- Prepare to start Routine "plan1_info_2" ---
        # create an object to store info about Routine plan1_info_2
        plan1_info_2 = data.Routine(
            name='plan1_info_2',
            components=[text_5, R1, R2, rew1, rew2, text_6, plan1_response, babyleft, toothbrushright, text_117, text_120],
        )
        plan1_info_2.status = NOT_STARTED
        continueRoutine = True
        # update component parameters for each repeat
        # Run 'Begin Routine' code from code_5
        w2=400
        R2.setImage(r2)
        # create starting attributes for plan1_response
        plan1_response.keys = []
        plan1_response.rt = []
        _plan1_response_allKeys = []
        text_117.setText(total_planning)
        # store start times for plan1_info_2
        plan1_info_2.tStartRefresh = win.getFutureFlipTime(clock=globalClock)
        plan1_info_2.tStart = globalClock.getTime(format='float')
        plan1_info_2.status = STARTED
        thisExp.addData('plan1_info_2.started', plan1_info_2.tStart)
        plan1_info_2.maxDuration = None
        # keep track of which components have finished
        plan1_info_2Components = plan1_info_2.components
        for thisComponent in plan1_info_2.components:
            thisComponent.tStart = None
            thisComponent.tStop = None
            thisComponent.tStartRefresh = None
            thisComponent.tStopRefresh = None
            if hasattr(thisComponent, 'status'):
                thisComponent.status = NOT_STARTED
        # reset timers
        t = 0
        _timeToFirstFrame = win.getFutureFlipTime(clock="now")
        frameN = -1
        
        # --- Run Routine "plan1_info_2" ---
        # if trial has changed, end Routine now
        if isinstance(planning_loop, data.TrialHandler2) and thisPlanning_loop.thisN != planning_loop.thisTrial.thisN:
            continueRoutine = False
        plan1_info_2.forceEnded = routineForceEnded = not continueRoutine
        while continueRoutine:
            # get current time
            t = routineTimer.getTime()
            tThisFlip = win.getFutureFlipTime(clock=routineTimer)
            tThisFlipGlobal = win.getFutureFlipTime(clock=None)
            frameN = frameN + 1  # number of completed frames (so 0 is the first frame)
            # update/draw components on each frame
            
            # *text_5* updates
            
            # if text_5 is starting this frame...
            if text_5.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
                # keep track of start time/frame for later
                text_5.frameNStart = frameN  # exact frame index
                text_5.tStart = t  # local t and not account for scr refresh
                text_5.tStartRefresh = tThisFlipGlobal  # on global time
                win.timeOnFlip(text_5, 'tStartRefresh')  # time at next scr refresh
                # add timestamp to datafile
                thisExp.timestampOnFlip(win, 'text_5.started')
                # update status
                text_5.status = STARTED
                text_5.setAutoDraw(True)
            
            # if text_5 is active this frame...
            if text_5.status == STARTED:
                # update params
                pass
            
            # *R1* updates
            
            # if R1 is starting this frame...
            if R1.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
                # keep track of start time/frame for later
                R1.frameNStart = frameN  # exact frame index
                R1.tStart = t  # local t and not account for scr refresh
                R1.tStartRefresh = tThisFlipGlobal  # on global time
                win.timeOnFlip(R1, 'tStartRefresh')  # time at next scr refresh
                # add timestamp to datafile
                thisExp.timestampOnFlip(win, 'R1.started')
                # update status
                R1.status = STARTED
                R1.setAutoDraw(True)
            
            # if R1 is active this frame...
            if R1.status == STARTED:
                # update params
                pass
            
            # *R2* updates
            
            # if R2 is starting this frame...
            if R2.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
                # keep track of start time/frame for later
                R2.frameNStart = frameN  # exact frame index
                R2.tStart = t  # local t and not account for scr refresh
                R2.tStartRefresh = tThisFlipGlobal  # on global time
                win.timeOnFlip(R2, 'tStartRefresh')  # time at next scr refresh
                # add timestamp to datafile
                thisExp.timestampOnFlip(win, 'R2.started')
                # update status
                R2.status = STARTED
                R2.setAutoDraw(True)
            
            # if R2 is active this frame...
            if R2.status == STARTED:
                # update params
                pass
            
            # *rew1* updates
            
            # if rew1 is starting this frame...
            if rew1.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
                # keep track of start time/frame for later
                rew1.frameNStart = frameN  # exact frame index
                rew1.tStart = t  # local t and not account for scr refresh
                rew1.tStartRefresh = tThisFlipGlobal  # on global time
                win.timeOnFlip(rew1, 'tStartRefresh')  # time at next scr refresh
                # add timestamp to datafile
                thisExp.timestampOnFlip(win, 'rew1.started')
                # update status
                rew1.status = STARTED
                rew1.setAutoDraw(True)
            
            # if rew1 is active this frame...
            if rew1.status == STARTED:
                # update params
                pass
            
            # *rew2* updates
            
            # if rew2 is starting this frame...
            if rew2.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
                # keep track of start time/frame for later
                rew2.frameNStart = frameN  # exact frame index
                rew2.tStart = t  # local t and not account for scr refresh
                rew2.tStartRefresh = tThisFlipGlobal  # on global time
                win.timeOnFlip(rew2, 'tStartRefresh')  # time at next scr refresh
                # add timestamp to datafile
                thisExp.timestampOnFlip(win, 'rew2.started')
                # update status
                rew2.status = STARTED
                rew2.setAutoDraw(True)
            
            # if rew2 is active this frame...
            if rew2.status == STARTED:
                # update params
                rew2.setText(w2, log=False)
            
            # *text_6* updates
            
            # if text_6 is starting this frame...
            if text_6.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
                # keep track of start time/frame for later
                text_6.frameNStart = frameN  # exact frame index
                text_6.tStart = t  # local t and not account for scr refresh
                text_6.tStartRefresh = tThisFlipGlobal  # on global time
                win.timeOnFlip(text_6, 'tStartRefresh')  # time at next scr refresh
                # add timestamp to datafile
                thisExp.timestampOnFlip(win, 'text_6.started')
                # update status
                text_6.status = STARTED
                text_6.setAutoDraw(True)
            
            # if text_6 is active this frame...
            if text_6.status == STARTED:
                # update params
                pass
            
            # *plan1_response* updates
            waitOnFlip = False
            
            # if plan1_response is starting this frame...
            if plan1_response.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
                # keep track of start time/frame for later
                plan1_response.frameNStart = frameN  # exact frame index
                plan1_response.tStart = t  # local t and not account for scr refresh
                plan1_response.tStartRefresh = tThisFlipGlobal  # on global time
                win.timeOnFlip(plan1_response, 'tStartRefresh')  # time at next scr refresh
                # add timestamp to datafile
                thisExp.timestampOnFlip(win, 'plan1_response.started')
                # update status
                plan1_response.status = STARTED
                # keyboard checking is just starting
                waitOnFlip = True
                win.callOnFlip(plan1_response.clock.reset)  # t=0 on next screen flip
                win.callOnFlip(plan1_response.clearEvents, eventType='keyboard')  # clear events on next screen flip
            if plan1_response.status == STARTED and not waitOnFlip:
                theseKeys = plan1_response.getKeys(keyList=['left', 'right','space'], ignoreKeys=["escape"], waitRelease=False)
                _plan1_response_allKeys.extend(theseKeys)
                if len(_plan1_response_allKeys):
                    plan1_response.keys = _plan1_response_allKeys[-1].name  # just the last key pressed
                    plan1_response.rt = _plan1_response_allKeys[-1].rt
                    plan1_response.duration = _plan1_response_allKeys[-1].duration
                    # a response ends the routine
                    continueRoutine = False
            
            # *babyleft* updates
            
            # if babyleft is starting this frame...
            if babyleft.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
                # keep track of start time/frame for later
                babyleft.frameNStart = frameN  # exact frame index
                babyleft.tStart = t  # local t and not account for scr refresh
                babyleft.tStartRefresh = tThisFlipGlobal  # on global time
                win.timeOnFlip(babyleft, 'tStartRefresh')  # time at next scr refresh
                # add timestamp to datafile
                thisExp.timestampOnFlip(win, 'babyleft.started')
                # update status
                babyleft.status = STARTED
                babyleft.setAutoDraw(True)
            
            # if babyleft is active this frame...
            if babyleft.status == STARTED:
                # update params
                pass
            
            # *toothbrushright* updates
            
            # if toothbrushright is starting this frame...
            if toothbrushright.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
                # keep track of start time/frame for later
                toothbrushright.frameNStart = frameN  # exact frame index
                toothbrushright.tStart = t  # local t and not account for scr refresh
                toothbrushright.tStartRefresh = tThisFlipGlobal  # on global time
                win.timeOnFlip(toothbrushright, 'tStartRefresh')  # time at next scr refresh
                # add timestamp to datafile
                thisExp.timestampOnFlip(win, 'toothbrushright.started')
                # update status
                toothbrushright.status = STARTED
                toothbrushright.setAutoDraw(True)
            
            # if toothbrushright is active this frame...
            if toothbrushright.status == STARTED:
                # update params
                pass
            
            # *text_117* updates
            
            # if text_117 is starting this frame...
            if text_117.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
                # keep track of start time/frame for later
                text_117.frameNStart = frameN  # exact frame index
                text_117.tStart = t  # local t and not account for scr refresh
                text_117.tStartRefresh = tThisFlipGlobal  # on global time
                win.timeOnFlip(text_117, 'tStartRefresh')  # time at next scr refresh
                # add timestamp to datafile
                thisExp.timestampOnFlip(win, 'text_117.started')
                # update status
                text_117.status = STARTED
                text_117.setAutoDraw(True)
            
            # if text_117 is active this frame...
            if text_117.status == STARTED:
                # update params
                pass
            
            # *text_120* updates
            
            # if text_120 is starting this frame...
            if text_120.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
                # keep track of start time/frame for later
                text_120.frameNStart = frameN  # exact frame index
                text_120.tStart = t  # local t and not account for scr refresh
                text_120.tStartRefresh = tThisFlipGlobal  # on global time
                win.timeOnFlip(text_120, 'tStartRefresh')  # time at next scr refresh
                # add timestamp to datafile
                thisExp.timestampOnFlip(win, 'text_120.started')
                # update status
                text_120.status = STARTED
                text_120.setAutoDraw(True)
            
            # if text_120 is active this frame...
            if text_120.status == STARTED:
                # update params
                pass
            
            # check for quit (typically the Esc key)
            if defaultKeyboard.getKeys(keyList=["escape"]):
                thisExp.status = FINISHED
            if thisExp.status == FINISHED or endExpNow:
                endExperiment(thisExp, win=win)
                return
            # pause experiment here if requested
            if thisExp.status == PAUSED:
                pauseExperiment(
                    thisExp=thisExp, 
                    win=win, 
                    timers=[routineTimer], 
                    playbackComponents=[]
                )
                # skip the frame we paused on
                continue
            
            # check if all components have finished
            if not continueRoutine:  # a component has requested a forced-end of Routine
                plan1_info_2.forceEnded = routineForceEnded = True
                break
            continueRoutine = False  # will revert to True if at least one component still running
            for thisComponent in plan1_info_2.components:
                if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:
                    continueRoutine = True
                    break  # at least one component has not yet finished
            
            # refresh the screen
            if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen
                win.flip()
        
        # --- Ending Routine "plan1_info_2" ---
        for thisComponent in plan1_info_2.components:
            if hasattr(thisComponent, "setAutoDraw"):
                thisComponent.setAutoDraw(False)
        # store stop times for plan1_info_2
        plan1_info_2.tStop = globalClock.getTime(format='float')
        plan1_info_2.tStopRefresh = tThisFlipGlobal
        thisExp.addData('plan1_info_2.stopped', plan1_info_2.tStop)
        # check responses
        if plan1_response.keys in ['', [], None]:  # No response was made
            plan1_response.keys = None
        planning_loop.addData('plan1_response.keys',plan1_response.keys)
        if plan1_response.keys != None:  # we had a response
            planning_loop.addData('plan1_response.rt', plan1_response.rt)
            planning_loop.addData('plan1_response.duration', plan1_response.duration)
        # the Routine "plan1_info_2" was not non-slip safe, so reset the non-slip timer
        routineTimer.reset()
        
        # --- Prepare to start Routine "plan2_info" ---
        # create an object to store info about Routine plan2_info
        plan2_info = data.Routine(
            name='plan2_info',
            components=[text_7, R1_2, R2_2, rew1_2, rew2_2, text_10, plan2_response, current_image_decision2, text_118, text_121],
        )
        plan2_info.status = NOT_STARTED
        continueRoutine = True
        # update component parameters for each repeat
        # Run 'Begin Routine' code from code_7
        if plan1_response.keys=='space':
            total_planning+=100
            if random.random()>0.5:
                x='baby'
            else:
                x='toothbrush'
        elif plan1_response.keys=='left':
            x='baby'
        elif plan1_response.keys=='right':
            x='toothbrush'
        current_image='images/'+x+'.png'
        R1_2.setImage('images/computer.png')
        R2_2.setImage(r2)
        # create starting attributes for plan2_response
        plan2_response.keys = []
        plan2_response.rt = []
        _plan2_response_allKeys = []
        current_image_decision2.setImage(current_image)
        text_118.setText(total_planning)
        # store start times for plan2_info
        plan2_info.tStartRefresh = win.getFutureFlipTime(clock=globalClock)
        plan2_info.tStart = globalClock.getTime(format='float')
        plan2_info.status = STARTED
        thisExp.addData('plan2_info.started', plan2_info.tStart)
        plan2_info.maxDuration = None
        # keep track of which components have finished
        plan2_infoComponents = plan2_info.components
        for thisComponent in plan2_info.components:
            thisComponent.tStart = None
            thisComponent.tStop = None
            thisComponent.tStartRefresh = None
            thisComponent.tStopRefresh = None
            if hasattr(thisComponent, 'status'):
                thisComponent.status = NOT_STARTED
        # reset timers
        t = 0
        _timeToFirstFrame = win.getFutureFlipTime(clock="now")
        frameN = -1
        
        # --- Run Routine "plan2_info" ---
        # if trial has changed, end Routine now
        if isinstance(planning_loop, data.TrialHandler2) and thisPlanning_loop.thisN != planning_loop.thisTrial.thisN:
            continueRoutine = False
        plan2_info.forceEnded = routineForceEnded = not continueRoutine
        while continueRoutine:
            # get current time
            t = routineTimer.getTime()
            tThisFlip = win.getFutureFlipTime(clock=routineTimer)
            tThisFlipGlobal = win.getFutureFlipTime(clock=None)
            frameN = frameN + 1  # number of completed frames (so 0 is the first frame)
            # update/draw components on each frame
            
            # *text_7* updates
            
            # if text_7 is starting this frame...
            if text_7.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
                # keep track of start time/frame for later
                text_7.frameNStart = frameN  # exact frame index
                text_7.tStart = t  # local t and not account for scr refresh
                text_7.tStartRefresh = tThisFlipGlobal  # on global time
                win.timeOnFlip(text_7, 'tStartRefresh')  # time at next scr refresh
                # add timestamp to datafile
                thisExp.timestampOnFlip(win, 'text_7.started')
                # update status
                text_7.status = STARTED
                text_7.setAutoDraw(True)
            
            # if text_7 is active this frame...
            if text_7.status == STARTED:
                # update params
                pass
            
            # *R1_2* updates
            
            # if R1_2 is starting this frame...
            if R1_2.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
                # keep track of start time/frame for later
                R1_2.frameNStart = frameN  # exact frame index
                R1_2.tStart = t  # local t and not account for scr refresh
                R1_2.tStartRefresh = tThisFlipGlobal  # on global time
                win.timeOnFlip(R1_2, 'tStartRefresh')  # time at next scr refresh
                # add timestamp to datafile
                thisExp.timestampOnFlip(win, 'R1_2.started')
                # update status
                R1_2.status = STARTED
                R1_2.setAutoDraw(True)
            
            # if R1_2 is active this frame...
            if R1_2.status == STARTED:
                # update params
                pass
            
            # *R2_2* updates
            
            # if R2_2 is starting this frame...
            if R2_2.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
                # keep track of start time/frame for later
                R2_2.frameNStart = frameN  # exact frame index
                R2_2.tStart = t  # local t and not account for scr refresh
                R2_2.tStartRefresh = tThisFlipGlobal  # on global time
                win.timeOnFlip(R2_2, 'tStartRefresh')  # time at next scr refresh
                # add timestamp to datafile
                thisExp.timestampOnFlip(win, 'R2_2.started')
                # update status
                R2_2.status = STARTED
                R2_2.setAutoDraw(True)
            
            # if R2_2 is active this frame...
            if R2_2.status == STARTED:
                # update params
                pass
            
            # *rew1_2* updates
            
            # if rew1_2 is starting this frame...
            if rew1_2.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
                # keep track of start time/frame for later
                rew1_2.frameNStart = frameN  # exact frame index
                rew1_2.tStart = t  # local t and not account for scr refresh
                rew1_2.tStartRefresh = tThisFlipGlobal  # on global time
                win.timeOnFlip(rew1_2, 'tStartRefresh')  # time at next scr refresh
                # add timestamp to datafile
                thisExp.timestampOnFlip(win, 'rew1_2.started')
                # update status
                rew1_2.status = STARTED
                rew1_2.setAutoDraw(True)
            
            # if rew1_2 is active this frame...
            if rew1_2.status == STARTED:
                # update params
                pass
            
            # *rew2_2* updates
            
            # if rew2_2 is starting this frame...
            if rew2_2.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
                # keep track of start time/frame for later
                rew2_2.frameNStart = frameN  # exact frame index
                rew2_2.tStart = t  # local t and not account for scr refresh
                rew2_2.tStartRefresh = tThisFlipGlobal  # on global time
                win.timeOnFlip(rew2_2, 'tStartRefresh')  # time at next scr refresh
                # add timestamp to datafile
                thisExp.timestampOnFlip(win, 'rew2_2.started')
                # update status
                rew2_2.status = STARTED
                rew2_2.setAutoDraw(True)
            
            # if rew2_2 is active this frame...
            if rew2_2.status == STARTED:
                # update params
                rew2_2.setText(w2, log=False)
            
            # *text_10* updates
            
            # if text_10 is starting this frame...
            if text_10.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
                # keep track of start time/frame for later
                text_10.frameNStart = frameN  # exact frame index
                text_10.tStart = t  # local t and not account for scr refresh
                text_10.tStartRefresh = tThisFlipGlobal  # on global time
                win.timeOnFlip(text_10, 'tStartRefresh')  # time at next scr refresh
                # add timestamp to datafile
                thisExp.timestampOnFlip(win, 'text_10.started')
                # update status
                text_10.status = STARTED
                text_10.setAutoDraw(True)
            
            # if text_10 is active this frame...
            if text_10.status == STARTED:
                # update params
                pass
            
            # *plan2_response* updates
            waitOnFlip = False
            
            # if plan2_response is starting this frame...
            if plan2_response.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
                # keep track of start time/frame for later
                plan2_response.frameNStart = frameN  # exact frame index
                plan2_response.tStart = t  # local t and not account for scr refresh
                plan2_response.tStartRefresh = tThisFlipGlobal  # on global time
                win.timeOnFlip(plan2_response, 'tStartRefresh')  # time at next scr refresh
                # add timestamp to datafile
                thisExp.timestampOnFlip(win, 'plan2_response.started')
                # update status
                plan2_response.status = STARTED
                # keyboard checking is just starting
                waitOnFlip = True
                win.callOnFlip(plan2_response.clock.reset)  # t=0 on next screen flip
                win.callOnFlip(plan2_response.clearEvents, eventType='keyboard')  # clear events on next screen flip
            if plan2_response.status == STARTED and not waitOnFlip:
                theseKeys = plan2_response.getKeys(keyList=['left', 'right','space'], ignoreKeys=["escape"], waitRelease=False)
                _plan2_response_allKeys.extend(theseKeys)
                if len(_plan2_response_allKeys):
                    plan2_response.keys = _plan2_response_allKeys[-1].name  # just the last key pressed
                    plan2_response.rt = _plan2_response_allKeys[-1].rt
                    plan2_response.duration = _plan2_response_allKeys[-1].duration
                    # a response ends the routine
                    continueRoutine = False
            
            # *current_image_decision2* updates
            
            # if current_image_decision2 is starting this frame...
            if current_image_decision2.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
                # keep track of start time/frame for later
                current_image_decision2.frameNStart = frameN  # exact frame index
                current_image_decision2.tStart = t  # local t and not account for scr refresh
                current_image_decision2.tStartRefresh = tThisFlipGlobal  # on global time
                win.timeOnFlip(current_image_decision2, 'tStartRefresh')  # time at next scr refresh
                # add timestamp to datafile
                thisExp.timestampOnFlip(win, 'current_image_decision2.started')
                # update status
                current_image_decision2.status = STARTED
                current_image_decision2.setAutoDraw(True)
            
            # if current_image_decision2 is active this frame...
            if current_image_decision2.status == STARTED:
                # update params
                pass
            
            # *text_118* updates
            
            # if text_118 is starting this frame...
            if text_118.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
                # keep track of start time/frame for later
                text_118.frameNStart = frameN  # exact frame index
                text_118.tStart = t  # local t and not account for scr refresh
                text_118.tStartRefresh = tThisFlipGlobal  # on global time
                win.timeOnFlip(text_118, 'tStartRefresh')  # time at next scr refresh
                # add timestamp to datafile
                thisExp.timestampOnFlip(win, 'text_118.started')
                # update status
                text_118.status = STARTED
                text_118.setAutoDraw(True)
            
            # if text_118 is active this frame...
            if text_118.status == STARTED:
                # update params
                pass
            
            # *text_121* updates
            
            # if text_121 is starting this frame...
            if text_121.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
                # keep track of start time/frame for later
                text_121.frameNStart = frameN  # exact frame index
                text_121.tStart = t  # local t and not account for scr refresh
                text_121.tStartRefresh = tThisFlipGlobal  # on global time
                win.timeOnFlip(text_121, 'tStartRefresh')  # time at next scr refresh
                # add timestamp to datafile
                thisExp.timestampOnFlip(win, 'text_121.started')
                # update status
                text_121.status = STARTED
                text_121.setAutoDraw(True)
            
            # if text_121 is active this frame...
            if text_121.status == STARTED:
                # update params
                pass
            
            # check for quit (typically the Esc key)
            if defaultKeyboard.getKeys(keyList=["escape"]):
                thisExp.status = FINISHED
            if thisExp.status == FINISHED or endExpNow:
                endExperiment(thisExp, win=win)
                return
            # pause experiment here if requested
            if thisExp.status == PAUSED:
                pauseExperiment(
                    thisExp=thisExp, 
                    win=win, 
                    timers=[routineTimer], 
                    playbackComponents=[]
                )
                # skip the frame we paused on
                continue
            
            # check if all components have finished
            if not continueRoutine:  # a component has requested a forced-end of Routine
                plan2_info.forceEnded = routineForceEnded = True
                break
            continueRoutine = False  # will revert to True if at least one component still running
            for thisComponent in plan2_info.components:
                if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:
                    continueRoutine = True
                    break  # at least one component has not yet finished
            
            # refresh the screen
            if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen
                win.flip()
        
        # --- Ending Routine "plan2_info" ---
        for thisComponent in plan2_info.components:
            if hasattr(thisComponent, "setAutoDraw"):
                thisComponent.setAutoDraw(False)
        # store stop times for plan2_info
        plan2_info.tStop = globalClock.getTime(format='float')
        plan2_info.tStopRefresh = tThisFlipGlobal
        thisExp.addData('plan2_info.stopped', plan2_info.tStop)
        # check responses
        if plan2_response.keys in ['', [], None]:  # No response was made
            plan2_response.keys = None
        planning_loop.addData('plan2_response.keys',plan2_response.keys)
        if plan2_response.keys != None:  # we had a response
            planning_loop.addData('plan2_response.rt', plan2_response.rt)
            planning_loop.addData('plan2_response.duration', plan2_response.duration)
        # the Routine "plan2_info" was not non-slip safe, so reset the non-slip timer
        routineTimer.reset()
        
        # --- Prepare to start Routine "plan3_info" ---
        # create an object to store info about Routine plan3_info
        plan3_info = data.Routine(
            name='plan3_info',
            components=[text_14, R1_3, R2_3, rew1_3, rew2_3, text_15, plan3_response, current_image_decision3, text_122, text_123],
        )
        plan3_info.status = NOT_STARTED
        continueRoutine = True
        # update component parameters for each repeat
        # Run 'Begin Routine' code from code_9
        if plan2_response.keys=='space':
            total_planning += 100;
            if random.random()>0.5:
                x='left'
            else:
                x='right'
        elif plan2_response.keys=='left':
            x='left'
        elif plan2_response.keys=='right':
            x='right' 
        current_image2='images/'+cogmap[current_image[7:-4]+'_'+x]+'.png'
        R2_3.setImage(r2)
        # create starting attributes for plan3_response
        plan3_response.keys = []
        plan3_response.rt = []
        _plan3_response_allKeys = []
        current_image_decision3.setImage(current_image2)
        text_122.setText(total_planning)
        # store start times for plan3_info
        plan3_info.tStartRefresh = win.getFutureFlipTime(clock=globalClock)
        plan3_info.tStart = globalClock.getTime(format='float')
        plan3_info.status = STARTED
        thisExp.addData('plan3_info.started', plan3_info.tStart)
        plan3_info.maxDuration = None
        # keep track of which components have finished
        plan3_infoComponents = plan3_info.components
        for thisComponent in plan3_info.components:
            thisComponent.tStart = None
            thisComponent.tStop = None
            thisComponent.tStartRefresh = None
            thisComponent.tStopRefresh = None
            if hasattr(thisComponent, 'status'):
                thisComponent.status = NOT_STARTED
        # reset timers
        t = 0
        _timeToFirstFrame = win.getFutureFlipTime(clock="now")
        frameN = -1
        
        # --- Run Routine "plan3_info" ---
        # if trial has changed, end Routine now
        if isinstance(planning_loop, data.TrialHandler2) and thisPlanning_loop.thisN != planning_loop.thisTrial.thisN:
            continueRoutine = False
        plan3_info.forceEnded = routineForceEnded = not continueRoutine
        while continueRoutine:
            # get current time
            t = routineTimer.getTime()
            tThisFlip = win.getFutureFlipTime(clock=routineTimer)
            tThisFlipGlobal = win.getFutureFlipTime(clock=None)
            frameN = frameN + 1  # number of completed frames (so 0 is the first frame)
            # update/draw components on each frame
            
            # *text_14* updates
            
            # if text_14 is starting this frame...
            if text_14.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
                # keep track of start time/frame for later
                text_14.frameNStart = frameN  # exact frame index
                text_14.tStart = t  # local t and not account for scr refresh
                text_14.tStartRefresh = tThisFlipGlobal  # on global time
                win.timeOnFlip(text_14, 'tStartRefresh')  # time at next scr refresh
                # add timestamp to datafile
                thisExp.timestampOnFlip(win, 'text_14.started')
                # update status
                text_14.status = STARTED
                text_14.setAutoDraw(True)
            
            # if text_14 is active this frame...
            if text_14.status == STARTED:
                # update params
                pass
            
            # *R1_3* updates
            
            # if R1_3 is starting this frame...
            if R1_3.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
                # keep track of start time/frame for later
                R1_3.frameNStart = frameN  # exact frame index
                R1_3.tStart = t  # local t and not account for scr refresh
                R1_3.tStartRefresh = tThisFlipGlobal  # on global time
                win.timeOnFlip(R1_3, 'tStartRefresh')  # time at next scr refresh
                # add timestamp to datafile
                thisExp.timestampOnFlip(win, 'R1_3.started')
                # update status
                R1_3.status = STARTED
                R1_3.setAutoDraw(True)
            
            # if R1_3 is active this frame...
            if R1_3.status == STARTED:
                # update params
                pass
            
            # *R2_3* updates
            
            # if R2_3 is starting this frame...
            if R2_3.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
                # keep track of start time/frame for later
                R2_3.frameNStart = frameN  # exact frame index
                R2_3.tStart = t  # local t and not account for scr refresh
                R2_3.tStartRefresh = tThisFlipGlobal  # on global time
                win.timeOnFlip(R2_3, 'tStartRefresh')  # time at next scr refresh
                # add timestamp to datafile
                thisExp.timestampOnFlip(win, 'R2_3.started')
                # update status
                R2_3.status = STARTED
                R2_3.setAutoDraw(True)
            
            # if R2_3 is active this frame...
            if R2_3.status == STARTED:
                # update params
                pass
            
            # *rew1_3* updates
            
            # if rew1_3 is starting this frame...
            if rew1_3.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
                # keep track of start time/frame for later
                rew1_3.frameNStart = frameN  # exact frame index
                rew1_3.tStart = t  # local t and not account for scr refresh
                rew1_3.tStartRefresh = tThisFlipGlobal  # on global time
                win.timeOnFlip(rew1_3, 'tStartRefresh')  # time at next scr refresh
                # add timestamp to datafile
                thisExp.timestampOnFlip(win, 'rew1_3.started')
                # update status
                rew1_3.status = STARTED
                rew1_3.setAutoDraw(True)
            
            # if rew1_3 is active this frame...
            if rew1_3.status == STARTED:
                # update params
                pass
            
            # *rew2_3* updates
            
            # if rew2_3 is starting this frame...
            if rew2_3.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
                # keep track of start time/frame for later
                rew2_3.frameNStart = frameN  # exact frame index
                rew2_3.tStart = t  # local t and not account for scr refresh
                rew2_3.tStartRefresh = tThisFlipGlobal  # on global time
                win.timeOnFlip(rew2_3, 'tStartRefresh')  # time at next scr refresh
                # add timestamp to datafile
                thisExp.timestampOnFlip(win, 'rew2_3.started')
                # update status
                rew2_3.status = STARTED
                rew2_3.setAutoDraw(True)
            
            # if rew2_3 is active this frame...
            if rew2_3.status == STARTED:
                # update params
                rew2_3.setText(w2, log=False)
            
            # *text_15* updates
            
            # if text_15 is starting this frame...
            if text_15.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
                # keep track of start time/frame for later
                text_15.frameNStart = frameN  # exact frame index
                text_15.tStart = t  # local t and not account for scr refresh
                text_15.tStartRefresh = tThisFlipGlobal  # on global time
                win.timeOnFlip(text_15, 'tStartRefresh')  # time at next scr refresh
                # add timestamp to datafile
                thisExp.timestampOnFlip(win, 'text_15.started')
                # update status
                text_15.status = STARTED
                text_15.setAutoDraw(True)
            
            # if text_15 is active this frame...
            if text_15.status == STARTED:
                # update params
                pass
            
            # *plan3_response* updates
            waitOnFlip = False
            
            # if plan3_response is starting this frame...
            if plan3_response.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
                # keep track of start time/frame for later
                plan3_response.frameNStart = frameN  # exact frame index
                plan3_response.tStart = t  # local t and not account for scr refresh
                plan3_response.tStartRefresh = tThisFlipGlobal  # on global time
                win.timeOnFlip(plan3_response, 'tStartRefresh')  # time at next scr refresh
                # add timestamp to datafile
                thisExp.timestampOnFlip(win, 'plan3_response.started')
                # update status
                plan3_response.status = STARTED
                # keyboard checking is just starting
                waitOnFlip = True
                win.callOnFlip(plan3_response.clock.reset)  # t=0 on next screen flip
                win.callOnFlip(plan3_response.clearEvents, eventType='keyboard')  # clear events on next screen flip
            if plan3_response.status == STARTED and not waitOnFlip:
                theseKeys = plan3_response.getKeys(keyList=['left', 'right','space'], ignoreKeys=["escape"], waitRelease=False)
                _plan3_response_allKeys.extend(theseKeys)
                if len(_plan3_response_allKeys):
                    plan3_response.keys = _plan3_response_allKeys[-1].name  # just the last key pressed
                    plan3_response.rt = _plan3_response_allKeys[-1].rt
                    plan3_response.duration = _plan3_response_allKeys[-1].duration
                    # a response ends the routine
                    continueRoutine = False
            
            # *current_image_decision3* updates
            
            # if current_image_decision3 is starting this frame...
            if current_image_decision3.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
                # keep track of start time/frame for later
                current_image_decision3.frameNStart = frameN  # exact frame index
                current_image_decision3.tStart = t  # local t and not account for scr refresh
                current_image_decision3.tStartRefresh = tThisFlipGlobal  # on global time
                win.timeOnFlip(current_image_decision3, 'tStartRefresh')  # time at next scr refresh
                # add timestamp to datafile
                thisExp.timestampOnFlip(win, 'current_image_decision3.started')
                # update status
                current_image_decision3.status = STARTED
                current_image_decision3.setAutoDraw(True)
            
            # if current_image_decision3 is active this frame...
            if current_image_decision3.status == STARTED:
                # update params
                pass
            
            # *text_122* updates
            
            # if text_122 is starting this frame...
            if text_122.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
                # keep track of start time/frame for later
                text_122.frameNStart = frameN  # exact frame index
                text_122.tStart = t  # local t and not account for scr refresh
                text_122.tStartRefresh = tThisFlipGlobal  # on global time
                win.timeOnFlip(text_122, 'tStartRefresh')  # time at next scr refresh
                # add timestamp to datafile
                thisExp.timestampOnFlip(win, 'text_122.started')
                # update status
                text_122.status = STARTED
                text_122.setAutoDraw(True)
            
            # if text_122 is active this frame...
            if text_122.status == STARTED:
                # update params
                pass
            
            # *text_123* updates
            
            # if text_123 is starting this frame...
            if text_123.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
                # keep track of start time/frame for later
                text_123.frameNStart = frameN  # exact frame index
                text_123.tStart = t  # local t and not account for scr refresh
                text_123.tStartRefresh = tThisFlipGlobal  # on global time
                win.timeOnFlip(text_123, 'tStartRefresh')  # time at next scr refresh
                # add timestamp to datafile
                thisExp.timestampOnFlip(win, 'text_123.started')
                # update status
                text_123.status = STARTED
                text_123.setAutoDraw(True)
            
            # if text_123 is active this frame...
            if text_123.status == STARTED:
                # update params
                pass
            
            # check for quit (typically the Esc key)
            if defaultKeyboard.getKeys(keyList=["escape"]):
                thisExp.status = FINISHED
            if thisExp.status == FINISHED or endExpNow:
                endExperiment(thisExp, win=win)
                return
            # pause experiment here if requested
            if thisExp.status == PAUSED:
                pauseExperiment(
                    thisExp=thisExp, 
                    win=win, 
                    timers=[routineTimer], 
                    playbackComponents=[]
                )
                # skip the frame we paused on
                continue
            
            # check if all components have finished
            if not continueRoutine:  # a component has requested a forced-end of Routine
                plan3_info.forceEnded = routineForceEnded = True
                break
            continueRoutine = False  # will revert to True if at least one component still running
            for thisComponent in plan3_info.components:
                if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:
                    continueRoutine = True
                    break  # at least one component has not yet finished
            
            # refresh the screen
            if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen
                win.flip()
        
        # --- Ending Routine "plan3_info" ---
        for thisComponent in plan3_info.components:
            if hasattr(thisComponent, "setAutoDraw"):
                thisComponent.setAutoDraw(False)
        # store stop times for plan3_info
        plan3_info.tStop = globalClock.getTime(format='float')
        plan3_info.tStopRefresh = tThisFlipGlobal
        thisExp.addData('plan3_info.stopped', plan3_info.tStop)
        # check responses
        if plan3_response.keys in ['', [], None]:  # No response was made
            plan3_response.keys = None
        planning_loop.addData('plan3_response.keys',plan3_response.keys)
        if plan3_response.keys != None:  # we had a response
            planning_loop.addData('plan3_response.rt', plan3_response.rt)
            planning_loop.addData('plan3_response.duration', plan3_response.duration)
        # the Routine "plan3_info" was not non-slip safe, so reset the non-slip timer
        routineTimer.reset()
        
        # --- Prepare to start Routine "planning4" ---
        # create an object to store info about Routine planning4
        planning4 = data.Routine(
            name='planning4',
            components=[image_4, text_19, text_119, text_131],
        )
        planning4.status = NOT_STARTED
        continueRoutine = True
        # update component parameters for each repeat
        # Run 'Begin Routine' code from code_25
        if current_image3==r2:
            total_planning+=w2
        image_4.setImage(current_image3)
        text_119.setText(total_planning)
        # store start times for planning4
        planning4.tStartRefresh = win.getFutureFlipTime(clock=globalClock)
        planning4.tStart = globalClock.getTime(format='float')
        planning4.status = STARTED
        thisExp.addData('planning4.started', planning4.tStart)
        planning4.maxDuration = None
        # keep track of which components have finished
        planning4Components = planning4.components
        for thisComponent in planning4.components:
            thisComponent.tStart = None
            thisComponent.tStop = None
            thisComponent.tStartRefresh = None
            thisComponent.tStopRefresh = None
            if hasattr(thisComponent, 'status'):
                thisComponent.status = NOT_STARTED
        # reset timers
        t = 0
        _timeToFirstFrame = win.getFutureFlipTime(clock="now")
        frameN = -1
        
        # --- Run Routine "planning4" ---
        # if trial has changed, end Routine now
        if isinstance(planning_loop, data.TrialHandler2) and thisPlanning_loop.thisN != planning_loop.thisTrial.thisN:
            continueRoutine = False
        planning4.forceEnded = routineForceEnded = not continueRoutine
        while continueRoutine and routineTimer.getTime() < 2.0:
            # get current time
            t = routineTimer.getTime()
            tThisFlip = win.getFutureFlipTime(clock=routineTimer)
            tThisFlipGlobal = win.getFutureFlipTime(clock=None)
            frameN = frameN + 1  # number of completed frames (so 0 is the first frame)
            # update/draw components on each frame
            
            # *image_4* updates
            
            # if image_4 is starting this frame...
            if image_4.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
                # keep track of start time/frame for later
                image_4.frameNStart = frameN  # exact frame index
                image_4.tStart = t  # local t and not account for scr refresh
                image_4.tStartRefresh = tThisFlipGlobal  # on global time
                win.timeOnFlip(image_4, 'tStartRefresh')  # time at next scr refresh
                # add timestamp to datafile
                thisExp.timestampOnFlip(win, 'image_4.started')
                # update status
                image_4.status = STARTED
                image_4.setAutoDraw(True)
            
            # if image_4 is active this frame...
            if image_4.status == STARTED:
                # update params
                pass
            
            # if image_4 is stopping this frame...
            if image_4.status == STARTED:
                # is it time to stop? (based on global clock, using actual start)
                if tThisFlipGlobal > image_4.tStartRefresh + 2.0-frameTolerance:
                    # keep track of stop time/frame for later
                    image_4.tStop = t  # not accounting for scr refresh
                    image_4.tStopRefresh = tThisFlipGlobal  # on global time
                    image_4.frameNStop = frameN  # exact frame index
                    # add timestamp to datafile
                    thisExp.timestampOnFlip(win, 'image_4.stopped')
                    # update status
                    image_4.status = FINISHED
                    image_4.setAutoDraw(False)
            
            # *text_19* updates
            
            # if text_19 is starting this frame...
            if text_19.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
                # keep track of start time/frame for later
                text_19.frameNStart = frameN  # exact frame index
                text_19.tStart = t  # local t and not account for scr refresh
                text_19.tStartRefresh = tThisFlipGlobal  # on global time
                win.timeOnFlip(text_19, 'tStartRefresh')  # time at next scr refresh
                # add timestamp to datafile
                thisExp.timestampOnFlip(win, 'text_19.started')
                # update status
                text_19.status = STARTED
                text_19.setAutoDraw(True)
            
            # if text_19 is active this frame...
            if text_19.status == STARTED:
                # update params
                pass
            
            # if text_19 is stopping this frame...
            if text_19.status == STARTED:
                # is it time to stop? (based on global clock, using actual start)
                if tThisFlipGlobal > text_19.tStartRefresh + 2.0-frameTolerance:
                    # keep track of stop time/frame for later
                    text_19.tStop = t  # not accounting for scr refresh
                    text_19.tStopRefresh = tThisFlipGlobal  # on global time
                    text_19.frameNStop = frameN  # exact frame index
                    # add timestamp to datafile
                    thisExp.timestampOnFlip(win, 'text_19.stopped')
                    # update status
                    text_19.status = FINISHED
                    text_19.setAutoDraw(False)
            
            # *text_119* updates
            
            # if text_119 is starting this frame...
            if text_119.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
                # keep track of start time/frame for later
                text_119.frameNStart = frameN  # exact frame index
                text_119.tStart = t  # local t and not account for scr refresh
                text_119.tStartRefresh = tThisFlipGlobal  # on global time
                win.timeOnFlip(text_119, 'tStartRefresh')  # time at next scr refresh
                # add timestamp to datafile
                thisExp.timestampOnFlip(win, 'text_119.started')
                # update status
                text_119.status = STARTED
                text_119.setAutoDraw(True)
            
            # if text_119 is active this frame...
            if text_119.status == STARTED:
                # update params
                pass
            
            # if text_119 is stopping this frame...
            if text_119.status == STARTED:
                # is it time to stop? (based on global clock, using actual start)
                if tThisFlipGlobal > text_119.tStartRefresh + 2.0-frameTolerance:
                    # keep track of stop time/frame for later
                    text_119.tStop = t  # not accounting for scr refresh
                    text_119.tStopRefresh = tThisFlipGlobal  # on global time
                    text_119.frameNStop = frameN  # exact frame index
                    # add timestamp to datafile
                    thisExp.timestampOnFlip(win, 'text_119.stopped')
                    # update status
                    text_119.status = FINISHED
                    text_119.setAutoDraw(False)
            
            # *text_131* updates
            
            # if text_131 is starting this frame...
            if text_131.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
                # keep track of start time/frame for later
                text_131.frameNStart = frameN  # exact frame index
                text_131.tStart = t  # local t and not account for scr refresh
                text_131.tStartRefresh = tThisFlipGlobal  # on global time
                win.timeOnFlip(text_131, 'tStartRefresh')  # time at next scr refresh
                # add timestamp to datafile
                thisExp.timestampOnFlip(win, 'text_131.started')
                # update status
                text_131.status = STARTED
                text_131.setAutoDraw(True)
            
            # if text_131 is active this frame...
            if text_131.status == STARTED:
                # update params
                pass
            
            # if text_131 is stopping this frame...
            if text_131.status == STARTED:
                # is it time to stop? (based on global clock, using actual start)
                if tThisFlipGlobal > text_131.tStartRefresh + 2.0-frameTolerance:
                    # keep track of stop time/frame for later
                    text_131.tStop = t  # not accounting for scr refresh
                    text_131.tStopRefresh = tThisFlipGlobal  # on global time
                    text_131.frameNStop = frameN  # exact frame index
                    # add timestamp to datafile
                    thisExp.timestampOnFlip(win, 'text_131.stopped')
                    # update status
                    text_131.status = FINISHED
                    text_131.setAutoDraw(False)
            
            # check for quit (typically the Esc key)
            if defaultKeyboard.getKeys(keyList=["escape"]):
                thisExp.status = FINISHED
            if thisExp.status == FINISHED or endExpNow:
                endExperiment(thisExp, win=win)
                return
            # pause experiment here if requested
            if thisExp.status == PAUSED:
                pauseExperiment(
                    thisExp=thisExp, 
                    win=win, 
                    timers=[routineTimer], 
                    playbackComponents=[]
                )
                # skip the frame we paused on
                continue
            
            # check if all components have finished
            if not continueRoutine:  # a component has requested a forced-end of Routine
                planning4.forceEnded = routineForceEnded = True
                break
            continueRoutine = False  # will revert to True if at least one component still running
            for thisComponent in planning4.components:
                if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:
                    continueRoutine = True
                    break  # at least one component has not yet finished
            
            # refresh the screen
            if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen
                win.flip()
        
        # --- Ending Routine "planning4" ---
        for thisComponent in planning4.components:
            if hasattr(thisComponent, "setAutoDraw"):
                thisComponent.setAutoDraw(False)
        # store stop times for planning4
        planning4.tStop = globalClock.getTime(format='float')
        planning4.tStopRefresh = tThisFlipGlobal
        thisExp.addData('planning4.stopped', planning4.tStop)
        # using non-slip timing so subtract the expected duration of this Routine (unless ended on request)
        if planning4.maxDurationReached:
            routineTimer.addTime(-planning4.maxDuration)
        elif planning4.forceEnded:
            routineTimer.reset()
        else:
            routineTimer.addTime(-2.000000)
        
        # --- Prepare to start Routine "next_trial" ---
        # create an object to store info about Routine next_trial
        next_trial = data.Routine(
            name='next_trial',
            components=[next_trial_text],
        )
        next_trial.status = NOT_STARTED
        continueRoutine = True
        # update component parameters for each repeat
        # store start times for next_trial
        next_trial.tStartRefresh = win.getFutureFlipTime(clock=globalClock)
        next_trial.tStart = globalClock.getTime(format='float')
        next_trial.status = STARTED
        thisExp.addData('next_trial.started', next_trial.tStart)
        next_trial.maxDuration = None
        # keep track of which components have finished
        next_trialComponents = next_trial.components
        for thisComponent in next_trial.components:
            thisComponent.tStart = None
            thisComponent.tStop = None
            thisComponent.tStartRefresh = None
            thisComponent.tStopRefresh = None
            if hasattr(thisComponent, 'status'):
                thisComponent.status = NOT_STARTED
        # reset timers
        t = 0
        _timeToFirstFrame = win.getFutureFlipTime(clock="now")
        frameN = -1
        
        # --- Run Routine "next_trial" ---
        # if trial has changed, end Routine now
        if isinstance(planning_loop, data.TrialHandler2) and thisPlanning_loop.thisN != planning_loop.thisTrial.thisN:
            continueRoutine = False
        next_trial.forceEnded = routineForceEnded = not continueRoutine
        while continueRoutine and routineTimer.getTime() < 1.0:
            # get current time
            t = routineTimer.getTime()
            tThisFlip = win.getFutureFlipTime(clock=routineTimer)
            tThisFlipGlobal = win.getFutureFlipTime(clock=None)
            frameN = frameN + 1  # number of completed frames (so 0 is the first frame)
            # update/draw components on each frame
            
            # *next_trial_text* updates
            
            # if next_trial_text is starting this frame...
            if next_trial_text.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
                # keep track of start time/frame for later
                next_trial_text.frameNStart = frameN  # exact frame index
                next_trial_text.tStart = t  # local t and not account for scr refresh
                next_trial_text.tStartRefresh = tThisFlipGlobal  # on global time
                win.timeOnFlip(next_trial_text, 'tStartRefresh')  # time at next scr refresh
                # add timestamp to datafile
                thisExp.timestampOnFlip(win, 'next_trial_text.started')
                # update status
                next_trial_text.status = STARTED
                next_trial_text.setAutoDraw(True)
            
            # if next_trial_text is active this frame...
            if next_trial_text.status == STARTED:
                # update params
                pass
            
            # if next_trial_text is stopping this frame...
            if next_trial_text.status == STARTED:
                # is it time to stop? (based on global clock, using actual start)
                if tThisFlipGlobal > next_trial_text.tStartRefresh + 1-frameTolerance:
                    # keep track of stop time/frame for later
                    next_trial_text.tStop = t  # not accounting for scr refresh
                    next_trial_text.tStopRefresh = tThisFlipGlobal  # on global time
                    next_trial_text.frameNStop = frameN  # exact frame index
                    # add timestamp to datafile
                    thisExp.timestampOnFlip(win, 'next_trial_text.stopped')
                    # update status
                    next_trial_text.status = FINISHED
                    next_trial_text.setAutoDraw(False)
            
            # check for quit (typically the Esc key)
            if defaultKeyboard.getKeys(keyList=["escape"]):
                thisExp.status = FINISHED
            if thisExp.status == FINISHED or endExpNow:
                endExperiment(thisExp, win=win)
                return
            # pause experiment here if requested
            if thisExp.status == PAUSED:
                pauseExperiment(
                    thisExp=thisExp, 
                    win=win, 
                    timers=[routineTimer], 
                    playbackComponents=[]
                )
                # skip the frame we paused on
                continue
            
            # check if all components have finished
            if not continueRoutine:  # a component has requested a forced-end of Routine
                next_trial.forceEnded = routineForceEnded = True
                break
            continueRoutine = False  # will revert to True if at least one component still running
            for thisComponent in next_trial.components:
                if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:
                    continueRoutine = True
                    break  # at least one component has not yet finished
            
            # refresh the screen
            if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen
                win.flip()
        
        # --- Ending Routine "next_trial" ---
        for thisComponent in next_trial.components:
            if hasattr(thisComponent, "setAutoDraw"):
                thisComponent.setAutoDraw(False)
        # store stop times for next_trial
        next_trial.tStop = globalClock.getTime(format='float')
        next_trial.tStopRefresh = tThisFlipGlobal
        thisExp.addData('next_trial.stopped', next_trial.tStop)
        # using non-slip timing so subtract the expected duration of this Routine (unless ended on request)
        if next_trial.maxDurationReached:
            routineTimer.addTime(-next_trial.maxDuration)
        elif next_trial.forceEnded:
            routineTimer.reset()
        else:
            routineTimer.addTime(-1.000000)
        thisExp.nextEntry()
        
    # completed 1.0 repeats of 'planning_loop'
    
    if thisSession is not None:
        # if running in a Session with a Liaison client, send data up to now
        thisSession.sendExperimentData()
    
    # --- Prepare to start Routine "planning_paths" ---
    # create an object to store info about Routine planning_paths
    planning_paths = data.Routine(
        name='planning_paths',
        components=[text_149, key_resp_40, text_49],
    )
    planning_paths.status = NOT_STARTED
    continueRoutine = True
    # update component parameters for each repeat
    # Run 'Begin Routine' code from code_42
    quiz1_count=1
    quiz_planning_corr=0
    
    # create starting attributes for key_resp_40
    key_resp_40.keys = []
    key_resp_40.rt = []
    _key_resp_40_allKeys = []
    # store start times for planning_paths
    planning_paths.tStartRefresh = win.getFutureFlipTime(clock=globalClock)
    planning_paths.tStart = globalClock.getTime(format='float')
    planning_paths.status = STARTED
    thisExp.addData('planning_paths.started', planning_paths.tStart)
    planning_paths.maxDuration = None
    # keep track of which components have finished
    planning_pathsComponents = planning_paths.components
    for thisComponent in planning_paths.components:
        thisComponent.tStart = None
        thisComponent.tStop = None
        thisComponent.tStartRefresh = None
        thisComponent.tStopRefresh = None
        if hasattr(thisComponent, 'status'):
            thisComponent.status = NOT_STARTED
    # reset timers
    t = 0
    _timeToFirstFrame = win.getFutureFlipTime(clock="now")
    frameN = -1
    
    # --- Run Routine "planning_paths" ---
    planning_paths.forceEnded = routineForceEnded = not continueRoutine
    while continueRoutine:
        # get current time
        t = routineTimer.getTime()
        tThisFlip = win.getFutureFlipTime(clock=routineTimer)
        tThisFlipGlobal = win.getFutureFlipTime(clock=None)
        frameN = frameN + 1  # number of completed frames (so 0 is the first frame)
        # update/draw components on each frame
        
        # *text_149* updates
        
        # if text_149 is starting this frame...
        if text_149.status == NOT_STARTED and tThisFlip >= 0-frameTolerance:
            # keep track of start time/frame for later
            text_149.frameNStart = frameN  # exact frame index
            text_149.tStart = t  # local t and not account for scr refresh
            text_149.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(text_149, 'tStartRefresh')  # time at next scr refresh
            # add timestamp to datafile
            thisExp.timestampOnFlip(win, 'text_149.started')
            # update status
            text_149.status = STARTED
            text_149.setAutoDraw(True)
        
        # if text_149 is active this frame...
        if text_149.status == STARTED:
            # update params
            pass
        
        # *key_resp_40* updates
        waitOnFlip = False
        
        # if key_resp_40 is starting this frame...
        if key_resp_40.status == NOT_STARTED and tThisFlip >= 5.0-frameTolerance:
            # keep track of start time/frame for later
            key_resp_40.frameNStart = frameN  # exact frame index
            key_resp_40.tStart = t  # local t and not account for scr refresh
            key_resp_40.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(key_resp_40, 'tStartRefresh')  # time at next scr refresh
            # add timestamp to datafile
            thisExp.timestampOnFlip(win, 'key_resp_40.started')
            # update status
            key_resp_40.status = STARTED
            # keyboard checking is just starting
            waitOnFlip = True
            win.callOnFlip(key_resp_40.clock.reset)  # t=0 on next screen flip
            win.callOnFlip(key_resp_40.clearEvents, eventType='keyboard')  # clear events on next screen flip
        if key_resp_40.status == STARTED and not waitOnFlip:
            theseKeys = key_resp_40.getKeys(keyList=['space'], ignoreKeys=["escape"], waitRelease=False)
            _key_resp_40_allKeys.extend(theseKeys)
            if len(_key_resp_40_allKeys):
                key_resp_40.keys = _key_resp_40_allKeys[-1].name  # just the last key pressed
                key_resp_40.rt = _key_resp_40_allKeys[-1].rt
                key_resp_40.duration = _key_resp_40_allKeys[-1].duration
                # a response ends the routine
                continueRoutine = False
        
        # *text_49* updates
        
        # if text_49 is starting this frame...
        if text_49.status == NOT_STARTED and tThisFlip >= 5.0-frameTolerance:
            # keep track of start time/frame for later
            text_49.frameNStart = frameN  # exact frame index
            text_49.tStart = t  # local t and not account for scr refresh
            text_49.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(text_49, 'tStartRefresh')  # time at next scr refresh
            # add timestamp to datafile
            thisExp.timestampOnFlip(win, 'text_49.started')
            # update status
            text_49.status = STARTED
            text_49.setAutoDraw(True)
        
        # if text_49 is active this frame...
        if text_49.status == STARTED:
            # update params
            pass
        
        # check for quit (typically the Esc key)
        if defaultKeyboard.getKeys(keyList=["escape"]):
            thisExp.status = FINISHED
        if thisExp.status == FINISHED or endExpNow:
            endExperiment(thisExp, win=win)
            return
        # pause experiment here if requested
        if thisExp.status == PAUSED:
            pauseExperiment(
                thisExp=thisExp, 
                win=win, 
                timers=[routineTimer], 
                playbackComponents=[]
            )
            # skip the frame we paused on
            continue
        
        # check if all components have finished
        if not continueRoutine:  # a component has requested a forced-end of Routine
            planning_paths.forceEnded = routineForceEnded = True
            break
        continueRoutine = False  # will revert to True if at least one component still running
        for thisComponent in planning_paths.components:
            if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:
                continueRoutine = True
                break  # at least one component has not yet finished
        
        # refresh the screen
        if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen
            win.flip()
    
    # --- Ending Routine "planning_paths" ---
    for thisComponent in planning_paths.components:
        if hasattr(thisComponent, "setAutoDraw"):
            thisComponent.setAutoDraw(False)
    # store stop times for planning_paths
    planning_paths.tStop = globalClock.getTime(format='float')
    planning_paths.tStopRefresh = tThisFlipGlobal
    thisExp.addData('planning_paths.stopped', planning_paths.tStop)
    # check responses
    if key_resp_40.keys in ['', [], None]:  # No response was made
        key_resp_40.keys = None
    thisExp.addData('key_resp_40.keys',key_resp_40.keys)
    if key_resp_40.keys != None:  # we had a response
        thisExp.addData('key_resp_40.rt', key_resp_40.rt)
        thisExp.addData('key_resp_40.duration', key_resp_40.duration)
    thisExp.nextEntry()
    # the Routine "planning_paths" was not non-slip safe, so reset the non-slip timer
    routineTimer.reset()
    
    # set up handler to look after randomisation of conditions etc
    remember_planning_paths = data.TrialHandler2(
        name='remember_planning_paths',
        nReps=1.0, 
        method='random', 
        extraInfo=expInfo, 
        originPath=-1, 
        trialList=data.importConditions('forgetting1.xlsx'), 
        seed=None, 
    )
    thisExp.addLoop(remember_planning_paths)  # add the loop to the experiment
    thisRemember_planning_path = remember_planning_paths.trialList[0]  # so we can initialise stimuli with some values
    # abbreviate parameter names if possible (e.g. rgb = thisRemember_planning_path.rgb)
    if thisRemember_planning_path != None:
        for paramName in thisRemember_planning_path:
            globals()[paramName] = thisRemember_planning_path[paramName]
    if thisSession is not None:
        # if running in a Session with a Liaison client, send data up to now
        thisSession.sendExperimentData()
    
    for thisRemember_planning_path in remember_planning_paths:
        currentLoop = remember_planning_paths
        thisExp.timestampOnFlip(win, 'thisRow.t', format=globalClock.format)
        if thisSession is not None:
            # if running in a Session with a Liaison client, send data up to now
            thisSession.sendExperimentData()
        # abbreviate parameter names if possible (e.g. rgb = thisRemember_planning_path.rgb)
        if thisRemember_planning_path != None:
            for paramName in thisRemember_planning_path:
                globals()[paramName] = thisRemember_planning_path[paramName]
        
        # --- Prepare to start Routine "forgetting_paths1" ---
        # create an object to store info about Routine forgetting_paths1
        forgetting_paths1 = data.Routine(
            name='forgetting_paths1',
            components=[question_quiz1_3, answer_quiz1_3, answer1_3, answer2_3, answer3_3, a1_3, a2_3, text_146],
        )
        forgetting_paths1.status = NOT_STARTED
        continueRoutine = True
        # update component parameters for each repeat
        # create starting attributes for answer_quiz1_3
        answer_quiz1_3.keys = []
        answer_quiz1_3.rt = []
        _answer_quiz1_3_allKeys = []
        answer1_3.setImage(ans1)
        answer2_3.setImage(ans2)
        answer3_3.setImage(ans3)
        # store start times for forgetting_paths1
        forgetting_paths1.tStartRefresh = win.getFutureFlipTime(clock=globalClock)
        forgetting_paths1.tStart = globalClock.getTime(format='float')
        forgetting_paths1.status = STARTED
        thisExp.addData('forgetting_paths1.started', forgetting_paths1.tStart)
        forgetting_paths1.maxDuration = None
        # keep track of which components have finished
        forgetting_paths1Components = forgetting_paths1.components
        for thisComponent in forgetting_paths1.components:
            thisComponent.tStart = None
            thisComponent.tStop = None
            thisComponent.tStartRefresh = None
            thisComponent.tStopRefresh = None
            if hasattr(thisComponent, 'status'):
                thisComponent.status = NOT_STARTED
        # reset timers
        t = 0
        _timeToFirstFrame = win.getFutureFlipTime(clock="now")
        frameN = -1
        
        # --- Run Routine "forgetting_paths1" ---
        # if trial has changed, end Routine now
        if isinstance(remember_planning_paths, data.TrialHandler2) and thisRemember_planning_path.thisN != remember_planning_paths.thisTrial.thisN:
            continueRoutine = False
        forgetting_paths1.forceEnded = routineForceEnded = not continueRoutine
        while continueRoutine and routineTimer.getTime() < 120.0:
            # get current time
            t = routineTimer.getTime()
            tThisFlip = win.getFutureFlipTime(clock=routineTimer)
            tThisFlipGlobal = win.getFutureFlipTime(clock=None)
            frameN = frameN + 1  # number of completed frames (so 0 is the first frame)
            # update/draw components on each frame
            
            # *question_quiz1_3* updates
            
            # if question_quiz1_3 is starting this frame...
            if question_quiz1_3.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
                # keep track of start time/frame for later
                question_quiz1_3.frameNStart = frameN  # exact frame index
                question_quiz1_3.tStart = t  # local t and not account for scr refresh
                question_quiz1_3.tStartRefresh = tThisFlipGlobal  # on global time
                win.timeOnFlip(question_quiz1_3, 'tStartRefresh')  # time at next scr refresh
                # add timestamp to datafile
                thisExp.timestampOnFlip(win, 'question_quiz1_3.started')
                # update status
                question_quiz1_3.status = STARTED
                question_quiz1_3.setAutoDraw(True)
            
            # if question_quiz1_3 is active this frame...
            if question_quiz1_3.status == STARTED:
                # update params
                pass
            
            # if question_quiz1_3 is stopping this frame...
            if question_quiz1_3.status == STARTED:
                # is it time to stop? (based on global clock, using actual start)
                if tThisFlipGlobal > question_quiz1_3.tStartRefresh + 120-frameTolerance:
                    # keep track of stop time/frame for later
                    question_quiz1_3.tStop = t  # not accounting for scr refresh
                    question_quiz1_3.tStopRefresh = tThisFlipGlobal  # on global time
                    question_quiz1_3.frameNStop = frameN  # exact frame index
                    # add timestamp to datafile
                    thisExp.timestampOnFlip(win, 'question_quiz1_3.stopped')
                    # update status
                    question_quiz1_3.status = FINISHED
                    question_quiz1_3.setAutoDraw(False)
            
            # *answer_quiz1_3* updates
            waitOnFlip = False
            
            # if answer_quiz1_3 is starting this frame...
            if answer_quiz1_3.status == NOT_STARTED and tThisFlip >= 0-frameTolerance:
                # keep track of start time/frame for later
                answer_quiz1_3.frameNStart = frameN  # exact frame index
                answer_quiz1_3.tStart = t  # local t and not account for scr refresh
                answer_quiz1_3.tStartRefresh = tThisFlipGlobal  # on global time
                win.timeOnFlip(answer_quiz1_3, 'tStartRefresh')  # time at next scr refresh
                # add timestamp to datafile
                thisExp.timestampOnFlip(win, 'answer_quiz1_3.started')
                # update status
                answer_quiz1_3.status = STARTED
                # keyboard checking is just starting
                waitOnFlip = True
                win.callOnFlip(answer_quiz1_3.clock.reset)  # t=0 on next screen flip
                win.callOnFlip(answer_quiz1_3.clearEvents, eventType='keyboard')  # clear events on next screen flip
            
            # if answer_quiz1_3 is stopping this frame...
            if answer_quiz1_3.status == STARTED:
                # is it time to stop? (based on global clock, using actual start)
                if tThisFlipGlobal > answer_quiz1_3.tStartRefresh + 120-frameTolerance:
                    # keep track of stop time/frame for later
                    answer_quiz1_3.tStop = t  # not accounting for scr refresh
                    answer_quiz1_3.tStopRefresh = tThisFlipGlobal  # on global time
                    answer_quiz1_3.frameNStop = frameN  # exact frame index
                    # add timestamp to datafile
                    thisExp.timestampOnFlip(win, 'answer_quiz1_3.stopped')
                    # update status
                    answer_quiz1_3.status = FINISHED
                    answer_quiz1_3.status = FINISHED
            if answer_quiz1_3.status == STARTED and not waitOnFlip:
                theseKeys = answer_quiz1_3.getKeys(keyList=["left","right"], ignoreKeys=["escape"], waitRelease=False)
                _answer_quiz1_3_allKeys.extend(theseKeys)
                if len(_answer_quiz1_3_allKeys):
                    answer_quiz1_3.keys = _answer_quiz1_3_allKeys[0].name  # just the first key pressed
                    answer_quiz1_3.rt = _answer_quiz1_3_allKeys[0].rt
                    answer_quiz1_3.duration = _answer_quiz1_3_allKeys[0].duration
                    # was this correct?
                    if (answer_quiz1_3.keys == str(correct_answer1)) or (answer_quiz1_3.keys == correct_answer1):
                        answer_quiz1_3.corr = 1
                    else:
                        answer_quiz1_3.corr = 0
                    # a response ends the routine
                    continueRoutine = False
            
            # *answer1_3* updates
            
            # if answer1_3 is starting this frame...
            if answer1_3.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
                # keep track of start time/frame for later
                answer1_3.frameNStart = frameN  # exact frame index
                answer1_3.tStart = t  # local t and not account for scr refresh
                answer1_3.tStartRefresh = tThisFlipGlobal  # on global time
                win.timeOnFlip(answer1_3, 'tStartRefresh')  # time at next scr refresh
                # add timestamp to datafile
                thisExp.timestampOnFlip(win, 'answer1_3.started')
                # update status
                answer1_3.status = STARTED
                answer1_3.setAutoDraw(True)
            
            # if answer1_3 is active this frame...
            if answer1_3.status == STARTED:
                # update params
                pass
            
            # if answer1_3 is stopping this frame...
            if answer1_3.status == STARTED:
                # is it time to stop? (based on global clock, using actual start)
                if tThisFlipGlobal > answer1_3.tStartRefresh + 120-frameTolerance:
                    # keep track of stop time/frame for later
                    answer1_3.tStop = t  # not accounting for scr refresh
                    answer1_3.tStopRefresh = tThisFlipGlobal  # on global time
                    answer1_3.frameNStop = frameN  # exact frame index
                    # add timestamp to datafile
                    thisExp.timestampOnFlip(win, 'answer1_3.stopped')
                    # update status
                    answer1_3.status = FINISHED
                    answer1_3.setAutoDraw(False)
            
            # *answer2_3* updates
            
            # if answer2_3 is starting this frame...
            if answer2_3.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
                # keep track of start time/frame for later
                answer2_3.frameNStart = frameN  # exact frame index
                answer2_3.tStart = t  # local t and not account for scr refresh
                answer2_3.tStartRefresh = tThisFlipGlobal  # on global time
                win.timeOnFlip(answer2_3, 'tStartRefresh')  # time at next scr refresh
                # add timestamp to datafile
                thisExp.timestampOnFlip(win, 'answer2_3.started')
                # update status
                answer2_3.status = STARTED
                answer2_3.setAutoDraw(True)
            
            # if answer2_3 is active this frame...
            if answer2_3.status == STARTED:
                # update params
                pass
            
            # if answer2_3 is stopping this frame...
            if answer2_3.status == STARTED:
                # is it time to stop? (based on global clock, using actual start)
                if tThisFlipGlobal > answer2_3.tStartRefresh + 120-frameTolerance:
                    # keep track of stop time/frame for later
                    answer2_3.tStop = t  # not accounting for scr refresh
                    answer2_3.tStopRefresh = tThisFlipGlobal  # on global time
                    answer2_3.frameNStop = frameN  # exact frame index
                    # add timestamp to datafile
                    thisExp.timestampOnFlip(win, 'answer2_3.stopped')
                    # update status
                    answer2_3.status = FINISHED
                    answer2_3.setAutoDraw(False)
            
            # *answer3_3* updates
            
            # if answer3_3 is starting this frame...
            if answer3_3.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
                # keep track of start time/frame for later
                answer3_3.frameNStart = frameN  # exact frame index
                answer3_3.tStart = t  # local t and not account for scr refresh
                answer3_3.tStartRefresh = tThisFlipGlobal  # on global time
                win.timeOnFlip(answer3_3, 'tStartRefresh')  # time at next scr refresh
                # add timestamp to datafile
                thisExp.timestampOnFlip(win, 'answer3_3.started')
                # update status
                answer3_3.status = STARTED
                answer3_3.setAutoDraw(True)
            
            # if answer3_3 is active this frame...
            if answer3_3.status == STARTED:
                # update params
                pass
            
            # if answer3_3 is stopping this frame...
            if answer3_3.status == STARTED:
                # is it time to stop? (based on global clock, using actual start)
                if tThisFlipGlobal > answer3_3.tStartRefresh + 120-frameTolerance:
                    # keep track of stop time/frame for later
                    answer3_3.tStop = t  # not accounting for scr refresh
                    answer3_3.tStopRefresh = tThisFlipGlobal  # on global time
                    answer3_3.frameNStop = frameN  # exact frame index
                    # add timestamp to datafile
                    thisExp.timestampOnFlip(win, 'answer3_3.stopped')
                    # update status
                    answer3_3.status = FINISHED
                    answer3_3.setAutoDraw(False)
            
            # *a1_3* updates
            
            # if a1_3 is starting this frame...
            if a1_3.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
                # keep track of start time/frame for later
                a1_3.frameNStart = frameN  # exact frame index
                a1_3.tStart = t  # local t and not account for scr refresh
                a1_3.tStartRefresh = tThisFlipGlobal  # on global time
                win.timeOnFlip(a1_3, 'tStartRefresh')  # time at next scr refresh
                # add timestamp to datafile
                thisExp.timestampOnFlip(win, 'a1_3.started')
                # update status
                a1_3.status = STARTED
                a1_3.setAutoDraw(True)
            
            # if a1_3 is active this frame...
            if a1_3.status == STARTED:
                # update params
                pass
            
            # if a1_3 is stopping this frame...
            if a1_3.status == STARTED:
                # is it time to stop? (based on global clock, using actual start)
                if tThisFlipGlobal > a1_3.tStartRefresh + 120-frameTolerance:
                    # keep track of stop time/frame for later
                    a1_3.tStop = t  # not accounting for scr refresh
                    a1_3.tStopRefresh = tThisFlipGlobal  # on global time
                    a1_3.frameNStop = frameN  # exact frame index
                    # add timestamp to datafile
                    thisExp.timestampOnFlip(win, 'a1_3.stopped')
                    # update status
                    a1_3.status = FINISHED
                    a1_3.setAutoDraw(False)
            
            # *a2_3* updates
            
            # if a2_3 is starting this frame...
            if a2_3.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
                # keep track of start time/frame for later
                a2_3.frameNStart = frameN  # exact frame index
                a2_3.tStart = t  # local t and not account for scr refresh
                a2_3.tStartRefresh = tThisFlipGlobal  # on global time
                win.timeOnFlip(a2_3, 'tStartRefresh')  # time at next scr refresh
                # add timestamp to datafile
                thisExp.timestampOnFlip(win, 'a2_3.started')
                # update status
                a2_3.status = STARTED
                a2_3.setAutoDraw(True)
            
            # if a2_3 is active this frame...
            if a2_3.status == STARTED:
                # update params
                pass
            
            # if a2_3 is stopping this frame...
            if a2_3.status == STARTED:
                # is it time to stop? (based on global clock, using actual start)
                if tThisFlipGlobal > a2_3.tStartRefresh + 120-frameTolerance:
                    # keep track of stop time/frame for later
                    a2_3.tStop = t  # not accounting for scr refresh
                    a2_3.tStopRefresh = tThisFlipGlobal  # on global time
                    a2_3.frameNStop = frameN  # exact frame index
                    # add timestamp to datafile
                    thisExp.timestampOnFlip(win, 'a2_3.stopped')
                    # update status
                    a2_3.status = FINISHED
                    a2_3.setAutoDraw(False)
            
            # *text_146* updates
            
            # if text_146 is starting this frame...
            if text_146.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
                # keep track of start time/frame for later
                text_146.frameNStart = frameN  # exact frame index
                text_146.tStart = t  # local t and not account for scr refresh
                text_146.tStartRefresh = tThisFlipGlobal  # on global time
                win.timeOnFlip(text_146, 'tStartRefresh')  # time at next scr refresh
                # add timestamp to datafile
                thisExp.timestampOnFlip(win, 'text_146.started')
                # update status
                text_146.status = STARTED
                text_146.setAutoDraw(True)
            
            # if text_146 is active this frame...
            if text_146.status == STARTED:
                # update params
                pass
            
            # if text_146 is stopping this frame...
            if text_146.status == STARTED:
                # is it time to stop? (based on global clock, using actual start)
                if tThisFlipGlobal > text_146.tStartRefresh + 120.0-frameTolerance:
                    # keep track of stop time/frame for later
                    text_146.tStop = t  # not accounting for scr refresh
                    text_146.tStopRefresh = tThisFlipGlobal  # on global time
                    text_146.frameNStop = frameN  # exact frame index
                    # add timestamp to datafile
                    thisExp.timestampOnFlip(win, 'text_146.stopped')
                    # update status
                    text_146.status = FINISHED
                    text_146.setAutoDraw(False)
            
            # check for quit (typically the Esc key)
            if defaultKeyboard.getKeys(keyList=["escape"]):
                thisExp.status = FINISHED
            if thisExp.status == FINISHED or endExpNow:
                endExperiment(thisExp, win=win)
                return
            # pause experiment here if requested
            if thisExp.status == PAUSED:
                pauseExperiment(
                    thisExp=thisExp, 
                    win=win, 
                    timers=[routineTimer], 
                    playbackComponents=[]
                )
                # skip the frame we paused on
                continue
            
            # check if all components have finished
            if not continueRoutine:  # a component has requested a forced-end of Routine
                forgetting_paths1.forceEnded = routineForceEnded = True
                break
            continueRoutine = False  # will revert to True if at least one component still running
            for thisComponent in forgetting_paths1.components:
                if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:
                    continueRoutine = True
                    break  # at least one component has not yet finished
            
            # refresh the screen
            if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen
                win.flip()
        
        # --- Ending Routine "forgetting_paths1" ---
        for thisComponent in forgetting_paths1.components:
            if hasattr(thisComponent, "setAutoDraw"):
                thisComponent.setAutoDraw(False)
        # store stop times for forgetting_paths1
        forgetting_paths1.tStop = globalClock.getTime(format='float')
        forgetting_paths1.tStopRefresh = tThisFlipGlobal
        thisExp.addData('forgetting_paths1.stopped', forgetting_paths1.tStop)
        # check responses
        if answer_quiz1_3.keys in ['', [], None]:  # No response was made
            answer_quiz1_3.keys = None
            # was no response the correct answer?!
            if str(correct_answer1).lower() == 'none':
               answer_quiz1_3.corr = 1;  # correct non-response
            else:
               answer_quiz1_3.corr = 0;  # failed to respond (incorrectly)
        # store data for remember_planning_paths (TrialHandler)
        remember_planning_paths.addData('answer_quiz1_3.keys',answer_quiz1_3.keys)
        remember_planning_paths.addData('answer_quiz1_3.corr', answer_quiz1_3.corr)
        if answer_quiz1_3.keys != None:  # we had a response
            remember_planning_paths.addData('answer_quiz1_3.rt', answer_quiz1_3.rt)
            remember_planning_paths.addData('answer_quiz1_3.duration', answer_quiz1_3.duration)
        # using non-slip timing so subtract the expected duration of this Routine (unless ended on request)
        if forgetting_paths1.maxDurationReached:
            routineTimer.addTime(-forgetting_paths1.maxDuration)
        elif forgetting_paths1.forceEnded:
            routineTimer.reset()
        else:
            routineTimer.addTime(-120.000000)
        
        # --- Prepare to start Routine "planningpathstraining2" ---
        # create an object to store info about Routine planningpathstraining2
        planningpathstraining2 = data.Routine(
            name='planningpathstraining2',
            components=[question_quiz1_5, answer_quiz1_5, answer1_5, answer2_5, answer3_5, a1_5, a2_5, text_152],
        )
        planningpathstraining2.status = NOT_STARTED
        continueRoutine = True
        # update component parameters for each repeat
        # create starting attributes for answer_quiz1_5
        answer_quiz1_5.keys = []
        answer_quiz1_5.rt = []
        _answer_quiz1_5_allKeys = []
        answer1_5.setImage(ans1)
        answer2_5.setImage(ans2)
        answer3_5.setImage(ans3)
        # store start times for planningpathstraining2
        planningpathstraining2.tStartRefresh = win.getFutureFlipTime(clock=globalClock)
        planningpathstraining2.tStart = globalClock.getTime(format='float')
        planningpathstraining2.status = STARTED
        thisExp.addData('planningpathstraining2.started', planningpathstraining2.tStart)
        planningpathstraining2.maxDuration = None
        # keep track of which components have finished
        planningpathstraining2Components = planningpathstraining2.components
        for thisComponent in planningpathstraining2.components:
            thisComponent.tStart = None
            thisComponent.tStop = None
            thisComponent.tStartRefresh = None
            thisComponent.tStopRefresh = None
            if hasattr(thisComponent, 'status'):
                thisComponent.status = NOT_STARTED
        # reset timers
        t = 0
        _timeToFirstFrame = win.getFutureFlipTime(clock="now")
        frameN = -1
        
        # --- Run Routine "planningpathstraining2" ---
        # if trial has changed, end Routine now
        if isinstance(remember_planning_paths, data.TrialHandler2) and thisRemember_planning_path.thisN != remember_planning_paths.thisTrial.thisN:
            continueRoutine = False
        planningpathstraining2.forceEnded = routineForceEnded = not continueRoutine
        while continueRoutine and routineTimer.getTime() < 120.0:
            # get current time
            t = routineTimer.getTime()
            tThisFlip = win.getFutureFlipTime(clock=routineTimer)
            tThisFlipGlobal = win.getFutureFlipTime(clock=None)
            frameN = frameN + 1  # number of completed frames (so 0 is the first frame)
            # update/draw components on each frame
            
            # *question_quiz1_5* updates
            
            # if question_quiz1_5 is starting this frame...
            if question_quiz1_5.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
                # keep track of start time/frame for later
                question_quiz1_5.frameNStart = frameN  # exact frame index
                question_quiz1_5.tStart = t  # local t and not account for scr refresh
                question_quiz1_5.tStartRefresh = tThisFlipGlobal  # on global time
                win.timeOnFlip(question_quiz1_5, 'tStartRefresh')  # time at next scr refresh
                # add timestamp to datafile
                thisExp.timestampOnFlip(win, 'question_quiz1_5.started')
                # update status
                question_quiz1_5.status = STARTED
                question_quiz1_5.setAutoDraw(True)
            
            # if question_quiz1_5 is active this frame...
            if question_quiz1_5.status == STARTED:
                # update params
                pass
            
            # if question_quiz1_5 is stopping this frame...
            if question_quiz1_5.status == STARTED:
                # is it time to stop? (based on global clock, using actual start)
                if tThisFlipGlobal > question_quiz1_5.tStartRefresh + 120-frameTolerance:
                    # keep track of stop time/frame for later
                    question_quiz1_5.tStop = t  # not accounting for scr refresh
                    question_quiz1_5.tStopRefresh = tThisFlipGlobal  # on global time
                    question_quiz1_5.frameNStop = frameN  # exact frame index
                    # add timestamp to datafile
                    thisExp.timestampOnFlip(win, 'question_quiz1_5.stopped')
                    # update status
                    question_quiz1_5.status = FINISHED
                    question_quiz1_5.setAutoDraw(False)
            
            # *answer_quiz1_5* updates
            waitOnFlip = False
            
            # if answer_quiz1_5 is starting this frame...
            if answer_quiz1_5.status == NOT_STARTED and tThisFlip >= 0-frameTolerance:
                # keep track of start time/frame for later
                answer_quiz1_5.frameNStart = frameN  # exact frame index
                answer_quiz1_5.tStart = t  # local t and not account for scr refresh
                answer_quiz1_5.tStartRefresh = tThisFlipGlobal  # on global time
                win.timeOnFlip(answer_quiz1_5, 'tStartRefresh')  # time at next scr refresh
                # add timestamp to datafile
                thisExp.timestampOnFlip(win, 'answer_quiz1_5.started')
                # update status
                answer_quiz1_5.status = STARTED
                # keyboard checking is just starting
                waitOnFlip = True
                win.callOnFlip(answer_quiz1_5.clock.reset)  # t=0 on next screen flip
                win.callOnFlip(answer_quiz1_5.clearEvents, eventType='keyboard')  # clear events on next screen flip
            
            # if answer_quiz1_5 is stopping this frame...
            if answer_quiz1_5.status == STARTED:
                # is it time to stop? (based on global clock, using actual start)
                if tThisFlipGlobal > answer_quiz1_5.tStartRefresh + 120-frameTolerance:
                    # keep track of stop time/frame for later
                    answer_quiz1_5.tStop = t  # not accounting for scr refresh
                    answer_quiz1_5.tStopRefresh = tThisFlipGlobal  # on global time
                    answer_quiz1_5.frameNStop = frameN  # exact frame index
                    # add timestamp to datafile
                    thisExp.timestampOnFlip(win, 'answer_quiz1_5.stopped')
                    # update status
                    answer_quiz1_5.status = FINISHED
                    answer_quiz1_5.status = FINISHED
            if answer_quiz1_5.status == STARTED and not waitOnFlip:
                theseKeys = answer_quiz1_5.getKeys(keyList=["left","right"], ignoreKeys=["escape"], waitRelease=False)
                _answer_quiz1_5_allKeys.extend(theseKeys)
                if len(_answer_quiz1_5_allKeys):
                    answer_quiz1_5.keys = _answer_quiz1_5_allKeys[0].name  # just the first key pressed
                    answer_quiz1_5.rt = _answer_quiz1_5_allKeys[0].rt
                    answer_quiz1_5.duration = _answer_quiz1_5_allKeys[0].duration
                    # was this correct?
                    if (answer_quiz1_5.keys == str(correct_answer2)) or (answer_quiz1_5.keys == correct_answer2):
                        answer_quiz1_5.corr = 1
                    else:
                        answer_quiz1_5.corr = 0
                    # a response ends the routine
                    continueRoutine = False
            
            # *answer1_5* updates
            
            # if answer1_5 is starting this frame...
            if answer1_5.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
                # keep track of start time/frame for later
                answer1_5.frameNStart = frameN  # exact frame index
                answer1_5.tStart = t  # local t and not account for scr refresh
                answer1_5.tStartRefresh = tThisFlipGlobal  # on global time
                win.timeOnFlip(answer1_5, 'tStartRefresh')  # time at next scr refresh
                # add timestamp to datafile
                thisExp.timestampOnFlip(win, 'answer1_5.started')
                # update status
                answer1_5.status = STARTED
                answer1_5.setAutoDraw(True)
            
            # if answer1_5 is active this frame...
            if answer1_5.status == STARTED:
                # update params
                pass
            
            # if answer1_5 is stopping this frame...
            if answer1_5.status == STARTED:
                # is it time to stop? (based on global clock, using actual start)
                if tThisFlipGlobal > answer1_5.tStartRefresh + 120-frameTolerance:
                    # keep track of stop time/frame for later
                    answer1_5.tStop = t  # not accounting for scr refresh
                    answer1_5.tStopRefresh = tThisFlipGlobal  # on global time
                    answer1_5.frameNStop = frameN  # exact frame index
                    # add timestamp to datafile
                    thisExp.timestampOnFlip(win, 'answer1_5.stopped')
                    # update status
                    answer1_5.status = FINISHED
                    answer1_5.setAutoDraw(False)
            
            # *answer2_5* updates
            
            # if answer2_5 is starting this frame...
            if answer2_5.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
                # keep track of start time/frame for later
                answer2_5.frameNStart = frameN  # exact frame index
                answer2_5.tStart = t  # local t and not account for scr refresh
                answer2_5.tStartRefresh = tThisFlipGlobal  # on global time
                win.timeOnFlip(answer2_5, 'tStartRefresh')  # time at next scr refresh
                # add timestamp to datafile
                thisExp.timestampOnFlip(win, 'answer2_5.started')
                # update status
                answer2_5.status = STARTED
                answer2_5.setAutoDraw(True)
            
            # if answer2_5 is active this frame...
            if answer2_5.status == STARTED:
                # update params
                pass
            
            # if answer2_5 is stopping this frame...
            if answer2_5.status == STARTED:
                # is it time to stop? (based on global clock, using actual start)
                if tThisFlipGlobal > answer2_5.tStartRefresh + 120-frameTolerance:
                    # keep track of stop time/frame for later
                    answer2_5.tStop = t  # not accounting for scr refresh
                    answer2_5.tStopRefresh = tThisFlipGlobal  # on global time
                    answer2_5.frameNStop = frameN  # exact frame index
                    # add timestamp to datafile
                    thisExp.timestampOnFlip(win, 'answer2_5.stopped')
                    # update status
                    answer2_5.status = FINISHED
                    answer2_5.setAutoDraw(False)
            
            # *answer3_5* updates
            
            # if answer3_5 is starting this frame...
            if answer3_5.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
                # keep track of start time/frame for later
                answer3_5.frameNStart = frameN  # exact frame index
                answer3_5.tStart = t  # local t and not account for scr refresh
                answer3_5.tStartRefresh = tThisFlipGlobal  # on global time
                win.timeOnFlip(answer3_5, 'tStartRefresh')  # time at next scr refresh
                # add timestamp to datafile
                thisExp.timestampOnFlip(win, 'answer3_5.started')
                # update status
                answer3_5.status = STARTED
                answer3_5.setAutoDraw(True)
            
            # if answer3_5 is active this frame...
            if answer3_5.status == STARTED:
                # update params
                pass
            
            # if answer3_5 is stopping this frame...
            if answer3_5.status == STARTED:
                # is it time to stop? (based on global clock, using actual start)
                if tThisFlipGlobal > answer3_5.tStartRefresh + 120-frameTolerance:
                    # keep track of stop time/frame for later
                    answer3_5.tStop = t  # not accounting for scr refresh
                    answer3_5.tStopRefresh = tThisFlipGlobal  # on global time
                    answer3_5.frameNStop = frameN  # exact frame index
                    # add timestamp to datafile
                    thisExp.timestampOnFlip(win, 'answer3_5.stopped')
                    # update status
                    answer3_5.status = FINISHED
                    answer3_5.setAutoDraw(False)
            
            # *a1_5* updates
            
            # if a1_5 is starting this frame...
            if a1_5.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
                # keep track of start time/frame for later
                a1_5.frameNStart = frameN  # exact frame index
                a1_5.tStart = t  # local t and not account for scr refresh
                a1_5.tStartRefresh = tThisFlipGlobal  # on global time
                win.timeOnFlip(a1_5, 'tStartRefresh')  # time at next scr refresh
                # add timestamp to datafile
                thisExp.timestampOnFlip(win, 'a1_5.started')
                # update status
                a1_5.status = STARTED
                a1_5.setAutoDraw(True)
            
            # if a1_5 is active this frame...
            if a1_5.status == STARTED:
                # update params
                pass
            
            # if a1_5 is stopping this frame...
            if a1_5.status == STARTED:
                # is it time to stop? (based on global clock, using actual start)
                if tThisFlipGlobal > a1_5.tStartRefresh + 120-frameTolerance:
                    # keep track of stop time/frame for later
                    a1_5.tStop = t  # not accounting for scr refresh
                    a1_5.tStopRefresh = tThisFlipGlobal  # on global time
                    a1_5.frameNStop = frameN  # exact frame index
                    # add timestamp to datafile
                    thisExp.timestampOnFlip(win, 'a1_5.stopped')
                    # update status
                    a1_5.status = FINISHED
                    a1_5.setAutoDraw(False)
            
            # *a2_5* updates
            
            # if a2_5 is starting this frame...
            if a2_5.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
                # keep track of start time/frame for later
                a2_5.frameNStart = frameN  # exact frame index
                a2_5.tStart = t  # local t and not account for scr refresh
                a2_5.tStartRefresh = tThisFlipGlobal  # on global time
                win.timeOnFlip(a2_5, 'tStartRefresh')  # time at next scr refresh
                # add timestamp to datafile
                thisExp.timestampOnFlip(win, 'a2_5.started')
                # update status
                a2_5.status = STARTED
                a2_5.setAutoDraw(True)
            
            # if a2_5 is active this frame...
            if a2_5.status == STARTED:
                # update params
                pass
            
            # if a2_5 is stopping this frame...
            if a2_5.status == STARTED:
                # is it time to stop? (based on global clock, using actual start)
                if tThisFlipGlobal > a2_5.tStartRefresh + 120-frameTolerance:
                    # keep track of stop time/frame for later
                    a2_5.tStop = t  # not accounting for scr refresh
                    a2_5.tStopRefresh = tThisFlipGlobal  # on global time
                    a2_5.frameNStop = frameN  # exact frame index
                    # add timestamp to datafile
                    thisExp.timestampOnFlip(win, 'a2_5.stopped')
                    # update status
                    a2_5.status = FINISHED
                    a2_5.setAutoDraw(False)
            
            # *text_152* updates
            
            # if text_152 is starting this frame...
            if text_152.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
                # keep track of start time/frame for later
                text_152.frameNStart = frameN  # exact frame index
                text_152.tStart = t  # local t and not account for scr refresh
                text_152.tStartRefresh = tThisFlipGlobal  # on global time
                win.timeOnFlip(text_152, 'tStartRefresh')  # time at next scr refresh
                # add timestamp to datafile
                thisExp.timestampOnFlip(win, 'text_152.started')
                # update status
                text_152.status = STARTED
                text_152.setAutoDraw(True)
            
            # if text_152 is active this frame...
            if text_152.status == STARTED:
                # update params
                pass
            
            # if text_152 is stopping this frame...
            if text_152.status == STARTED:
                # is it time to stop? (based on global clock, using actual start)
                if tThisFlipGlobal > text_152.tStartRefresh + 120.0-frameTolerance:
                    # keep track of stop time/frame for later
                    text_152.tStop = t  # not accounting for scr refresh
                    text_152.tStopRefresh = tThisFlipGlobal  # on global time
                    text_152.frameNStop = frameN  # exact frame index
                    # add timestamp to datafile
                    thisExp.timestampOnFlip(win, 'text_152.stopped')
                    # update status
                    text_152.status = FINISHED
                    text_152.setAutoDraw(False)
            
            # check for quit (typically the Esc key)
            if defaultKeyboard.getKeys(keyList=["escape"]):
                thisExp.status = FINISHED
            if thisExp.status == FINISHED or endExpNow:
                endExperiment(thisExp, win=win)
                return
            # pause experiment here if requested
            if thisExp.status == PAUSED:
                pauseExperiment(
                    thisExp=thisExp, 
                    win=win, 
                    timers=[routineTimer], 
                    playbackComponents=[]
                )
                # skip the frame we paused on
                continue
            
            # check if all components have finished
            if not continueRoutine:  # a component has requested a forced-end of Routine
                planningpathstraining2.forceEnded = routineForceEnded = True
                break
            continueRoutine = False  # will revert to True if at least one component still running
            for thisComponent in planningpathstraining2.components:
                if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:
                    continueRoutine = True
                    break  # at least one component has not yet finished
            
            # refresh the screen
            if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen
                win.flip()
        
        # --- Ending Routine "planningpathstraining2" ---
        for thisComponent in planningpathstraining2.components:
            if hasattr(thisComponent, "setAutoDraw"):
                thisComponent.setAutoDraw(False)
        # store stop times for planningpathstraining2
        planningpathstraining2.tStop = globalClock.getTime(format='float')
        planningpathstraining2.tStopRefresh = tThisFlipGlobal
        thisExp.addData('planningpathstraining2.stopped', planningpathstraining2.tStop)
        # check responses
        if answer_quiz1_5.keys in ['', [], None]:  # No response was made
            answer_quiz1_5.keys = None
            # was no response the correct answer?!
            if str(correct_answer2).lower() == 'none':
               answer_quiz1_5.corr = 1;  # correct non-response
            else:
               answer_quiz1_5.corr = 0;  # failed to respond (incorrectly)
        # store data for remember_planning_paths (TrialHandler)
        remember_planning_paths.addData('answer_quiz1_5.keys',answer_quiz1_5.keys)
        remember_planning_paths.addData('answer_quiz1_5.corr', answer_quiz1_5.corr)
        if answer_quiz1_5.keys != None:  # we had a response
            remember_planning_paths.addData('answer_quiz1_5.rt', answer_quiz1_5.rt)
            remember_planning_paths.addData('answer_quiz1_5.duration', answer_quiz1_5.duration)
        # using non-slip timing so subtract the expected duration of this Routine (unless ended on request)
        if planningpathstraining2.maxDurationReached:
            routineTimer.addTime(-planningpathstraining2.maxDuration)
        elif planningpathstraining2.forceEnded:
            routineTimer.reset()
        else:
            routineTimer.addTime(-120.000000)
        
        # --- Prepare to start Routine "correct_forget_paths" ---
        # create an object to store info about Routine correct_forget_paths
        correct_forget_paths = data.Routine(
            name='correct_forget_paths',
            components=[next_trial_text_2, text_151],
        )
        correct_forget_paths.status = NOT_STARTED
        continueRoutine = True
        # update component parameters for each repeat
        next_trial_text_2.setText(msg)
        text_151.setText(quiz_planning_corr)
        # store start times for correct_forget_paths
        correct_forget_paths.tStartRefresh = win.getFutureFlipTime(clock=globalClock)
        correct_forget_paths.tStart = globalClock.getTime(format='float')
        correct_forget_paths.status = STARTED
        thisExp.addData('correct_forget_paths.started', correct_forget_paths.tStart)
        correct_forget_paths.maxDuration = None
        # keep track of which components have finished
        correct_forget_pathsComponents = correct_forget_paths.components
        for thisComponent in correct_forget_paths.components:
            thisComponent.tStart = None
            thisComponent.tStop = None
            thisComponent.tStartRefresh = None
            thisComponent.tStopRefresh = None
            if hasattr(thisComponent, 'status'):
                thisComponent.status = NOT_STARTED
        # reset timers
        t = 0
        _timeToFirstFrame = win.getFutureFlipTime(clock="now")
        frameN = -1
        
        # --- Run Routine "correct_forget_paths" ---
        # if trial has changed, end Routine now
        if isinstance(remember_planning_paths, data.TrialHandler2) and thisRemember_planning_path.thisN != remember_planning_paths.thisTrial.thisN:
            continueRoutine = False
        correct_forget_paths.forceEnded = routineForceEnded = not continueRoutine
        while continueRoutine and routineTimer.getTime() < 3.0:
            # get current time
            t = routineTimer.getTime()
            tThisFlip = win.getFutureFlipTime(clock=routineTimer)
            tThisFlipGlobal = win.getFutureFlipTime(clock=None)
            frameN = frameN + 1  # number of completed frames (so 0 is the first frame)
            # update/draw components on each frame
            
            # *next_trial_text_2* updates
            
            # if next_trial_text_2 is starting this frame...
            if next_trial_text_2.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
                # keep track of start time/frame for later
                next_trial_text_2.frameNStart = frameN  # exact frame index
                next_trial_text_2.tStart = t  # local t and not account for scr refresh
                next_trial_text_2.tStartRefresh = tThisFlipGlobal  # on global time
                win.timeOnFlip(next_trial_text_2, 'tStartRefresh')  # time at next scr refresh
                # add timestamp to datafile
                thisExp.timestampOnFlip(win, 'next_trial_text_2.started')
                # update status
                next_trial_text_2.status = STARTED
                next_trial_text_2.setAutoDraw(True)
            
            # if next_trial_text_2 is active this frame...
            if next_trial_text_2.status == STARTED:
                # update params
                pass
            
            # if next_trial_text_2 is stopping this frame...
            if next_trial_text_2.status == STARTED:
                # is it time to stop? (based on global clock, using actual start)
                if tThisFlipGlobal > next_trial_text_2.tStartRefresh + 3-frameTolerance:
                    # keep track of stop time/frame for later
                    next_trial_text_2.tStop = t  # not accounting for scr refresh
                    next_trial_text_2.tStopRefresh = tThisFlipGlobal  # on global time
                    next_trial_text_2.frameNStop = frameN  # exact frame index
                    # add timestamp to datafile
                    thisExp.timestampOnFlip(win, 'next_trial_text_2.stopped')
                    # update status
                    next_trial_text_2.status = FINISHED
                    next_trial_text_2.setAutoDraw(False)
            
            # *text_151* updates
            
            # if text_151 is starting this frame...
            if text_151.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
                # keep track of start time/frame for later
                text_151.frameNStart = frameN  # exact frame index
                text_151.tStart = t  # local t and not account for scr refresh
                text_151.tStartRefresh = tThisFlipGlobal  # on global time
                win.timeOnFlip(text_151, 'tStartRefresh')  # time at next scr refresh
                # add timestamp to datafile
                thisExp.timestampOnFlip(win, 'text_151.started')
                # update status
                text_151.status = STARTED
                text_151.setAutoDraw(True)
            
            # if text_151 is active this frame...
            if text_151.status == STARTED:
                # update params
                pass
            
            # if text_151 is stopping this frame...
            if text_151.status == STARTED:
                # is it time to stop? (based on global clock, using actual start)
                if tThisFlipGlobal > text_151.tStartRefresh + 3.0-frameTolerance:
                    # keep track of stop time/frame for later
                    text_151.tStop = t  # not accounting for scr refresh
                    text_151.tStopRefresh = tThisFlipGlobal  # on global time
                    text_151.frameNStop = frameN  # exact frame index
                    # add timestamp to datafile
                    thisExp.timestampOnFlip(win, 'text_151.stopped')
                    # update status
                    text_151.status = FINISHED
                    text_151.setAutoDraw(False)
            
            # check for quit (typically the Esc key)
            if defaultKeyboard.getKeys(keyList=["escape"]):
                thisExp.status = FINISHED
            if thisExp.status == FINISHED or endExpNow:
                endExperiment(thisExp, win=win)
                return
            # pause experiment here if requested
            if thisExp.status == PAUSED:
                pauseExperiment(
                    thisExp=thisExp, 
                    win=win, 
                    timers=[routineTimer], 
                    playbackComponents=[]
                )
                # skip the frame we paused on
                continue
            
            # check if all components have finished
            if not continueRoutine:  # a component has requested a forced-end of Routine
                correct_forget_paths.forceEnded = routineForceEnded = True
                break
            continueRoutine = False  # will revert to True if at least one component still running
            for thisComponent in correct_forget_paths.components:
                if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:
                    continueRoutine = True
                    break  # at least one component has not yet finished
            
            # refresh the screen
            if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen
                win.flip()
        
        # --- Ending Routine "correct_forget_paths" ---
        for thisComponent in correct_forget_paths.components:
            if hasattr(thisComponent, "setAutoDraw"):
                thisComponent.setAutoDraw(False)
        # store stop times for correct_forget_paths
        correct_forget_paths.tStop = globalClock.getTime(format='float')
        correct_forget_paths.tStopRefresh = tThisFlipGlobal
        thisExp.addData('correct_forget_paths.stopped', correct_forget_paths.tStop)
        # using non-slip timing so subtract the expected duration of this Routine (unless ended on request)
        if correct_forget_paths.maxDurationReached:
            routineTimer.addTime(-correct_forget_paths.maxDuration)
        elif correct_forget_paths.forceEnded:
            routineTimer.reset()
        else:
            routineTimer.addTime(-3.000000)
        thisExp.nextEntry()
        
    # completed 1.0 repeats of 'remember_planning_paths'
    
    if thisSession is not None:
        # if running in a Session with a Liaison client, send data up to now
        thisSession.sendExperimentData()
    
    # --- Prepare to start Routine "total_score_planning" ---
    # create an object to store info about Routine total_score_planning
    total_score_planning = data.Routine(
        name='total_score_planning',
        components=[next_trial_text_3, text_150],
    )
    total_score_planning.status = NOT_STARTED
    continueRoutine = True
    # update component parameters for each repeat
    # Run 'Begin Routine' code from code_43
    total_planning_score_training=(quiz_planning_corr/8.0)*100
    next_trial_text_3.setText(total_planning_score_training)
    # store start times for total_score_planning
    total_score_planning.tStartRefresh = win.getFutureFlipTime(clock=globalClock)
    total_score_planning.tStart = globalClock.getTime(format='float')
    total_score_planning.status = STARTED
    thisExp.addData('total_score_planning.started', total_score_planning.tStart)
    total_score_planning.maxDuration = None
    # keep track of which components have finished
    total_score_planningComponents = total_score_planning.components
    for thisComponent in total_score_planning.components:
        thisComponent.tStart = None
        thisComponent.tStop = None
        thisComponent.tStartRefresh = None
        thisComponent.tStopRefresh = None
        if hasattr(thisComponent, 'status'):
            thisComponent.status = NOT_STARTED
    # reset timers
    t = 0
    _timeToFirstFrame = win.getFutureFlipTime(clock="now")
    frameN = -1
    
    # --- Run Routine "total_score_planning" ---
    total_score_planning.forceEnded = routineForceEnded = not continueRoutine
    while continueRoutine and routineTimer.getTime() < 3.0:
        # get current time
        t = routineTimer.getTime()
        tThisFlip = win.getFutureFlipTime(clock=routineTimer)
        tThisFlipGlobal = win.getFutureFlipTime(clock=None)
        frameN = frameN + 1  # number of completed frames (so 0 is the first frame)
        # update/draw components on each frame
        
        # *next_trial_text_3* updates
        
        # if next_trial_text_3 is starting this frame...
        if next_trial_text_3.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
            # keep track of start time/frame for later
            next_trial_text_3.frameNStart = frameN  # exact frame index
            next_trial_text_3.tStart = t  # local t and not account for scr refresh
            next_trial_text_3.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(next_trial_text_3, 'tStartRefresh')  # time at next scr refresh
            # add timestamp to datafile
            thisExp.timestampOnFlip(win, 'next_trial_text_3.started')
            # update status
            next_trial_text_3.status = STARTED
            next_trial_text_3.setAutoDraw(True)
        
        # if next_trial_text_3 is active this frame...
        if next_trial_text_3.status == STARTED:
            # update params
            pass
        
        # if next_trial_text_3 is stopping this frame...
        if next_trial_text_3.status == STARTED:
            # is it time to stop? (based on global clock, using actual start)
            if tThisFlipGlobal > next_trial_text_3.tStartRefresh + 3-frameTolerance:
                # keep track of stop time/frame for later
                next_trial_text_3.tStop = t  # not accounting for scr refresh
                next_trial_text_3.tStopRefresh = tThisFlipGlobal  # on global time
                next_trial_text_3.frameNStop = frameN  # exact frame index
                # add timestamp to datafile
                thisExp.timestampOnFlip(win, 'next_trial_text_3.stopped')
                # update status
                next_trial_text_3.status = FINISHED
                next_trial_text_3.setAutoDraw(False)
        
        # *text_150* updates
        
        # if text_150 is starting this frame...
        if text_150.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
            # keep track of start time/frame for later
            text_150.frameNStart = frameN  # exact frame index
            text_150.tStart = t  # local t and not account for scr refresh
            text_150.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(text_150, 'tStartRefresh')  # time at next scr refresh
            # add timestamp to datafile
            thisExp.timestampOnFlip(win, 'text_150.started')
            # update status
            text_150.status = STARTED
            text_150.setAutoDraw(True)
        
        # if text_150 is active this frame...
        if text_150.status == STARTED:
            # update params
            pass
        
        # if text_150 is stopping this frame...
        if text_150.status == STARTED:
            # is it time to stop? (based on global clock, using actual start)
            if tThisFlipGlobal > text_150.tStartRefresh + 3.0-frameTolerance:
                # keep track of stop time/frame for later
                text_150.tStop = t  # not accounting for scr refresh
                text_150.tStopRefresh = tThisFlipGlobal  # on global time
                text_150.frameNStop = frameN  # exact frame index
                # add timestamp to datafile
                thisExp.timestampOnFlip(win, 'text_150.stopped')
                # update status
                text_150.status = FINISHED
                text_150.setAutoDraw(False)
        
        # check for quit (typically the Esc key)
        if defaultKeyboard.getKeys(keyList=["escape"]):
            thisExp.status = FINISHED
        if thisExp.status == FINISHED or endExpNow:
            endExperiment(thisExp, win=win)
            return
        # pause experiment here if requested
        if thisExp.status == PAUSED:
            pauseExperiment(
                thisExp=thisExp, 
                win=win, 
                timers=[routineTimer], 
                playbackComponents=[]
            )
            # skip the frame we paused on
            continue
        
        # check if all components have finished
        if not continueRoutine:  # a component has requested a forced-end of Routine
            total_score_planning.forceEnded = routineForceEnded = True
            break
        continueRoutine = False  # will revert to True if at least one component still running
        for thisComponent in total_score_planning.components:
            if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:
                continueRoutine = True
                break  # at least one component has not yet finished
        
        # refresh the screen
        if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen
            win.flip()
    
    # --- Ending Routine "total_score_planning" ---
    for thisComponent in total_score_planning.components:
        if hasattr(thisComponent, "setAutoDraw"):
            thisComponent.setAutoDraw(False)
    # store stop times for total_score_planning
    total_score_planning.tStop = globalClock.getTime(format='float')
    total_score_planning.tStopRefresh = tThisFlipGlobal
    thisExp.addData('total_score_planning.stopped', total_score_planning.tStop)
    # using non-slip timing so subtract the expected duration of this Routine (unless ended on request)
    if total_score_planning.maxDurationReached:
        routineTimer.addTime(-total_score_planning.maxDuration)
    elif total_score_planning.forceEnded:
        routineTimer.reset()
    else:
        routineTimer.addTime(-3.000000)
    thisExp.nextEntry()
    
    # --- Prepare to start Routine "end" ---
    # create an object to store info about Routine end
    end = data.Routine(
        name='end',
        components=[text_20],
    )
    end.status = NOT_STARTED
    continueRoutine = True
    # update component parameters for each repeat
    # store start times for end
    end.tStartRefresh = win.getFutureFlipTime(clock=globalClock)
    end.tStart = globalClock.getTime(format='float')
    end.status = STARTED
    thisExp.addData('end.started', end.tStart)
    end.maxDuration = None
    # keep track of which components have finished
    endComponents = end.components
    for thisComponent in end.components:
        thisComponent.tStart = None
        thisComponent.tStop = None
        thisComponent.tStartRefresh = None
        thisComponent.tStopRefresh = None
        if hasattr(thisComponent, 'status'):
            thisComponent.status = NOT_STARTED
    # reset timers
    t = 0
    _timeToFirstFrame = win.getFutureFlipTime(clock="now")
    frameN = -1
    
    # --- Run Routine "end" ---
    end.forceEnded = routineForceEnded = not continueRoutine
    while continueRoutine and routineTimer.getTime() < 4.0:
        # get current time
        t = routineTimer.getTime()
        tThisFlip = win.getFutureFlipTime(clock=routineTimer)
        tThisFlipGlobal = win.getFutureFlipTime(clock=None)
        frameN = frameN + 1  # number of completed frames (so 0 is the first frame)
        # update/draw components on each frame
        
        # *text_20* updates
        
        # if text_20 is starting this frame...
        if text_20.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
            # keep track of start time/frame for later
            text_20.frameNStart = frameN  # exact frame index
            text_20.tStart = t  # local t and not account for scr refresh
            text_20.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(text_20, 'tStartRefresh')  # time at next scr refresh
            # add timestamp to datafile
            thisExp.timestampOnFlip(win, 'text_20.started')
            # update status
            text_20.status = STARTED
            text_20.setAutoDraw(True)
        
        # if text_20 is active this frame...
        if text_20.status == STARTED:
            # update params
            pass
        
        # if text_20 is stopping this frame...
        if text_20.status == STARTED:
            # is it time to stop? (based on global clock, using actual start)
            if tThisFlipGlobal > text_20.tStartRefresh + 4.0-frameTolerance:
                # keep track of stop time/frame for later
                text_20.tStop = t  # not accounting for scr refresh
                text_20.tStopRefresh = tThisFlipGlobal  # on global time
                text_20.frameNStop = frameN  # exact frame index
                # add timestamp to datafile
                thisExp.timestampOnFlip(win, 'text_20.stopped')
                # update status
                text_20.status = FINISHED
                text_20.setAutoDraw(False)
        
        # check for quit (typically the Esc key)
        if defaultKeyboard.getKeys(keyList=["escape"]):
            thisExp.status = FINISHED
        if thisExp.status == FINISHED or endExpNow:
            endExperiment(thisExp, win=win)
            return
        # pause experiment here if requested
        if thisExp.status == PAUSED:
            pauseExperiment(
                thisExp=thisExp, 
                win=win, 
                timers=[routineTimer], 
                playbackComponents=[]
            )
            # skip the frame we paused on
            continue
        
        # check if all components have finished
        if not continueRoutine:  # a component has requested a forced-end of Routine
            end.forceEnded = routineForceEnded = True
            break
        continueRoutine = False  # will revert to True if at least one component still running
        for thisComponent in end.components:
            if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:
                continueRoutine = True
                break  # at least one component has not yet finished
        
        # refresh the screen
        if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen
            win.flip()
    
    # --- Ending Routine "end" ---
    for thisComponent in end.components:
        if hasattr(thisComponent, "setAutoDraw"):
            thisComponent.setAutoDraw(False)
    # store stop times for end
    end.tStop = globalClock.getTime(format='float')
    end.tStopRefresh = tThisFlipGlobal
    thisExp.addData('end.stopped', end.tStop)
    # using non-slip timing so subtract the expected duration of this Routine (unless ended on request)
    if end.maxDurationReached:
        routineTimer.addTime(-end.maxDuration)
    elif end.forceEnded:
        routineTimer.reset()
    else:
        routineTimer.addTime(-4.000000)
    thisExp.nextEntry()
    
    # mark experiment as finished
    endExperiment(thisExp, win=win)


def saveData(thisExp):
    """
    Save data from this experiment
    
    Parameters
    ==========
    thisExp : psychopy.data.ExperimentHandler
        Handler object for this experiment, contains the data to save and information about 
        where to save it to.
    """
    filename = thisExp.dataFileName
    # these shouldn't be strictly necessary (should auto-save)
    thisExp.saveAsWideText(filename + '.csv', delim='auto')
    thisExp.saveAsPickle(filename)


def endExperiment(thisExp, win=None):
    """
    End this experiment, performing final shut down operations.
    
    This function does NOT close the window or end the Python process - use `quit` for this.
    
    Parameters
    ==========
    thisExp : psychopy.data.ExperimentHandler
        Handler object for this experiment, contains the data to save and information about 
        where to save it to.
    win : psychopy.visual.Window
        Window for this experiment.
    """
    if win is not None:
        # remove autodraw from all current components
        win.clearAutoDraw()
        # Flip one final time so any remaining win.callOnFlip() 
        # and win.timeOnFlip() tasks get executed
        win.flip()
    # return console logger level to WARNING
    logging.console.setLevel(logging.WARNING)
    # mark experiment handler as finished
    thisExp.status = FINISHED
    logging.flush()


def quit(thisExp, win=None, thisSession=None):
    """
    Fully quit, closing the window and ending the Python process.
    
    Parameters
    ==========
    win : psychopy.visual.Window
        Window to close.
    thisSession : psychopy.session.Session or None
        Handle of the Session object this experiment is being run from, if any.
    """
    thisExp.abort()  # or data files will save again on exit
    # make sure everything is closed down
    if win is not None:
        # Flip one final time so any remaining win.callOnFlip() 
        # and win.timeOnFlip() tasks get executed before quitting
        win.flip()
        win.close()
    logging.flush()
    if thisSession is not None:
        thisSession.stop()
    # terminate Python process
    core.quit()


# if running this experiment as a script...
if __name__ == '__main__':
    # call all functions in order
    expInfo = showExpInfoDlg(expInfo=expInfo)
    thisExp = setupData(expInfo=expInfo)
    logFile = setupLogging(filename=thisExp.dataFileName)
    win = setupWindow(expInfo=expInfo)
    setupDevices(expInfo=expInfo, thisExp=thisExp, win=win)
    run(
        expInfo=expInfo, 
        thisExp=thisExp, 
        win=win,
        globalClock='float'
    )
    saveData(thisExp=thisExp)
    quit(thisExp=thisExp, win=win)
